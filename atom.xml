<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>星星的猫(&gt;^ω^&lt;)喵</title>
  
  
  <link href="https://www.shawn22.xyz/atom.xml" rel="self"/>
  
  <link href="https://www.shawn22.xyz/"/>
  <updated>2023-03-05T16:22:57.706Z</updated>
  <id>https://www.shawn22.xyz/</id>
  
  <author>
    <name>Shawn</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>语雀批量导出与图片下载</title>
    <link href="https://www.shawn22.xyz/posts/4f9b313c.html"/>
    <id>https://www.shawn22.xyz/posts/4f9b313c.html</id>
    <published>2023-03-05T16:18:39.000Z</published>
    <updated>2023-03-05T16:22:57.706Z</updated>
    
    <content type="html"><![CDATA[<h1>一、简介</h1><p>在云笔记方面我一般使用<a href="https://www.wolai.com/signup?invitation=JMJ57S3" target="_blank" rel="noopener" title="wolai"><strong>wolai</strong></a>和<strong>语雀</strong>，本地笔记用Typora，但是这两个云笔记各有利弊</p><ul><li>wolai的导出可以随md文件直接生成对应的图片文件夹，而且可以直接批量导出(需要企业版)，但是普通账户的图床容量只有200M</li><li>语雀个人账户的图床拥有10G容量，但是只支持单个文件导出，而且导出md文档的时候图片使用的还是语雀的图床，断网会导致不可访问，而且不能进行本地离线备份</li></ul><p>因此今天这篇文章就记录一下语雀如何进行图片本地化保存以及文档批量备份下载</p><a id="more"></a><h1>二、导出文档图片批量替换</h1><p>在实际的使用中，有几个网站是可以获取到语雀图片的（不用重新上传，自动转存）</p><ul><li>微信公众号</li><li>csdn</li><li>掘金</li><li>知乎</li></ul><p>但是还是需要将语雀图片的后缀给去掉，第一种方法是无需运行脚本，如果Typora支持正则，直接正则匹配<code>#clientId=[a-z0-9-&amp;=%.]*</code>(注意可能会变，自己根据实际情况来进行替换)，将这串字符给全部替换为空；</p><p>第二种需要进行跑python脚本，然后运行<code>python test.py [源文章] [目标文章]</code>(举例：<code>python test.py test.md test2.md</code>)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">output_content = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deal_yuque</span><span class="params">(origin_md_path, output_md_path)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(origin_md_path, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>, errors=<span class="string">'ignore'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():</span><br><span class="line">            line = re.sub(<span class="string">r'png#(.*)+'</span>, <span class="string">'png)'</span>, line)</span><br><span class="line">            image_url = str(re.findall(<span class="string">r'http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&amp;+]|[!*\(\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+'</span>,line))</span><br><span class="line">            output_content.append(line)</span><br><span class="line">    <span class="keyword">with</span> open(output_md_path, <span class="string">'w'</span>, encoding=<span class="string">'utf-8'</span>, errors=<span class="string">'ignore'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> _output_content <span class="keyword">in</span> output_content:</span><br><span class="line">            f.write(str(_output_content))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    origin_md_path = sys.argv[<span class="number">1</span>]</span><br><span class="line">    output_md_path = sys.argv[<span class="number">2</span>]</span><br><span class="line">    deal_yuque(origin_md_path, output_md_path)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h1>三、Markdown中的图片转换到本地</h1><blockquote><p>参考：<a href="https://github.com/u21h2/yuque2md" target="_blank" rel="noopener" title="https://github.com/u21h2/yuque2md">https://github.com/u21h2/yuque2md</a></p></blockquote><p>可以根据自己定制批量化的修改操作，修改原理识别文档的图片地址，并自动下载到本地，最后替换文档中的路径</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">yuque_cdn_domain = <span class="string">'cdn.nlark.com'</span></span><br><span class="line">output_content = []</span><br><span class="line">image_file_prefix = <span class="string">'image-'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># origin_md_path: 输入的markdown文件路径</span></span><br><span class="line"><span class="comment"># output_md_path: 输出的markdown文件路径</span></span><br><span class="line"><span class="comment"># image_dir: 图片存储的目录</span></span><br><span class="line"><span class="comment"># image_url_prefix: 图片链接前缀，空字符串或者路径或者CDN地址</span></span><br><span class="line"><span class="comment"># image_rename_mode: 图片重命名模式，raw: 原始uuid模式，asc: 递增重命名模式</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deal_yuque</span><span class="params">(origin_md_path, output_md_path, image_dir,image_url_prefix,image_rename_mode)</span>:</span></span><br><span class="line">    idx = <span class="number">0</span></span><br><span class="line">    <span class="keyword">with</span> open(origin_md_path, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>, errors=<span class="string">'ignore'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():</span><br><span class="line">            line = re.sub(<span class="string">r'png#(.*)+'</span>, <span class="string">'png)'</span>, line)</span><br><span class="line">            image_url = str(re.findall(<span class="string">r'http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&amp;+]|[!*\(\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+'</span>,line))</span><br><span class="line">            <span class="comment"># 如果只下载语雀的图片可以在这里加个判断</span></span><br><span class="line">            <span class="comment"># if yuque_cdn_domain in image_url:</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">'https://'</span> <span class="keyword">in</span> image_url) <span class="keyword">and</span> (<span class="string">'.png'</span> <span class="keyword">in</span> image_url):</span><br><span class="line">                image_url = image_url.replace(<span class="string">'('</span>, <span class="string">''</span>).replace(<span class="string">')'</span>, <span class="string">''</span>).replace(<span class="string">'['</span>, <span class="string">''</span>).replace(<span class="string">']'</span>, <span class="string">''</span>).replace(<span class="string">"'"</span>, <span class="string">''</span>)</span><br><span class="line">                <span class="keyword">if</span> <span class="string">'.png'</span> <span class="keyword">in</span> image_url:</span><br><span class="line">                    suffix = <span class="string">'.png'</span></span><br><span class="line">                <span class="keyword">elif</span> <span class="string">'.jpeg'</span> <span class="keyword">in</span> image_url:</span><br><span class="line">                    suffix = <span class="string">'.jpeg'</span></span><br><span class="line">                download_image(image_url, image_dir, image_rename_mode, idx, suffix)</span><br><span class="line">                to_replace = <span class="string">'/'</span>.join(image_url.split(<span class="string">'/'</span>)[:<span class="number">-1</span>])</span><br><span class="line">                new_image_url = image_url.replace(to_replace, <span class="string">'placeholder'</span>)</span><br><span class="line">                <span class="keyword">if</span> image_rename_mode == <span class="string">'asc'</span>:</span><br><span class="line">                    new_image_url = image_url_prefix + image_file_prefix + str(idx) + suffix</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    new_image_url = new_image_url.replace(<span class="string">'placeholder/'</span>,image_url_prefix)</span><br><span class="line">                idx += <span class="number">1</span></span><br><span class="line">                line = line.replace(image_url, new_image_url)</span><br><span class="line">            output_content.append(line)</span><br><span class="line">    <span class="keyword">with</span> open(output_md_path, <span class="string">'w'</span>, encoding=<span class="string">'utf-8'</span>, errors=<span class="string">'ignore'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> _output_content <span class="keyword">in</span> output_content:</span><br><span class="line">            f.write(str(_output_content))</span><br><span class="line">    <span class="keyword">return</span> idx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_image</span><span class="params">(image_url, image_dir, image_name_mode, idx, suffix)</span>:</span></span><br><span class="line">    r = requests.get(image_url, stream=<span class="literal">True</span>)</span><br><span class="line">    image_name = image_url.split(<span class="string">'/'</span>)[<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">if</span> image_name_mode == <span class="string">'asc'</span>:</span><br><span class="line">        image_name = image_file_prefix + str(idx) + suffix</span><br><span class="line">    <span class="keyword">if</span> r.status_code == <span class="number">200</span>:</span><br><span class="line">        open(image_dir+<span class="string">'/'</span>+image_name, <span class="string">'wb'</span>).write(r.content)</span><br><span class="line">    <span class="keyword">del</span> r</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mkdir</span><span class="params">(image_dir)</span>:</span></span><br><span class="line">    image_dir = image_dir.strip()</span><br><span class="line">    image_dir = image_dir.rstrip(<span class="string">"\\"</span>)</span><br><span class="line">    isExists = os.path.exists(image_dir)</span><br><span class="line">    <span class="keyword">if</span> isExists:</span><br><span class="line">        print(<span class="string">'图片存储目录已存在'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        os.makedirs(image_dir)</span><br><span class="line">        print(<span class="string">'图片存储目录创建成功'</span>)</span><br><span class="line">    <span class="keyword">return</span> image_dir</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    origin_md_path = sys.argv[<span class="number">1</span>]</span><br><span class="line">    output_md_path = sys.argv[<span class="number">2</span>]</span><br><span class="line">    image_dir = sys.argv[<span class="number">3</span>]</span><br><span class="line">    image_url_prefix = sys.argv[<span class="number">4</span>]</span><br><span class="line">    image_rename_mode = sys.argv[<span class="number">5</span>] <span class="comment"># raw asc</span></span><br><span class="line">    mkdir(image_dir)</span><br><span class="line">    cnt = deal_yuque(origin_md_path, output_md_path, image_dir, image_url_prefix, image_rename_mode)</span><br><span class="line">    print(<span class="string">'处理完成, 共&#123;&#125;张图片'</span>.format(cnt))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># origin_md_path = input('原文件路径：') </span></span><br><span class="line">    <span class="comment"># output_md_path = input('目标输出文件路径：')</span></span><br><span class="line">    <span class="comment"># image_dir = input('图片存储路径：')</span></span><br><span class="line">    <span class="comment"># image_url_prefix = input('文档图片前缀(默认为当前路径)：') or ''</span></span><br><span class="line">    <span class="comment"># image_rename_mode = input('图片重命名模式(raw和asc默认为asc)：') or 'asc'</span></span><br><span class="line">    <span class="comment"># mkdir(image_dir)</span></span><br><span class="line">    <span class="comment"># cnt = deal_yuque(origin_md_path, output_md_path, image_dir, image_url_prefix, image_rename_mode)</span></span><br><span class="line">    <span class="comment"># print('处理完成, 共&#123;&#125;张图片'.format(cnt))</span></span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h1>四、文档批量下载</h1><blockquote><p>参考：<a href="https://github.com/dzh929/ExportMD-rectify-pics" target="_blank" rel="noopener" title="https://github.com/dzh929/ExportMD-rectify-pics">https://github.com/dzh929/ExportMD-rectify-pics</a><br><a href="https://www.yuque.com/duzh929/blog/ocffqg" target="_blank" rel="noopener" title="https://www.yuque.com/duzh929/blog/ocffqg">https://www.yuque.com/duzh929/blog/ocffqg</a></p></blockquote><p>改导出方法不仅批量导出md文档，而且图片也以文件夹方式保存在本地</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/dzh929/ExportMD-rectify-pics.git</span><br><span class="line"><span class="built_in">cd</span> ExportMD-rectify-pics</span><br><span class="line">pip install -r requirements.txt</span><br><span class="line">python ExportMD.py</span><br><span class="line"><span class="comment"># 对于namespace的获取</span></span><br><span class="line"><span class="comment"># 知识库 https://www.yuque.com/YourYuqueUserName 对应的 namespace 为 YourYuqueUserName</span></span><br><span class="line"><span class="comment"># Token需要创建</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果发生错误，删除.userinfo后重试</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1&gt;一、简介&lt;/h1&gt;
&lt;p&gt;在云笔记方面我一般使用&lt;a href=&quot;https://www.wolai.com/signup?invitation=JMJ57S3&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; title=&quot;wolai&quot;&gt;&lt;strong&gt;wolai&lt;/strong&gt;&lt;/a&gt;和&lt;strong&gt;语雀&lt;/strong&gt;，本地笔记用Typora，但是这两个云笔记各有利弊&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;wolai的导出可以随md文件直接生成对应的图片文件夹，而且可以直接批量导出(需要企业版)，但是普通账户的图床容量只有200M&lt;/li&gt;
&lt;li&gt;语雀个人账户的图床拥有10G容量，但是只支持单个文件导出，而且导出md文档的时候图片使用的还是语雀的图床，断网会导致不可访问，而且不能进行本地离线备份&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此今天这篇文章就记录一下语雀如何进行图片本地化保存以及文档批量备份下载&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://www.shawn22.xyz/categories/Java/"/>
    
    
    <category term="IDETools" scheme="https://www.shawn22.xyz/tags/IDETools/"/>
    
  </entry>
  
  <entry>
    <title>配置文件、API接口脱敏</title>
    <link href="https://www.shawn22.xyz/posts/1b12b5fa.html"/>
    <id>https://www.shawn22.xyz/posts/1b12b5fa.html</id>
    <published>2023-03-05T16:18:31.000Z</published>
    <updated>2023-03-05T16:24:17.612Z</updated>
    
    <content type="html"><![CDATA[<h1>一、配置文件脱敏</h1><h2 id="1、概述">1、概述</h2><p>核心隐私数据无论对于企业还是用户来说尤其重要，因此要想办法杜绝各种隐私数据的泄漏。对于工程中的敏感信息，与数据库打交道的的工程肯定是配置数据源，尤其是数据库的<code>账号密码</code>，我们不想把它们<code>明文</code>写在配置文件里，又想让工程能正确跑起来，那应该怎么做呢？</p><a id="more"></a><p>**由于数据库的敏感性，所以不可能让每个人都知道su ****<code>root</code><strong><strong>的密码。且数据库中权限、视图这些机制也是为了保证安全性，所以要保证让尽可能少的人知道</strong></strong><code>root</code>**<strong>的密码</strong>。所以我们可以利用非对称加密算法的思想：</p><ul><li>在工程的配置文件中写入加密好的<code>密文</code>。</li><li>启动工程时让知道<code>密钥</code>的人，以启动参数的形式将<code>密钥</code>输入进去。</li><li>工程根据<code>密钥</code>，将<code>密文</code>自动解密为<code>明文</code>，用来完成配置。</li><li>无关的人是无法知道敏感信息的<code>明文</code>是什么的</li></ul><blockquote><p>这里我们使用一款开源插件：<code>jasypt-spring-boot</code>来进行脱敏处理，项目地址：<a href="https://github.com/ulisesbocchio/jasypt-spring-boot" target="_blank" rel="noopener" title="https://github.com/ulisesbocchio/jasypt-spring-boot">https://github.com/ulisesbocchio/jasypt-spring-boot</a></p></blockquote><h2 id="2、利用jar包手动加密">2、利用jar包手动加密</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用秘钥和密码明文生成密码</span></span><br><span class="line">java -cp jasypt-1.9.3.jar org.jasypt.intf.cli.JasyptPBEStringEncryptionCLI input=待加密内容 password=加密秘钥 algorithm=PBEWithMD5AndDES</span><br><span class="line"><span class="comment"># 检查生成的密码是否正确</span></span><br><span class="line">java -cp jasypt-1.9.3.jar org.jasypt.intf.cli.JasyptPBEStringDecryptionCLI input=加密后内容 password=加密秘钥 algorithm=PBEWithMD5AndDES</span><br></pre></td></tr></table></figure><h2 id="3、SpringBoot实现脱敏">3、SpringBoot实现脱敏</h2><h3 id="3-1-代码实现">3.1 代码实现</h3><p>首先引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.ulisesbocchio<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jasypt-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后进行密钥的配置（配置文件），当然将秘钥直接放在配置文件中也是不安全的，我们可以在项目启动的时候配置秘钥<code>java -jar xxx.jar  -Djasypt.encryptor.password=dGNtLW1hbmFnZS1zeXN0ZW</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jasypt:</span></span><br><span class="line">  <span class="attr">encryptor:</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">dGNtLW1hbmFnZS1zeXN0ZW</span></span><br><span class="line">    <span class="attr">algorithm:</span> <span class="string">PBEWithMD5AndDES</span></span><br></pre></td></tr></table></figure><p>然后可以对明文进行加密</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DesensitizationApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注入加密方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringEncryptor encryptor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 手动生成密文，此处演示了url，user，password</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">encrypt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String url = encryptor.encrypt(<span class="string">"jdbc\\:mysql\\://127.0.0.1\\:3306/test?useUnicode\\=true&amp;characterEncoding\\=UTF-8&amp;zeroDateTimeBehavior\\=convertToNull&amp;useSSL\\=false&amp;allowMultiQueries\\=true&amp;serverTimezone=Asia/Shanghai"</span>);</span><br><span class="line">        String name = encryptor.encrypt(<span class="string">"root"</span>);</span><br><span class="line">        String password = encryptor.encrypt(<span class="string">"123456"</span>);</span><br><span class="line">        System.out.println(<span class="string">"database url: "</span> + url);</span><br><span class="line">        System.out.println(<span class="string">"database name: "</span> + name);</span><br><span class="line">        System.out.println(<span class="string">"database password: "</span> + password);</span><br><span class="line">        <span class="keyword">assert</span> url.length() &gt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">assert</span> name.length() &gt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">assert</span> password.length() &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第二种手动加密的方法，不过加密解密要配合，与上面的方法不能混合使用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        BasicTextEncryptor textEncryptor = <span class="keyword">new</span> BasicTextEncryptor();</span><br><span class="line">        <span class="comment">//加密所需的密钥</span></span><br><span class="line">        textEncryptor.setPassword(<span class="string">"shawn"</span>);</span><br><span class="line">        <span class="comment">//要加密的数据（数据库的用户名或密码）</span></span><br><span class="line">        String username = textEncryptor.encrypt(<span class="string">"root"</span>);</span><br><span class="line">        String password = textEncryptor.encrypt(<span class="string">"123456"</span>);</span><br><span class="line">        String url = textEncryptor.encrypt(<span class="string">"jdbc:mysql://10.18.104.78:4000/testdb?useUnicode=true&amp;characterEncoding=utf-8&amp;allowMultiQueries=true&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai&amp;allowPublicKeyRetrieval=true"</span>);</span><br><span class="line">        String redisHost = textEncryptor.encrypt(<span class="string">"172.16.110.85"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//String decrypt = textEncryptor.decrypt("L+tOtB0YuK78F12PtS5c1Q==");</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"username:"</span>+username);</span><br><span class="line">        System.out.println(<span class="string">"password:"</span>+password);</span><br><span class="line">        System.out.println(<span class="string">"url:"</span>+url);</span><br><span class="line">        System.out.println(<span class="string">"redisHost:"</span>+redisHost);</span><br><span class="line">        System.out.println(textEncryptor.decrypt(<span class="string">"c9oILGKe4gHAs/FxJEcLug=="</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后将加密后的密文写入配置,<code>jasypt</code>默认使用<code>ENC()</code>包裹，此时的数据源配置如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="comment">#   数据源基本配置</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">ENC(L8I2RqYPptEtQNL4x8VhRVakSUdlsTGzEND/3TOnVTYPWe0ZnWsW0/5JdUsw9ulm)</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">ENC(EJYCSbBL8Pmf2HubIH7dHhpfDZcLyJCEGMR9jAV3apJtvFtx9TVdhUPsAxjQ2pnJ)</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">ENC(szkFDG56WcAOzG2utv0m2aoAvNFH5g3DXz0o6joZjT26Y5WNA+1Z+pQFpyhFBokqOp2jsFtB+P9b3gB601rfas3dSfvS8Bgo3MyP1nojJgVp6gCVi+B/XUs0keXPn+pbX/19HrlUN1LeEweHS/LCRZslhWJCsIXTwZo1PlpXRv3Vyhf2OEzzKLm3mIAYj51CrEaN3w5cMiCESlwvKUhpAJVz/uXQJ1spLUAMuXCKKrXM/6dSRnWyTtdFRost5cChEU9uRjw5M+8HU3BLemtcK0vM8iYDjEi5zDbZtwxD3hA=)</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br></pre></td></tr></table></figure><p>上述配置是使用默认的<code>prefix=ENC(</code>、<code>suffix=)</code>，当然我们可以根据自己的要求更改，只需要在配置文件中更改即可，如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jasypt:</span></span><br><span class="line">  <span class="attr">encryptor:</span></span><br><span class="line">    <span class="comment">## 指定前缀、后缀</span></span><br><span class="line">    <span class="attr">property:</span></span><br><span class="line">      <span class="attr">prefix:</span> <span class="string">'PASS('</span></span><br><span class="line">      <span class="attr">suffix:</span> <span class="string">')'</span></span><br></pre></td></tr></table></figure><p>那么此时的配置就必须使用<code>PASS()</code>包裹才会被解密，如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="comment">#   数据源基本配置</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">PASS(L8I2RqYPptEtQNL4x8VhRVakSUdlsTGzEND/3TOnVTYPWe0ZnWsW0/5JdUsw9ulm)</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">PASS(EJYCSbBL8Pmf2HubIH7dHhpfDZcLyJCEGMR9jAV3apJtvFtx9TVdhUPsAxjQ2pnJ)</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">PASS(szkFDG56WcAOzG2utv0m2aoAvNFH5g3DXz0o6joZjT26Y5WNA+1Z+pQFpyhFBokqOp2jsFtB+P9b3gB601rfas3dSfvS8Bgo3MyP1nojJgVp6gCVi+B/XUs0keXPn+pbX/19HrlUN1LeEweHS/LCRZslhWJCsIXTwZo1PlpXRv3Vyhf2OEzzKLm3mIAYj51CrEaN3w5cMiCESlwvKUhpAJVz/uXQJ1spLUAMuXCKKrXM/6dSRnWyTtdFRost5cChEU9uRjw5M+8HU3BLemtcK0vM8iYDjEi5zDbZtwxD3hA=)</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br></pre></td></tr></table></figure><h3 id="3-2-运行原理">3.2 运行原理</h3><ul><li>**jasypt的加密方式  **<br>jasypt采用<code>PBEWithMD5AndDES</code>加密方式，在相同的秘钥情况下，每次生成的密文都不相同，但可以使用秘钥解密获得相同的明文，可以确保秘钥的安全性</li><li>**jasypt-spring-boot-starter的运行原理  **<br>先使用原先的配置加载方式加载配置信息（因此系统使用何种配置方式，对加解密没有影响），再通过代理的方式代理了配置获取类，在Bean生成时加载配置的地方使用代理类执行密码转换获得明文</li><li>**jasypt-spring-boot-starter工作原理  **<br>在spring中的加载方式：<code>EnableEncryptablePropertiesConfiguration 类</code>负责配置文件加载将当前的environment环境配置进行代理或包装（返回<code>EnableEncryptablePropertiesBeanFactoryPostProcessor</code>）对所有的参数值使用Encryptable进行代理，生成<code>PropertySource</code>的AOP代理类  并使用<code>EncryptableMapPropertySourceWrapper</code>类来包装PropertySource  使用的时候通过<code>DefaultPropertyDetector</code>来判断数据是否符合<code>ENC(**********)</code>这样的数据结构  符合时，使用<code>EncryptablePropertyResolver</code>来解码数据</li></ul><h2 id="4、其他注意事项说明">4、其他注意事项说明</h2><p>对于密文使用，可以支持nacos配置中心，yml等多种配置文件；项目启动参数增加【-Djasypt.encryptor.password=秘钥】 来实现密文解密 ；最后关于加密结果，每次加密的结果都不一样，但使用秘钥都能得到正确的明文，注意加解密一定需要使用<code>jasypt-spring-boot-starter</code>中引用的<code>jasypt-x.x.x.jar</code> 对应版本，否则可能导致密文无法解析的情况</p><h1>二、接口返回数据脱敏</h1><h2 id="1、概述-v2">1、概述</h2><p>通常接口返回值中的一些敏感数据也是要脱敏的，因为不脱敏的敏感数据，可能会引起用户的不满。比如身份证号、手机号码、地址等通常的手段就是用<code>*</code>隐藏一部分数据，当然也可以根据自己需求定制。言归正传，如何优雅的实现呢？有两种实现方案：</p><ul><li>整合Mybatis插件，在查询的时候针对特定的字段进行脱敏</li><li>整合Jackson，在序列化阶段对特定字段进行脱敏</li></ul><p>这里我们就先使用第二种方法对数据进行脱敏</p><h2 id="2、SpringBoot实战">2、SpringBoot实战</h2><p>首先定制脱敏策略，针对项目需求，定制不同字段的脱敏规则，比如手机号中间几位用<code>*</code>替代，不同项目可以根据自己需求进行删减</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 脱敏策略，枚举类，针对不同的数据定制特定的策略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SensitiveStrategy &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    USERNAME(s -&gt; s.replaceAll(<span class="string">"(\\S)\\S(\\S*)"</span>, <span class="string">"$1*$2"</span>)),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 身份证</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ID_CARD(s -&gt; s.replaceAll(<span class="string">"(\\d&#123;4&#125;)\\d&#123;10&#125;(\\w&#123;4&#125;)"</span>, <span class="string">"$1****$2"</span>)),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 手机号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    PHONE(s -&gt; s.replaceAll(<span class="string">"(\\d&#123;3&#125;)\\d&#123;4&#125;(\\d&#123;4&#125;)"</span>, <span class="string">"$1****$2"</span>)),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ADDRESS(s -&gt; s.replaceAll(<span class="string">"(\\S&#123;3&#125;)\\S&#123;2&#125;(\\S*)\\S&#123;2&#125;"</span>, <span class="string">"$1****$2****"</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Function&lt;String, String&gt; desensitizer;</span><br><span class="line"></span><br><span class="line">    SensitiveStrategy(Function&lt;String, String&gt; desensitizer) &#123;</span><br><span class="line">        <span class="keyword">this</span>.desensitizer = desensitizer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Function&lt;String, String&gt; <span class="title">desensitizer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> desensitizer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步自定义一个脱敏注解，一旦有属性被标注，则进行对应得脱敏</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义jackson注解，标注在属性上</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="meta">@JacksonAnnotationsInside</span></span><br><span class="line"><span class="meta">@JsonSerialize</span>(using = SensitiveJsonSerializer<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">Sensitive</span> </span>&#123;</span><br><span class="line">    <span class="comment">//脱敏策略</span></span><br><span class="line">    <span class="function">SensitiveStrategy <span class="title">strategy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面将是重要实现，对标注注解<code>@Sensitive</code>的字段进行脱敏，实现如下，其中<code>createContextual</code>的作用是通过字段已知的上下文信息定制<code>JsonSerializer</code>对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 序列化注解自定义实现</span></span><br><span class="line"><span class="comment"> * JsonSerializer&lt;String&gt;：指定String 类型，serialize()方法用于将修改后的数据载入</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SensitiveJsonSerializer</span> <span class="keyword">extends</span> <span class="title">JsonSerializer</span>&lt;<span class="title">String</span>&gt; <span class="keyword">implements</span> <span class="title">ContextualSerializer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SensitiveStrategy strategy;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serialize</span><span class="params">(String value, JsonGenerator gen, SerializerProvider serializers)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        gen.writeString(strategy.desensitizer().apply(value));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取属性上的注解属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> JsonSerializer&lt;?&gt; createContextual(SerializerProvider prov, BeanProperty property) <span class="keyword">throws</span> JsonMappingException &#123;</span><br><span class="line"></span><br><span class="line">        Sensitive annotation = property.getAnnotation(Sensitive<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (Objects.nonNull(annotation)&amp;&amp;Objects.equals(String<span class="class">.<span class="keyword">class</span>, <span class="title">property</span>.<span class="title">getType</span>().<span class="title">getRawClass</span>())) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.strategy = annotation.strategy();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prov.findValueSerializer(property.getType(), property);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后定义Person类，对其数据脱敏，使用注解<code>@Sensitive</code>注解进行数据脱敏</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 真实姓名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Sensitive</span>(strategy = SensitiveStrategy.USERNAME)</span><br><span class="line">    <span class="keyword">private</span> String realName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Sensitive</span>(strategy = SensitiveStrategy.ADDRESS)</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 电话号码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Sensitive</span>(strategy = SensitiveStrategy.PHONE)</span><br><span class="line">    <span class="keyword">private</span> String phoneNumber;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 身份证号码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Sensitive</span>(strategy = SensitiveStrategy.ID_CARD)</span><br><span class="line">    <span class="keyword">private</span> String idCard;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 昵称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String nickName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后模拟接口测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Person user = <span class="keyword">new</span> Person();</span><br><span class="line">        user.setRealName(<span class="string">"接口测试"</span>);</span><br><span class="line">        user.setPhoneNumber(<span class="string">"17683456578"</span>);</span><br><span class="line">        user.setAddress(<span class="string">"浙江省杭州市温州市...."</span>);</span><br><span class="line">        user.setIdCard(<span class="string">"4333333333334334333"</span>);</span><br><span class="line">        user.setNickName(<span class="string">"shawn"</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"realName"</span>: <span class="string">"接*测试"</span>,</span><br><span class="line">  <span class="string">"address"</span>: <span class="string">"浙江省****市温州市..****"</span>,</span><br><span class="line">  <span class="string">"phoneNumber"</span>: <span class="string">"176****6578"</span>,</span><br><span class="line">  <span class="string">"idCard"</span>: <span class="string">"4333****34333"</span>,</span><br><span class="line">  <span class="string">"nickName"</span>: <span class="string">"shawn"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>参考文章</p><p><a href="https://blog.csdn.net/zym_1321/article/details/122198121" target="_blank" rel="noopener" title="https://blog.csdn.net/zym_1321/article/details/122198121">https://blog.csdn.net/zym_1321/article/details/122198121</a></p><p><a href="https://mp.weixin.qq.com/s/fIhZS1zso0FmBCRfNKezJg" target="_blank" rel="noopener" title="https://mp.weixin.qq.com/s/fIhZS1zso0FmBCRfNKezJg">https://mp.weixin.qq.com/s/fIhZS1zso0FmBCRfNKezJg</a></p><p><a href="https://www.zhihu.com/question/431015637" target="_blank" rel="noopener" title="https://www.zhihu.com/question/431015637">https://www.zhihu.com/question/431015637</a></p>]]></content>
    
    
    <summary type="html">&lt;h1&gt;一、配置文件脱敏&lt;/h1&gt;
&lt;h2 id=&quot;1、概述&quot;&gt;1、概述&lt;/h2&gt;
&lt;p&gt;核心隐私数据无论对于企业还是用户来说尤其重要，因此要想办法杜绝各种隐私数据的泄漏。对于工程中的敏感信息，与数据库打交道的的工程肯定是配置数据源，尤其是数据库的&lt;code&gt;账号密码&lt;/code&gt;，我们不想把它们&lt;code&gt;明文&lt;/code&gt;写在配置文件里，又想让工程能正确跑起来，那应该怎么做呢？&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://www.shawn22.xyz/categories/Java/"/>
    
    
    <category term="SpringBoot" scheme="https://www.shawn22.xyz/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>过滤器与拦截器</title>
    <link href="https://www.shawn22.xyz/posts/5a99ecc7.html"/>
    <id>https://www.shawn22.xyz/posts/5a99ecc7.html</id>
    <published>2023-03-05T16:18:22.000Z</published>
    <updated>2023-03-05T16:25:49.697Z</updated>
    
    <content type="html"><![CDATA[<h1>一、前言</h1><blockquote><p>常用项目编写规范参考：<a href="https://blog.csdn.net/lemon_TT/article/details/108309900" target="_blank" rel="noopener" title="Spring Boot后端接口规范">Spring Boot后端接口规范</a></p></blockquote><h2 id="1、概述">1、概述</h2><p>前面讲到数据统一响应、全局异常等常用后端框架，那么随着项目的开发，需要对请求进行校验(参数校验、前面校验等)，不符合的不进入后端业务逻辑，提前返回并抛出异常。一般实现方法有拦截器和过滤器，这两者都可以实现对应的功能，可以根据自己喜好进行编写。</p><p>过滤器一般完成通用的操作。如：<strong>登录验证、统⼀编码处理、敏感字符过滤</strong>，常见的过滤器用途主要包括：<strong>对用户请求进行统一认证、对用户的访问请求进行记录和审核</strong>、对用户发送的数据进行过滤或替换、转换图象格式、对响应内容进行压缩以减少传输量、对请求或响应进行加解密处理、触发资源访问事件等；拦截器采用AOP的设计思想， 它跟过滤器类似， 用来<strong>拦截处理方法在之前和之后执行一些 跟主业务没有关系的一些公共功能</strong>，比如<strong>权限控制、日志、异常记录、记录方法执行时间</strong></p><a id="more"></a><p>下面来讲讲这两者的异同和代码demo。</p><h2 id="2、过滤器与拦截器异同">2、过滤器与拦截器异同</h2><h3 id="2-1-简介">2.1 简介</h3><p>过滤器(filter)和拦截器(Inteceptor)的执行顺序概览</p><p><img src="https://img-blog.csdnimg.cn/da12fa07e67f48a385233ac4352f2e8b.png#pic_center" alt="在这里插入图片描述"></p><h3 id="2-2-异同">2.2 异同</h3><ul><li>过滤器和拦截器触发时机不一样，过滤器是在请求进入容器后，但请求进入servlet之前进行预处理的。请求结束返回也是，是在servlet处理完后，返回给前端之前</li><li><strong>拦截器可以获取IOC容器中的各个bean</strong>，而过滤器就不行，因为拦截器是spring提供并管理的，spring的功能可以被拦截器使用，在拦截器里注入一个service，可以调用业务逻辑。而过滤器是JavaEE标准，只需依赖servlet api ，不需要依赖spring</li><li>过滤器的实现基于回调函数。而拦截器（代理模式）的实现基于反射</li><li>Filter是依赖于Servlet容器，属于Servlet规范的一部分，而拦截器则是独立存在的，可以在任何情况下使用</li><li>Filter的执行由Servlet容器回调完成，而拦截器通常通过动态代理（反射）的方式来执行</li><li>Filter的生命周期由Servlet容器管理，而拦截器则可以通过IoC容器来管理，因此可以通过注入等方式来获取其他Bean的实例，因此使用会更方便</li></ul><h3 id="2-3-总结">2.3 总结</h3><ul><li>过滤器可以修改request，而拦截器不能  </li><li>过滤器需要在servlet容器中实现，拦截器可以适用于javaEE，javaSE等各种环境</li><li>拦截器可以调用IOC容器中的各种依赖，而过滤器不能</li><li>过滤器只能在请求的前后使用，而拦截器可以详细到每个方法</li></ul><p>具体的执行调用流程如下</p><p><img src="https://img-blog.csdnimg.cn/0c4dc4e4867a4edb8163950eb3db8865.png#pic_center" alt="在这里插入图片描述"></p><ul><li>过滤器（Filter） ：可以拿到原始的http请求，但是拿不到你请求的控制器和请求控制器中的方法的信息</li><li>拦截器（Interceptor）：可以拿到你请求的控制器和方法，却拿不到请求方法的参数</li><li>切片（Aspect）: 可以拿到方法的参数，但是却拿不到http请求和响应的对象</li></ul><p><img src="https://img-blog.csdnimg.cn/e041e0dadd6c44238a65b91d68ab42f5.png#pic_center" alt="在这里插入图片描述"></p><p>这里说一下为什么spring security使用过滤器而不是拦截器。因为作为一个通用的安全框架不应该耦合其他web框架的元素。很显然拦截器是spring mvc或struts等框架提供的，如果基于拦截器势必耦合这些框架，就做不到通用了</p><h2 id="3、Filters-vs-HandlerInterceptors">3、Filters vs HandlerInterceptors</h2><ul><li><em>Filter</em> 是 Servlet 规范中的，而 <em>HandlerInterceptor</em> 是 Spring 中的一个概念</li><li>拦截器位置相对于过滤器更靠后</li><li>精细的预处理任务适用于拦截器，如授权检查等</li><li>内容处理相关或通用的流程，非常适合用过滤器；如上传表单、zip 压缩、图像处理、日志记录请求、身份验证等</li><li><em>HandlerInterceptor</em> 的 <code>postHandle</code> 方法允许我们向视图添加更多模型对象，但不能更改 HttpServletResponse，因为它已经被提交了</li><li>过滤器的 <code>doFilter</code> 方法比拦截器的 <code>postHandle</code> 更通用。我们可以在过滤器中改变请求或响应，并将其传递给链，甚至阻止请求的处理</li><li><em>HandlerInterceptor</em> 提供了比过滤器更精细的控制，因为我们可以访问实际的目标 <em>handler</em>，甚至可以检查 handler 方法是否有某个特定的注解</li></ul><h1>二、过滤器</h1><h2 id="1、概述-v2">1、概述</h2><blockquote><p>过滤器（Filter）是处于客户端与服务器目标资源之间的⼀道过滤技术，当访问服务器的资源时，过滤器可以将请求拦截下来，完成⼀些特殊的功能</p></blockquote><p>执行是在Servlet之前，客户端发送请求时，会先经过Filter，再到达目标Servlet中；响应时， 会根据执行流程再次反向执行Filter，⼀般用于完成通用的操作。如：登录验证、统⼀编码处理、敏感字符过滤。常见的过滤器用途主要包括：<strong>对用户请求进行统一认证、对用户的访问请</strong>求进行记录和审核、对用户发送的数据进行过滤或替换、转换图象格式、对响应内容进行压缩以减少传输量、对请求或响应进行加解密处理、触发资源访问事件等</p><h2 id="2、生命周期">2、生命周期</h2><h3 id="2-1-生命周期概述">2.1 生命周期概述</h3><p>过滤器的配置比较简单，<strong>直接实现Filter 接口即可</strong>，也可以通过<code>@WebFilter</code>注解实现对特定URL拦截，看到Filter 接口中定义了三个方法。</p><ul><li><code>init()</code> ：该方法在容器启动初始化过滤器时被调用，它在 Filter 的整个生命周期只会被调用一次。注意：这个方法必须执行成功，否则过滤器会不起作用</li><li><code>doFilter()</code> ：容器中的每一次请求都会调用该方法，比如定义一个 Filter 拦截 <code>/path/*</code>，那么每一个匹配 <code>/path/*</code> 访问资源的请求进来时，都会执行此方法， FilterChain 用来调用下一个过滤器 Filter。不同的过滤器通过<code>@Order()</code>排序注解执行顺序</li><li><code>destroy()</code>： 当容器销毁 过滤器实例时调用该方法，一般在方法中销毁或关闭资源，在过滤器 Filter 的整个生命周期也只会被调用一次</li></ul><h3 id="2-2-基于函数回调实现原理">2.2 基于函数回调实现原理</h3><p>在我们自定义的过滤器中都会实现一个 <code>doFilter()</code>方法，这个方法有一个<code>FilterChain</code> 参数，而实际上它是一个回调接口。<code>ApplicationFilterChain</code>是它的实现类， 这个实现类内部也有一个 <code>doFilter()</code> 方法就是回调方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FilterChain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest var1, ServletResponse var2)</span> <span class="keyword">throws</span> IOException, ServletException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ApplicationFilterChain</code>里面能拿到我们自定义的<code>xxxFilter</code>类，在其内部回调方法<code>doFilter()</code>里调用各个自定义<code>xxxFilter</code>过滤器，并执行 <code>doFilter()</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationFilterChain</span> <span class="keyword">implements</span> <span class="title">FilterChain</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response)</span> </span>&#123;</span><br><span class="line">            ...<span class="comment">//省略</span></span><br><span class="line">            internalDoFilter(request,response);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">internalDoFilter</span><span class="params">(ServletRequest request, ServletResponse response)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pos &lt; n) &#123;</span><br><span class="line">            <span class="comment">//获取第pos个filter    </span></span><br><span class="line">            ApplicationFilterConfig filterConfig = filters[pos++];        </span><br><span class="line">            Filter filter = filterConfig.getFilter();</span><br><span class="line">            ...</span><br><span class="line">            filter.doFilter(request, response, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而每个<code>xxxFilter </code>会先执行自身的 <code>doFilter()</code> 过滤逻辑，最后在执行结束前会执行<code>filterChain.doFilter(servletRequest, servletResponse)</code>，也就是回调<code>ApplicationFilterChain</code>的<code>doFilter()</code> 方法，以此循环执行实现函数回调</p><h2 id="3、自定义过滤器两种实现方式">3、自定义过滤器两种实现方式</h2><p>不论是注解配置还是Java配置，都需要在启动类上加上<code>@ServletComponentScan(&quot;过滤器路径&quot;)</code>注解，过滤路径可以不写(或者直接注入容器交给spring管理)。注解注册和Java配置类注册，它们的自定义过滤器类都是一样的，只不过注册过程一个是通过<code>@WebFilter</code>注解，一个是通过Java配置类注册Bean。</p><h3 id="3-1-WebFilter注解注册">3.1 @WebFilter注解注册</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义注解过滤器实现</span></span><br><span class="line"><span class="comment"> * Filter的包是javax.servlet.Filter的</span></span><br><span class="line"><span class="comment"> * filterName：过滤器名称，需要唯一，不能重复</span></span><br><span class="line"><span class="comment"> * urlPatterns：要拦截的url资源路径，注意：通配符是一个星号（*）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Order</span>(<span class="number">2</span>)<span class="comment">//排序注解，执行顺序</span></span><br><span class="line"><span class="meta">@WebFilter</span>(filterName = <span class="string">"filterAnnotation"</span>,urlPatterns = &#123;<span class="string">"/study/interfaces/v1/user"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">filterAnnotation</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化操作，只会执行一次</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"filterAnnotation--初始化Filter"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进入到过滤资源之前和之后做的事情</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"filterAnnotation--进入Target Resource之前做的事情"</span>);</span><br><span class="line">        filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">        System.out.println(<span class="string">"filterAnnotation--处理返回的Response"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//销毁，只会在项目停止或者重新部署的时候才会执行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"filterAnnotation--销毁Filter"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再举一个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查用户是否已经完成登录</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebFilter</span>(filterName = <span class="string">"loginCheckFilter"</span>,urlPatterns = <span class="string">"/*"</span>)</span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginCheckFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span></span>&#123;</span><br><span class="line">    <span class="comment">//路径匹配器，支持通配符</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> AntPathMatcher PATH_MATCHER = <span class="keyword">new</span> AntPathMatcher();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        HttpServletRequest request = (HttpServletRequest) servletRequest;</span><br><span class="line">        HttpServletResponse response = (HttpServletResponse) servletResponse;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1、获取本次请求的URI</span></span><br><span class="line">        String requestURI = request.getRequestURI();<span class="comment">// /backend/index.html</span></span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"拦截到请求：&#123;&#125;"</span>,requestURI);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义不需要处理的请求路径</span></span><br><span class="line">        String[] urls = <span class="keyword">new</span> String[]&#123;</span><br><span class="line">                <span class="string">"/employee/login"</span>,</span><br><span class="line">                <span class="string">"/employee/logout"</span>,</span><br><span class="line">                <span class="string">"/backend/**"</span>,</span><br><span class="line">                <span class="string">"/front/**"</span>,</span><br><span class="line">                <span class="string">"/common/**"</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、判断本次请求是否需要处理</span></span><br><span class="line">        <span class="keyword">boolean</span> check = check(urls, requestURI);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、如果不需要处理，则直接放行</span></span><br><span class="line">        <span class="keyword">if</span>(check)&#123;</span><br><span class="line">            log.info(<span class="string">"本次请求&#123;&#125;不需要处理"</span>,requestURI);</span><br><span class="line">            filterChain.doFilter(request,response);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4、判断登录状态，如果已登录，则直接放行</span></span><br><span class="line">        <span class="keyword">if</span>(request.getSession().getAttribute(<span class="string">"employee"</span>) != <span class="keyword">null</span>)&#123;</span><br><span class="line">            log.info(<span class="string">"用户已登录，用户id为：&#123;&#125;"</span>,request.getSession().getAttribute(<span class="string">"employee"</span>));</span><br><span class="line"></span><br><span class="line">            Long empId = (Long) request.getSession().getAttribute(<span class="string">"employee"</span>);</span><br><span class="line">            BaseContext.setCurrentId(empId);</span><br><span class="line"></span><br><span class="line">            filterChain.doFilter(request,response);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"用户未登录"</span>);</span><br><span class="line">        <span class="comment">//5、如果未登录则返回未登录结果，通过输出流方式向客户端页面响应数据</span></span><br><span class="line">        response.getWriter().write(JSON.toJSONString(R.error(<span class="string">"NOTLOGIN"</span>)));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 路径匹配，检查本次请求是否需要放行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(String[] urls,String requestURI)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String url : urls) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> match = PATH_MATCHER.match(url, requestURI);</span><br><span class="line">            <span class="keyword">if</span>(match)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-过滤器（配置类注册过滤器）">3.2 过滤器（配置类注册过滤器）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    Logger logger = LoggerFactory.getLogger(BaseFilter<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String TOKEN = <span class="string">"20220423344556abac"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//内部接口集合</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; INSIDE_URLS = Lists.newArrayList(<span class="string">"/index"</span>,<span class="string">"/inside"</span>);</span><br><span class="line">    <span class="comment">//白名单接口集合</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; WHITE_PATH = Lists.newArrayList(<span class="string">"/white"</span>,<span class="string">"/login"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"初始化数据"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        HttpServletResponseWrapper wrapper = <span class="keyword">new</span> HttpServletResponseWrapper((HttpServletResponse)servletResponse);</span><br><span class="line">        HttpServletRequest request = (HttpServletRequest) servletRequest;</span><br><span class="line">        String requestURI = request.getRequestURI();</span><br><span class="line">        <span class="keyword">if</span>(INSIDE_URLS.contains(requestURI))&#123;</span><br><span class="line">            <span class="comment">//内部接口，直接通过</span></span><br><span class="line">            filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(WHITE_PATH.contains(requestURI))&#123;</span><br><span class="line">            <span class="comment">//白名单接口，直接通过</span></span><br><span class="line">            filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//进行校验，如token校验</span></span><br><span class="line">        String token = request.getHeader(<span class="string">"token"</span>);</span><br><span class="line">        <span class="keyword">if</span>(TOKEN.equals(token))&#123;</span><br><span class="line">            filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//token校验不通过，重定向到登录页面</span></span><br><span class="line">            wrapper.sendRedirect(<span class="string">"/login"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后设置配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 作用相当于<span class="doctag">@WebFilter</span>这个注解</span></span><br><span class="line"><span class="comment"> * 过滤器配置类，进过滤器配置到bean中</span></span><br><span class="line"><span class="comment"> * Filter的包是javax.servlet.Filter的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span><span class="comment">//这个注解的目的是被IOC容器获取到</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基础过滤器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FilterRegistrationBean&lt;Filter&gt; <span class="title">baseFilter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        FilterRegistrationBean&lt;Filter&gt; filterRegistrationBean = <span class="keyword">new</span> FilterRegistrationBean();</span><br><span class="line">        filterRegistrationBean.setFilter(<span class="keyword">new</span> BaseFilter());<span class="comment">//注册自定义过滤器类</span></span><br><span class="line">        <span class="comment">//过滤资源的路径，或者静态资源，注意：通配符是一个星号（*）</span></span><br><span class="line">        filterRegistrationBean.setUrlPatterns(Lists.newArrayList(<span class="string">"/*"</span>));</span><br><span class="line">        filterRegistrationBean.setOrder(<span class="number">1</span>);<span class="comment">//排序</span></span><br><span class="line">        <span class="keyword">return</span> filterRegistrationBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、实战OncePerRequestFilter">4、实战OncePerRequestFilter</h2><p>自定义配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"security.checker"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityCheckerConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Boolean enable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存放accessKey和accessSecurity</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; maps;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * sign的过期时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer signExpireTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面继承了OncePerRequestFilter 来实现我们自己的自定义过滤器，OncePerRequestFilter 特点是请求进入后只会过滤一次，不会重复过滤(有些情况请求可能会两次进入相同的过滤器)，同时在不符合要求的请求需要即使抛出异常返回，或者重定向到其他接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParamCheckFilter</span> <span class="keyword">extends</span> <span class="title">OncePerRequestFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">"handlerExceptionResolver"</span>)</span><br><span class="line">    <span class="keyword">private</span> HandlerExceptionResolver resolver;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自己在application.yaml定义的字段</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> SecurityCheckerConfig securityCheckerConfig;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!securityCheckerConfig.getEnable())&#123;</span><br><span class="line">            filterChain.doFilter(request,response);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String timestamp = request.getHeader(<span class="string">"timestamp"</span>);</span><br><span class="line">        String accessKey = request.getHeader(<span class="string">"accesskey"</span>);</span><br><span class="line">        String sign = request.getHeader(<span class="string">"sign"</span>);</span><br><span class="line">        <span class="comment">//根据key在配置文件拿取accessSecret</span></span><br><span class="line">        String accessSecret = securityCheckerConfig.getMaps().get(accessKey);</span><br><span class="line">        <span class="comment">//检查时间戳合法性</span></span><br><span class="line">        <span class="keyword">if</span>(!StringUtils.isNumeric(timestamp))&#123;</span><br><span class="line">            <span class="comment">// 异常类自定义的</span></span><br><span class="line">            resolver.resolveException(request,response,<span class="keyword">null</span>,<span class="keyword">new</span> TruckException(CustomCodeEnum.TIMESTAMP_IS_WRONGFUL));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//禁止超时签名</span></span><br><span class="line">        Long ts = Long.valueOf(timestamp);</span><br><span class="line">        <span class="keyword">if</span> (System.currentTimeMillis() - ts &gt; (securityCheckerConfig.getSignExpireTime() * CommonConstant.SECOND_TO_MILLIS)) &#123;</span><br><span class="line">            resolver.resolveException(request,response,<span class="keyword">null</span>,<span class="keyword">new</span> TruckException(CustomCodeEnum.SIGN_OVERTIME));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查KEY是否合理</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(accessKey) || StringUtils.isBlank(accessSecret)) &#123;</span><br><span class="line">            resolver.resolveException(request,response,<span class="keyword">null</span>,<span class="keyword">new</span> TruckException(CustomCodeEnum.ACCESSKEY_WRONGFUL));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!checkSign(getBody(request),accessSecret, sign))&#123;</span><br><span class="line">            resolver.resolveException(request,response,<span class="keyword">null</span>,<span class="keyword">new</span> TruckException(CustomCodeEnum.SIGN_ERROR));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        filterChain.doFilter(request,response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkSign</span><span class="params">(Map&lt;String, Object&gt; params, String accessSecret, String originSign)</span> </span>&#123;</span><br><span class="line">        String sign = createSign(params, accessSecret);</span><br><span class="line">        <span class="keyword">if</span> (!sign.equals(originSign)) &#123;</span><br><span class="line">            log.error(<span class="string">"sign 校验不通过！ params: &#123;&#125;, ours sign : &#123;&#125;, theirs : &#123;&#125;"</span>, params, sign, originSign);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取请求体（去除空值）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> LinkedHashMap&lt;String, Object&gt; <span class="title">getBody</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, String[]&gt; requestParameterMap = request.getParameterMap();</span><br><span class="line">        JSONObject params = <span class="keyword">new</span> JSONObject();</span><br><span class="line">        <span class="keyword">if</span>(!CollectionUtils.isEmpty(requestParameterMap))&#123;</span><br><span class="line">            requestParameterMap.forEach((k,v) -&gt; params.put(k,v[<span class="number">0</span>]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sortFields(params);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将请求参数按照ASCII码排序，方便校验sign</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> LinkedHashMap&lt;String, Object&gt; <span class="title">sortFields</span><span class="params">(JSONObject params)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将请求参数按照ASCII码排序，方便校验sign</span></span><br><span class="line">        String json = JSON.toJSONString(params, SerializerFeature.SortField);</span><br><span class="line">        <span class="keyword">return</span> JSONObject.parseObject(json, LinkedHashMap<span class="class">.<span class="keyword">class</span>, <span class="title">Feature</span>.<span class="title">OrderedField</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成sign</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> params 所有字段按照ASCII码排序，否则签名不一样</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">createSign</span><span class="params">(Map&lt;String, Object&gt; params, String accessSecret)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; keysSet = params.keySet();</span><br><span class="line">        Object[] keys = keysSet.toArray();</span><br><span class="line">        Arrays.sort(keys);</span><br><span class="line">        <span class="comment">// 拼接所有一级字段，二级字段不处理，但是字段按ASCII码排序</span></span><br><span class="line">        List&lt;String&gt; paramList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Object key : keys) &#123;</span><br><span class="line">            String value = String.valueOf(params.get(key));</span><br><span class="line">            String  str = key + <span class="string">"="</span> + value.replaceAll(<span class="string">"[\"| ]"</span>,<span class="string">""</span>).replaceAll(<span class="string">":"</span>, <span class="string">""</span>).trim();</span><br><span class="line">            paramList.add(str);</span><br><span class="line">        &#125;</span><br><span class="line">        paramList.add(<span class="string">"accessSecret="</span> + accessSecret);</span><br><span class="line">        String paramStr = String.join(<span class="string">"&amp;"</span>, paramList);</span><br><span class="line">        <span class="keyword">return</span> DigestUtils.md5DigestAsHex(paramStr.getBytes()).toUpperCase();</span><br><span class="line"><span class="comment">//        return DigestUtils.md5Hex(paramStr).toUpperCase();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里要注意的是我们用了<code>HandlerExceptionResolver</code> ，因为在Spring Boot由于全局异常处理<code>@RestControllerAdvice</code>只会去捕获所有Controller层抛出的异常，所以在filter当中抛出的异常GlobalExceptionHandler类是没有感知的，所以在filter当中抛出的异常最终会被Spring框架自带的全局异常处理类BasicErrorController捕获，会返回基础格式的Json响应</p><p>一种方法是继承上面所说的<code>BasicErrorController类</code>，并重写error()方法；另一种就是在filter当中引入<code>HandlerExceptionResolver</code>类，通过该类的<code>resolveException</code>方法抛出自定义异常，通过resolveException方法抛出的自定义异常可以被<code>RestControllerAdvice</code>捕获，从而满足我们的需求，最终得到的响应格式</p><h1>三、拦截器</h1><h2 id="1、概述-v3">1、概述</h2><p>拦截器采用AOP的设计思想， 它跟过滤器类似， 用来拦截处理方法在之前和之后执行一些 跟主业务没有关系的一些公共功能，比如可以实现权限控制、日志、异常记录、记录方法执行时间等等</p><h2 id="2、自定义拦截器">2、自定义拦截器</h2><h3 id="2-1-生命周期">2.1 生命周期</h3><p>SpringMVC提供了拦截器机制，允许运行目标方法之前进行一些拦截工作或者目标方法运行之后进行一下其他相关的处理。自定义的拦截器<strong>必须实现 HandlerInterceptor接口</strong>。</p><p>HandlerInterceptor 接口中定义了三个方法</p><ul><li><code>preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)</code> ：这个方法将在请求处理之前进行调用。注意：如果该方法的<strong>返回值为false ，将视为当前请求结束</strong>，不仅自身的拦截器会失效，还会导致其他的拦截器也不再执行。</li><li><code>postHandle(HttpServletRequest request, HttpServletResponse response, Object handler)</code>：只有在 preHandle() 方法返回值为true 时才会执行。会在Controller 中的方法调用之后，DispatcherServlet 返回渲染视图之前被调用。 此时我们可以通过modelAndView（模型和视图对象）对模型数据进行处理或对视图进行处理，modelAndView也可能为null</li><li><code>afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler)</code>：只有在 preHandle() 方法返回值为true 时才会执行。在整个请求结束之后， DispatcherServlet 渲染了对应的视图之后执行。如性能监控中我们可以在此记录结束时间并输出消耗时间，还可以进行一些资源清理，类似于<code>try­ catch ­finally</code>中的finally，但仅调用处理器执行链中preHandle返回true的拦截器才会执行</li></ul><h3 id="2-2-代码示例">2.2 代码示例</h3><p>首先创建自定义拦截器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFirstInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在处理方法之前执 日志、权限、 记录调用时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request 可以在方法请求进来之前更改request中的属性值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler 封装了当前处理方法的信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 后续调用链是否执行/ false 则中断后续执行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在请求映射到对应的处理方法映射，实现类才是HandlerMethod。</span></span><br><span class="line">        <span class="comment">// 如果是视图控制器，实现类ParameterizableViewController</span></span><br><span class="line">        <span class="keyword">if</span>(handler <span class="keyword">instanceof</span> HandlerMethod ) &#123;</span><br><span class="line">            HandlerMethod handMethod = (HandlerMethod) handler;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*System.out.println("-------类["+handMethod.getBean().getClass().getName()+"]" +</span></span><br><span class="line"><span class="comment">                "方法名["+handMethod.getMethod().getName()+"]" +</span></span><br><span class="line"><span class="comment">                "参数["+ Arrays.toString(handMethod.getMethod().getParameters()) +"]前执行--------preHandle");*/</span></span><br><span class="line">        System.out.println(<span class="keyword">this</span>.getClass().getName()+<span class="string">"---------方法后执行，在渲染之前--------------preHandle"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  如果preHandle返回false则会不会允许该方法</span></span><br><span class="line"><span class="comment">     *  在请求执行后执行, 在视图渲染之前执行</span></span><br><span class="line"><span class="comment">     *  当处理方法出现了异常则不会执行方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response 可以在方法执行后去更改response中的信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler  封装了当前处理方法的信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> modelAndView 封装了model和view.所以当请求结束后可以修改model中的数据或者新增model数据，也可以修改view的跳转</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.getClass().getName()+<span class="string">"---------方法后执行，在渲染之前--------------postHandle"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果preHandle返回false则会不会允许该方法</span></span><br><span class="line"><span class="comment">     * 在视图渲染之后执行，相当于try catch finally 中finally，出现异常也一定会执行该方法</span></span><br><span class="line"><span class="comment">     * 如果执行的时候核心的业务代码出问题了，那么已经通过的拦截器的 afterCompletion会接着执行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ex  Exception对象，在该方法中去做一些：记录异常日志的功能，或者清除资源</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.getClass().getName()+<span class="string">"---------在视图渲染之后--------------afterCompletion"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在spring boot 项目中配置，实现 <code>WebMvcConfigurer </code>接口 并重写 <code>addInterceptors</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorAdapter</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyFirstInterceptor <span class="title">myInterceptor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyFirstInterceptor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addInterceptor(myInterceptor())</span><br><span class="line">            .addPathPatterns(<span class="string">"/**"</span>)</span><br><span class="line">            .excludePathPatterns(<span class="string">"/*.html"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/test01"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"请求方法执行中..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"admin"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-多拦截器示例">2.3 多拦截器示例</h3><p>拦截顺序取决于配置的顺序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorAdapter</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyFirstInterceptor <span class="title">myInterceptor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyFirstInterceptor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MySecondInterceptor <span class="title">mySecondInterceptor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MySecondInterceptor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addInterceptor(myInterceptor()).addPathPatterns(<span class="string">"/**"</span>).excludePathPatterns(<span class="string">"/*.html"</span>);</span><br><span class="line">        registry.addInterceptor(mySecondInterceptor()).addPathPatterns(<span class="string">"/**"</span>)</span><br><span class="line">        .excludePathPatterns(<span class="string">"/*.html"</span>)</span><br><span class="line">        .order(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到输出结果发现，先声明的拦截器 preHandle() 方法先执行，而postHandle()方法反而会后执行。<strong>但注意postHandle() 方法被调用的顺序跟 preHandle() 是相反的</strong>。我们要知道controller 中所有的请求都要经过核心组件<strong>DispatcherServlet</strong>路由，都会执行它的 <code>doDispatch()</code> 方法，而拦截器postHandle()、preHandle()方法便是在其中调用的。查看源码可知，发现两个方法中在调用拦截器数组 HandlerInterceptor[] 时，循环的顺序竟然是相反的</p><h3 id="3-4-静态资源被拦截问题">3.4 静态资源被拦截问题</h3><p>配置拦截器会导致静态资源被拦截，比如在 resources/static/ 目录下放置一个图片资源或者 html 文件，然后启动项目直接访问，即可看到无法访问的现象。也就是说，虽然 Spring Boot 2.0 废弃了<code>WebMvcConfigurerAdapter</code>，但是 <code>WebMvcConfigurationSupport</code> 又会导致默认的静态资源被拦截，这就需要我们手动将静态资源放开</p><p>除了在 MyInterceptorConfig 配置类中重写 <code>addInterceptors</code> 方法外，还需要再重写一个方法：<code>addResourceHandlers</code>，将静态资源放开</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用来指定静态资源不被拦截，否则继承WebMvcConfigurationSupport这种方式会导致静态资源无法直接访问</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> registry</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">    registry.addResourceHandler(<span class="string">"/**"</span>).addResourceLocations(<span class="string">"classpath:/static/"</span>);</span><br><span class="line">    <span class="keyword">super</span>.addResourceHandlers(registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样配置好之后，重启项目，静态资源也可以正常访问了。</p><p>另一种方法是不继承 <code>WebMvcConfigurationSupport </code>类，直接实现 <code>WebMvcConfigurer </code>接口，然后重写 <code>addInterceptors</code> 方法，将自定义的拦截器添加进去即可（上面讲到）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptorConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实现WebMvcConfigurer不会导致静态资源被拦截</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> MyInterceptor()).addPathPatterns(<span class="string">"/**"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、实战demo">4、实战demo</h2><p>判断用户有没有登录，一般用户登录功能我们可以这么做，要么往 session 中写一个 user，要么针对每个 user 生成一个 token，第二种要更好一点，那么针对第二种方式，如果用户登录成功了，每次请求的时候都会带上该用户的 token，如果未登录，则没有该 token，服务端可以检测这个 token 参数的有无来判断用户有没有登录，从而实现拦截功能。我们改造一下 <code>preHandle</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    HandlerMethod handlerMethod = (HandlerMethod) handler;</span><br><span class="line">    Method method = handlerMethod.getMethod();</span><br><span class="line">    String methodName = method.getName();</span><br><span class="line">    logger.info(<span class="string">"====拦截到了方法：&#123;&#125;，在该方法执行之前执行===="</span>, methodName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断用户有没有登陆，一般登陆之后的用户都有一个对应的token</span></span><br><span class="line">    String token = request.getParameter(<span class="string">"token"</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == token || <span class="string">""</span>.equals(token)) &#123;</span><br><span class="line">        logger.info(<span class="string">"用户未登录，没有权限执行……请登录"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回true才会继续执行，返回false则取消当前请求</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后还有一个监听器，可以参考：<a href="https://blog.csdn.net/lemon_TT/article/details/126063399" target="_blank" rel="noopener" title="Spring事件监听">Spring事件监听</a></p><hr><p><a href="https://zhuanlan.zhihu.com/p/340397290" target="_blank" rel="noopener" title="https://zhuanlan.zhihu.com/p/340397290">https://zhuanlan.zhihu.com/p/340397290</a></p><p><a href="https://zhuanlan.zhihu.com/p/484289805" target="_blank" rel="noopener" title="https://zhuanlan.zhihu.com/p/484289805">https://zhuanlan.zhihu.com/p/484289805</a></p><p><a href="https://www.zhihu.com/question/443466900/answer/2509838187" target="_blank" rel="noopener" title="https://www.zhihu.com/question/443466900/answer/2509838187">https://www.zhihu.com/question/443466900/answer/2509838187</a>  </p><p><a href="https://blog.csdn.net/qq_45534061/article/details/106266747" target="_blank" rel="noopener" title="https://blog.csdn.net/qq_45534061/article/details/106266747">https://blog.csdn.net/qq_45534061/article/details/106266747</a></p><p><a href="https://blog.csdn.net/m0_37731470/article/details/116754395" target="_blank" rel="noopener" title="https://blog.csdn.net/m0_37731470/article/details/116754395">https://blog.csdn.net/m0_37731470/article/details/116754395</a></p><p><a href="https://blog.csdn.net/xinzhifu1/article/details/106356958/" target="_blank" rel="noopener" title="https://blog.csdn.net/xinzhifu1/article/details/106356958/">https://blog.csdn.net/xinzhifu1/article/details/106356958/</a></p>]]></content>
    
    
    <summary type="html">&lt;h1&gt;一、前言&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;常用项目编写规范参考：&lt;a href=&quot;https://blog.csdn.net/lemon_TT/article/details/108309900&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; title=&quot;Spring Boot后端接口规范&quot;&gt;Spring Boot后端接口规范&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1、概述&quot;&gt;1、概述&lt;/h2&gt;
&lt;p&gt;前面讲到数据统一响应、全局异常等常用后端框架，那么随着项目的开发，需要对请求进行校验(参数校验、前面校验等)，不符合的不进入后端业务逻辑，提前返回并抛出异常。一般实现方法有拦截器和过滤器，这两者都可以实现对应的功能，可以根据自己喜好进行编写。&lt;/p&gt;
&lt;p&gt;过滤器一般完成通用的操作。如：&lt;strong&gt;登录验证、统⼀编码处理、敏感字符过滤&lt;/strong&gt;，常见的过滤器用途主要包括：&lt;strong&gt;对用户请求进行统一认证、对用户的访问请求进行记录和审核&lt;/strong&gt;、对用户发送的数据进行过滤或替换、转换图象格式、对响应内容进行压缩以减少传输量、对请求或响应进行加解密处理、触发资源访问事件等；拦截器采用AOP的设计思想， 它跟过滤器类似， 用来&lt;strong&gt;拦截处理方法在之前和之后执行一些 跟主业务没有关系的一些公共功能&lt;/strong&gt;，比如&lt;strong&gt;权限控制、日志、异常记录、记录方法执行时间&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://www.shawn22.xyz/categories/Java/"/>
    
    
    <category term="Spring基础" scheme="https://www.shawn22.xyz/tags/Spring%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot监控</title>
    <link href="https://www.shawn22.xyz/posts/d1523d3d.html"/>
    <id>https://www.shawn22.xyz/posts/d1523d3d.html</id>
    <published>2023-03-05T16:18:15.000Z</published>
    <updated>2023-03-05T16:27:29.982Z</updated>
    
    <content type="html"><![CDATA[<h1>一、Prometheus+Grafana监控Springboot</h1><h2 id="1、简介">1、简介</h2><p>任何一个系统上线，运维监控都太重要了。关于Springboot微服务的监控，之前写过<a href="https://blog.csdn.net/lemon_TT/article/details/124675465" target="_blank" rel="noopener" title="Spring Boot Admin服务监控">Spring Boot Admin服务监控</a>，这个方案可以<strong>实时监控并提供告警提醒功能，但不能记录历史数据</strong>，无法查看过去1小时或过去1天等运维情况。本文介绍Prometheus + Grafana的方法监控Springboot 2.X，实现美观漂亮的数据可视化。</p><a id="more"></a><h2 id="2、SpringBoot应用镜像搭建">2、SpringBoot应用镜像搭建</h2><h3 id="2-1-springboot应用创建">2.1 springboot应用创建</h3><p>引入依赖，springboot选用2.x，jdk8</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Exposition servlet --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- prometheus --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Hotspot JVM metrics--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.micrometer<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>micrometer-registry-prometheus<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>创建测试Controller，提供1000个线程方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(TestController<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 创建线程</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@RequestMapping</span>(<span class="string">""</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        logger.info(Thread.currentThread().getName());</span><br><span class="line">      &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在resources目录下创建application.yml配置文件，endpoints可以参考：<a href="https://blog.csdn.net/lemon_TT/article/details/127089969" target="_blank" rel="noopener" title="SpringBoot生产监控">SpringBoot生产监控</a></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span> </span><br><span class="line">  <span class="attr">port:</span> <span class="number">8888</span></span><br><span class="line">  </span><br><span class="line"><span class="attr">spring:</span> </span><br><span class="line">  <span class="attr">application:</span> </span><br><span class="line">    <span class="attr">name:</span> <span class="string">monitor-demo</span></span><br><span class="line">  <span class="attr">security:</span> </span><br><span class="line">    <span class="attr">user:</span> </span><br><span class="line">      <span class="attr">name:</span> <span class="string">admin</span></span><br><span class="line">      <span class="attr">password:</span> <span class="number">123456</span> </span><br><span class="line"> </span><br><span class="line"><span class="attr">management:</span> </span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">"*"</span></span><br></pre></td></tr></table></figure><h3 id="2-2-镜像创建">2.2 镜像创建</h3><p>上传服务器创建Dockerfile</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基于java镜像创建新镜像</span></span><br><span class="line"><span class="keyword">FROM</span> java:<span class="number">8</span></span><br><span class="line"><span class="comment"># 作者</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> shawn</span><br><span class="line"><span class="comment"># 将jar包添加到容器中并更名为app.jar</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash">  ./visualization.jar /visualization.jar</span></span><br><span class="line"><span class="comment"># 运行jar包</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"nohup"</span>,<span class="string">"java"</span>,<span class="string">"-jar"</span>,<span class="string">"/visualization.jar"</span>,<span class="string">"&amp;"</span>]</span></span><br></pre></td></tr></table></figure><p>打包与运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker build -t demo01 .</span><br><span class="line">docker run -d -p 8888:8888 --name demo01 demo01</span><br><span class="line">docker ps -a</span><br><span class="line">docker logs demo01</span><br><span class="line"><span class="comment"># 浏览器访问，输入用户名密码：admin/123456</span></span><br><span class="line">http://192.168.31.98:8888/actuator/prometheus</span><br></pre></td></tr></table></figure><h2 id="3、Prometheus">3、Prometheus</h2><h3 id="3-1-概述">3.1 概述</h3><p>Prometheus是一个开源的服务监控系统时间序列数据库，通过Http请求拉取被监控的服务暴露的端点公开的度量列表和值，然后存放到时序数据库中，在现在最常见的<code>Kubernetes</code>容器管理系统中。最好再通过 Grafana的Dashboard进行图表展示分析和告警</p><h3 id="3-2-Prometheus创建">3.2 Prometheus创建</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p visual/prometheus</span><br><span class="line"><span class="built_in">cd</span> visual</span><br><span class="line"></span><br><span class="line">docker pull prom/prometheus</span><br><span class="line">docker images</span><br><span class="line"><span class="comment"># 注意这里先创建好配置文件，配置文件见下面</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始启动运行，注意修改路径</span></span><br><span class="line">docker run --name=prometheus --privileged=<span class="literal">true</span> \</span><br><span class="line">-p 9090:9090 -m 500M \</span><br><span class="line">--restart=on-failure:3 \</span><br><span class="line">-v /home/shawn/visual/prometheus.yml:/prometheus.yml \</span><br><span class="line">-v /home/shawn/visual/prometheus/data:/data -d prom/prometheus \</span><br><span class="line">--config.file=/prometheus.yml</span><br><span class="line"></span><br><span class="line">docker ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后就可以打开网页查看</span></span><br><span class="line">http://192.168.31.98:9090/targets</span><br></pre></td></tr></table></figure><p>准备配置文件<code>prometheus.yml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">scrape_configs:</span> </span><br><span class="line">  <span class="comment"># 可随意指定，默认保存15天</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">monitor-demo</span></span><br><span class="line">    <span class="comment"># 多久采集一次数据</span></span><br><span class="line">    <span class="attr">scrape_interval:</span> <span class="string">5s</span></span><br><span class="line">    <span class="comment"># 采集时的超时时间</span></span><br><span class="line">    <span class="attr">scrape_timeout:</span> <span class="string">5s</span></span><br><span class="line">    <span class="comment"># 采集的路径</span></span><br><span class="line">    <span class="attr">metrics_path:</span> <span class="string">/actuator/prometheus</span></span><br><span class="line">    <span class="attr">scheme:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">basic_auth:</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">      <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="comment"># 采集服务的地址，设置成Springboot应用所在服务器的具体地址</span></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">      <span class="comment"># 可以多个地址- targets: ['hostname:9000','hostname:8080']</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">targets:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.31</span><span class="number">.98</span><span class="string">:8888</span></span><br></pre></td></tr></table></figure><p>结果页面<br><img src="https://img-blog.csdnimg.cn/b664b1fc48a940c49f48a3996d9dc450.png#pic_center" alt="在这里插入图片描述"></p><h2 id="4、Grafana可视化监控">4、Grafana可视化监控</h2><h3 id="4-1-可视化">4.1 可视化</h3><p>Docker部署Grafana，注意镜像源的修改</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker pull grafana/grafana</span><br><span class="line">docker images</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 </span></span><br><span class="line">docker run --name=grafana -p 3000:3000 --restart=always -d grafana/grafana</span><br></pre></td></tr></table></figure><p>浏览器访问：<code>http://192.168.31.98:3000</code>，输入用户名密码：admin/admin。成功登录后首先导入数据源，<code>Settings--&gt;Data Sources--&gt;选择Prometheus --&gt;url填写http://192.168.31.98:9090(刚才Prometheus 的地址)--&gt;保存</code></p><p>然后导入可视化面板：点击<code>+</code>号 --&gt; <code>Import</code> --&gt; 输入模板链接或ID --&gt; 点击Load</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里推荐一个模板id:10280</span></span><br><span class="line"><span class="comment"># 模板官网：https://grafana.com/grafana/dashboards</span></span><br></pre></td></tr></table></figure><p>当然各个面板可以自定义，不过要注意的是，面板的数据需要在<code>http://192.168.31.98:9090/graph</code>查得到才行，可以点击Explore→Metrics browser查看<br><img src="https://img-blog.csdnimg.cn/b2a36a8fe1d84feda6c5ea201e22700b.png#pic_center" alt="在这里插入图片描述"></p><h3 id="4-2-告警设置">4.2 告警设置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run --name=grafana -p 3000:3000 \</span><br><span class="line">-v /home/shawn/visual/custom.ini:/usr/grafana/conf/custom.ini \</span><br><span class="line">--restart=always -d grafana/grafana \</span><br><span class="line">--config /usr/grafana/conf/custom.ini</span><br></pre></td></tr></table></figure><p>custom.ini</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#第522行修改smtp配置，所有修改配置前 ; 注释符号需要取消，将对应行，改为以下内容：</span></span><br><span class="line"><span class="section">[smtp]</span></span><br><span class="line"><span class="comment">#启用smtp</span></span><br><span class="line"><span class="attr">enabled</span> = <span class="literal">true</span>                 </span><br><span class="line"><span class="comment">#qq smtp服务地址</span></span><br><span class="line"><span class="attr">host</span> = smtp.qq.com:<span class="number">465</span>        </span><br><span class="line"><span class="comment">#qq邮箱用户名</span></span><br><span class="line"><span class="attr">user</span> = <span class="number">86251</span>xxx@qq.com   </span><br><span class="line"><span class="comment"># If the password contains # or ; you have to wrap it with triple quotes. Ex """#password;"""</span></span><br><span class="line"><span class="attr">password</span> = xxxxx     <span class="comment">#授权密码</span></span><br><span class="line"><span class="comment">#邮件From地址，和登录用户一致即可。</span></span><br><span class="line"><span class="attr">from_address</span> = <span class="number">86251</span>xxx@qq.com  </span><br><span class="line"><span class="comment">#修改完邮件配置后修改domain信息，邮件内容中包含Grafana的访问地址，默认地址为localhost</span></span><br></pre></td></tr></table></figure><h1>二、轻量级日志系统Loki</h1><blockquote><p>Loki官网：<a href="https://grafana.com/oss/loki/" target="_blank" rel="noopener" title="https://grafana.com/oss/loki/">https://grafana.com/oss/loki/</a></p></blockquote><h2 id="1、简介-v2">1、简介</h2><h3 id="1-1-介绍">1.1 介绍</h3><p>Loki是受Prometheus启发由Grafana Labs团队开源的水平可扩展，高度可用的多租户日志聚合系统。 开发语言: Google Go。它的设计具有很高的成本效益，并且易于操作。使用标签来作为索引，而不是对全文进行检索，也就是说，你通过这些标签既可以查询日志的内容也可以查询到监控的数据签，极大地降低了日志索引的存储。系统架构十分简单，由以下3个部分组成 ：</p><ul><li>Loki 是主服务器，负责存储日志和处理查询 。</li><li>promtail 是代理，负责收集日志并将其发送给 loki 。</li><li>Grafana 用于 UI 展示。</li></ul><p>只要在应用程序服务器上安装promtail来收集日志然后发送给Loki存储，就可以在Grafana UI界面通过添加Loki为数据源进行日志查询（如果Loki服务器性能不够，可以部署多个Loki进行存储及查询）。作为一个日志系统不关只有查询分析日志的能力，还能对日志进行监控和报警</p><h3 id="1-2-与ELK差异">1.2 与ELK差异</h3><ul><li>ELK虽然功能丰富，但规模复杂，资源占用高，操作苦难，很多功能往往用不上，有点杀鸡用牛刀的感觉。</li><li>不对日志进行全文索引。通过存储压缩非结构化日志和仅索引元数据，Loki 操作起来会更简单，更省成本。</li><li>通过使用与 Prometheus 相同的标签记录流对日志进行索引和分组，这使得日志的扩展和操作效率更高。</li><li>安装部署简单快速，且受 Grafana 原生支持</li></ul><h2 id="2、grafana-loki日志系统基本使用">2、grafana loki日志系统基本使用</h2><blockquote><p>高版本可以参考：<a href="https://grafana.com/docs/loki/latest/installation/docker/" target="_blank" rel="noopener" title="https://grafana.com/docs/loki/latest/installation/docker/">https://grafana.com/docs/loki/latest/installation/docker/</a></p></blockquote><h3 id="2-1-本机日志收集">2.1 本机日志收集</h3><p>这里直接使用docker-compose进行安装了，<code>docker-compose -f docker-compose.yaml up -d</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3"</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">loki:</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">loki:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">grafana/loki:1.5.0</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">LANG=zh_CN.UTF-8</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"3100:3100"</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">-config.file=/etc/loki/local-config.yaml</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">loki</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">promtail:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">grafana/promtail:1.5.0</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">LANG=zh_CN.UTF-8</span></span><br><span class="line">    <span class="comment"># 日志映射路径自己修改</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/var/log/:/var/log/</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">-config.file=/etc/promtail/docker-config.yaml</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">loki</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">grafana:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">grafana/grafana:latest</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">LANG=zh_CN.UTF-8</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"3000:3000"</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">loki</span></span><br></pre></td></tr></table></figure><h3 id="2-2-docker日志容器查看">2.2 docker日志容器查看</h3><p>promtail只能收集本机的日志文件，如果要收集docker容器日志文件，需要在安装一个docker插件<code>loki-docker-driver</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装插件</span></span><br><span class="line">docker plugin install grafana/loki-docker-driver:latest --<span class="built_in">alias</span> loki --grant-all-permissions</span><br><span class="line"><span class="comment"># 当有新版本时, 更新plugins</span></span><br><span class="line">docker plugin <span class="built_in">disable</span> loki --force</span><br><span class="line">docker plugin upgrade loki grafana/loki-docker-driver:latest --grant-all-permissions</span><br><span class="line">docker plugin <span class="built_in">enable</span> loki</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><p>对于loki的<a href="https://github.com/cyriltovena/loki/blob/master/docs/sources/clients/docker-driver/configuration.md" target="_blank" rel="noopener" title="docker plugin">docker plugin</a>有两种使用方式。</p><ul><li>配置daemon.json,收集此后创建的所有容器的日志(注意，是配置daemon.json后重启docker服务后创建的容器才会把日志输出到loki</li><li>新建容器时指定logging类型为loki，这样只有指定了logging的容器才会输出到loki</li></ul><p><strong>全局收集配置</strong></p><p>编辑daemon.json，linux下默认路径是<code>/etc/docker/daemon.json (需要sudo)</code>， windows则默认是%userprofile%\.docker\daemon.json</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#123;</span></span><br><span class="line">  <span class="comment"># 加速地址</span></span><br><span class="line">  <span class="attr">"registry-mirrors":</span> <span class="string">["https://xxx.mirror.aliyuncs.com"],</span></span><br><span class="line">  <span class="attr">"log-driver":</span> <span class="string">"loki"</span><span class="string">,</span></span><br><span class="line">  <span class="attr">"log-opts":</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="comment"># 配置的loki服务器地址</span></span><br><span class="line">    <span class="attr">"loki-url":</span> <span class="string">"http://192.168.1.1:3100/loki/api/v1/push"</span><span class="string">,</span></span><br><span class="line">    <span class="comment"># "loki-pipeline-stages": "- multiline:\n      firstline: '^\[\d&#123;2&#125;:\d&#123;2&#125;:\d&#123;2&#125; \w&#123;4&#125;\]'\n",</span></span><br><span class="line">    <span class="attr">"max-size":</span> <span class="string">"50m"</span><span class="string">,</span></span><br><span class="line">    <span class="attr">"max-file":</span> <span class="string">"10"</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>max-size表示日志文件最大大小</li><li>max-file表示最多10个日志文件，都是对单个容器来说的,  </li><li><a href="https://github.com/cyriltovena/loki/blob/master/docs/sources/clients/promtail/stages/multiline.md" target="_blank" rel="noopener" title="multiline">multiline</a>是配置多行识别(默认最多128行)，转为单行，firstline表示单条日志的首行正则表达式。例如 [03:00:32 INFO] 开头这种格式,所以对应正则是^\[\d{2}:\d{2}:\d{2} \w{4}\]  按照你自己的日志开头编写对应正则替换即可</li></ul><p>最后重启docker，<code>sudo systemctl restart docker</code>，在此之后创建的容器默认都会把日志发送到loki</p><p><strong>docker run配置日志输出到loki</strong></p><p>通过docker run启动容器，可以通过–log-driver来指定为loki，进行特定的容器日志收集</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8888:8888 --rm --name=demo01 \</span><br><span class="line">--<span class="built_in">log</span>-driver=loki --<span class="built_in">log</span>-opt loki-url=<span class="string">"http://YOUR_IP:3100/loki/api/v1/push"</span> \</span><br><span class="line">--<span class="built_in">log</span>-opt max-size=50m --<span class="built_in">log</span>-opt max-file=10 \</span><br><span class="line">demo01</span><br></pre></td></tr></table></figure><ul><li>–log-driver=loki指定日志驱动器为loki</li><li>–log-opt loki-url则指定了loki的url</li><li>–log-opt max-size日志最大大小</li><li>–log-opt max-file日志文件最大数量</li></ul><p><strong>docker-compose 配置日志输出到loki</strong></p><p>docker-compose 小于3.4可以对需要日志输出的配置添加配置如下，注意：max-size和max-file这里需要加引号</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">driver:</span> <span class="string">loki</span></span><br><span class="line">  <span class="attr">options:</span></span><br><span class="line">    <span class="attr">loki-url:</span> <span class="string">"http://YOUR_IP:3100/loki/api/v1/push"</span></span><br><span class="line">    <span class="attr">max-size:</span> <span class="string">"50m"</span></span><br><span class="line">    <span class="attr">max-file:</span> <span class="string">"10"</span></span><br><span class="line">    <span class="attr">loki-pipeline-stages:</span> <span class="string">|</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">multiline:</span></span><br><span class="line">          <span class="attr">firstline:</span> <span class="string">'^\[\d&#123;2&#125;:\d&#123;2&#125;:\d&#123;2&#125; \w&#123;4&#125;\]'</span></span><br></pre></td></tr></table></figure><p>对于3.4及其以上版本可以通过定义模板来减少代码量</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3.4"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">x-logging:</span></span><br><span class="line">  <span class="string">&amp;loki-logging</span></span><br><span class="line">  <span class="attr">driver:</span> <span class="string">loki</span></span><br><span class="line">  <span class="attr">options:</span></span><br><span class="line">    <span class="attr">loki-url:</span> <span class="string">"http://YOUR_IP:3100/loki/api/v1/push"</span></span><br><span class="line">    <span class="attr">max-size:</span> <span class="string">"50m"</span></span><br><span class="line">    <span class="attr">max-file:</span> <span class="string">"10"</span></span><br><span class="line">    <span class="attr">loki-pipeline-stages:</span> <span class="string">|</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">multiline:</span></span><br><span class="line">          <span class="attr">firstline:</span> <span class="string">'^\[\d&#123;2&#125;:\d&#123;2&#125;:\d&#123;2&#125; \w&#123;4&#125;\]'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">host:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">grafana</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">grafana/grafana</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">LANG=zh_CN.UTF-8</span></span><br><span class="line">    <span class="attr">logging:</span> <span class="string">*loki-logging</span></span><br></pre></td></tr></table></figure><h3 id="2-3-grafana可视化">2.3 grafana可视化</h3><p>打开grafana，<code>http://192.168.1.1:3000</code>(换成自己的ip)，账户密码为admin/admin，进入后首先配置配置<code>Data sources</code>，选择Loki数据源，url填写<code>http://192.168.1.1:3100</code>(换成自己的ip)，保存后点击Explore即可成功查看</p><p><img src="https://img-blog.csdnimg.cn/7143efd4ddd34db49c6d3356dfa9cd21.png#pic_center" alt="在这里插入图片描述"></p><h2 id="3、grafana-prometheus-loki-监控docker容器收集服务日志">3、grafana+prometheus+loki 监控docker容器收集服务日志</h2><h3 id="3-1-创建grafana，prometheus文件夹及配置文件">3.1 创建grafana，prometheus文件夹及配置文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line"><span class="comment"># 创建grafana文件夹</span></span><br><span class="line">mkdir -p grafana/grafana</span><br><span class="line">mkdir -p grafana/grafana/data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建prometheus文件夹</span></span><br><span class="line">mkdir -p grafana/prometheus</span><br><span class="line">mkdir -p grafana/prometheus/data</span><br><span class="line">mkdir -p grafana/prometheus/<span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建prometheus配置文件</span></span><br><span class="line">vim grafana/prometheus/prometheus.yml</span><br></pre></td></tr></table></figure><p>注意ip和路径的修改</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">global:</span></span><br><span class="line">  <span class="attr">scrape_interval:</span>     <span class="string">15s</span></span><br><span class="line">  <span class="attr">evaluation_interval:</span> <span class="string">15s</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 报警暂时不需要，后续可以添加</span></span><br><span class="line"><span class="comment">#alerting:</span></span><br><span class="line"><span class="comment">#  alertmanagers:</span></span><br><span class="line"><span class="comment">#  - static_configs:</span></span><br><span class="line"><span class="comment">#    - targets:</span></span><br><span class="line"><span class="comment">#      - alertmanager:9093</span></span><br><span class="line"></span><br><span class="line"><span class="attr">rule_files:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"*rules.yml"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line">  <span class="comment"># prometheus</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">'prometheus'</span></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">targets:</span> <span class="string">['192.168.249.149:9090']</span></span><br><span class="line">  <span class="comment"># 主机监控</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">'node'</span></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">targets:</span> <span class="string">['192.168.249.149:9100']</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment"># docker资源监控</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">'cadvisor'</span></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">targets:</span> <span class="string">['192.168.249.149:8080']</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># springboot 项目监控</span></span><br><span class="line"><span class="comment"># springboot 监控需要项目中集成prometheus</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">monitor-demo</span></span><br><span class="line">    <span class="comment"># 多久采集一次数据</span></span><br><span class="line">    <span class="attr">scrape_interval:</span> <span class="string">5s</span></span><br><span class="line">    <span class="comment"># 采集时的超时时间</span></span><br><span class="line">    <span class="attr">scrape_timeout:</span> <span class="string">5s</span></span><br><span class="line">    <span class="comment"># 采集的路径</span></span><br><span class="line">    <span class="attr">metrics_path:</span> <span class="string">/actuator/prometheus</span></span><br><span class="line">    <span class="attr">scheme:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">basic_auth:</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">      <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="comment"># 采集服务的地址，设置成Springboot应用所在服务器的具体地址</span></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">      <span class="comment"># 可以多个地址- targets: ['hostname:9000','hostname:8080']</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">targets:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">localhost:8888</span></span><br><span class="line"> <span class="comment">#  - job_name: 'alertmanager'</span></span><br><span class="line"><span class="comment">#    static_configs:</span></span><br><span class="line"><span class="comment">#    - targets: ['alertmanager:9093']</span></span><br></pre></td></tr></table></figure><h3 id="3-2-创建loki-文件夹及配置文件">3.2 创建loki 文件夹及配置文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p grafana/loki</span><br><span class="line">mkdir -p grafana/loki/chunks</span><br><span class="line">mkdir -p grafana/loki/rules</span><br><span class="line"></span><br><span class="line">vim grafana/loki/<span class="built_in">local</span>-config.yaml</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">auth_enabled:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">http_listen_port:</span> <span class="number">3100</span></span><br><span class="line"></span><br><span class="line"><span class="attr">common:</span></span><br><span class="line">  <span class="attr">path_prefix:</span> <span class="string">/loki</span></span><br><span class="line">  <span class="attr">storage:</span></span><br><span class="line">    <span class="attr">filesystem:</span></span><br><span class="line">      <span class="attr">chunks_directory:</span> <span class="string">/loki/chunks</span></span><br><span class="line">      <span class="attr">rules_directory:</span> <span class="string">/loki/rules</span></span><br><span class="line">  <span class="attr">replication_factor:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">ring:</span></span><br><span class="line">    <span class="attr">instance_addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">kvstore:</span></span><br><span class="line">      <span class="attr">store:</span> <span class="string">inmemory</span></span><br><span class="line"></span><br><span class="line"><span class="attr">schema_config:</span></span><br><span class="line">  <span class="attr">configs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">from:</span> <span class="number">2020</span><span class="number">-10</span><span class="number">-24</span></span><br><span class="line">      <span class="attr">store:</span> <span class="string">boltdb-shipper</span></span><br><span class="line">      <span class="attr">object_store:</span> <span class="string">filesystem</span></span><br><span class="line">      <span class="attr">schema:</span> <span class="string">v11</span></span><br><span class="line">      <span class="attr">index:</span></span><br><span class="line">        <span class="attr">prefix:</span> <span class="string">index_</span></span><br><span class="line">        <span class="attr">period:</span> <span class="string">24h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 日志保存时长配置 12小时的倍数</span></span><br><span class="line"><span class="attr">table_manager:</span> </span><br><span class="line">  <span class="attr">retention_deletes_enabled:</span> <span class="literal">true</span> </span><br><span class="line">  <span class="attr">retention_period:</span> <span class="string">480h</span> </span><br><span class="line"></span><br><span class="line"><span class="attr">ruler:</span></span><br><span class="line">  <span class="attr">alertmanager_url:</span> <span class="string">http://localhost:9093</span></span><br></pre></td></tr></table></figure><h3 id="3-3-创建compose文件">3.3 创建compose文件</h3><p><code>vim grafana/docker-compose.yml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"2"</span> </span><br><span class="line"> </span><br><span class="line"><span class="attr">networks:</span> </span><br><span class="line">  <span class="attr">prom:</span> </span><br><span class="line"> </span><br><span class="line"><span class="attr">services:</span> </span><br><span class="line">  <span class="attr">prometheus:</span> </span><br><span class="line">    <span class="attr">image:</span> <span class="string">prom/prometheus:latest</span> </span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">prometheus</span> </span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">prometheus</span> </span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span> </span><br><span class="line">    <span class="attr">user:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">volumes:</span> </span><br><span class="line">      <span class="comment"># 挂载prometheus配置文件</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./prometheus/prometheus.yml:/etc/prometheus/prometheus.yml</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">./prometheus/data:/prometheus</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">./prometheus/log:/var/log/</span></span><br><span class="line">    <span class="attr">command:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">'--config.file=/etc/prometheus/prometheus.yml'</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">'--storage.tsdb.path=/prometheus'</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">'--storage.tsdb.retention.time=7d'</span></span><br><span class="line">    <span class="attr">ports:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">"9090:9090"</span> </span><br><span class="line">    <span class="attr">networks:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">prom</span> </span><br><span class="line">  <span class="attr">grafana:</span> </span><br><span class="line">    <span class="attr">image:</span> <span class="string">grafana/grafana:latest</span> </span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">grafana</span> </span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">grafana</span> </span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">user:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">volumes:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">./grafana/data:/var/lib/grafana</span> </span><br><span class="line">    <span class="attr">ports:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">"3000:3000"</span> </span><br><span class="line">    <span class="attr">networks:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">prom</span> </span><br><span class="line">  <span class="attr">node-exporter:</span> </span><br><span class="line">    <span class="attr">image:</span> <span class="string">prom/node-exporter:latest</span> </span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">node-exporter</span> </span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">exporter</span> </span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span> </span><br><span class="line">    <span class="attr">ports:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">"9100:9100"</span> </span><br><span class="line">    <span class="attr">networks:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">prom</span> </span><br><span class="line">  <span class="attr">cadvisor:</span> </span><br><span class="line">    <span class="attr">image:</span> <span class="string">google/cadvisor:latest</span> </span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">cadvisor</span> </span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">cadvisor</span> </span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span> </span><br><span class="line">    <span class="attr">volumes:</span> </span><br><span class="line">      <span class="comment"># 挂载docker目录，为了监控docker使用情况，必须</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/:/rootfs:ro</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">/var/run:/var/run:rw</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">/sys:/sys:ro</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">/var/lib/docker/:/var/lib/docker:ro</span> </span><br><span class="line">    <span class="attr">ports:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">"8080:8080"</span> </span><br><span class="line">    <span class="attr">networks:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">prom</span> </span><br><span class="line">  <span class="attr">loki:</span> </span><br><span class="line">    <span class="attr">image:</span> <span class="string">grafana/loki:latest</span> </span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">loki</span> </span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">loki</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">user:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">volumes:</span> </span><br><span class="line">      <span class="comment"># 挂载chunks文件夹及配置文件，loki收集到日志后会存储到chunks中</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./loki/chunks:/loki/chunks</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">./loki/rules:/loki/rules</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">./loki/local-config.yaml:/etc/loki/local-config.yaml</span> </span><br><span class="line">    <span class="attr">ports:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">"3100:3100"</span> </span><br><span class="line">    <span class="attr">networks:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">prom</span></span><br></pre></td></tr></table></figure><p>启动命令，注意命令和路径，实在grafana目录中启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> grafana</span><br><span class="line"><span class="comment"># docker-compose up -d</span></span><br><span class="line">docker-compose -f docker-compose.yml up -d</span><br></pre></td></tr></table></figure><h3 id="3-4-收集日志">3.4 收集日志</h3><p>使用loki-docker-driver，docker 安装loki驱动收集日志</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker plugin install  grafana/loki-docker-driver:latest --<span class="built_in">alias</span> loki --grant-all-permissions</span><br><span class="line"></span><br><span class="line"><span class="comment"># 日志收集，或者全部容器都收集方法见上面</span></span><br><span class="line">docker run -d -p 8888:8888 --rm --name=demo01 \</span><br><span class="line">--<span class="built_in">log</span>-driver=loki --<span class="built_in">log</span>-opt \</span><br><span class="line">loki-url=<span class="string">"http://192.168.249.149:3100/loki/api/v1/push"</span> --<span class="built_in">log</span>-opt max-size=50m \</span><br><span class="line">--<span class="built_in">log</span>-opt max-file=10 demo01</span><br></pre></td></tr></table></figure><p>需要使用loki记录日志的docker-compose文件中替换日志收集驱动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">logging:</span><br><span class="line">  driver: loki</span><br><span class="line">  options:</span><br><span class="line">    loki-url: <span class="string">"http://192.168.249.149:3100/api/prom/push"</span></span><br><span class="line">    loki-retries: <span class="string">"5"</span></span><br><span class="line">    loki-batch-size: <span class="string">"400"</span></span><br></pre></td></tr></table></figure><p><strong>使用promtail收集日志文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">vim grafana/promatil/config.yml</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">http_listen_port:</span> <span class="number">9080</span></span><br><span class="line">  <span class="attr">grpc_listen_port:</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="attr">positions:</span></span><br><span class="line">  <span class="attr">filename:</span> <span class="string">/var/log-position/positions.yaml</span> <span class="comment"># 记录日志上传的行号</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># loki服务地址</span></span><br><span class="line"><span class="attr">client:</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">http://192.168.249.149:3100/loki/api/v1/push</span></span><br><span class="line"></span><br><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">my-service</span></span><br><span class="line">  <span class="attr">static_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">targets:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">job:</span> <span class="string">test-service</span></span><br><span class="line">      <span class="attr">__path__:</span> <span class="string">/var/log/*.log</span></span><br></pre></td></tr></table></figure><p><code>vim grafana/promatil/promtail.yml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"2"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">grafana_promtail:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">promtail2</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">grafana/promtail:2.4.0</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">user:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/var/log:/var/log</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./promatil/config.yml:/etc/promtail/config.yml</span></span><br></pre></td></tr></table></figure><p>最后启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> grafana</span><br><span class="line"><span class="comment"># docker-compose up -d</span></span><br><span class="line">docker-compose -f promtail.yml up -d</span><br><span class="line"><span class="comment"># 如果改了配置文件</span></span><br><span class="line">docker-compose -f promtail.yml rebuild</span><br><span class="line"><span class="comment"># 如果修改了编排文件，就需要down后up</span></span><br></pre></td></tr></table></figure><h3 id="3-5-测试与模板">3.5 测试与模板</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 好用的grafana模板下载</span></span><br><span class="line"><span class="comment"># https://grafana.com/dashboards</span></span><br><span class="line"></span><br><span class="line">Spring Boot 2.1 Statistics: 10280</span><br><span class="line">Spring Boot Statistics: 6756</span><br><span class="line">1 Node Exporter <span class="keyword">for</span> Prometheus Dashboard EN 20201010: 11074</span><br><span class="line">Docker and system monitoring: 893</span><br><span class="line">Docker Container &amp; Host Metrics: 10619</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/809238c86589408f9a120c15b0931d70.png#pic_center" alt="在这里插入图片描述"></p><hr><p><a href="https://www.cnblogs.com/turingguo/p/13847003.html" target="_blank" rel="noopener" title="docker-compose安装loki套件(loki+grafana)">docker-compose安装loki套件(loki+grafana)</a></p><p><a href="https://www.cnblogs.com/yg0070/p/16437578.html" target="_blank" rel="noopener" title="docker-compose安装grafana+prometheus+loki 监控docker容器收集服务日志">docker-compose安装grafana+prometheus+loki 监控docker容器收集服务日志</a></p><p><a href="https://blog.csdn.net/u011943534/article/details/120871258" target="_blank" rel="noopener" title="k8s学习(三十二)K8s部署Loki日志收集">k8s学习(三十二)K8s部署Loki日志收集</a></p>]]></content>
    
    
    <summary type="html">&lt;h1&gt;一、Prometheus+Grafana监控Springboot&lt;/h1&gt;
&lt;h2 id=&quot;1、简介&quot;&gt;1、简介&lt;/h2&gt;
&lt;p&gt;任何一个系统上线，运维监控都太重要了。关于Springboot微服务的监控，之前写过&lt;a href=&quot;https://blog.csdn.net/lemon_TT/article/details/124675465&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; title=&quot;Spring Boot Admin服务监控&quot;&gt;Spring Boot Admin服务监控&lt;/a&gt;，这个方案可以&lt;strong&gt;实时监控并提供告警提醒功能，但不能记录历史数据&lt;/strong&gt;，无法查看过去1小时或过去1天等运维情况。本文介绍Prometheus + Grafana的方法监控Springboot 2.X，实现美观漂亮的数据可视化。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux运维" scheme="https://www.shawn22.xyz/categories/Linux%E8%BF%90%E7%BB%B4/"/>
    
    
    <category term="linux基础" scheme="https://www.shawn22.xyz/tags/linux%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot2.0经典学习笔记</title>
    <link href="https://www.shawn22.xyz/posts/701720ae.html"/>
    <id>https://www.shawn22.xyz/posts/701720ae.html</id>
    <published>2023-03-05T16:18:05.000Z</published>
    <updated>2023-03-05T16:29:27.932Z</updated>
    
    <content type="html"><![CDATA[<h1>导读：课程概览</h1><h2 id="1-Spring-Boot是什么">1. Spring Boot是什么</h2><p>我们知道，从 2002 年开始，Spring 一直在飞速的发展，如今已经成为了在Java EE（Java Enterprise Edition）开发中真正意义上的标准，但是随着技术的发展，Java EE使用 Spring 逐渐变得笨重起来，大量的 XML 文件存在于项目之中。<strong>繁琐的配置，整合第三方框架的配置问题，导致了开发和部署效率的降低</strong>。</p><a id="more"></a><p>2012 年 10 月，Mike Youngstrom 在 Spring jira 中创建了一个功能请求，要求<strong>在 Spring 框架中支持无容器 Web 应用程序体系结构</strong>。他谈到了在主容器引导 spring 容器内配置 Web 容器服务。这是 jira 请求的摘录：</p><blockquote><p>我认为 Spring 的 Web 应用体系结构可以大大简化，如果它提供了从上到下利用 Spring 组件和配置模型的工具和参考体系结构。在简单的 <code>main()</code>方法引导的 Spring 容器内嵌入和统一这些常用Web 容器服务的配置。</p></blockquote><p>这一要求促使了 2013 年初开始的 Spring Boot 项目的研发，到今天，Spring Boot 的版本已经到了 2.0.3 RELEASE。Spring Boot 并不是用来替代 Spring 的解决方案，而<strong>是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具</strong>。</p><p>它集成了大量常用的第三方库配置，Spring Boot应用中这些第三方库几乎可以是零配置的开箱即用（out-of-the-box），大部分的 Spring Boot 应用都只需要非常少量的配置代码（基于 Java 的配置），开发者能够更加专注于业务逻辑。</p><h2 id="2-为什么学习Spring-Boot">2. 为什么学习Spring Boot</h2><h3 id="2-1-从Spring官方来看">2.1 从Spring官方来看</h3><p>我们打开 Spring 的<a href="http://spring.io/" target="_blank" rel="noopener">官方网站</a>，可以看到下图：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/c6a86cf65b118d8318fa483ef872e3dd.png" alt="Spring官网首图"></p><p>我们可以看到图中官方对 Spring Boot 的定位：<em>Build Anything</em>， Build任何东西。Spring Boot旨在尽可能快地启动和运行，并且只需最少的 Spring 前期配置。  同时我们也来看一下官方对后面两个的定位：</p><p>SpringCloud：<em>Coordinate Anything</em>，协调任何事情；<br>SpringCloud Data Flow：<em>Connect everything</em>，连接任何东西。</p><p>仔细品味一下，Spring 官网对 Spring Boot、SpringCloud 和 SpringCloud Data Flow三者定位的措辞非常有味道，同时也可以看出，Spring 官方对这三个技术非常重视，是现在以及今后学习的重点（SpringCloud 相关达人课课程届时也会上线）。</p><h3 id="2-2-从Spring-Boot的优点来看">2.2 从Spring Boot的优点来看</h3><p>Spring Boot 有哪些优点？主要给我们解决了哪些问题呢？我们以下图来说明：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/df2f09bcb2eb6b05b7c2f8451acd2735.png" alt="Spring Boot的优点"></p><h4 id="2-2-1-良好的基因">2.2.1 良好的基因</h4><p>Spring Boot 是伴随着 Spring 4.0 诞生的，从字面理解，Boot是引导的意思，因此 Spring Boot 旨在帮助开发者快速搭建 Spring 框架。Spring Boot 继承了原有 Spring 框架的优秀基因，使 Spring 在使用中更加方便快捷。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/f56c48f83b52cebf1dd6cc83f9624dca.png" alt="Spring Boot与Spring"></p><h4 id="2-2-2-简化编码">2.2.2 简化编码</h4><p>举个例子，比如我们要创建一个 web 项目，使用 Spring 的朋友都知道，在使用 Spring 的时候，需要在 pom 文件中添加多个依赖，而 Spring Boot 则会帮助开发着快速启动一个 web 容器，在 Spring Boot 中，我们只需要在 pom 文件中添加如下一个 starter-web 依赖即可。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们点击进入该依赖后可以看到，Spring Boot 这个 starter-web 已经包含了多个依赖，包括之前在 Spring 工程中需要导入的依赖，我们看一下其中的一部分，如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- .....省略其他依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>由此可以看出，Spring Boot 大大简化了我们的编码，我们不用一个个导入依赖，直接一个依赖即可。</p><h4 id="2-2-3-简化配置">2.2.3 简化配置</h4><p>Spring 虽然使Java EE轻量级框架，但由于其繁琐的配置，一度被人认为是“配置地狱”。各种XML、Annotation配置会让人眼花缭乱，而且配置多的话，如果出错了也很难找出原因。Spring Boot更多的是采用 Java Config 的方式，对 Spring 进行配置。举个例子：</p><p>我新建一个类，但是我不用 <code>@Service</code>注解，也就是说，它是个普通的类，那么我们如何使它也成为一个 Bean 让 Spring 去管理呢？只需要<code>@Configuration</code> 和<code>@Bean</code>两个注解即可，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello Spring Boot!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TestService <span class="title">getTestService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TestService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@Configuration</code>表示该类是个配置类，<code>@Bean</code>表示该方法返回一个 Bean。这样就把<code>TestService</code>作为 Bean 让 Spring 去管理了，在其他地方，我们如果需要使用该 Bean，和原来一样，直接使用<code>@Resource</code>注解注入进来即可使用，非常方便。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> TestService testService;</span><br></pre></td></tr></table></figure><p>另外，部署配置方面，原来 Spring 有多个 xml 和 properties配置，在 Spring Boot 中只需要个 application.yml即可。</p><h4 id="2-2-4-简化部署">2.2.4 简化部署</h4><p>在使用 Spring 时，项目部署时需要我们在服务器上部署 tomcat，然后把项目打成 war 包扔到 tomcat里，在使用 Spring Boot 后，我们不需要在服务器上去部署 tomcat，因为 Spring Boot 内嵌了 tomcat，我们只需要将项目打成 jar 包，使用 <code>java -jar xxx.jar</code>一键式启动项目。</p><p>另外，也降低对运行环境的基本要求，环境变量中有JDK即可。</p><h4 id="2-2-5-简化监控">2.2.5 简化监控</h4><p>我们可以引入 spring-boot-start-actuator 依赖，直接使用 REST 方式来获取进程的运行期性能参数，从而达到监控的目的，比较方便。但是 Spring Boot 只是个微框架，没有提供相应的服务发现与注册的配套功能，没有外围监控集成方案，没有外围安全管理方案，所以在微服务架构中，还需要 Spring Cloud 来配合一起使用。</p><h3 id="2-3-从未来发展的趋势来看">2.3 从未来发展的趋势来看</h3><p>微服务是未来发展的趋势，项目会从传统架构慢慢转向微服务架构，因为微服务可以使不同的团队专注于更小范围的工作职责、使用独立的技术、更安全更频繁地部署。而 继承了 Spring 的优良特性，与 Spring 一脉相承，而且 支持各种REST API 的实现方式。Spring Boot 也是官方大力推荐的技术，可以看出，Spring Boot 是未来发展的一个大趋势。</p><h2 id="3-本课程能学到什么">3. 本课程能学到什么</h2><p>本课程使用目前 Spring Boot 最新版本2.0.3 RELEASE，课程文章均为作者在实际项目中剥离出来的场景和demo，目标是带领学习者快速上手 Spring Boot，将 Spring Boot 相关技术点快速运用在微服务项目中。全篇分为两部分：基础篇和进阶篇。</p><p>基础篇（01—10课）主要介绍 Spring Boot 在项目中最常使用的一些功能点，旨在带领学习者快速掌握 Spring Boot 在开发时需要的知识点，能够把 Spring Boot 相关技术运用到实际项目架构中去。该部分以 Spring Boot 框架为主线，内容包括Json数据封装、日志记录、属性配置、MVC支持、在线文档、模板引擎、异常处理、AOP 处理、持久层集成等等。</p><p>进阶篇（11—17课）主要是介绍 Spring Boot 在项目中拔高一些的技术点，包括集成的一些组件，旨在带领学习者在项目中遇到具体的场景时能够快速集成，完成对应的功能。该部分以 Spring Boot 框架为主线，内容包括拦截器、监听器、缓存、安全认证、分词插件、消息队列等等。</p><p>认真读完该系列文章之后，学习者会快速了解并掌握 Spring Boot 在项目中最常用的技术点，作者课程的最后，会基于课程内容搭建一个 Spring Boot 项目的空架构，该架构也是从实际项目中剥离出来，学习者可以运用该架构于实际项目中，具备使用 Spring Boot 进行实际项目开发的能力。</p><p>课程所有源码提供免费下载：<a href="https://gitee.com/eson15/springboot_study" target="_blank" rel="noopener">下载地址</a>。</p><blockquote><p>欢迎关注我的为微信公众号：武哥聊编程</p></blockquote><h2 id="4-适合阅读的人群">4. 适合阅读的人群</h2><p>本课程适合以下人群阅读：</p><ul><li>有一定的Java语言基础，了解Spring、Maven的在校学生或自学者</li><li>有传统项目经验，想往微服务方向发展的工作人员</li><li>热衷于新技术并对 Spring Boot 感兴趣的人员</li><li>希望了解 Spring Boot 2.0.3 的研究人员</li></ul><h2 id="5-本课程开发环境和插件">5. 本课程开发环境和插件</h2><p>本课程的开发环境：</p><ul><li>开发工具：IDEA 2017</li><li>JDK版本： JDK 1.8</li><li>Spring Boot版本：2.0.3 RELEASE</li><li>Maven版本：3.5.2</li></ul><p>涉及到的插件：</p><ul><li>FastJson</li><li>Swagger2</li><li>Thymeleaf</li><li>MyBatis</li><li>Redis</li><li>ActiveMQ</li><li>Shiro</li><li>Lucence</li></ul><h2 id="6-课程目录">6. 课程目录</h2><ul><li>导读：课程概览</li><li>第01课：Spring Boot开发环境搭建和项目启动</li><li>第02课：Spring Boot返回Json数据及数据封装</li><li>第03课：Spring Boot使用slf4j进行日志记录</li><li>第04课：Spring Boot中的项目属性配置</li><li>第05课：Spring Boot中的MVC支持</li><li>第06课：Spring Boot集成Swagger2展现在线接口文档</li><li>第07课：Spring Boot集成Thymeleaf模板引擎</li><li>第08课：Spring Boot中的全局异常处理</li><li>第09课：Spring Boot中的切面AOP处理</li><li>第10课：Spring Boot中集成MyBatis</li><li>第11课：Spring Boot事务配置管理</li><li>第12课：Spring Boot中使用监听器</li><li>第13课：Spring Boot中使用拦截器</li><li>第14课：Spring Boot中集成Redis</li><li>第15课：Spring Boot中集成ActiveMQ</li><li>第16课：Spring Boot中集成Shiro</li><li>第17课：Spring Boot中结成Lucence</li><li>第18课：Spring Boot搭建实际项目开发中的架构</li></ul><blockquote><p>欢迎关注我的为微信公众号：武哥聊编程</p></blockquote><h1>第01课：Spring Boot开发环境搭建和项目启动</h1><p>上一节对 SpringBoot 的特性做了一个介绍，本节主要对 <strong>jdk 的配置、Spring Boot工程的构建和项目的启动、Spring Boot 项目工程的结构做一下讲解和分析</strong>。</p><h2 id="1-jdk-的配置">1. jdk 的配置</h2><p>本课程是使用 IDEA 进行开发，在IDEA 中配置 jdk 的方式很简单，打开<code>File-&gt;Project Structure</code>，如下图所：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/faa60319c032339997a3fadcea5895de.png" alt="IDEA中配置jdk"></p><ol><li>选择 SDKs</li><li>在 JDK home path 中选择本地 jdk 的安装目录</li><li>在 Name 中为 jdk 自定义名字</li></ol><p>通过以上三步骤，即可导入本地安装的 jdk。如果是使用 STS 或者 eclipse 的朋友，可以通过两步骤添加：</p><ul><li><code>window-&gt;preference-&gt;java-&gt;Instralled JRES</code>来添加本地 jdk。</li><li><code>window--&gt;preference--&gt;java--&gt;Compiler</code>选择 jre，和 jdk 保持一致。</li></ul><h2 id="2-Spring-Boot-工程的构建">2. Spring Boot 工程的构建</h2><h3 id="2-1-IDEA-快速构建">2.1 IDEA 快速构建</h3><p>IDEA 中可以通过<code>File-&gt;New-&gt;Project</code>来快速构建 Spring Boot 工程。如下，选择 Spring Initializr，在 Project SDK 中选择刚刚我们导入的 jdk，点击 Next，到了项目的配置信息。</p><ul><li>Group：填企业域名，本课程使用com.itcodai</li><li>Artifact：填项目名称，本课程中每一课的工程名以<code>course+课号</code>命令，这里使用 course01</li><li>Dependencies：可以添加我们项目中所需要的依赖信息，根据实际情况来添加，本课程只需要选择 Web 即可。</li></ul><h3 id="2-2-官方构建">2.2 官方构建</h3><p>第二种方式可以通过官方构建，步骤如下：</p><ul><li>访问 <a href="http://start.spring.io/%E3%80%82" target="_blank" rel="noopener">http://start.spring.io/。</a></li><li>在页面上输入相应的 Spring Boot 版本、Group 和 Artifact 信息以及项目依赖，然后创建项目。</li><li><img src="https://img-blog.csdnimg.cn/img_convert/e1376b2acdb7ce97bf68ef6b2843da06.png" alt="创建Spring Boot工程"></li><li>解压后，使用 IDEA 导入该 maven 工程：<code>File-&gt;New-&gt;Model from Existing Source</code>，然后选择解压后的项目文件夹即可。如果是使用 eclipse 的朋友，可以通过<code>Import-&gt;Existing Maven Projects-&gt;Next</code>，然后选择解压后的项目文件夹即可。</li></ul><h3 id="2-3-maven配置">2.3 maven配置</h3><p>创建了 Spring Boot 项目之后，需要进行 maven 配置。打开<code>File-&gt;settings</code>，搜索 maven，配置一下本地的 maven 信息。如下：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/e3a4231c5914b2bf446756c71fceab6e.png" alt="maven配置"></p><p>在 Maven home directory 中选择本地 Maven 的安装路径；在 User settings file 中选择本地 Maven 的配置文件所在路径。在配置文件中，我们配置一下国内阿里的镜像，这样在下载 maven 依赖时，速度很快。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus aliyun<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果是使用 eclipse 的朋友，可以通过<code>window--&gt;preference--&gt;Maven--&gt;User Settings</code>来配置，配置方式和上面一致。</p><h3 id="2-4-编码配置">2.4 编码配置</h3><p>同样地，新建项目后，我们一般都需要配置编码，这点非常重要，很多初学者都会忘记这一步，所以要养成良好的习惯。</p><p>IDEA 中，仍然是打开<code>File-&gt;settings</code>，搜索 encoding，配置一下本地的编码信息。如下：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/07f9bb8e5d2c42fd5604b810f5a753f8.png" alt="编码配置"></p><p>如果是使用 eclipse 的朋友，有两个地方需要设置一下编码：</p><ul><li>window–&gt; perferences–&gt;General–&gt;Workspace，将Text file encoding改成utf-8</li><li>window–&gt;perferences–&gt;General–&gt;content types，选中Text，将Default encoding填入utf-8</li></ul><p>OK，编码设置完成即可启动项目工程了。</p><h2 id="3-Spring-Boot-项目工程结构">3. Spring Boot 项目工程结构</h2><p>Spring Boot 项目总共有三个模块，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/b573b06a7c19dd1fa6b62487d93c7e32.png" alt="Spring Boot项目工程结构"></p><ul><li>src/main/java路径：主要编写业务程序</li><li>src/main/resources路径：存放静态文件和配置文件</li><li>src/test/java路径：主要编写测试程序</li></ul><p>默认情况下，如上图所示会创建一个启动类 Course01Application，该类上面有个<code>@SpringBootApplication</code>注解，该启动类中有个 main 方法，没错，Spring Boot 启动只要运行该 main 方法即可，非常方便。另外，Spring Boot 内部集成了 tomcat，不需要我们人为手动去配置 tomcat，开发者只需要关注具体的业务逻辑即可。</p><p>到此为止，Spring Boot 就启动成功了，为了比较清楚的看到效果，我们写一个 Controller 来测试一下，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itcodai.course01.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/start"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StartController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/springboot"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">startSpringBoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Welcome to the world of Spring Boot!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新运行 main 方法启动项目，在浏览器中输入 <code>localhost:8080/start/springboot</code>，如果看到 <code>“Welcome to the world of Spring Boot!”</code>，那么恭喜你项目启动成功！Spring Boot 就是这么简单方便！端口号默认是8080，如果想要修改，可以在 application.yml 文件中使用 <code>server.port</code> 来人为指定端口，如8001端口：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8001</span><br></pre></td></tr></table></figure><h2 id="4-总结">4. 总结</h2><p>本节我们快速学习了如何在 IDEA 中导入 jdk，以及使用 IDEA 如何配置 maven 和编码，如何快速的创建和启动 Spring Boot 工程。IDEA 对 Spring Boot 的支持非常友好，建议大家使用 IDEA 进行 Spring Boot 的开发，从下一课开始，我们真正进入 Spring Boot 的学习中。<br>课程源代码下载地址：<a href="https://gitee.com/eson15/springboot_study" target="_blank" rel="noopener">戳我下载</a></p><blockquote><p>欢迎关注我的为微信公众号：武哥聊编程</p></blockquote><h1>第02课：Spring Boot返回Json数据及数据封装</h1><p>在项目开发中，接口与接口之间，前后端之间数据的传输都使用 Json 格式，在 Spring Boot 中，接口返回 Json 格式的数据很简单，在 Controller 中使用<code>@RestController</code>注解即可返回 Json 格式的数据，<code>@RestController</code>也是 Spring Boot 新增的一个注解，我们点进去看一下该注解都包含了哪些东西。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RestController &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出， <code>@RestController</code> 注解包含了原来的 <code>@Controller</code> 和 <code>@ResponseBody</code> 注解，使用过 Spring 的朋友对 <code>@Controller</code> 注解已经非常了解了，这里不再赘述， <code>@ResponseBody</code> 注解是将返回的数据结构转换为 Json 格式。所以在默认情况下，使用了 <code>@RestController</code> 注解即可将返回的数据结构转换成 Json 格式，Spring Boot 中默认使用的 Json 解析技术框架是 jackson。我们点开 pom.xml 中的 <code>spring-boot-starter-web</code> 依赖，可以看到一个 <code>spring-boot-starter-json</code> 依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-json<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Spring Boot 中对依赖都做了很好的封装，可以看到很多 <code>spring-boot-starter-xxx</code> 系列的依赖，这是 Spring Boot 的特点之一，不需要人为去引入很多相关的依赖了，starter-xxx 系列直接都包含了所必要的依赖，所以我们再次点进去上面这个 <code>spring-boot-starter-json</code> 依赖，可以看到：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.datatype<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-datatype-jdk8<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.datatype<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-datatype-jsr310<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.module<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-module-parameter-names<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>到此为止，我们知道了 Spring Boot 中默认使用的 json 解析框架是 jackson。下面我们看一下默认的 jackson 框架对常用数据类型的转 Json 处理。</p><h2 id="1-Spring-Boot-默认对Json的处理">1. Spring Boot 默认对Json的处理</h2><p>在实际项目中，常用的数据结构无非有类对象、List对象、Map对象，我们看一下默认的 jackson 框架对这三个常用的数据结构转成 json 后的格式如何。</p><h3 id="1-1-创建-User-实体类">1.1 创建 User 实体类</h3><p>为了测试，我们需要创建一个实体类，这里我们就用 User 来演示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"><span class="comment">/* 省略get、set和带参构造方法 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-创建Controller类">1.2 创建Controller类</h3><p>然后我们创建一个 Controller，分别返回 <code>User</code>对象、<code>List&lt;User&gt;</code> 和 <code>Map&lt;String, Object&gt;</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.itcodai.course02.entity.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/json"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="number">1</span>, <span class="string">"倪升武"</span>, <span class="string">"123456"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/list"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getUserList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;User&gt; userList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        User user1 = <span class="keyword">new</span> User(<span class="number">1</span>, <span class="string">"倪升武"</span>, <span class="string">"123456"</span>);</span><br><span class="line">        User user2 = <span class="keyword">new</span> User(<span class="number">2</span>, <span class="string">"达人课"</span>, <span class="string">"123456"</span>);</span><br><span class="line">        userList.add(user1);</span><br><span class="line">        userList.add(user2);</span><br><span class="line">        <span class="keyword">return</span> userList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/map"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="number">1</span>, <span class="string">"倪升武"</span>, <span class="string">"123456"</span>);</span><br><span class="line">        map.put(<span class="string">"作者信息"</span>, user);</span><br><span class="line">        map.put(<span class="string">"博客地址"</span>, <span class="string">"http://blog.itcodai.com"</span>);</span><br><span class="line">        map.put(<span class="string">"CSDN地址"</span>, <span class="string">"http://blog.csdn.net/eson_15"</span>);</span><br><span class="line">        map.put(<span class="string">"粉丝数量"</span>, <span class="number">4153</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-测试不同数据类型返回的json">1.3 测试不同数据类型返回的json</h3><p>OK，写好了接口，分别返回了一个 User 对象、一个 List 集合和一个 Map 集合，其中 Map 集合中的 value 存的是不同的数据类型。接下来我们依次来测试一下效果。</p><p>在浏览器中输入：<code>localhost:8080/json/user</code> 返回 json 如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"id"</span>:<span class="number">1</span>,<span class="attr">"username"</span>:<span class="string">"倪升武"</span>,<span class="attr">"password"</span>:<span class="string">"123456"</span>&#125;</span><br></pre></td></tr></table></figure><p>在浏览器中输入：<code>localhost:8080/json/list</code> 返回 json 如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#123;<span class="attr">"id"</span>:<span class="number">1</span>,<span class="attr">"username"</span>:<span class="string">"倪升武"</span>,<span class="attr">"password"</span>:<span class="string">"123456"</span>&#125;,&#123;<span class="attr">"id"</span>:<span class="number">2</span>,<span class="attr">"username"</span>:<span class="string">"达人课"</span>,<span class="attr">"password"</span>:<span class="string">"123456"</span>&#125;]</span><br></pre></td></tr></table></figure><p>在浏览器中输入：<code>localhost:8080/json/map</code> 返回 json 如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"作者信息"</span>:&#123;<span class="attr">"id"</span>:<span class="number">1</span>,<span class="attr">"username"</span>:<span class="string">"倪升武"</span>,<span class="attr">"password"</span>:<span class="string">"123456"</span>&#125;,<span class="attr">"CSDN地址"</span>:<span class="string">"http://blog.csdn.net/eson_15"</span>,<span class="attr">"粉丝数量"</span>:<span class="number">4153</span>,<span class="attr">"博客地址"</span>:<span class="string">"http://blog.itcodai.com"</span>&#125;</span><br></pre></td></tr></table></figure><p>可以看出，map 中不管是什么数据类型，都可以转成相应的 json 格式，这样就非常方便。</p><h3 id="1-4-jackson-中对null的处理">1.4 jackson 中对null的处理</h3><p>在实际项目中，我们难免会遇到一些 null 值出现，我们转 json 时，是不希望有这些 null 出现的，比如我们期望所有的 null 在转 json 时都变成 “” 这种空字符串，那怎么做呢？在 Spring Boot 中，我们做一下配置即可，新建一个 jackson 的配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.JsonGenerator;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.JsonSerializer;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.SerializerProvider;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Primary;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.converter.json.Jackson2ObjectMapperBuilder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JacksonConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span>(ObjectMapper<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">ObjectMapper</span> <span class="title">jacksonObjectMapper</span>(<span class="title">Jackson2ObjectMapperBuilder</span> <span class="title">builder</span>) </span>&#123;</span><br><span class="line">        ObjectMapper objectMapper = builder.createXmlMapper(<span class="keyword">false</span>).build();</span><br><span class="line">        objectMapper.getSerializerProvider().setNullValueSerializer(<span class="keyword">new</span> JsonSerializer&lt;Object&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serialize</span><span class="params">(Object o, JsonGenerator jsonGenerator, SerializerProvider serializerProvider)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                jsonGenerator.writeString(<span class="string">""</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> objectMapper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们修改一下上面返回 map 的接口，将几个值改成 null 测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/map"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">    User user = <span class="keyword">new</span> User(<span class="number">1</span>, <span class="string">"倪升武"</span>, <span class="keyword">null</span>);</span><br><span class="line">    map.put(<span class="string">"作者信息"</span>, user);</span><br><span class="line">    map.put(<span class="string">"博客地址"</span>, <span class="string">"http://blog.itcodai.com"</span>);</span><br><span class="line">    map.put(<span class="string">"CSDN地址"</span>, <span class="keyword">null</span>);</span><br><span class="line">    map.put(<span class="string">"粉丝数量"</span>, <span class="number">4153</span>);</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启项目，再次输入：<code>localhost:8080/json/map</code>，可以看到 jackson 已经将所有 null 字段转成了空字符串了。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"作者信息"</span>:&#123;<span class="attr">"id"</span>:<span class="number">1</span>,<span class="attr">"username"</span>:<span class="string">"倪升武"</span>,<span class="attr">"password"</span>:<span class="string">""</span>&#125;,<span class="attr">"CSDN地址"</span>:<span class="string">""</span>,<span class="attr">"粉丝数量"</span>:<span class="number">4153</span>,<span class="attr">"博客地址"</span>:<span class="string">"http://blog.itcodai.com"</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="2-使用阿里巴巴FastJson的设置">2. 使用阿里巴巴FastJson的设置</h2><h3 id="2-1-jackson-和-fastJson-的对比">2.1 jackson 和 fastJson 的对比</h3><p>有很多朋友习惯于使用阿里巴巴的 fastJson 来做项目中 json 转换的相关工作，目前我们项目中使用的就是阿里的 fastJson，那么 jackson 和 fastJson 有哪些区别呢？根据网上公开的资料比较得到下表。</p><table><thead><tr><th style="text-align:center">选项</th><th style="text-align:center">fastJson</th><th style="text-align:center">jackson</th></tr></thead><tbody><tr><td style="text-align:center">上手难易程度</td><td style="text-align:center">容易</td><td style="text-align:center">中等</td></tr><tr><td style="text-align:center">高级特性支持</td><td style="text-align:center">中等</td><td style="text-align:center">丰富</td></tr><tr><td style="text-align:center">官方文档、Example支持</td><td style="text-align:center">中文</td><td style="text-align:center">英文</td></tr><tr><td style="text-align:center">处理json速度</td><td style="text-align:center">略快</td><td style="text-align:center">快</td></tr></tbody></table><p>关于 fastJson 和 jackson 的对比，网上有很多资料可以查看，主要是根据自己实际项目情况来选择合适的框架。从扩展上来看，fastJson 没有 jackson 灵活，从速度或者上手难度来看，fastJson 可以考虑，我们项目中目前使用的是阿里的 fastJson，挺方便的。</p><h3 id="2-2-fastJson依赖导入">2.2 fastJson依赖导入</h3><p>使用 fastJson 需要导入依赖，本课程使用 1.2.35 版本，依赖如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.35<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-2-使用-fastJson-处理-null">2.2 使用 fastJson 处理 null</h3><p>使用 fastJson 时，对 null 的处理和 jackson 有些不同，需要继承  <code>WebMvcConfigurationSupport</code> 类，然后覆盖 <code>configureMessageConverters</code> 方法，在方法中，我们可以选择对要实现 null 转换的场景，配置好即可。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.serializer.SerializerFeature;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.support.config.FastJsonConfig;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.MediaType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.converter.HttpMessageConverter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">fastJsonConfig</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurationSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用阿里 FastJson 作为JSON MessageConverter</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> converters</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> </span>&#123;</span><br><span class="line">        FastJsonHttpMessageConverter converter = <span class="keyword">new</span> FastJsonHttpMessageConverter();</span><br><span class="line">        FastJsonConfig config = <span class="keyword">new</span> FastJsonConfig();</span><br><span class="line">        config.setSerializerFeatures(</span><br><span class="line">                <span class="comment">// 保留map空的字段</span></span><br><span class="line">                SerializerFeature.WriteMapNullValue,</span><br><span class="line">                <span class="comment">// 将String类型的null转成""</span></span><br><span class="line">                SerializerFeature.WriteNullStringAsEmpty,</span><br><span class="line">                <span class="comment">// 将Number类型的null转成0</span></span><br><span class="line">                SerializerFeature.WriteNullNumberAsZero,</span><br><span class="line">                <span class="comment">// 将List类型的null转成[]</span></span><br><span class="line">                SerializerFeature.WriteNullListAsEmpty,</span><br><span class="line">                <span class="comment">// 将Boolean类型的null转成false</span></span><br><span class="line">                SerializerFeature.WriteNullBooleanAsFalse,</span><br><span class="line">                <span class="comment">// 避免循环引用</span></span><br><span class="line">                SerializerFeature.DisableCircularReferenceDetect);</span><br><span class="line"></span><br><span class="line">        converter.setFastJsonConfig(config);</span><br><span class="line">        converter.setDefaultCharset(Charset.forName(<span class="string">"UTF-8"</span>));</span><br><span class="line">        List&lt;MediaType&gt; mediaTypeList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 解决中文乱码问题，相当于在Controller上的@RequestMapping中加了个属性produces = "application/json"</span></span><br><span class="line">        mediaTypeList.add(MediaType.APPLICATION_JSON);</span><br><span class="line">        converter.setSupportedMediaTypes(mediaTypeList);</span><br><span class="line">        converters.add(converter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-封装统一返回的数据结构">3. 封装统一返回的数据结构</h2><p>以上是 Spring Boot 返回 json 的几个代表的例子，但是在实际项目中，除了要封装数据之外，我们往往需要在返回的 json 中添加一些其他信息，比如返回一些状态码 code ，返回一些 msg 给调用者，这样调用者可以根据 code 或者 msg 做一些逻辑判断。所以在实际项目中，我们需要封装一个统一的 json 返回结构存储返回信息。</p><h3 id="3-1-定义统一的-json-结构">3.1 定义统一的 json 结构</h3><p>由于封装的 json 数据的类型不确定，所以在定义统一的 json 结构时，我们需要用到泛型。统一的 json 结构中属性包括数据、状态码、提示信息即可，构造方法可以根据实际业务需求做相应的添加即可，一般来说，应该有默认的返回结构，也应该有用户指定的返回结构。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonResult</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">    <span class="keyword">private</span> String code;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 若没有数据返回，默认状态码为0，提示信息为：操作成功！</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JsonResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = <span class="string">"0"</span>;</span><br><span class="line">        <span class="keyword">this</span>.msg = <span class="string">"操作成功！"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 若没有数据返回，可以人为指定状态码和提示信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> code</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JsonResult</span><span class="params">(String code, String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有数据返回时，状态码为0，默认提示信息为：操作成功！</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JsonResult</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.code = <span class="string">"0"</span>;</span><br><span class="line">        <span class="keyword">this</span>.msg = <span class="string">"操作成功！"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有数据返回，状态码为0，人为指定提示信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JsonResult</span><span class="params">(T data, String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.code = <span class="string">"0"</span>;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略get和set方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-修改-Controller-中的返回值类型及测试">3.2 修改 Controller 中的返回值类型及测试</h3><p>由于 JsonResult 使用了泛型，所以所有的返回值类型都可以使用该统一结构，在具体的场景将泛型替换成具体的数据类型即可，非常方便，也便于维护。在实际项目中，还可以继续封装，比如状态码和提示信息可以定义一个枚举类型，以后我们只需要维护这个枚举类型中的数据即可（在本课程中就不展开了）。根据以上的 JsonResult，我们改写一下 Controller，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/jsonresult"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonResultController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> JsonResult&lt;User&gt; <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="number">1</span>, <span class="string">"倪升武"</span>, <span class="string">"123456"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JsonResult&lt;&gt;(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/list"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> JsonResult&lt;List&gt; <span class="title">getUserList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;User&gt; userList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        User user1 = <span class="keyword">new</span> User(<span class="number">1</span>, <span class="string">"倪升武"</span>, <span class="string">"123456"</span>);</span><br><span class="line">        User user2 = <span class="keyword">new</span> User(<span class="number">2</span>, <span class="string">"达人课"</span>, <span class="string">"123456"</span>);</span><br><span class="line">        userList.add(user1);</span><br><span class="line">        userList.add(user2);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JsonResult&lt;&gt;(userList, <span class="string">"获取用户列表成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/map"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> JsonResult&lt;Map&gt; <span class="title">getMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="number">1</span>, <span class="string">"倪升武"</span>, <span class="keyword">null</span>);</span><br><span class="line">        map.put(<span class="string">"作者信息"</span>, user);</span><br><span class="line">        map.put(<span class="string">"博客地址"</span>, <span class="string">"http://blog.itcodai.com"</span>);</span><br><span class="line">        map.put(<span class="string">"CSDN地址"</span>, <span class="keyword">null</span>);</span><br><span class="line">        map.put(<span class="string">"粉丝数量"</span>, <span class="number">4153</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JsonResult&lt;&gt;(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们重新在浏览器中输入：<code>localhost:8080/jsonresult/user</code> 返回 json 如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"code"</span>:<span class="string">"0"</span>,<span class="attr">"data"</span>:&#123;<span class="attr">"id"</span>:<span class="number">1</span>,<span class="attr">"password"</span>:<span class="string">"123456"</span>,<span class="attr">"username"</span>:<span class="string">"倪升武"</span>&#125;,<span class="attr">"msg"</span>:<span class="string">"操作成功！"</span>&#125;</span><br></pre></td></tr></table></figure><p>输入：<code>localhost:8080/jsonresult/list</code>，返回 json 如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"code"</span>:<span class="string">"0"</span>,<span class="attr">"data"</span>:[&#123;<span class="attr">"id"</span>:<span class="number">1</span>,<span class="attr">"password"</span>:<span class="string">"123456"</span>,<span class="attr">"username"</span>:<span class="string">"倪升武"</span>&#125;,&#123;<span class="attr">"id"</span>:<span class="number">2</span>,<span class="attr">"password"</span>:<span class="string">"123456"</span>,<span class="attr">"username"</span>:<span class="string">"达人课"</span>&#125;],<span class="attr">"msg"</span>:<span class="string">"获取用户列表成功"</span>&#125;</span><br></pre></td></tr></table></figure><p>输入：<code>localhost:8080/jsonresult/map</code>，返回 json 如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"code"</span>:<span class="string">"0"</span>,<span class="attr">"data"</span>:&#123;<span class="attr">"作者信息"</span>:&#123;<span class="attr">"id"</span>:<span class="number">1</span>,<span class="attr">"password"</span>:<span class="string">""</span>,<span class="attr">"username"</span>:<span class="string">"倪升武"</span>&#125;,<span class="attr">"CSDN地址"</span>:<span class="literal">null</span>,<span class="attr">"粉丝数量"</span>:<span class="number">4153</span>,<span class="attr">"博客地址"</span>:<span class="string">"http://blog.itcodai.com"</span>&#125;,<span class="attr">"msg"</span>:<span class="string">"操作成功！"</span>&#125;</span><br></pre></td></tr></table></figure><p>通过封装，我们不但将数据通过 json 传给前端或者其他接口，还带上了状态码和提示信息，这在实际项目场景中应用非常广泛。</p><h2 id="4-总结-v2">4. 总结</h2><p>本节主要对 Spring Boot 中 json 数据的返回做了详细的分析，从 Spring Boot 默认的 jackson 框架到阿里巴巴的 fastJson 框架，分别对它们的配置做了相应的讲解。另外，结合实际项目情况，总结了实际项目中使用的 json 封装结构体，加入了状态码和提示信息，使得返回的 json 数据信息更加完整。<br>课程源代码下载地址：<a href="https://gitee.com/eson15/springboot_study" target="_blank" rel="noopener">戳我下载</a></p><blockquote><p>欢迎关注我的为微信公众号：武哥聊编程</p></blockquote><h1>第03课：Spring Boot使用slf4j进行日志记录</h1><p>在开发中，我们经常使用 <code>System.out.println()</code> 来打印一些信息，但是这样不好，因为大量的使用 <code>System.out</code> 会增加资源的消耗。我们实际项目中使用的是 slf4j 的 logback 来输出日志，效率挺高的，Spring Boot 提供了一套日志系统，logback 是最优的选择。</p><h2 id="1-slf4j-介绍">1. slf4j 介绍</h2><p>引用百度百科里的一段话：</p><blockquote><p>SLF4J，即简单日志门面（Simple Logging Facade for Java），不是具体的日志解决方案，它只服务于各种各样的日志系统。按照官方的说法，SLF4J是一个用于日志系统的简单Facade，允许最终用户在部署其应用时使用其所希望的日志系统。</p></blockquote><p>这段的大概意思是：你只需要按统一的方式写记录日志的代码，而无需关心日志是通过哪个日志系统，以什么风格输出的。因为它们取决于部署项目时绑定的日志系统。例如，在项目中使用了 slf4j 记录日志，并且绑定了 log4j（即导入相应的依赖），则日志会以 log4j 的风格输出；后期需要改为以 logback 的风格输出日志，只需要将 log4j 替换成 logback 即可，不用修改项目中的代码。这对于第三方组件的引入的不同日志系统来说几乎零学习成本，况且它的优点不仅仅这一个而已，还有简洁的占位符的使用和日志级别的判断。</p><p>正因为 sfl4j 有如此多的优点，阿里巴巴已经将 slf4j 作为他们的日志框架了。在《阿里巴巴Java开发手册(正式版)》中，日志规约一项第一条就强制要求使用 slf4j：</p><blockquote><p>1.【强制】应用中不可直接使用日志系统（Log4j、Logback）中的API，而应依赖使用日志框架SLF4J中的API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。</p></blockquote><p>“强制”两个字体现出了 slf4j 的优势，所以建议在实际项目中，使用 slf4j 作为自己的日志框架。使用 slf4j 记录日志非常简单，直接使用  LoggerFactory 创建即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(Test<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-application-yml-中对日志的配置">2. application.yml 中对日志的配置</h2><p>Spring Boot 对 slf4j 支持的很好，内部已经集成了 slf4j，一般我们在使用的时候，会对slf4j 做一下配置。<code>application.yml</code> 文件是 Spring Boot 中唯一一个需要配置的文件，一开始创建工程的时候是 <code>application.properties</code> 文件，个人比较细化用 yml 文件，因为 yml 文件的层次感特别好，看起来更直观，但是 yml 文件对格式要求比较高，比如英文冒号后面必须要有个空格，否则项目估计无法启动，而且也不报错。用 properties 还是 yml 视个人习惯而定，都可以。本课程使用 yml。</p><p>我们看一下 application.yml 文件中对日志的配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">logging:</span><br><span class="line">  config: logback.xml</span><br><span class="line">  level:</span><br><span class="line">    com.itcodai.course03.dao: trace</span><br></pre></td></tr></table></figure><p><code>logging.config</code> 是用来指定项目启动的时候，读取哪个配置文件，这里指定的是日志配置文件是根路径下的 <code>logback.xml</code> 文件，关于日志的相关配置信息，都放在 <code>logback.xml</code> 文件中了。<code>logging.level</code> 是用来指定具体的 mapper 中日志的输出级别，上面的配置表示 <code>com.itcodai.course03.dao</code> 包下的所有 mapper 日志输出级别为 trace，会将操作数据库的 sql 打印出来，开发时设置成 trace 方便定位问题，在生产环境上，将这个日志级别再设置成 error 级别即可（本节课不讨论 mapper 层，在后面 Spring Boot 集成 MyBatis 时再详细讨论）。</p><p>常用的日志级别按照从高到低依次为：ERROR、WARN、INFO、DEBUG。</p><h2 id="3-logback-xml-配置文件解析">3. logback.xml 配置文件解析</h2><p>在上面 <code>application.yml</code> 文件中，我们指定了日志配置文件 <code>logback.xml</code>，<code>logback.xml</code> 文件中主要用来做日志的相关配置。在 <code>logback.xml</code> 中，我们可以定义日志输出的格式、路径、控制台输出格式、文件大小、保存时长等等。下面来分析一下：</p><h3 id="3-1-定义日志输出格式和存储路径">3.1 定义日志输出格式和存储路径</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"LOG_PATTERN"</span> <span class="attr">value</span>=<span class="string">"%date&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"FILE_PATH"</span> <span class="attr">value</span>=<span class="string">"D:/logs/course03/demo.%d&#123;yyyy-MM-dd&#125;.%i.log"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们来看一下这个定义的含义：首先定义一个格式，命名为 “LOG_PATTERN”，该格式中 <code>%date</code> 表示日期，<code>%thread</code> 表示线程名，<code>%-5level</code> 表示级别从左显示5个字符宽度，<code>%logger{36}</code>  表示 logger 名字最长36个字符，<code>%msg</code> 表示日志消息，<code>%n</code> 是换行符。</p><p>然后再定义一下名为 “FILE_PATH” 文件路径，日志都会存储在该路径下。<code>%i</code> 表示第 i 个文件，当日志文件达到指定大小时，会将日志生成到新的文件里，这里的 i 就是文件索引，日志文件允许的大小可以设置，下面会讲解。这里需要注意的是，不管是 windows 系统还是 Linux 系统，日志存储的路径必须要是绝对路径。</p><h3 id="3-2-定义控制台输出">3.2 定义控制台输出</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"CONSOLE"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 按照上面配置的LOG_PATTERN来打印日志 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pattern</span>&gt;</span>$&#123;LOG_PATTERN&#125;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用 <code>&lt;appender&gt;</code> 节点设置个控制台输出（<code>class=&quot;ch.qos.logback.core.ConsoleAppender&quot;</code>）的配置，定义为 “CONSOLE”。使用上面定义好的输出格式（LOG_PATTERN）来输出，使用 <code>${}</code> 引用进来即可。</p><h3 id="3-3-定义日志文件的相关参数">3.3 定义日志文件的相关参数</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"FILE"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 按照上面配置的FILE_PATH路径来保存日志 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;FILE_PATH&#125;<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 日志保存15天 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>15<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">timeBasedFileNamingAndTriggeringPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 单个日志文件的最大，超过则新建日志文件存储 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>10MB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">timeBasedFileNamingAndTriggeringPolicy</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 按照上面配置的LOG_PATTERN来打印日志 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pattern</span>&gt;</span>$&#123;LOG_PATTERN&#125;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用 <code>&lt;appender&gt;</code> 定义一个名为 “FILE” 的文件配置，主要是配置日志文件保存的时间、单个日志文件存储的大小、以及文件保存的路径和日志的输出格式。</p><h3 id="3-4-定义日志输出级别">3.4 定义日志输出级别</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"com.test"</span> <span class="attr">level</span>=<span class="string">"INFO"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"INFO"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"CONSOLE"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"FILE"</span> /&gt;</span></span><br><span class="line">       </span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>有了上面那些定义后，最后我们使用 <code>&lt;logger&gt;</code> 来定义一下项目中默认的日志输出级别，这里定义级别为 INFO，然后针对 INFO 级别的日志，使用 <code>&lt;root&gt;</code> 引用上面定义好的控制台日志输出和日志文件的参数。这样 logback.xml 文件中的配置就设置完了。</p><h2 id></h2><p>本节课主要对 slf4j 做了一个简单的介绍，并且对 Spring Boot 中如何使用 slf4j 输出日志做了详细的说明，着重分析了 <code>logback.xml</code> 文件中对日志相关信息的配置，包括日志的不同级别。最后针对这些配置，在代码中使用 Logger 打印出一些进行测试。在实际项目中，这些日志都是排查问题的过程中非常重要的资料。<br>课程源代码下载地址：<a href="https://gitee.com/eson15/springboot_study" target="_blank" rel="noopener">戳我下载</a></p><blockquote><p>欢迎关注我的为微信公众号：武哥聊编程</p></blockquote><h1>第04课：Spring Boot中的项目属性配置</h1><p>我们知道，在项目中，很多时候需要用到一些配置的信息，这些信息可能在测试环境和生产环境下会有不同的配置，后面根据实际业务情况有可能还会做修改，针对这种情况，我们不能将这些配置在代码中写死，最好就是写到配置文件中。比如可以把这些信息写到 <code>application.yml</code> 文件中。</p><h2 id="1-少量配置信息的情形">1. 少量配置信息的情形</h2><p>举个例子，在微服务架构中，最常见的就是某个服务需要调用其他服务来获取其提供的相关信息，那么在该服务的配置文件中需要配置被调用的服务地址，比如在当前服务里，我们需要调用订单微服务获取订单相关的信息，假设 订单服务的端口号是 8002，那我们可以做如下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8001</span><br><span class="line"></span><br><span class="line"># 配置微服务的地址</span><br><span class="line">url:</span><br><span class="line">  # 订单微服务的地址</span><br><span class="line">  orderUrl: http://localhost:8002</span><br></pre></td></tr></table></figure><p>然后在业务代码中如何获取到这个配置的订单服务地址呢？我们可以使用 <code>@Value</code> 注解来解决。在对应的类中加上一个属性，在属性上使用 <code>@Value</code> 注解即可获取到配置文件中的配置信息，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(ConfigController<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;url.orderUrl&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String orderUrl;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/config"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"=====获取的订单服务地址为：&#123;&#125;"</span>, orderUrl);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@Value</code> 注解上通过 <code>${key}</code> 即可获取配置文件中和 key 对应的 value 值。我们启动一下项目，在浏览器中输入 <code>localhost:8080/test/config</code> 请求服务后，可以看到控制台会打印出订单服务的地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;获取的订单服务地址为：http:&#x2F;&#x2F;localhost:8002</span><br></pre></td></tr></table></figure><p>说明我们成功获取到了配置文件中的订单微服务地址，在实际项目中也是这么用的，后面如果因为服务器部署的原因，需要修改某个服务的地址，那么只要在配置文件中修改即可。</p><h2 id="2-多个配置信息的情形">2. 多个配置信息的情形</h2><p>这里再引申一个问题，随着业务复杂度的增加，一个项目中可能会有越来越多的微服务，某个模块可能需要调用多个微服务获取不同的信息，那么就需要在配置文件中配置多个微服务的地址。可是，在需要调用这些微服务的代码中，如果这样一个个去使用 <code>@Value</code> 注解引入相应的微服务地址的话，太过于繁琐，也不科学。</p><p>所以，在实际项目中，业务繁琐，逻辑复杂的情况下，需要考虑封装一个或多个配置类。举个例子：假如在当前服务中，某个业务需要同时调用订单微服务、用户微服务和购物车微服务，分别获取订单、用户和购物车相关信息，然后对这些信息做一定的逻辑处理。那么在配置文件中，我们需要将这些微服务的地址都配置好：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 配置多个微服务的地址</span><br><span class="line">url:</span><br><span class="line">  # 订单微服务的地址</span><br><span class="line">  orderUrl: http://localhost:8002</span><br><span class="line">  # 用户微服务的地址</span><br><span class="line">  userUrl: http://localhost:8003</span><br><span class="line">  # 购物车微服务的地址</span><br><span class="line">  shoppingUrl: http://localhost:8004</span><br></pre></td></tr></table></figure><p>也许实际业务中，远远不止这三个微服务，甚至十几个都有可能。对于这种情况，我们可以先定义一个 <code>MicroServiceUrl</code> 类来专门保存微服务的 url，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"url"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MicroServiceUrl</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String orderUrl;</span><br><span class="line">    <span class="keyword">private</span> String userUrl;</span><br><span class="line">    <span class="keyword">private</span> String shoppingUrl;</span><br><span class="line">    <span class="comment">// 省去get和set方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>细心的朋友应该可以看到，使用 <code>@ConfigurationProperties</code> 注解并且使用 prefix 来指定一个前缀，然后该类中的属性名就是配置中去掉前缀后的名字，一一对应即可。即：前缀名 + 属性名就是配置文件中定义的 key。同时，该类上面需要加上 <code>@Component</code> 注解，把该类作为组件放到Spring容器中，让 Spring 去管理，我们使用的时候直接注入即可。</p><p>需要注意的是，使用 <code>@ConfigurationProperties</code> 注解需要导入它的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>OK，到此为止，我们将配置写好了，接下来写个 Controller 来测试一下。此时，不需要在代码中一个个引入这些微服务的 url 了，直接通过 <code>@Resource</code> 注解将刚刚写好配置类注入进来即可使用了，非常方便。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(TestController<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> MicroServiceUrl microServiceUrl;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/config"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"=====获取的订单服务地址为：&#123;&#125;"</span>, microServiceUrl.getOrderUrl());</span><br><span class="line">        LOGGER.info(<span class="string">"=====获取的用户服务地址为：&#123;&#125;"</span>, microServiceUrl.getUserUrl());</span><br><span class="line">        LOGGER.info(<span class="string">"=====获取的购物车服务地址为：&#123;&#125;"</span>, microServiceUrl.getShoppingUrl());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次启动项目，请求一下可以看到，控制台打印出如下信息，说明配置文件生效，同时正确获取配置文件内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;获取的订单服务地址为：http:&#x2F;&#x2F;localhost:8002</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;获取的订单服务地址为：http:&#x2F;&#x2F;localhost:8002</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;获取的用户服务地址为：http:&#x2F;&#x2F;localhost:8003</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;获取的购物车服务地址为：http:&#x2F;&#x2F;localhost:8004</span><br></pre></td></tr></table></figure><h2 id="3-指定项目配置文件">3. 指定项目配置文件</h2><p>我们知道，在实际项目中，一般有两个环境：开发环境和生产环境。开发环境中的配置和生产环境中的配置往往不同，比如：环境、端口、数据库、相关地址等等。我们不可能在开发环境调试好之后，部署到生产环境后，又要将配置信息全部修改成生产环境上的配置，这样太麻烦，也不科学。</p><p>最好的解决方法就是开发环境和生产环境都有一套对用的配置信息，然后当我们在开发时，指定读取开发环境的配置，当我们将项目部署到服务器上之后，再指定去读取生产环境的配置。</p><p>我们新建两个配置文件： <code>application-dev.yml</code> 和 <code>application-pro.yml</code>，分别用来对开发环境和生产环境进行相关配置。这里为了方便，我们分别设置两个访问端口号，开发环境用 8001，生产环境用 8002.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 开发环境配置文件</span><br><span class="line">server:</span><br><span class="line">  port: 8001</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 开发环境配置文件</span><br><span class="line">server:</span><br><span class="line">  port: 8002</span><br></pre></td></tr></table></figure><p>然后在 <code>application.yml</code> 文件中指定读取哪个配置文件即可。比如我们在开发环境下，指定读取 <code>applicationn-dev.yml</code> 文件，如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  profiles:</span><br><span class="line">    active:</span><br><span class="line">    - dev</span><br></pre></td></tr></table></figure><p>这样就可以在开发的时候，指定读取  <code>application-dev.yml</code> 文件，访问的时候使用 8001 端口，部署到服务器后，只需要将 <code>application.yml</code> 中指定的文件改成 <code>application-pro.yml</code> 即可，然后使用 8002 端口访问，非常方便。</p><h2 id="4-总结-v3">4. 总结</h2><p>本节课主要讲解了 Spring Boot 中如何在业务代码中读取相关配置，包括单一配置和多个配置项，在微服务中，这种情况非常常见，往往会有很多其他微服务需要调用，所以封装一个配置类来接收这些配置是个很好的处理方式。除此之外，例如数据库相关的连接参数等等，也可以放到一个配置类中，其他遇到类似的场景，都可以这么处理。最后介绍了开发环境和生产环境配置的快速切换方式，省去了项目部署时，诸多配置信息的修改。<br>课程源代码下载地址：<a href="https://gitee.com/eson15/springboot_study" target="_blank" rel="noopener">戳我下载</a></p><blockquote><p>欢迎关注我的为微信公众号：武哥聊编程</p></blockquote><h1>第05课：Spring Boot中的MVC支持</h1><p>Spring Boot 的 MVC 支持主要来介绍实际项目中最常用的几个注解，包括 <code>@RestController</code>、 <code>@RequestMapping</code>、<code>@PathVariable</code>、<code>@RequestParam</code> 以及 <code>@RequestBody</code>。主要介绍这几个注解常用的使用方式和特点。</p><h2 id="1-RestController">1. @RestController</h2><p><code>@RestController</code> 是 Spring Boot 新增的一个注解，我们看一下该注解都包含了哪些东西。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RestController &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出， <code>@RestController</code> 注解包含了原来的 <code>@Controller</code> 和 <code>@ResponseBody</code> 注解，使用过 Spring 的朋友对 <code>@Controller</code> 注解已经非常了解了，这里不再赘述， <code>@ResponseBody</code> 注解是将返回的数据结构转换为 Json 格式。所以 <code>@RestController</code> 可以看作是 <code>@Controller</code> 和 <code>@ResponseBody</code> 的结合体，相当于偷个懒，我们使用 <code>@RestController</code> 之后就不用再使用 <code>@Controller</code> 了。但是需要注意一个问题：如果是前后端分离，不用模板渲染的话，比如 Thymeleaf，这种情况下是可以直接使用<code>@RestController</code> 将数据以 json 格式传给前端，前端拿到之后解析；但如果不是前后端分离，需要使用模板来渲染的话，一般 Controller 中都会返回到具体的页面，那么此时就不能使用<code>@RestController</code>了，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"user"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实是需要返回到 user.html 页面的，如果使用 <code>@RestController</code> 的话，会将 user 作为字符串返回的，所以这时候我们需要使用 <code>@Controller</code> 注解。这在下一节 Spring Boot 集成 Thymeleaf 模板引擎中会再说明。</p><h2 id="2-RequestMapping">2. @RequestMapping</h2><p><code>@RequestMapping</code> 是一个用来处理请求地址映射的注解，它可以用于类上，也可以用于方法上。在类的级别上的注解会将一个特定请求或者请求模式映射到一个控制器之上，表示类中的所有响应请求的方法都是以该地址作为父路径；在方法的级别表示进一步指定到处理方法的映射关系。</p><p>该注解有6个属性，一般在项目中比较常用的有三个属性：value、method 和 produces。</p><ul><li>value 属性：指定请求的实际地址，value 可以省略不写</li><li>method 属性：指定请求的类型，主要有 GET、PUT、POST、DELETE，默认为 GET</li><li>produces属性：指定返回内容类型，如 produces = “application/json; charset=UTF-8”</li></ul><p><code>@RequestMapping</code> 注解比较简单，举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/test"</span>, produces = <span class="string">"application/json; charset=UTF-8"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/get"</span>, method = RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个很简单，启动项目在浏览器中输入 <code>localhost:8080/test/get</code> 测试一下即可。</p><p>针对四种不同的请求方式，是有相应注解的，不用每次在 <code>@RequestMapping</code> 注解中加 method 属性来指定，上面的 GET 方式请求可以直接使用 <code>@GetMapping(&quot;/get&quot;)</code> 注解，效果一样。相应地，PUT 方式、POST 方式和 DELETE 方式对应的注解分别为 <code>@PutMapping</code>、<code>@PostMapping</code> 和 <code>DeleteMapping</code>。</p><h2 id="3-PathVariable">3. @PathVariable</h2><p><code>@PathVariable</code> 注解主要是用来获取 url 参数，Spring Boot 支持 restfull 风格的 url，比如一个 GET 请求携带一个参数 id 过来，我们将 id 作为参数接收，可以使用 <code>@PathVariable</code> 注解。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/user/&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testPathVariable</span><span class="params">(@PathVariable Integer id)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"获取到的id为："</span> + id);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意一个问题，如果想要 url 中占位符中的 id 值直接赋值到参数 id 中，需要保证 url 中的参数和方法接收参数一致，否则就无法接收。如果不一致的话，其实也可以解决，需要用 <code>@PathVariable</code> 中的 value 属性来指定对应关系。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user/&#123;idd&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testPathVariable</span><span class="params">(@PathVariable(value = <span class="string">"idd"</span>)</span> Integer id) </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"获取到的id为："</span> + id);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于访问的 url，占位符的位置可以在任何位置，不一定非要在最后，比如这样也行：<code>/xxx/{id}/user</code>。另外，url 也支持多个占位符，方法参数使用同样数量的参数来接收，原理和一个参数是一样的，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/user/&#123;idd&#125;/&#123;name&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testPathVariable</span><span class="params">(@PathVariable(value = <span class="string">"idd"</span>)</span> Integer id, @PathVariable String name) </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"获取到的id为："</span> + id);</span><br><span class="line">        System.out.println(<span class="string">"获取到的name为："</span> + name);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>运行项目，在浏览器中请求 <code>localhost:8080/test/user/2/zhangsan</code> 可以看到控制台输出如下信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">获取到的id为：2</span><br><span class="line">获取到的name为：zhangsan</span><br></pre></td></tr></table></figure><p>所以支持多个参数的接收。同样地，如果 url 中的参数和方法中的参数名称不同的话，也需要使用 value 属性来绑定两个参数。</p><h2 id="4-RequestParam">4. @RequestParam</h2><p><code>@RequestParam</code> 注解顾名思义，也是获取请求参数的，上面我们介绍了 <code>@PathValiable</code> 注解也是获取请求参数的，那么 <code>@RequestParam</code> 和 <code>@PathVariable</code> 有什么不同呢？主要区别在于： <code>@PathValiable</code> 是从 url 模板中获取参数值， 即这种风格的 url：<code>http://localhost:8080/user/{id}</code> ；而 <code>@RequestParam</code> 是从 request 里面获取参数值，即这种风格的 url：<code>http://localhost:8080/user?id=1</code>  。我们使用该 url 带上参数 id 来测试一下如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testRequestParam</span><span class="params">(@RequestParam Integer id)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"获取到的id为："</span> + id);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以正常从控制台打印出 id 信息。同样地，url 上面的参数和方法的参数需要一致，如果不一致，也需要使用 value 属性来说明，比如 url 为：<code>http://localhost:8080/user?idd=1</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testRequestParam</span><span class="params">(@RequestParam(value = <span class="string">"idd"</span>, required = <span class="keyword">false</span>)</span> Integer id) </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"获取到的id为："</span> + id);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了 value 属性外，还有个两个属性比较常用：</p><ul><li>required 属性：true 表示该参数必须要传，否则就会报 404 错误，false 表示可有可无。</li><li>defaultValue 属性：默认值，表示如果请求中没有同名参数时的默认值。</li></ul><p>从 url 中可以看出，<code>@RequestParam</code> 注解用于 GET 请求上时，接收拼接在 url 中的参数。除此之外，该注解还可以用于 POST 请求，接收前端表单提交的参数，假如前端通过表单提交 username 和 password 两个参数，那我们可以使用 <code>@RequestParam</code> 来接收，用法和上面一样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/form1"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testForm</span><span class="params">(@RequestParam String username, @RequestParam String password)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"获取到的username为："</span> + username);</span><br><span class="line">        System.out.println(<span class="string">"获取到的password为："</span> + password);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们使用 postman 来模拟一下表单提交，测试一下接口：</p><p><img src="https://img-blog.csdnimg.cn/20200215043749282.png" alt="使用postman测试表单提交"></p><p>那么问题来了，如果表单数据很多，我们不可能在后台方法中写上很多参数，每个参数还要 <code>@RequestParam</code> 注解。针对这种情况，我们需要封装一个实体类来接收这些参数，实体中的属性名和表单中的参数名一致即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String username;</span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"><span class="comment">// set get</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用实体接收的话，我们不能在前面加 <code>@RequestParam</code> 注解了，直接使用即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/form2"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testForm</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"获取到的username为："</span> + user.getUsername());</span><br><span class="line">        System.out.println(<span class="string">"获取到的password为："</span> + user.getPassword());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>使用 postman 再次测试一下表单提交，观察一下返回值和控制台打印出的日志即可。在实际项目中，一般都是封装一个实体类来接收表单数据，因为实际项目中表单数据一般都很多。</p><h2 id="5-RequestBody">5. @RequestBody</h2><p><code>@RequestBody</code> 注解用于接收前端传来的实体，接收参数也是对应的实体，比如前端通过 json 提交传来两个参数 username 和 password，此时我们需要在后端封装一个实体来接收。在传递的参数比较多的情况下，使用 <code>@RequestBody</code> 接收会非常方便。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String username;</span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"><span class="comment">// set get</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testRequestBody</span><span class="params">(@RequestBody User user)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"获取到的username为："</span> + user.getUsername());</span><br><span class="line">System.out.println(<span class="string">"获取到的password为："</span> + user.getPassword());</span><br><span class="line"><span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用 postman 工具来测试一下效果，打开 postman，然后输入请求地址和参数，参数我们用 json 来模拟，如下图所有，调用之后返回 success。</p><p><img src="https://img-blog.csdnimg.cn/20200215043853532.png" alt="使用Postman测试requestBody"></p><p>同时看一下后台控制台输出的日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">获取到的username为：倪升武</span><br><span class="line">获取到的password为：123456</span><br></pre></td></tr></table></figure><p>可以看出，<code>@RequestBody</code> 注解用于 POST 请求上，接收 json 实体参数。它和上面我们介绍的表单提交有点类似，只不过参数的格式不同，一个是 json 实体，一个是表单提交。在实际项目中根据具体场景和需要使用对应的注解即可。</p><h2 id="6-总结">6. 总结</h2><p>本节课主要讲解了 Spring Boot 中对 MVC 的支持，分析了 <code>@RestController</code>、 <code>@RequestMapping</code>、<code>@PathVariable</code>、 <code>@RequestParam</code> 和 <code>@RequestBody</code> 四个注解的使用方式，由于 <code>@RestController</code> 中集成了 <code>@ResponseBody</code> 所以对返回 json 的注解不再赘述。以上四个注解是使用频率很高的注解，在所有的实际项目中基本都会遇到，要熟练掌握。</p><p>课程源代码下载地址：<a href="https://gitee.com/eson15/springboot_study" target="_blank" rel="noopener">戳我下载</a></p><blockquote><p>欢迎关注我的为微信公众号：武哥聊编程</p></blockquote><h1>第06课：Spring Boot集成 Swagger2 展现在线接口文档</h1><h2 id="1-Swagger-简介">1. Swagger 简介</h2><h3 id="1-1-解决的问题">1.1 解决的问题</h3><p>随着互联网技术的发展，现在的网站架构基本都由原来的后端渲染，变成了前后端分离的形态，而且前端技术和后端技术在各自的道路上越走越远。前端和后端的唯一联系，变成了 API 接口，所以 API 文档变成了前后端开发人员联系的纽带，变得越来越重要。</p><p>那么问题来了，随着代码的不断更新，开发人员在开发新的接口或者更新旧的接口后，由于开发任务的繁重，往往文档很难持续跟着更新，Swagger 就是用来解决该问题的一款重要的工具，对使用接口的人来说，开发人员不需要给他们提供文档，只要告诉他们一个 Swagger 地址，即可展示在线的 API 接口文档，除此之外，调用接口的人员还可以在线测试接口数据，同样地，开发人员在开发接口时，同样也可以利用 Swagger 在线接口文档测试接口数据，这给开发人员提供了便利。</p><h3 id="1-2-Swagger-官方">1.2 Swagger 官方</h3><p>我们打开 <a href="https://swagger.io/" target="_blank" rel="noopener">Swagger 官网</a>，官方对 Swagger 的定义为：</p><blockquote><p>The Best APIs are Built with Swagger Tools</p></blockquote><p>翻译成中文是：“最好的 API 是使用 Swagger 工具构建的”。由此可见，Swagger 官方对其功能和所处的地位非常自信，由于其非常好用，所以官方对其定位也合情合理。如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/20200215043936444.png" alt="官方对swagger的定位"></p><p>本文主要讲解在 Spring Boot 中如何导入 Swagger2 工具来展现项目中的接口文档。本节课使用的 Swagger 版本为 2.2.2。下面开始进入 Swagger2 之旅。</p><h2 id="2-Swagger2-的-maven-依赖">2. Swagger2 的 maven 依赖</h2><p>使用 Swagger2 工具，必须要导入 maven 依赖，当前官方最高版本是 2.8.0，我尝试了一下，个人感觉页面展示的效果不太好，而且不够紧凑，不利于操作。另外，最新版本并不一定是最稳定版本，当前我们实际项目中使用的是 2.2.2 版本，该版本稳定，界面友好，所以本节课主要围绕着 2.2.2 版本来展开，依赖如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-Swagger2-的配置">3. Swagger2 的配置</h2><p>使用 Swagger2 需要进行配置，Spring Boot 中对 Swagger2 的配置非常方便，新建一个配置类，Swagger2 的配置类上除了添加必要的 <code>@Configuration</code> 注解外，还需要添加 <code>@EnableSwagger2</code> 注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.ApiInfoBuilder;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.PathSelectors;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.RequestHandlerSelectors;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.ApiInfo;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spi.DocumentationType;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spring.web.plugins.Docket;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.swagger2.annotations.EnableSwagger2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shengwu ni</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger</span>2</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">createRestApi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                <span class="comment">// 指定构建api文档的详细信息的方法：apiInfo()</span></span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                <span class="comment">// 指定要生成api接口的包路径，这里把controller作为包路径，生成controller中的所有接口</span></span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="string">"com.itcodai.course06.controller"</span>))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建api文档的详细信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ApiInfo <span class="title">apiInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiInfoBuilder()</span><br><span class="line">                <span class="comment">// 设置页面标题</span></span><br><span class="line">                .title(<span class="string">"Spring Boot集成Swagger2接口总览"</span>)</span><br><span class="line">                <span class="comment">// 设置接口描述</span></span><br><span class="line">                .description(<span class="string">"跟武哥一起学Spring Boot第06课"</span>)</span><br><span class="line">                <span class="comment">// 设置联系方式</span></span><br><span class="line">                .contact(<span class="string">"倪升武，"</span> + <span class="string">"CSDN：http://blog.csdn.net/eson_15"</span>)</span><br><span class="line">                <span class="comment">// 设置版本</span></span><br><span class="line">                .version(<span class="string">"1.0"</span>)</span><br><span class="line">                <span class="comment">// 构建</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该配置类中，已经使用注释详细解释了每个方法的作用了，在此不再赘述。到此为止，我们已经配置好了 Swagger2 了。现在我们可以测试一下配置有没有生效，启动项目，在浏览器中输入 <code>localhost:8080/swagger-ui.html</code>，即可看到 swagger2 的接口页面，如下图所示，说明Swagger2 集成成功。</p><p><img src="https://img-blog.csdnimg.cn/20200215044013383.png" alt="swagger2页面"></p><p>结合该图，对照上面的 Swagger2 配置文件中的配置，可以很明确的知道配置类中每个方法的作用。这样就很容易理解和掌握 Swagger2 中的配置了，也可以看出，其实 Swagger2 配置很简单。</p><p>【友情提示】可能有很多朋友在配置 Swagger 的时候会遇到下面的情况，而且还关不掉的，这是因为浏览器缓存引起的，清空一下浏览器缓存即可解决问题。</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-SWRv5YTY-1675176330110)(<a href="http://p99jlm9k5.bkt.clouddn.com/blog/images/1/error.png" target="_blank" rel="noopener">http://p99jlm9k5.bkt.clouddn.com/blog/images/1/error.png</a>)]</p><h2 id="4-Swagger2-的使用">4. Swagger2 的使用</h2><p>上面我们已经配置好了 Swagger2，并且也启动测试了一下，功能正常，下面我们开始使用 Swagger2，主要来介绍 Swagger2 中的几个常用的注解，分别在实体类上、 Controller 类上以及 Controller 中的方法上，最后我们看一下 Swagger2 是如何在页面上呈现在线接口文档的，并且结合 Controller 中的方法在接口中测试一下数据。</p><h3 id="4-1-实体类注解">4.1 实体类注解</h3><p>本节我们建一个 User 实体类，主要介绍一下 Swagger2 中的 <code>@ApiModel</code> 和 <code>@ApiModelProperty</code> 注解，同时为后面的测试做准备。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiModel;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiModelProperty;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ApiModel</span>(value = <span class="string">"用户实体类"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">"用户唯一标识"</span>)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">"用户姓名"</span>)</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">"用户密码"</span>)</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略set和get方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释下 <code>@ApiModel</code> 和 <code>@ApiModelProperty</code> 注解：</p><blockquote><p><code>@ApiModel</code> 注解用于实体类，表示对类进行说明，用于参数用实体类接收。<br><code>@ApiModelProperty</code> 注解用于类中属性，表示对 model 属性的说明或者数据操作更改。</p></blockquote><p>该注解在在线 API 文档中的具体效果在下文说明。</p><h3 id="4-2-Controller-类中相关注解">4.2 Controller 类中相关注解</h3><p>我们写一个 TestController，再写几个接口，然后学习一下 Controller 中和 Swagger2 相关的注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.itcodai.course06.entiy.JsonResult;</span><br><span class="line"><span class="keyword">import</span> com.itcodai.course06.entiy.User;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.Api;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiOperation;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiParam;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/swagger"</span>)</span><br><span class="line"><span class="meta">@Api</span>(value = <span class="string">"Swagger2 在线接口文档"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/get/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="meta">@ApiOperation</span>(value = <span class="string">"根据用户唯一标识获取用户信息"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> JsonResult&lt;User&gt; <span class="title">getUserInfo</span><span class="params">(@PathVariable @ApiParam(value = <span class="string">"用户唯一标识"</span>)</span> Long id) </span>&#123;</span><br><span class="line">        <span class="comment">// 模拟数据库中根据id获取User信息</span></span><br><span class="line">        User user = <span class="keyword">new</span> User(id, <span class="string">"倪升武"</span>, <span class="string">"123456"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JsonResult(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来学习一下 <code>@Api</code> 、 <code>@ApiOperation</code> 和 <code>@ApiParam</code> 注解。</p><blockquote><p><code>@Api</code> 注解用于类上，表示标识这个类是 swagger 的资源。<br><code>@ApiOperation</code> 注解用于方法，表示一个 http 请求的操作。<br><code>@ApiParam</code> 注解用于参数上，用来标明参数信息。</p></blockquote><p>这里返回的是 JsonResult，是第02课中学习返回 json 数据时封装的实体。以上是 Swagger 中最常用的 5 个注解，接下来运行一下项目工程，在浏览器中输入 <code>localhost:8080/swagger-ui.html</code> 看一下 Swagger 页面的接口状态。</p><p><img src="https://img-blog.csdnimg.cn/20200215044156305.png" alt="swagger接口展示"></p><p>可以看出，Swagger 页面对该接口的信息展示的非常全面，每个注解的作用以及展示的地方在上图中已经标明，通过页面即可知道该接口的所有信息，那么我们直接在线测试一下该接口返回的信息，输入id为1，看一下返回数据：</p><p><img src="https://img-blog.csdnimg.cn/20200215044226292.png" alt="返回数据测试"></p><p>可以看出，直接在页面返回了 json 格式的数据，开发人员可以直接使用该在线接口来测试数据的正确与否，非常方便。上面是对于单个参数的输入，如果输入参数为某个对象这种情况，Swagger 是什么样子呢？我们再写一个接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/insert"</span>)</span><br><span class="line">    <span class="meta">@ApiOperation</span>(value = <span class="string">"添加用户信息"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> JsonResult&lt;Void&gt; <span class="title">insertUser</span><span class="params">(@RequestBody @ApiParam(value = <span class="string">"用户信息"</span>)</span> User user) </span>&#123;</span><br><span class="line">        <span class="comment">// 处理添加逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JsonResult&lt;&gt;();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>重启项目，在浏览器中输入 <code>localhost:8080/swagger-ui.html</code> 看一下效果：</p><p><img src="https://img-blog.csdnimg.cn/20200215044256579.png" alt="swagger接口展示"></p><h2 id="5-总结">5. 总结</h2><p>OK，本节课详细分析了 Swagger 的优点，以及 Spring Boot 如何集成 Swagger2，包括配置，相关注解的讲解，涉及到了实体类和接口类，以及如何使用。最后通过页面测试，体验了 Swagger 的强大之处，基本上是每个项目组中必备的工具之一，所以要掌握该工具的使用，也不难。</p><p>课程源代码下载地址：<a href="https://gitee.com/eson15/springboot_study" target="_blank" rel="noopener">戳我下载</a></p><blockquote><p>欢迎关注我的为微信公众号：武哥聊编程</p></blockquote><h1>第07课：Spring Boot集成Thymeleaf模板引擎</h1><h2 id="1-Thymeleaf-介绍">1. Thymeleaf 介绍</h2><blockquote><p>Thymeleaf 是适用于 Web 和独立环境的现代服务器端 Java 模板引擎。<br>Thymeleaf 的主要目标是为您的开发工作流程带来优雅的自然模板 - 可以在浏览器中正确显示的HTML，也可以用作静态原型，从而在开发团队中实现更强大的协作。</p></blockquote><p>以上翻译自 Thymeleaf 官方网站。传统的 JSP+JSTL 组合是已经过去了，Thymeleaf 是现代服务端的模板引擎，与传统的 JSP 不同，Thymeleaf 可以使用浏览器直接打开，因为可以忽略掉拓展属性，相当于打开原生页面，给前端人员也带来一定的便利。</p><p>什么意思呢？就是说在本地环境或者有网络的环境下，Thymeleaf 均可运行。由于 thymeleaf 支持 html 原型，也支持在 html 标签里增加额外的属性来达到 “模板+数据” 的展示方式，所以美工可以直接在浏览器中查看页面效果，当服务启动后，也可以让后台开发人员查看带数据的动态页面效果。比如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"ui right aligned basic segment"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"ui orange basic label"</span> <span class="attr">th:text</span>=<span class="string">"$&#123;blog.flag&#125;"</span>&gt;</span>静态原创信息<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">"ui center aligned header"</span> <span class="attr">th:text</span>=<span class="string">"$&#123;blog.title&#125;"</span>&gt;</span>这是静态标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure><p>类似与上面这样，在静态页面时，会展示静态信息，当服务启动后，动态获取数据库中的数据后，就可以展示动态数据，<code>th:text</code> 标签是用来动态替换文本的，这会在下文说明。该例子说明浏览器解释 html 时会忽略 html 中未定义的标签属性（比如 <code>th:text</code>），所以 thymeleaf 的模板可以静态地运行；当有数据返回到页面时，Thymeleaf 标签会动态地替换掉静态内容，使页面动态显示数据。</p><h2 id="2-依赖导入">2. 依赖导入</h2><p>在 Spring Boot 中使用 thymeleaf 模板需要引入依赖，可以在创建项目工程时勾选 Thymeleaf，也可以创建之后再手动导入，如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>另外，在 html 页面上如果要使用 thymeleaf 模板，需要在页面标签中引入：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-Thymeleaf相关配置">3. Thymeleaf相关配置</h2><p>因为 Thymeleaf 中已经有默认的配置了，我们不需要再对其做过多的配置，有一个需要注意一下，Thymeleaf 默认是开启页面缓存的，所以在开发的时候，需要关闭这个页面缓存，配置如下。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">thymeleaf:</span></span><br><span class="line">    <span class="attr">cache:</span> <span class="literal">false</span> <span class="comment">#关闭缓存</span></span><br></pre></td></tr></table></figure><p>否则会有缓存，导致页面没法及时看到更新后的效果。 比如你修改了一个文件，已经 update 到 tomcat 了，但刷新页面还是之前的页面，就是因为缓存引起的。</p><h2 id="4-Thymeleaf-的使用">4. Thymeleaf 的使用</h2><h3 id="4-1-访问静态页面">4.1 访问静态页面</h3><p>这个和 Thymeleaf 没啥关系，应该说是通用的，我把它一并写到这里的原因是一般我们做网站的时候，都会做一个 404 页面和 500 页面，为了出错时给用户一个友好的展示，而不至于一堆异常信息抛出来。Spring Boot 中会自动识别模板目录（templates/）下的 404.html 和 500.html 文件。我们在 templates/ 目录下新建一个 error 文件夹，专门放置错误的 html 页面，然后分别打印些信息。以 404.html 为例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    这是404页面</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们再写一个 controller 来测试一下 404 和 500 页面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/thymeleaf"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThymeleafController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/test404"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test404</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/test500"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test500</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当我们在浏览器中输入 <code>localhost:8080/thymeleaf/test400</code> 时，故意输入错误，找不到对应的方法，就会跳转到 404.html 显示。<br>当我们在浏览器中输入 <code>localhost:8088/thymeleaf/test505</code> 时，会抛出异常，然后会自动跳转到 500.html 显示。</p></blockquote><p>【注】这里有个问题需要注意一下，前面的课程中我们说了微服务中会走向前后端分离，我们在 Controller 层上都是使用的 <code>@RestController</code> 注解，自动会把返回的数据转成 json 格式。但是在使用模板引擎时，Controller 层就不能用 <code>@RestController</code> 注解了，因为在使用 thymeleaf 模板时，返回的是视图文件名，比如上面的 Controller 中是返回到 index.html 页面，如果使用 <code>@RestController</code> 的话，会把 index 当作 String 解析了，直接返回到页面了，而不是去找 index.html 页面，大家可以试一下。所以在使用模板时要用 <code>@Controller</code> 注解。</p><h3 id="4-2-Thymeleaf-中处理对象">4.2 Thymeleaf 中处理对象</h3><p>我们来看一下 thymeleaf 模板中如何处理对象信息，假如我们在做个人博客的时候，需要给前端传博主相关信息来展示，那么我们会封装成一个博主对象，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Blogger</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String pass;</span><br><span class="line"><span class="comment">// 省去set和get</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在controller层中初始化一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/getBlogger"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getBlogger</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">Blogger blogger = <span class="keyword">new</span> Blogger(<span class="number">1L</span>, <span class="string">"倪升武"</span>, <span class="string">"123456"</span>);</span><br><span class="line">model.addAttribute(<span class="string">"blogger"</span>, blogger);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"blogger"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先初始化一个 Blogger 对象，然后将该对象放到 Model 中，然后返回到 blogger.html 页面去渲染。接下来我们再写一个 blogger.html 来渲染 blogger 信息：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>博主信息<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">""</span> <span class="attr">th:object</span>=<span class="string">"$&#123;blogger&#125;"</span> &gt;</span></span><br><span class="line">    用户编号：<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">th:value</span>=<span class="string">"$&#123;blogger.id&#125;"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    用户姓名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">th:value</span>=<span class="string">"$&#123;blogger.getName()&#125;"</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    登陆密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">th:value</span>=<span class="string">"*&#123;pass&#125;"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看出，在 thymeleaf 模板中，使用 <code>th:object=&quot;${}&quot;</code> 来获取对象信息，然后在表单里面可以有三种方式来获取对象属性。如下：</p><blockquote><p>使用 <code>th:value=&quot;*{属性名}&quot;</code><br>使用 <code>th:value=&quot;${对象.属性名}&quot;</code>，对象指的是上面使用 <code>th:object</code> 获取的对象<br>使用 <code>th:value=&quot;${对象.get方法}&quot;</code>，对象指的是上面使用 <code>th:object</code> 获取的对象</p></blockquote><p>可以看出，在 Thymeleaf 中可以像写 java 一样写代码，很方便。我们在浏览器中输入 <code>localhost:8080/thymeleaf/getBlogger</code> 来测试一下数据：</p><p><img src="https://img-blog.csdnimg.cn/20200215044353803.jpg" alt="thymeleaf中处理对象"></p><h3 id="4-3-Thymeleaf-中处理-List">4.3 Thymeleaf 中处理 List</h3><p>处理 List 的话，和处理上面介绍的对象差不多，但是需要在 thymeleaf 中进行遍历。我们先在 Controller 中模拟一个 List。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/getList"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getList</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">    Blogger blogger1 = <span class="keyword">new</span> Blogger(<span class="number">1L</span>, <span class="string">"倪升武"</span>, <span class="string">"123456"</span>);</span><br><span class="line">    Blogger blogger2 = <span class="keyword">new</span> Blogger(<span class="number">2L</span>, <span class="string">"达人课"</span>, <span class="string">"123456"</span>);</span><br><span class="line">    List&lt;Blogger&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(blogger1);</span><br><span class="line">    list.add(blogger2);</span><br><span class="line">    model.addAttribute(<span class="string">"list"</span>, list);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"list"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们写一个 list.html 来获取该 list 信息，然后在 list.html 中遍历这个list。如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>博主信息<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">""</span> <span class="attr">th:each</span>=<span class="string">"blogger : $&#123;list&#125;"</span> &gt;</span></span><br><span class="line">    用户编号：<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">th:value</span>=<span class="string">"$&#123;blogger.id&#125;"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    用户姓名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">th:value</span>=<span class="string">"$&#123;blogger.name&#125;"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    登录密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">th:value</span>=<span class="string">"$&#123;blogger.getPass()&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看出，其实和处理单个对象信息差不多，Thymeleaf 使用 <code>th:each</code> 进行遍历，<code>${}</code> 取 model 中传过来的参数，然后自定义 list 中取出来的每个对象，这里定义为 blogger。表单里面可以直接使用 <code>${对象.属性名}</code> 来获取 list 中对象的属性值，也可以使用 <code>${对象.get方法}</code> 来获取，这点和上面处理对象信息是一样的，但是不能使用 <code>*{属性名}</code> 来获取对象中的属性，thymeleaf 模板获取不到。</p><h3 id="4-4-其他常用-thymeleaf-操作">4.4 其他常用 thymeleaf 操作</h3><p>我们来总结一下 thymeleaf 中的一些常用的标签操作，如下：</p><table><thead><tr><th>标签</th><th>功能</th><th>例子</th></tr></thead><tbody><tr><td><code>th:value</code></td><td>给属性赋值</td><td><code>&lt;input th:value=&quot;${blog.name}&quot; /&gt; </code></td></tr><tr><td><code>th:style</code></td><td>设置样式</td><td><code>th:style=&quot;'display:'+@{(${sitrue}?'none':'inline-block')} + ''&quot;</code></td></tr><tr><td><code>th:onclick</code></td><td>点击事件</td><td><code>th:onclick=&quot;'getInfo()'&quot;</code></td></tr><tr><td><code>th:if</code></td><td>条件判断</td><td><code>&lt;a th:if=&quot;${userId == collect.userId}&quot; &gt;</code></td></tr><tr><td><code>th:href</code></td><td>超链接</td><td><code>&lt;a th:href=&quot;@{/blogger/login}&quot;&gt;Login&lt;/a&gt; /&gt;</code></td></tr><tr><td><code>th:unless</code></td><td>条件判断和<code>th:if</code>相反</td><td><code>&lt;a th:href=&quot;@{/blogger/login}&quot; th:unless=${session.user != null}&gt;Login&lt;/a&gt;</code></td></tr><tr><td><code>th:switch</code></td><td>配合<code>th:case</code></td><td><code>&lt;div th:switch=&quot;${user.role}&quot;&gt;</code></td></tr><tr><td><code>th:case</code></td><td>配合<code>th:switch</code></td><td><code>&lt;p th:case=&quot;'admin'&quot;&gt;administator&lt;/p&gt;</code></td></tr><tr><td><code>th:src</code></td><td>地址引入</td><td><code>&lt;img alt=&quot;csdn logo&quot; th:src=&quot;@{/img/logo.png}&quot; /&gt;</code></td></tr><tr><td><code>th:action</code></td><td>表单提交的地址</td><td><code>&lt;form th:action=&quot;@{/blogger/update}&quot;&gt;</code></td></tr></tbody></table><p>Thymeleaf 还有很多其他用法，这里就不总结了，具体的可以参考Thymeleaf的<a href="https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html" target="_blank" rel="noopener">官方文档（v3.0）</a>。主要要学会如何在 Spring Boot 中去使用 thymeleaf，遇到对应的标签或者方法，查阅官方文档即可。</p><h2 id="5-总结-v2">5. 总结</h2><p>Thymeleaf 在 Spring Boot 中使用非常广泛，本节课主要分析了 thymeleaf 的优点，以及如何在 Spring Boot 中集成并使用 thymeleaf 模板，包括依赖、配置，相关数据的获取、以及一些注意事项等等。最后列举了一些 thymeleaf 中常用的标签，在实际项目中多使用，多查阅就能熟练掌握，thymeleaf 中的一些标签或者方法不用死记硬背，用到什么去查阅什么，关键是要会在 Spring Boot 中集成，用的多了就熟能生巧。</p><p>课程源代码下载地址：<a href="https://gitee.com/eson15/springboot_study" target="_blank" rel="noopener">戳我下载</a></p><blockquote><p>欢迎关注我的为微信公众号：武哥聊编程</p></blockquote><h1>第08课：Spring Boot中的全局异常处理</h1><p>在项目开发过程中，不管是对底层数据库的操作过程，还是业务层的处理过程，还是控制层的处理过程，都不可避免会遇到各种可预知的、不可预知的异常需要处理。如果对每个过程都单独作异常处理，那系统的代码耦合度会变得很高，此外，开发工作量也会加大而且不好统一，这也增加了代码的维护成本。<br>针对这种实际情况，我们需要将所有类型的异常处理从各处理过程解耦出来，这样既保证了相关处理过程的功能单一，也实现了异常信息的统一处理和维护。同时，我们也不希望直接把异常抛给用户，应该对异常进行处理，对错误信息进行封装，然后返回一个友好的信息给用户。这节主要总结一下项目中如何使用 Spring Boot 如何拦截并处理全局的异常。</p><h2 id="1-定义返回的统一-json-结构">1. 定义返回的统一 json 结构</h2><p>前端或者其他服务请求本服务的接口时，该接口需要返回对应的 json 数据，一般该服务只需要返回请求着需要的参数即可，但是在实际项目中，我们需要封装更多的信息，比如状态码 code、相关信息 msg 等等，这一方面是在项目中可以有个统一的返回结构，整个项目组都适用，另一方面是方便结合全局异常处理信息，因为异常处理信息中一般我们需要把状态码和异常内容反馈给调用方。<br>这个统一的 json 结构这可以参考<a href="https://gitbook.cn/gitchat/column/5b3c9f35a3442272491a176a" target="_blank" rel="noopener">第02课：Spring Boot 返回 JSON 数据及数据封装</a>中封装的统一 json 结构，本节内容我们简化一下，只保留状态码 code 和异常信息 msg即可。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonResult</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异常码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> String code;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异常信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> String msg;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JsonResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = <span class="string">"200"</span>;</span><br><span class="line">        <span class="keyword">this</span>.msg = <span class="string">"操作成功"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JsonResult</span><span class="params">(String code, String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// get set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-处理系统异常">2. 处理系统异常</h2><p>新建一个 GlobalExceptionHandler 全局异常处理类，然后加上 <code>@ControllerAdvice</code> 注解即可拦截项目中抛出的异常，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line"><span class="comment">// 打印log</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们点开 <code>@ControllerAdvice</code> 注解可以看到，<code>@ControllerAdvice</code> 注解包含了 <code>@Component</code> 注解，说明在 Spring Boot 启动时，也会把该类作为组件交给 Spring 来管理。除此之外，该注解还有个 <code>basePackages</code> 属性，该属性是用来拦截哪个包中的异常信息，一般我们不指定这个属性，我们拦截项目工程中的所有异常。<code>@ResponseBody</code> 注解是为了异常处理完之后给调用方输出一个 json 格式的封装数据。<br>在项目中如何使用呢？Spring Boot 中很简单，在方法上通过 <code>@ExceptionHandler</code> 注解来指定具体的异常，然后在方法中处理该异常信息，最后将结果通过统一的 json 结构体返回给调用者。下面我们举几个例子来说明如何来使用。</p><h3 id="2-1-处理参数缺失异常">2.1 处理参数缺失异常</h3><p>在前后端分离的架构中，前端请求后台的接口都是通过 rest 风格来调用，有时候，比如 POST 请求 需要携带一些参数，但是往往有时候参数会漏掉。另外，在微服务架构中，涉及到多个微服务之间的接口调用时，也可能出现这种情况，此时我们需要定义一个处理参数缺失异常的方法，来给前端或者调用方提示一个友好信息。</p><p>参数缺失的时候，会抛出 <code>HttpMessageNotReadableException</code>，我们可以拦截该异常，做一个友好处理，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 缺少请求参数异常</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> ex HttpMessageNotReadableException</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@ExceptionHandler</span>(MissingServletRequestParameterException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ResponseStatus</span>(<span class="title">value</span> </span>= HttpStatus.BAD_REQUEST)</span><br><span class="line"><span class="function"><span class="keyword">public</span> JsonResult <span class="title">handleHttpMessageNotReadableException</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    MissingServletRequestParameterException ex)</span> </span>&#123;</span><br><span class="line">    logger.error(<span class="string">"缺少请求参数，&#123;&#125;"</span>, ex.getMessage());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JsonResult(<span class="string">"400"</span>, <span class="string">"缺少必要的请求参数"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来写个简单的 Controller 测试一下该异常，通过 POST 请求方式接收两个参数：姓名和密码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/exception"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ExceptionController<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> JsonResult <span class="title">test</span><span class="params">(@RequestParam(<span class="string">"name"</span>)</span> String name,</span></span><br><span class="line"><span class="function">                           @<span class="title">RequestParam</span><span class="params">(<span class="string">"pass"</span>)</span> String pass) </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"name：&#123;&#125;"</span>, name);</span><br><span class="line">        logger.info(<span class="string">"pass：&#123;&#125;"</span>, pass);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JsonResult();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后使用 Postman 来调用一下该接口，调用的时候，只传姓名，不传密码，就会抛缺少参数异常，该异常被捕获之后，就会进入我们写好的逻辑，给调用方返回一个友好信息，如下：</p><p><img src="https://img-blog.csdnimg.cn/2020021504443480.png" alt="缺失参数异常"></p><h3 id="2-2-处理空指针异常">2.2 处理空指针异常</h3><p>空指针异常是开发中司空见惯的东西了，一般发生的地方有哪些呢？<br>先来聊一聊一些注意的地方，比如在微服务中，经常会调用其他服务获取数据，这个数据主要是 json 格式的，但是在解析 json 的过程中，可能会有空出现，所以我们在获取某个 jsonObject 时，再通过该 jsonObject 去获取相关信息时，应该要先做非空判断。<br>还有一个很常见的地方就是从数据库中查询的数据，不管是查询一条记录封装在某个对象中，还是查询多条记录封装在一个 List 中，我们接下来都要去处理数据，那么就有可能出现空指针异常，因为谁也不能保证从数据库中查出来的东西就一定不为空，所以在使用数据时一定要先做非空判断。<br>对空指针异常的处理很简单，和上面的逻辑一样，将异常信息换掉即可。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 空指针异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ex NullPointerException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(NullPointerException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseStatus</span>(<span class="title">value</span> </span>= HttpStatus.INTERNAL_SERVER_ERROR)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> JsonResult <span class="title">handleTypeMismatchException</span><span class="params">(NullPointerException ex)</span> </span>&#123;</span><br><span class="line">        logger.error(<span class="string">"空指针异常，&#123;&#125;"</span>, ex.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JsonResult(<span class="string">"500"</span>, <span class="string">"空指针异常了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个我就不测试了，代码中 ExceptionController 有个 <code>testNullPointException</code> 方法，模拟了一个空指针异常，我们在浏览器中请求一下对应的 url 即可看到返回的信息：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"code"</span>:<span class="string">"500"</span>,<span class="attr">"msg"</span>:<span class="string">"空指针异常了"</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-一劳永逸？">2.3 一劳永逸？</h3><p>当然了，异常很多，比如还有 RuntimeException，数据库还有一些查询或者操作异常等等。由于 Exception 异常是父类，所有异常都会继承该异常，所以我们可以直接拦截 Exception 异常，一劳永逸：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 系统异常 预期以外异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseStatus</span>(<span class="title">value</span> </span>= HttpStatus.INTERNAL_SERVER_ERROR)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> JsonResult <span class="title">handleUnexpectedServer</span><span class="params">(Exception ex)</span> </span>&#123;</span><br><span class="line">        logger.error(<span class="string">"系统异常："</span>, ex);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JsonResult(<span class="string">"500"</span>, <span class="string">"系统发生异常，请联系管理员"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是项目中，我们一般都会比较详细的去拦截一些常见异常，拦截 Exception 虽然可以一劳永逸，但是不利于我们去排查或者定位问题。实际项目中，可以把拦截 Exception 异常写在 GlobalExceptionHandler 最下面，如果都没有找到，最后再拦截一下 Exception 异常，保证输出信息友好。</p><h2 id="3-拦截自定义异常">3. 拦截自定义异常</h2><p>在实际项目中，除了拦截一些系统异常外，在某些业务上，我们需要自定义一些业务异常，比如在微服务中，服务之间的相互调用很平凡，很常见。要处理一个服务的调用时，那么可能会调用失败或者调用超时等等，此时我们需要自定义一个异常，当调用失败时抛出该异常，给 GlobalExceptionHandler 去捕获。</p><h3 id="3-1-定义异常信息">3.1 定义异常信息</h3><p>由于在业务中，有很多异常，针对不同的业务，可能给出的提示信息不同，所以为了方便项目异常信息管理，我们一般会定义一个异常信息枚举类。比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 业务异常提示信息枚举类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shengwu ni</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> BusinessMsgEnum &#123;</span><br><span class="line">    <span class="comment">/** 参数异常 */</span></span><br><span class="line">    PARMETER_EXCEPTION(<span class="string">"102"</span>, <span class="string">"参数异常!"</span>),</span><br><span class="line">    <span class="comment">/** 等待超时 */</span></span><br><span class="line">    SERVICE_TIME_OUT(<span class="string">"103"</span>, <span class="string">"服务调用超时！"</span>),</span><br><span class="line">    <span class="comment">/** 参数过大 */</span></span><br><span class="line">    PARMETER_BIG_EXCEPTION(<span class="string">"102"</span>, <span class="string">"输入的图片数量不能超过50张!"</span>),</span><br><span class="line">    <span class="comment">/** 500 : 一劳永逸的提示也可以在这定义 */</span></span><br><span class="line">    UNEXPECTED_EXCEPTION(<span class="string">"500"</span>, <span class="string">"系统发生异常，请联系管理员！"</span>);</span><br><span class="line">    <span class="comment">// 还可以定义更多的业务异常</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String code;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">BusinessMsgEnum</span><span class="params">(String code, String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// set get方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-拦截自定义异常">3.2 拦截自定义异常</h3><p>然后我们可以定义一个业务异常，当出现业务异常时，我们就抛这个自定义的业务异常即可。比如我们定义一个 BusinessErrorException 异常，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义业务异常</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shengwu ni</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BusinessErrorException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">7480022450501760611L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异常码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String code;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异常提示信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BusinessErrorException</span><span class="params">(BusinessMsgEnum businessMsgEnum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = businessMsgEnum.code();</span><br><span class="line">        <span class="keyword">this</span>.message = businessMsgEnum.msg();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// get set方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在构造方法中，传入我们上面自定义的异常枚举类，所以在项目中，如果有新的异常信息需要添加，我们直接在枚举类中添加即可，很方便，做到统一维护，然后再拦截该异常时获取即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拦截业务异常，返回业务异常信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(BusinessErrorException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseStatus</span>(<span class="title">value</span> </span>= HttpStatus.INTERNAL_SERVER_ERROR)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> JsonResult <span class="title">handleBusinessError</span><span class="params">(BusinessErrorException ex)</span> </span>&#123;</span><br><span class="line">        String code = ex.getCode();</span><br><span class="line">        String message = ex.getMessage();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JsonResult(code, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在业务代码中，我们可以直接模拟一下抛出业务异常，测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/exception"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ExceptionController<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/business"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> JsonResult <span class="title">testException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BusinessErrorException(BusinessMsgEnum.UNEXPECTED_EXCEPTION);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JsonResult();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行一下项目，测试一下，返回 json 如下，说明我们自定义的业务异常捕获成功：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"code"</span>:<span class="string">"500"</span>,<span class="attr">"msg"</span>:<span class="string">"系统发生异常，请联系管理员！"</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="4-总结-v4">4. 总结</h2><p>本节课程主要讲解了Spring Boot 的全局异常处理，包括异常信息的封装、异常信息的捕获和处理，以及在实际项目中，我们用到的自定义异常枚举类和业务异常的捕获与处理，在项目中运用的非常广泛，基本上每个项目中都需要做全局异常处理。</p><p>课程源代码下载地址：<a href="https://gitee.com/eson15/springboot_study" target="_blank" rel="noopener">戳我下载</a></p><blockquote><p>欢迎关注我的为微信公众号：武哥聊编程</p></blockquote><h1>第09课：Spring Boot中的切面AOP处理</h1><h2 id="1-什么是AOP">1. 什么是AOP</h2><p>AOP：Aspect Oriented Programming 的缩写，意为：面向切面编程。面向切面编程的目标就是分离关注点。什么是关注点呢？就是关注点，就是你要做的事情。假如你是一位公子哥，没啥人生目标，每天衣来伸手，饭来张口，整天只知道一件事：玩（这就是你的关注点，你只要做这一件事）！但是有个问题，你在玩之前，你还需要起床、穿衣服、穿鞋子、叠被子、做早饭等等等等，但是这些事情你不想关注，也不用关注，你只想想玩，那么怎么办呢？</p><p>对！这些事情通通交给下人去干。你有一个专门的仆人 A 帮你穿衣服，仆人 B 帮你穿鞋子，仆人 C 帮你叠好被子，仆人 D 帮你做饭，然后你就开始吃饭、去玩（这就是你一天的正事），你干完你的正事之后，回来，然后一系列仆人又开始帮你干这个干那个，然后一天就结束了！</p><p>这就是 AOP。AOP 的好处就是你只需要干你的正事，其它事情别人帮你干。也许有一天，你想裸奔，不想穿衣服，那么你把仆人 A 解雇就是了！也许有一天，出门之前你还想带点钱，那么你再雇一个仆人 E 专门帮你干取钱的活！这就是AOP。每个人各司其职，灵活组合，达到一种可配置的、可插拔的程序结构。</p><h2 id="2-Spring-Boot-中的-AOP-处理">2. Spring Boot 中的 AOP 处理</h2><h3 id="2-1-AOP-依赖">2.1 AOP 依赖</h3><p>使用AOP，首先需要引入AOP的依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-2-实现-AOP-切面">2.2 实现 AOP 切面</h3><p>Spring Boot 中使用 AOP 非常简单，假如我们要在项目中打印一些 log，在引入了上面的依赖之后，我们新建一个类 LogAspectHandler，用来定义切面和处理方法。只要在类上加个<code>@Aspect</code>注解即可。<code>@Aspect</code> 注解用来描述一个切面类，定义切面类的时候需要打上这个注解。<code>@Component</code> 注解让该类交给 Spring 来管理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAspectHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要介绍几个常用的注解及使用：</p><blockquote><p>1.@Pointcut：定义一个切面，即上面所描述的关注的某件事入口。<br>2.@Before：在做某件事之前做的事。<br>3.@After：在做某件事之后做的事。<br>4.@AfterReturning：在做某件事之后，对其返回值做增强处理。<br>5.@AfterThrowing：在做某件事抛出异常时，处理。</p></blockquote><h4 id="2-2-1-Pointcut-注解">2.2.1 @Pointcut 注解</h4><p><code>@Pointcut</code> 注解：用来定义一个切面（切入点），即上文中所关注的某件事情的入口。切入点决定了连接点关注的内容，使得我们可以控制通知什么时候执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAspectHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一个切面，拦截com.itcodai.course09.controller包和子包下的所有方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* com.itcodai.course09.controller..*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointCut</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@Pointcut</code> 注解指定一个切面，定义需要拦截的东西，这里介绍两个常用的表达式：一个是使用 <code>execution()</code>，另一个是使用 <code>annotation()</code>。<br>以 <code>execution(* com.itcodai.course09.controller..*.*(..)))</code> 表达式为例，语法如下：</p><blockquote><p><code>execution()</code> 为表达式主体<br>第一个 <code>*</code> 号的位置：表示返回值类型，<code>*</code> 表示所有类型<br>包名：表示需要拦截的包名，后面的两个句点表示当前包和当前包的所有子包，<code>com.itcodai.course09.controller</code> 包、子包下所有类的方法<br>第二个 <code>*</code> 号的位置：表示类名，<code>*</code> 表示所有类<br><code>*(..)</code> ：这个星号表示方法名，<code>*</code> 表示所有的方法，后面括弧里面表示方法的参数，两个句点表示任何参数</p></blockquote><p><code>annotation()</code> 方式是针对某个注解来定义切面，比如我们对具有<code>@GetMapping</code>注解的方法做切面，可以如下定义切面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"@annotation(org.springframework.web.bind.annotation.GetMapping)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">annotationCut</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>然后使用该切面的话，就会切入注解是 <code>@GetMapping</code> 的方法。因为在实际项目中，可能对于不同的注解有不同的逻辑处理，比如 <code>@GetMapping</code>、<code>@PostMapping</code>、<code>@DeleteMapping</code> 等。所以这种按照注解的切入方式在实际项目中也很常用。</p><h4 id="2-2-2-Before-注解">2.2.2 @Before 注解</h4><p><code>@Before</code> 注解指定的方法在切面切入目标方法之前执行，可以做一些 log 处理，也可以做一些信息的统计，比如获取用户的请求 url 以及用户的 ip 地址等等，这个在做个人站点的时候都能用得到，都是常用的方法。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAspectHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在上面定义的切面方法之前执行该方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint jointPoint</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"pointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"====doBefore方法进入了===="</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取签名</span></span><br><span class="line">        Signature signature = joinPoint.getSignature();</span><br><span class="line">        <span class="comment">// 获取切入的包名</span></span><br><span class="line">        String declaringTypeName = signature.getDeclaringTypeName();</span><br><span class="line">        <span class="comment">// 获取即将执行的方法名</span></span><br><span class="line">        String funcName = signature.getName();</span><br><span class="line">        logger.info(<span class="string">"即将执行方法为: &#123;&#125;，属于&#123;&#125;包"</span>, funcName, declaringTypeName);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 也可以用来记录一些信息，比如获取请求的url和ip</span></span><br><span class="line">        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class="line">        HttpServletRequest request = attributes.getRequest();</span><br><span class="line">        <span class="comment">// 获取请求url</span></span><br><span class="line">        String url = request.getRequestURL().toString();</span><br><span class="line">        <span class="comment">// 获取请求ip</span></span><br><span class="line">        String ip = request.getRemoteAddr();</span><br><span class="line">        logger.info(<span class="string">"用户请求的url为：&#123;&#125;，ip地址为：&#123;&#125;"</span>, url, ip);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JointPoint 对象很有用，可以用它来获取一个签名，然后利用签名可以获取请求的包名、方法名，包括参数（通过 <code>joinPoint.getArgs()</code> 获取）等等。</p><h4 id="2-2-3-After-注解">2.2.3 @After 注解</h4><p><code>@After</code> 注解和 <code>@Before</code>  注解相对应，指定的方法在切面切入目标方法之后执行，也可以做一些完成某方法之后的 log 处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAspectHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一个切面，拦截com.itcodai.course09.controller包下的所有方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* com.itcodai.course09.controller..*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointCut</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在上面定义的切面方法之后执行该方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint jointPoint</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"pointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfter</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">"====doAfter方法进入了===="</span>);</span><br><span class="line">        Signature signature = joinPoint.getSignature();</span><br><span class="line">        String method = signature.getName();</span><br><span class="line">        logger.info(<span class="string">"方法&#123;&#125;已经执行完"</span>, method);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，我们来写一个 Controller 来测试一下执行结果，新建一个 AopController 如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/aop"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AopController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/&#123;name&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testAop</span><span class="params">(@PathVariable String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello "</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动项目，在浏览器中输入 <code>localhost:8080/aop/CSDN</code>，观察一下控制台的输出信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;doBefore方法进入了&#x3D;&#x3D;&#x3D;&#x3D;  </span><br><span class="line">即将执行方法为: testAop，属于com.itcodai.course09.controller.AopController包  </span><br><span class="line">用户请求的url为：http:&#x2F;&#x2F;localhost:8080&#x2F;aop&#x2F;name，ip地址为：0:0:0:0:0:0:0:1  </span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;doAfter方法进入了&#x3D;&#x3D;&#x3D;&#x3D;  </span><br><span class="line">方法testAop已经执行完</span><br></pre></td></tr></table></figure><p>从打印出来的 log 中可以看出程序执行的逻辑与顺序，可以很直观的掌握 <code>@Before</code> 和 <code>@After</code> 两个注解的实际作用。</p><h4 id="2-2-4-AfterReturning-注解">2.2.4 @AfterReturning 注解</h4><p><code>@AfterReturning</code> 注解和 <code>@After</code> 有些类似，区别在于 <code>@AfterReturning</code> 注解可以用来捕获切入方法执行完之后的返回值，对返回值进行业务逻辑上的增强处理，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAspectHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在上面定义的切面方法返回后执行该方法，可以捕获返回对象或者对返回对象进行增强</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint joinPoint</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> result result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AfterReturning</span>(pointcut = <span class="string">"pointCut()"</span>, returning = <span class="string">"result"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterReturning</span><span class="params">(JoinPoint joinPoint, Object result)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Signature signature = joinPoint.getSignature();</span><br><span class="line">        String classMethod = signature.getName();</span><br><span class="line">        logger.info(<span class="string">"方法&#123;&#125;执行完毕，返回参数为：&#123;&#125;"</span>, classMethod, result);</span><br><span class="line">        <span class="comment">// 实际项目中可以根据业务做具体的返回值增强</span></span><br><span class="line">        logger.info(<span class="string">"对返回参数进行业务上的增强：&#123;&#125;"</span>, result + <span class="string">"增强版"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是：在 <code>@AfterReturning</code>注解 中，属性 <code>returning</code> 的值必须要和参数保持一致，否则会检测不到。该方法中的第二个入参就是被切方法的返回值，在 <code>doAfterReturning</code> 方法中可以对返回值进行增强，可以根据业务需要做相应的封装。我们重启一下服务，再测试一下（多余的 log 我不贴出来了）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">方法testAop执行完毕，返回参数为：Hello CSDN  </span><br><span class="line">对返回参数进行业务上的增强：Hello CSDN增强版</span><br></pre></td></tr></table></figure><h4 id="2-2-5-AfterThrowing-注解">2.2.5 @AfterThrowing 注解</h4><p>顾名思义，<code>@AfterThrowing</code> 注解是当被切方法执行时抛出异常时，会进入 <code>@AfterThrowing</code> 注解的方法中执行，在该方法中可以做一些异常的处理逻辑。要注意的是 <code>throwing</code> 属性的值必须要和参数一致，否则会报错。该方法中的第二个入参即为抛出的异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用AOP处理log</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shengwu ni</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/05/04 20:24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAspectHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在上面定义的切面方法执行抛异常时，执行该方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint jointPoint</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ex ex</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AfterThrowing</span>(pointcut = <span class="string">"pointCut()"</span>, throwing = <span class="string">"ex"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowing</span><span class="params">(JoinPoint joinPoint, Throwable ex)</span> </span>&#123;</span><br><span class="line">        Signature signature = joinPoint.getSignature();</span><br><span class="line">        String method = signature.getName();</span><br><span class="line">        <span class="comment">// 处理异常的逻辑</span></span><br><span class="line">        logger.info(<span class="string">"执行方法&#123;&#125;出错，异常为：&#123;&#125;"</span>, method, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法我就不测试了，大家可以自行测试一下。</p><h2 id="3-总结">3. 总结</h2><p>本节课针对 Spring Boot 中的切面 AOP 做了详细的讲解，主要介绍了 Spring Boot 中 AOP 的引入，常用注解的使用，参数的使用，以及常用 api 的介绍。AOP 在实际项目中很有用，对切面方法执行前后都可以根据具体的业务，做相应的预处理或者增强处理，同时也可以用作异常捕获处理，可以根据具体业务场景，合理去使用 AOP。</p><p>课程源代码下载地址：<a href="https://gitee.com/eson15/springboot_study" target="_blank" rel="noopener">戳我下载</a></p><blockquote><p>欢迎关注我的为微信公众号：武哥聊编程</p></blockquote><h1>第10课：Spring Boot集成MyBatis</h1><h2 id="1-MyBatis-介绍">1. MyBatis 介绍</h2><p>大家都知道，MyBatis 框架是一个持久层框架，是 Apache 下的顶级项目。Mybatis 可以让开发者的主要精力放在 sql 上，通过 Mybatis 提供的映射方式，自由灵活的生成满足需要的 sql 语句。使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs 映射成数据库中的记录，在国内可谓是占据了半壁江山。本节课程主要通过两种方式来对 Spring Boot 集成 MyBatis 做一讲解。重点讲解一下基于注解的方式。因为实际项目中使用注解的方式更多一点，更简洁一点，省去了很多 xml 配置（这不是绝对的，有些项目组中可能也在使用 xml 的方式）。</p><h2 id="2-MyBatis-的配置">2. MyBatis 的配置</h2><h2 id="2-1-依赖导入">2.1 依赖导入</h2><p>Spring Boot 集成 MyBatis，需要导入 <code>mybatis-spring-boot-starter</code> 和 mysql 的依赖，这里我们使用的版本时 1.3.2，如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们点开 <code>mybatis-spring-boot-starter</code> 依赖，可以看到我们之前使用 Spring 时候熟悉的依赖，就像我在课程的一开始介绍的那样，Spring Boot 致力于简化编码，使用 starter 系列将相关依赖集成在一起，开发者不需要关注繁琐的配置，非常方便。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 省去其他 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-2-properties-yml配置">2.2 properties.yml配置</h2><p>我们再来看一下，集成 MyBatis 时需要在 properties.yml 配置文件中做哪些基本配置呢？</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 服务端口号</span><br><span class="line">server:</span><br><span class="line">  port: 8080</span><br><span class="line"></span><br><span class="line"># 数据库地址</span><br><span class="line">datasource:</span><br><span class="line">  url: localhost:3306/blog_test</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  datasource: # 数据库配置</span><br><span class="line">    driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql://$&#123;datasource.url&#125;?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;allowMultiQueries=true&amp;autoReconnect=true&amp;failOverReadOnly=false&amp;maxReconnects=10</span><br><span class="line">    username: root</span><br><span class="line">    password: 123456</span><br><span class="line">    hikari:</span><br><span class="line">      maximum-pool-size: 10 # 最大连接池数</span><br><span class="line">      max-lifetime: 1770000</span><br><span class="line"></span><br><span class="line">mybatis:</span><br><span class="line">  # 指定别名设置的包为所有entity</span><br><span class="line">  type-aliases-package: com.itcodai.course10.entity</span><br><span class="line">  configuration:</span><br><span class="line">    map-underscore-to-camel-case: true # 驼峰命名规范</span><br><span class="line">  mapper-locations: # mapper映射文件位置</span><br><span class="line">    - classpath:mapper/*.xml</span><br></pre></td></tr></table></figure><p>我们来简单介绍一下上面的这些配置：关于数据库的相关配置，我就不详细的解说了，这点相信大家已经非常熟练了，配置一下用户名、密码、数据库连接等等，这里使用的连接池是 Spring Boot 自带的 hikari，感兴趣的朋友可以去百度或者谷歌搜一搜，了解一下。</p><p>这里说明一下 <code>map-underscore-to-camel-case: true</code>， 用来开启驼峰命名规范，这个比较好用，比如数据库中字段名为：<code>user_name</code>， 那么在实体类中可以定义属性为 <code>userName</code> （甚至可以写成 <code>username</code>，也能映射上），会自动匹配到驼峰属性，如果不这样配置的话，针对字段名和属性名不同的情况，会映射不到。</p><h2 id="3-基于-xml-的整合">3. 基于 xml 的整合</h2><p>使用原始的 xml 方式，需要新建 UserMapper.xml 文件，在上面的 application.yml 配置文件中，我们已经定义了 xml 文件的路径：<code>classpath:mapper/*.xml</code>，所以我们在 resources 目录下新建一个 mapper 文件夹，然后创建一个 UserMapper.xml 文件。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span> <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.itcodai.course10.dao.UserMapper"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"BaseResultMap"</span> <span class="attr">type</span>=<span class="string">"com.itcodai.course10.entity.User"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">jdbcType</span>=<span class="string">"BIGINT"</span> <span class="attr">property</span>=<span class="string">"id"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"user_name"</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span> <span class="attr">property</span>=<span class="string">"username"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"password"</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span> <span class="attr">property</span>=<span class="string">"password"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">   <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getUserByName"</span> <span class="attr">resultType</span>=<span class="string">"User"</span> <span class="attr">parameterType</span>=<span class="string">"String"</span>&gt;</span></span><br><span class="line">       select * from user where user_name = #&#123;username&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这和整合 Spring 一样的，namespace 中指定的是对应的 Mapper， <code>&lt;resultMap&gt;</code> 中指定对应的实体类，即 User。然后在内部指定表的字段和实体的属性相对应即可。这里我们写一个根据用户名查询用户的 sql。</p><p>实体类中有 id，username 和 password，我不在这贴代码，大家可以下载源码查看。UserMapper.java 文件中写一个接口即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">User <span class="title">getUserByName</span><span class="params">(String username)</span></span>;</span><br></pre></td></tr></table></figure><p>中间省略 service 的代码，我们写一个 Controller 来测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/getUserByName/&#123;name&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUserByName</span><span class="params">(@PathVariable String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.getUserByName(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动项目，在浏览器中输入：<code>http://localhost:8080/getUserByName/CSDN</code> 即可查询到数据库表中用户名为 CSDN 的用户信息（事先搞两个数据进去即可）：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"id"</span>:<span class="number">2</span>,<span class="attr">"username"</span>:<span class="string">"CSDN"</span>,<span class="attr">"password"</span>:<span class="string">"123456"</span>&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意一下：Spring Boot 如何知道这个 Mapper 呢？一种方法是在上面的 mapper 层对应的类上面添加 <code>@Mapper</code> 注解即可，但是这种方法有个弊端，当我们有很多个 mapper 时，那么每一个类上面都得添加 <code>@Mapper</code> 注解。另一种比较简便的方法是在 Spring Boot 启动类上添加<code>@MaperScan</code> 注解，来扫描一个包下的所有 mapper。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan</span>(<span class="string">"com.itcodai.course10.dao"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Course10Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(Course10Application<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的话，<code>com.itcodai.course10.dao</code> 包下的所有 mapper 都会被扫描到了。</p><h2 id="4-基于注解的整合">4. 基于注解的整合</h2><p>基于注解的整合就不需要 xml 配置文件了，MyBatis 主要提供了 <code>@Select</code>， <code>@Insert</code>， <code>@Update</code>， <code>Delete</code> 四个注解。这四个注解是用的非常多的，也很简单，注解后面跟上对应的 sql 语句即可，我们举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select</span>(<span class="string">"select * from user where id = #&#123;id&#125;"</span>)</span><br><span class="line"><span class="function">User <span class="title">getUser</span><span class="params">(Long id)</span></span>;</span><br></pre></td></tr></table></figure><p>这跟 xml 文件中写 sql 语句是一样的，这样就不需要 xml 文件了，但是有个问题，有人可能会问，如果是两个参数呢？如果是两个参数，我们需要使用 <code>@Param</code> 注解来指定每一个参数的对应关系，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select</span>(<span class="string">"select * from user where id = #&#123;id&#125; and user_name=#&#123;name&#125;"</span>)</span><br><span class="line"><span class="function">User <span class="title">getUserByIdAndName</span><span class="params">(@Param(<span class="string">"id"</span>)</span> Long id, @<span class="title">Param</span><span class="params">(<span class="string">"name"</span>)</span> String username)</span>;</span><br></pre></td></tr></table></figure><p>可以看出，<code>@Param</code> 指定的参数应该要和 sql 中 <code>#{}</code> 取的参数名相同，不同则取不到。可以在 controller 中自行测试一下，接口都在源码中，文章中我就不贴测试代码和结果了。</p><p>有个问题需要注意一下，一般我们在设计表字段后，都会根据自动生成工具生成实体类，这样的话，基本上实体类是能和表字段对应上的，最起码也是驼峰对应的，由于在上面配置文件中开启了驼峰的配置，所以字段都是能对的上的。但是，万一有对不上的呢？我们也有解决办法，使用 <code>@Results</code> 注解来解决。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select</span>(<span class="string">"select * from user where id = #&#123;id&#125;"</span>)</span><br><span class="line"><span class="meta">@Results</span>(&#123;</span><br><span class="line">        <span class="meta">@Result</span>(property = <span class="string">"username"</span>, column = <span class="string">"user_name"</span>),</span><br><span class="line">        <span class="meta">@Result</span>(property = <span class="string">"password"</span>, column = <span class="string">"password"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="function">User <span class="title">getUser</span><span class="params">(Long id)</span></span>;</span><br></pre></td></tr></table></figure><p><code>@Results</code> 中的 <code>@Result</code> 注解是用来指定每一个属性和字段的对应关系，这样的话就可以解决上面说的这个问题了。</p><p>当然了，我们也可以 xml 和注解相结合使用，目前我们实际的项目中也是采用混用的方式，因为有时候 xml 方便，有时候注解方便，比如就上面这个问题来说，如果我们定义了上面的这个 UserMapper.xml，那么我们完全可以使用 <code>@ResultMap</code> 注解来替代 <code>@Results</code> 注解，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select</span>(<span class="string">"select * from user where id = #&#123;id&#125;"</span>)</span><br><span class="line"><span class="meta">@ResultMap</span>(<span class="string">"BaseResultMap"</span>)</span><br><span class="line"><span class="function">User <span class="title">getUser</span><span class="params">(Long id)</span></span>;</span><br></pre></td></tr></table></figure><p><code>@ResultMap</code> 注解中的值从哪来呢？对应的是 UserMapper.xml 文件中定义的 <code>&lt;resultMap&gt;</code> 时对应的 id 值：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"BaseResultMap"</span> <span class="attr">type</span>=<span class="string">"com.itcodai.course10.entity.User"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这种 xml 和注解结合着使用的情况也很常见，而且也减少了大量的代码，因为 xml 文件可以使用自动生成工具去生成，也不需要人为手动敲，所以这种使用方式也很常见。</p><h2 id="5-总结-v3">5. 总结</h2><p>本节课主要系统的讲解了 Spring Boot 集成 MyBatis 的过程，分为基于 xml 形式和基于注解的形式来讲解，通过实际配置手把手讲解了 Spring Boot 中 MyBatis 的使用方式，并针对注解方式，讲解了常见的问题已经解决方式，有很强的实战意义。在实际项目中，建议根据实际情况来确定使用哪种方式，一般 xml 和注解都在用。</p><p>课程源代码下载地址：<a href="https://gitee.com/eson15/springboot_study" target="_blank" rel="noopener">戳我下载</a></p><blockquote><p>欢迎关注我的为微信公众号：武哥聊编程</p></blockquote><h1>第11课：Spring Boot事务配置管理</h1><h2 id="1-事务相关">1. 事务相关</h2><p>场景：我们在开发企业应用时，由于数据操作在顺序执行的过程中，线上可能有各种无法预知的问题，任何一步操作都有可能发生异常，异常则会导致后续的操作无法完成。此时由于业务逻辑并未正确的完成，所以在之前操作过数据库的动作并不可靠，需要在这种情况下进行数据的回滚。</p><p>事务的作用就是为了保证用户的每一个操作都是可靠的，事务中的每一步操作都必须成功执行，只要有发生异常就回退到事务开始未进行操作的状态。这很好理解，转账、购票等等，必须整个事件流程全部执行完才能人为该事件执行成功，不能转钱转到一半，系统死了，转账人钱没了，收款人钱还没到。</p><p>事务管理是 Spring Boot 框架中最为常用的功能之一，我们在实际应用开发时，基本上在 service 层处理业务逻辑的时候都要加上事务，当然了，有时候可能由于场景需要，也不用加事务（比如我们就要往一个表里插数据，相互没有影响，插多少是多少，不能因为某个数据挂了，把之前插的全部回滚）。</p><h2 id="2-Spring-Boot-事务配置">2. Spring Boot 事务配置</h2><h3 id="2-1-依赖导入-v2">2.1 依赖导入</h3><p>在 Spring Boot 中使用事务，需要导入 mysql 依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>导入了 mysql 依赖后，Spring Boot 会自动注入 DataSourceTransactionManager，我们不需要任何其他的配置就可以用 <code>@Transactional</code> 注解进行事务的使用。关于 mybatis 的配置，在上一节课中已经说明了，这里还是使用上一节课中的 mybatis 配置即可。</p><h3 id="2-2-事务的测试">2.2 事务的测试</h3><p>我们首先在数据库表中插入一条数据：</p><table><thead><tr><th style="text-align:center">id</th><th style="text-align:center">user_name</th><th style="text-align:center">password</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">倪升武</td><td style="text-align:center">123456</td></tr></tbody></table><p>然后我们写一个插入的 mapper：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Insert</span>(<span class="string">"insert into user (user_name, password) values (#&#123;username&#125;, #&#123;password&#125;)"</span>)</span><br><span class="line">    <span class="function">Integer <span class="title">insertUser</span><span class="params">(User user)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK，接下来我们来测试一下 Spring Boot 中的事务处理，在 service 层，我们手动抛出个异常来模拟实际中出现的异常，然后观察一下事务有没有回滚，如果数据库中没有新的记录，则说明事务回滚成功。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isertUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 插入用户信息</span></span><br><span class="line">        userMapper.insertUser(user);</span><br><span class="line">        <span class="comment">// 手动抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/adduser"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addUser</span><span class="params">(@RequestBody User user)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != user) &#123;</span><br><span class="line">            userService.isertUser(user);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"false"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用 postman 调用一下该接口，因为在程序中抛出了个异常，会造成事务回滚，我们刷新一下数据库，并没有增加一条记录，说明事务生效了。事务很简单，我们平时在使用的时候，一般不会有多少问题，但是并不仅仅如此……</p><h2 id="3-常见问题总结">3. 常见问题总结</h2><p>从上面的内容中可以看出，Spring Boot 中使用事务非常简单，<code>@Transactional</code> 注解即可解决问题，说是这么说，但是在实际项目中，是有很多小坑在等着我们，这些小坑是我们在写代码的时候没有注意到，而且正常情况下不容易发现这些小坑，等项目写大了，某一天突然出问题了，排查问题非常困难，到时候肯定是抓瞎，需要费很大的精力去排查问题。</p><p>这一小节，我专门针对实际项目中经常出现的，和事务相关的细节做一下总结，希望读者在读完之后，能够落实到自己的项目中，能有所受益。</p><h3 id="3-1-异常并没有被-”捕获“-到">3.1 异常并没有被 ”捕获“ 到</h3><p>首先要说的，就是异常并没有被 ”捕获“ 到，导致事务并没有回滚。我们在业务层代码中，也许已经考虑到了异常的存在，或者编辑器已经提示我们需要抛出异常，但是这里面有个需要注意的地方：并不是说我们把异常抛出来了，有异常了事务就会回滚，我们来看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isertUser2</span><span class="params">(User user)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 插入用户信息</span></span><br><span class="line">        userMapper.insertUser(user);</span><br><span class="line">        <span class="comment">// 手动抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(<span class="string">"数据库异常"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看上面这个代码，其实并没有什么问题，手动抛出一个 <code>SQLException</code> 来模拟实际中操作数据库发生的异常，在这个方法中，既然抛出了异常，那么事务应该回滚，实际却不如此，读者可以使用我源码中 controller 的接口，通过 postman 测试一下，就会发现，仍然是可以插入一条用户数据的。</p><p>那么问题出在哪呢？因为 Spring Boot 默认的事务规则是遇到运行异常（RuntimeException）和程序错误（Error）才会回滚。比如上面我们的例子中抛出的 RuntimeException 就没有问题，但是抛出 SQLException 就无法回滚了。针对非运行时异常，如果要进行事务回滚的话，可以在 <code>@Transactional</code> 注解中使用 <code>rollbackFor</code> 属性来指定异常，比如 <code>@Transactional(rollbackFor = Exception.class)</code>，这样就没有问题了，所以在实际项目中，一定要指定异常。</p><h3 id="3-2-异常被-”吃“-掉">3.2 异常被 ”吃“ 掉</h3><p>这个标题很搞笑，异常怎么会被吃掉呢？还是回归到现实项目中去，我们在处理异常时，有两种方式，要么抛出去，让上一层来捕获处理；要么把异常 try catch 掉，在异常出现的地方给处理掉。就因为有这中 try…catch，所以导致异常被 ”吃“ 掉，事务无法回滚。我们还是看上面那个例子，只不过简单修改一下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span>(rollbackFor = Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">void</span> <span class="title">isertUser3</span>(<span class="title">User</span> <span class="title">user</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 插入用户信息</span></span><br><span class="line">            userMapper.insertUser(user);</span><br><span class="line">            <span class="comment">// 手动抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(<span class="string">"数据库异常"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// 异常处理逻辑</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读者可以使用我源码中 controller 的接口，通过 postman 测试一下，就会发现，仍然是可以插入一条用户数据，说明事务并没有因为抛出异常而回滚。这个细节往往比上面那个坑更难以发现，因为我们的思维很容易导致 try…catch 代码的产生，一旦出现这种问题，往往排查起来比较费劲，所以我们平时在写代码时，一定要多思考，多注意这种细节，尽量避免给自己埋坑。</p><p>那这种怎么解决呢？直接往上抛，给上一层来处理即可，千万不要在事务中把异常自己 ”吃“ 掉。</p><h3 id="3-3-事务的范围">3.3 事务的范围</h3><p>事务范围这个东西比上面两个坑埋的更深！我之所以把这个也写上，是因为这是我之前在实际项目中遇到的，该场景在这个课程中我就不模拟了，我写一个 demo 让大家看一下，把这个坑记住即可，以后在写代码时，遇到并发问题，就会注意这个坑了，那么这节课也就有价值了。</p><p>我来写个 demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span>(rollbackFor = Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">synchronized</span> <span class="title">void</span> <span class="title">isertUser4</span>(<span class="title">User</span> <span class="title">user</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 实际中的具体业务……</span></span><br><span class="line">        userMapper.insertUser(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，因为要考虑并发问题，我在业务层代码的方法上加了个 synchronized 关键字。我举个实际的场景，比如一个数据库中，针对某个用户，只有一条记录，下一个插入动作过来，会先判断该数据库中有没有相同的用户，如果有就不插入，就更新，没有才插入，所以理论上，数据库中永远就一条同一用户信息，不会出现同一数据库中插入了两条相同用户的信息。</p><p>但是在压测时，就会出现上面的问题，数据库中确实有两条同一用户的信息，分析其原因，在于事务的范围和锁的范围问题。</p><p>从上面方法中可以看到，方法上是加了事务的，那么也就是说，在执行该方法开始时，事务启动，执行完了后，事务关闭。但是 synchronized 没有起作用，其实根本原因是因为事务的范围比锁的范围大。也就是说，在加锁的那部分代码执行完之后，锁释放掉了，但是事务还没结束，此时另一个线程进来了，事务没结束的话，第二个线程进来时，数据库的状态和第一个线程刚进来是一样的。即由于mysql Innodb引擎的默认隔离级别是可重复读（在同一个事务里，SELECT的结果是事务开始时时间点的状态），线程二事务开始的时候，线程一还没提交完成，导致读取的数据还没更新。第二个线程也做了插入动作，导致了脏数据。</p><p>这个问题可以避免，第一，把事务去掉即可（不推荐）；第二，在调用该 service 的地方加锁，保证锁的范围比事务的范围大即可。</p><h2 id="4-总结-v5">4. 总结</h2><p>本章主要总结了 Spring Boot 中如何使用事务，只要使用 <code>@Transactional</code> 注解即可使用，非常简单方便。除此之外，重点总结了三个在实际项目中可能遇到的坑点，这非常有意义，因为事务这东西不出问题还好，出了问题比较难以排查，所以总结的这三点注意事项，希望能帮助到开发中的朋友。</p><p>课程源代码下载地址：<a href="https://gitee.com/eson15/springboot_study" target="_blank" rel="noopener">戳我下载</a></p><blockquote><p>欢迎关注我的为微信公众号：武哥聊编程</p></blockquote><h1>第12课：Spring Boot中使用监听器</h1><h2 id="1-监听器介绍">1. 监听器介绍</h2><p>什么是 web 监听器？web 监听器是一种 Servlet 中特殊的类，它们能帮助开发者监听 web 中特定的事件，比如 ServletContext, HttpSession, ServletRequest 的创建和销毁；变量的创建、销毁和修改等。可以在某些动作前后增加处理，实现监控。</p><h2 id="2-Spring-Boot中监听器的使用">2. Spring Boot中监听器的使用</h2><p>web 监听器的使用场景很多，比如监听 servlet 上下文用来初始化一些数据、监听 http session 用来获取当前在线的人数、监听客户端请求的 servlet request 对象来获取用户的访问信息等等。这一节中，我们主要通过这三个实际的使用场景来学习一下 Spring Boot 中监听器的使用。</p><h3 id="2-1-监听Servlet上下文对象">2.1 监听Servlet上下文对象</h3><p>监听 servlet 上下文对象可以用来初始化数据，用于缓存。什么意思呢？我举一个很常见的场景，比如用户在点击某个站点的首页时，一般都会展现出首页的一些信息，而这些信息基本上或者大部分时间都保持不变的，但是这些信息都是来自数据库。如果用户的每次点击，都要从数据库中去获取数据的话，用户量少还可以接受，如果用户量非常大的话，这对数据库也是一笔很大的开销。</p><p>针对这种首页数据，大部分都不常更新的话，我们完全可以把它们缓存起来，每次用户点击的时候，我们都直接从缓存中拿，这样既可以提高首页的访问速度，又可以降低服务器的压力。如果做的更加灵活一点，可以再加个定时器，定期的来更新这个首页缓存。就类似与 CSDN 个人博客首页中排名的变化一样。</p><p>下面我们针对这个功能，来写一个 demo，在实际中，读者可以完全套用该代码，来实现自己项目中的相关逻辑。首先写一个 Service，模拟一下从数据库查询数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取用户信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实际中会根据具体的业务场景，从数据库中查询对应的信息</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="number">1L</span>, <span class="string">"倪升武"</span>, <span class="string">"123456"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后写一个监听器，实现 <code>ApplicationListener&lt;ContextRefreshedEvent&gt;</code> 接口，重写 <code>onApplicationEvent</code> 方法，将 ContextRefreshedEvent 对象传进去。如果我们想在加载或刷新应用上下文时，也重新刷新下我们预加载的资源，就可以通过监听 ContextRefreshedEvent 来做这样的事情。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用ApplicationListener来初始化一些数据到application域中的监听器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shengni ni</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/07/05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServletContextListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ContextRefreshedEvent</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextRefreshedEvent contextRefreshedEvent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先获取到application上下文</span></span><br><span class="line">        ApplicationContext applicationContext = contextRefreshedEvent.getApplicationContext();</span><br><span class="line">        <span class="comment">// 获取对应的service</span></span><br><span class="line">        UserService userService = applicationContext.getBean(UserService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        User user = userService.getUser();</span><br><span class="line">        <span class="comment">// 获取application域对象，将查到的信息放到application域中</span></span><br><span class="line">        ServletContext application = applicationContext.getBean(ServletContext<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        application.setAttribute(<span class="string">"user"</span>, user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如注释中描述的一样，首先通过 contextRefreshedEvent 来获取 application 上下文，再通过 application 上下文来获取 UserService 这个 bean，项目中可以根据实际业务场景，也可以获取其他的 bean，然后再调用自己的业务代码获取相应的数据，最后存储到 application 域中，这样前端在请求相应数据的时候，我们就可以直接从 application 域中获取信息，减少数据库的压力。下面写一个 Controller 直接从 application 域中获取 user 信息来测试一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/listener"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        ServletContext application = request.getServletContext();</span><br><span class="line">        <span class="keyword">return</span> (User) application.getAttribute(<span class="string">"user"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动项目，在浏览器中输入 <code>http://localhost:8080/listener/user</code> 测试一下即可，如果正常返回 user 信息，那么说明数据已经缓存成功。不过 application 这种是缓存在内存中，对内存会有消耗，后面的课程中我会讲到 redis，到时候再给大家介绍一下 redis 的缓存。</p><h3 id="2-2-监听HTTP会话-Session对象">2.2 监听HTTP会话 Session对象</h3><p>监听器还有一个比较常用的地方就是用来监听 session 对象，来获取在线用户数量，现在有很多开发者都有自己的网站，监听 session 来获取当前在下用户数量是个很常见的使用场景，下面来介绍一下如何来使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用HttpSessionListener统计在线用户数的监听器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shengwu ni</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/07/05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHttpSessionListener</span> <span class="keyword">implements</span> <span class="title">HttpSessionListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(MyHttpSessionListener<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录在线的用户数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Integer count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sessionCreated</span><span class="params">(HttpSessionEvent httpSessionEvent)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"新用户上线了"</span>);</span><br><span class="line">        count++;</span><br><span class="line">        httpSessionEvent.getSession().getServletContext().setAttribute(<span class="string">"count"</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sessionDestroyed</span><span class="params">(HttpSessionEvent httpSessionEvent)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"用户下线了"</span>);</span><br><span class="line">        count--;</span><br><span class="line">        httpSessionEvent.getSession().getServletContext().setAttribute(<span class="string">"count"</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，首先该监听器需要实现 HttpSessionListener 接口，然后重写 <code>sessionCreated</code> 和 <code>sessionDestroyed</code> 方法，在 <code>sessionCreated</code> 方法中传递一个 HttpSessionEvent 对象，然后将当前 session 中的用户数量加1，<code>sessionDestroyed</code> 方法刚好相反，不再赘述。然后我们写一个 Controller 来测试一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/listener"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前在线人数，该方法有bug</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/total"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTotalUser</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        Integer count = (Integer) request.getSession().getServletContext().getAttribute(<span class="string">"count"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"当前在线人数："</span> + count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该 Controller 中是直接获取当前 session 中的用户数量，启动服务器，在浏览器中输入 <code>localhost:8080/listener/total</code> 可以看到返回的结果是1，再打开一个浏览器，请求相同的地址可以看到 count 是 2 ，这没有问题。但是如果关闭一个浏览器再打开，理论上应该还是2，但是实际测试却是 3。原因是 session 销毁的方法没有执行（可以在后台控制台观察日志打印情况），当重新打开时，服务器找不到用户原来的 session，于是又重新创建了一个 session，那怎么解决该问题呢？我们可以将上面的 Controller 方法改造一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/total2"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getTotalUser</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">    Cookie cookie;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 把sessionId记录在浏览器中</span></span><br><span class="line">        cookie = <span class="keyword">new</span> Cookie(<span class="string">"JSESSIONID"</span>, URLEncoder.encode(request.getSession().getId(), <span class="string">"utf-8"</span>));</span><br><span class="line">        cookie.setPath(<span class="string">"/"</span>);</span><br><span class="line">        <span class="comment">//设置cookie有效期为2天，设置长一点</span></span><br><span class="line">        cookie.setMaxAge( <span class="number">48</span>*<span class="number">60</span> * <span class="number">60</span>);</span><br><span class="line">        response.addCookie(cookie);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    Integer count = (Integer) request.getSession().getServletContext().getAttribute(<span class="string">"count"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"当前在线人数："</span> + count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，该处理逻辑是让服务器记得原来那个 session，即把原来的 sessionId 记录在浏览器中，下次再打开时，把这个 sessionId 传过去，这样服务器就不会重新再创建了。重启一下服务器，在浏览器中再次测试一下，即可避免上面的问题。</p><h3 id="2-3-监听客户端请求Servlet-Request对象">2.3 监听客户端请求Servlet Request对象</h3><p>使用监听器获取用户的访问信息比较简单，实现 ServletRequestListener 接口即可，然后通过 request 对象获取一些信息。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用ServletRequestListener获取访问信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shengwu ni</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/07/05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServletRequestListener</span> <span class="keyword">implements</span> <span class="title">ServletRequestListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(MyServletRequestListener<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestInitialized</span><span class="params">(ServletRequestEvent servletRequestEvent)</span> </span>&#123;</span><br><span class="line">        HttpServletRequest request = (HttpServletRequest) servletRequestEvent.getServletRequest();</span><br><span class="line">        logger.info(<span class="string">"session id为：&#123;&#125;"</span>, request.getRequestedSessionId());</span><br><span class="line">        logger.info(<span class="string">"request url为：&#123;&#125;"</span>, request.getRequestURL());</span><br><span class="line"></span><br><span class="line">        request.setAttribute(<span class="string">"name"</span>, <span class="string">"倪升武"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestDestroyed</span><span class="params">(ServletRequestEvent servletRequestEvent)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">"request end"</span>);</span><br><span class="line">        HttpServletRequest request = (HttpServletRequest) servletRequestEvent.getServletRequest();</span><br><span class="line">        logger.info(<span class="string">"request域中保存的name值为：&#123;&#125;"</span>, request.getAttribute(<span class="string">"name"</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个比较简单，不再赘述，接下来写一个 Controller 测试一下即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/request"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getRequestInfo</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"requestListener中的初始化的name数据："</span> + request.getAttribute(<span class="string">"name"</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-Spring-Boot中自定义事件监听">3. Spring Boot中自定义事件监听</h2><p>在实际项目中，我们往往需要自定义一些事件和监听器来满足业务场景，比如在微服务中会有这样的场景：微服务 A 在处理完某个逻辑之后，需要通知微服务 B 去处理另一个逻辑，或者微服务 A 处理完某个逻辑之后，需要将数据同步到微服务 B，这种场景非常普遍，这个时候，我们可以自定义事件以及监听器来监听，一旦监听到微服务 A 中的某事件发生，就去通知微服务 B 处理对应的逻辑。</p><h3 id="3-1-自定义事件">3.1 自定义事件</h3><p>自定义事件需要继承 ApplicationEvent 对象，在事件中定义一个 User 对象来模拟数据，构造方法中将 User 对象传进来初始化。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义事件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shengwu ni</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/07/05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyEvent</span><span class="params">(Object source, User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">        <span class="keyword">this</span>.user = user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省去get、set方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-自定义监听器">3.2 自定义监听器</h3><p>接下来，自定义一个监听器来监听上面定义的 MyEvent 事件，自定义监听器需要实现 <code>ApplicationListener</code> 接口即可。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义监听器，监听MyEvent事件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shengwu ni</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/07/05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEventListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">MyEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(MyEvent myEvent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 把事件中的信息获取到</span></span><br><span class="line">        User user = myEvent.getUser();</span><br><span class="line">        <span class="comment">// 处理事件，实际项目中可以通知别的微服务或者处理其他逻辑等等</span></span><br><span class="line">        System.out.println(<span class="string">"用户名："</span> + user.getUsername());</span><br><span class="line">        System.out.println(<span class="string">"密码："</span> + user.getPassword());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后重写 <code>onApplicationEvent</code> 方法，将自定义的 MyEvent 事件传进来，因为该事件中，我们定义了 User 对象（该对象在实际中就是需要处理的数据，在下文来模拟），然后就可以使用该对象的信息了。</p><p>OK，定义好了事件和监听器之后，需要手动发布事件，这样监听器才能监听到，这需要根据实际业务场景来触发，针对本文的例子，我写个触发逻辑，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * UserService</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shengwu ni</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发布事件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="number">1L</span>, <span class="string">"倪升武"</span>, <span class="string">"123456"</span>);</span><br><span class="line">        <span class="comment">// 发布事件</span></span><br><span class="line">        MyEvent event = <span class="keyword">new</span> MyEvent(<span class="keyword">this</span>, user);</span><br><span class="line">        applicationContext.publishEvent(event);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 service 中注入 ApplicationContext，在业务代码处理完之后，通过 ApplicationContext 对象手动发布 MyEvent 事件，这样我们自定义的监听器就能监听到，然后处理监听器中写好的业务逻辑。</p><p>最后，在 Controller 中写一个接口来测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/request"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getRequestInfo</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"requestListener中的初始化的name数据："</span> + request.getAttribute(<span class="string">"name"</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在浏览器中输入 <code>http://localhost:8080/listener/publish</code>，然后观察一下控制台打印的用户名和密码，即可说明自定义监听器已经生效。</p><h2 id="4-总结-v6">4. 总结</h2><p>本课系统的介绍了监听器原理，以及在 Spring Boot 中如何使用监听器，列举了监听器的三个常用的案例，有很好的实战意义。最后讲解了项目中如何自定义事件和监听器，并结合微服务中常见的场景，给出具体的代码模型，均能运用到实际项目中去，希望读者认真消化。</p><p>课程源代码下载地址：<a href="https://gitee.com/eson15/springboot_study" target="_blank" rel="noopener">戳我下载</a></p><blockquote><p>欢迎关注我的为微信公众号：武哥聊编程</p></blockquote><h1>第13课：Spring Boot中使用拦截器</h1><p>拦截器的原理很简单，是 AOP 的一种实现，专门拦截对动态资源的后台请求，即拦截对控制层的请求。使用场景比较多的是判断用户是否有权限请求后台，更拔高一层的使用场景也有，比如拦截器可以结合 websocket 一起使用，用来拦截 websocket 请求，然后做相应的处理等等。拦截器不会拦截静态资源，Spring Boot 的默认静态目录为 resources/static，该目录下的静态页面、js、css、图片等等，不会被拦截（也要看如何实现，有些情况也会拦截，我在下文会指出）。</p><h2 id="1-拦截器的快速使用">1. 拦截器的快速使用</h2><p>使用拦截器很简单，只需要两步即可：定义拦截器和配置拦截器。在配置拦截器中，Spring Boot 2.0 以后的版本和之前的版本有所不同，我会重点讲解一下这里可能出现的坑。</p><h3 id="1-1-定义拦截器">1.1 定义拦截器</h3><p>定义拦截器，只需要实现 <code>HandlerInterceptor</code> 接口，<code>HandlerInterceptor</code> 接口是所有自定义拦截器或者 Spring Boot 提供的拦截器的鼻祖，所以，首先来了解下该接口。该接口中有三个方法： <code>preHandle(……)</code>、<code>postHandle(……)</code> 和 <code>afterCompletion(……)</code> 。</p><blockquote><p><code>preHandle(……)</code> 方法：该方法的执行时机是，当某个 url 已经匹配到对应的 Controller 中的某个方法，且在这个方法执行之前。所以 <code>preHandle(……)</code> 方法可以决定是否将请求放行，这是通过返回值来决定的，返回 true 则放行，返回 false 则不会向后执行。<br><code>postHandle(……)</code> 方法：该方法的执行时机是，当某个 url 已经匹配到对应的 Controller 中的某个方法，且在执行完了该方法，但是在 DispatcherServlet 视图渲染之前。所以在这个方法中有个 ModelAndView 参数，可以在此做一些修改动作。<br><code>afterCompletion(……)</code> 方法：顾名思义，该方法是在整个请求处理完成后（包括视图渲染）执行，这时做一些资源的清理工作，这个方法只有在 <code>preHandle(……)</code> 被成功执行后并且返回 true 才会被执行。</p></blockquote><p>了解了该接口，接下来自定义一个拦截器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义拦截器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shengwu ni</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/08/03</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(MyInterceptor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        HandlerMethod handlerMethod = (HandlerMethod) handler;</span><br><span class="line">        Method method = handlerMethod.getMethod();</span><br><span class="line">        String methodName = method.getName();</span><br><span class="line">        logger.info(<span class="string">"====拦截到了方法：&#123;&#125;，在该方法执行之前执行===="</span>, methodName);</span><br><span class="line">        <span class="comment">// 返回true才会继续执行，返回false则取消当前请求</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"执行完方法之后进执行(Controller方法调用之后)，但是此时还没进行视图渲染"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"整个请求都处理完咯，DispatcherServlet也渲染了对应的视图咯，此时我可以做一些清理的工作了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK，到此为止，拦截器已经定义完成，接下来就是对该拦截器进行拦截配置。</p><h3 id="1-2-配置拦截器">1.2 配置拦截器</h3><p>在 Spring Boot 2.0 之前，我们都是直接继承 WebMvcConfigurerAdapter 类，然后重写 <code>addInterceptors</code> 方法来实现拦截器的配置。但是在 Spring Boot 2.0 之后，该方法已经被废弃了（当然，也可以继续用），取而代之的是 WebMvcConfigurationSupport 方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptorConfig</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurationSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> MyInterceptor()).addPathPatterns(<span class="string">"/**"</span>);</span><br><span class="line">        <span class="keyword">super</span>.addInterceptors(registry);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该配置中重写 <code>addInterceptors</code> 方法，将我们上面自定义的拦截器添加进去，<code>addPathPatterns</code> 方法是添加要拦截的请求，这里我们拦截所有的请求。这样就配置好拦截器了，接下来写一个 Controller 测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/interceptor"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让其跳转到 hello.html 页面，直接在 hello.html 中输出 <code>hello interceptor</code> 即可。启动项目，在浏览器中输入 <code>localhost:8080/interceptor/test</code> 看一下控制台的日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;拦截到了方法：test，在该方法执行之前执行&#x3D;&#x3D;&#x3D;&#x3D;  </span><br><span class="line">执行完方法之后进执行(Controller方法调用之后)，但是此时还没进行视图渲染  </span><br><span class="line">整个请求都处理完咯，DispatcherServlet也渲染了对应的视图咯，此时我可以做一些清理的工作了</span><br></pre></td></tr></table></figure><p>可以看出拦截器已经生效，并能看出其执行顺序。</p><h3 id="1-3-解决静态资源被拦截问题">1.3 解决静态资源被拦截问题</h3><p>上文中已经介绍了拦截器的定义和配置，但是这样是否就没问题了呢？其实不然，如果使用上面这种配置的话，我们会发现一个缺陷，那就是静态资源被拦截了。可以在 resources/static/ 目录下放置一个图片资源或者 html 文件，然后启动项目直接访问，即可看到无法访问的现象。</p><p>也就是说，虽然 Spring Boot 2.0 废弃了WebMvcConfigurerAdapter，但是 WebMvcConfigurationSupport 又会导致默认的静态资源被拦截，这就需要我们手动将静态资源放开。</p><p>如何放开呢？除了在 MyInterceptorConfig 配置类中重写 <code>addInterceptors</code> 方法外，还需要再重写一个方法：<code>addResourceHandlers</code>，将静态资源放开：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用来指定静态资源不被拦截，否则继承WebMvcConfigurationSupport这种方式会导致静态资源无法直接访问</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> registry</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">    registry.addResourceHandler(<span class="string">"/**"</span>).addResourceLocations(<span class="string">"classpath:/static/"</span>);</span><br><span class="line">    <span class="keyword">super</span>.addResourceHandlers(registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样配置好之后，重启项目，静态资源也可以正常访问了。如果你是个善于学习或者研究的人，那肯定不会止步于此，没错，上面这种方式的确能解决静态资源无法访问的问题，但是，还有更方便的方式来配置。</p><p>我们不继承 WebMvcConfigurationSupport 类，直接实现 WebMvcConfigurer 接口，然后重写 <code>addInterceptors</code> 方法，将自定义的拦截器添加进去即可，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptorConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实现WebMvcConfigurer不会导致静态资源被拦截</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> MyInterceptor()).addPathPatterns(<span class="string">"/**"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就非常方便了，实现 WebMvcConfigure 接口的话，不会拦截 Spring Boot 默认的静态资源。</p><p>这两种方式都可以，具体他们之间的细节，感兴趣的读者可以做进一步的研究，由于这两种方式的不同，继承 WebMvcConfigurationSupport 类的方式可以用在前后端分离的项目中，后台不需要访问静态资源（就不需要放开静态资源了）；实现 WebMvcConfigure 接口的方式可以用在非前后端分离的项目中，因为需要读取一些图片、css、js文件等等。</p><h2 id="2-拦截器使用实例">2. 拦截器使用实例</h2><h3 id="2-1-判断用户有没有登录">2.1 判断用户有没有登录</h3><p>一般用户登录功能我们可以这么做，要么往 session 中写一个 user，要么针对每个 user 生成一个 token，第二种要更好一点，那么针对第二种方式，如果用户登录成功了，每次请求的时候都会带上该用户的 token，如果未登录，则没有该 token，服务端可以检测这个 token 参数的有无来判断用户有没有登录，从而实现拦截功能。我们改造一下 <code>preHandle</code> 方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    HandlerMethod handlerMethod = (HandlerMethod) handler;</span><br><span class="line">    Method method = handlerMethod.getMethod();</span><br><span class="line">    String methodName = method.getName();</span><br><span class="line">    logger.info(<span class="string">"====拦截到了方法：&#123;&#125;，在该方法执行之前执行===="</span>, methodName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断用户有没有登陆，一般登陆之后的用户都有一个对应的token</span></span><br><span class="line">    String token = request.getParameter(<span class="string">"token"</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == token || <span class="string">""</span>.equals(token)) &#123;</span><br><span class="line">        logger.info(<span class="string">"用户未登录，没有权限执行……请登录"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回true才会继续执行，返回false则取消当前请求</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启项目，在浏览器中输入 <code>localhost:8080/interceptor/test</code> 后查看控制台日志，发现被拦截，如果在浏览器中输入 <code>localhost:8080/interceptor/test?token=123</code> 即可正常往下走。</p><h3 id="2-2-取消拦截操作">2.2 取消拦截操作</h3><p>根据上文，如果我要拦截所有 <code>/admin</code> 开头的 url 请求的话，需要在拦截器配置中添加这个前缀，但是在实际项目中，可能会有这种场景出现：某个请求也是 <code>/admin</code> 开头的，但是不能拦截，比如 <code>/admin/login</code> 等等，这样的话又需要去配置。那么，可不可以做成一个类似于开关的东西，哪里不需要拦截，我就在哪里弄个开关上去，做成这种灵活的可插拔的效果呢？</p><p>是可以的，我们可以定义一个注解，该注解专门用来取消拦截操作，如果某个 Controller 中的方法我们不需要拦截掉，即可在该方法上加上我们自定义的注解即可，下面先定义一个注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该注解用来指定某个方法不用拦截</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> UnInterception &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 Controller 中的某个方法上添加该注解，在拦截器处理方法中添加该注解取消拦截的逻辑，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    HandlerMethod handlerMethod = (HandlerMethod) handler;</span><br><span class="line">    Method method = handlerMethod.getMethod();</span><br><span class="line">    String methodName = method.getName();</span><br><span class="line">    logger.info(<span class="string">"====拦截到了方法：&#123;&#125;，在该方法执行之前执行===="</span>, methodName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过方法，可以获取该方法上的自定义注解，然后通过注解来判断该方法是否要被拦截</span></span><br><span class="line">    <span class="comment">// @UnInterception 是我们自定义的注解</span></span><br><span class="line">    UnInterception unInterception = method.getAnnotation(UnInterception<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != unInterception) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回true才会继续执行，返回false则取消当前请求</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Controller 中的方法代码可以参见源码，重启项目在浏览器中输入 <code>http://localhost:8080/interceptor/test2?token=123</code> 测试一下，可以看出，加了该注解的方法不会被拦截。</p><h2 id="3-总结-v2">3. 总结</h2><p>本节主要介绍了 Spring Boot 中拦截器的使用，从拦截器的创建、配置，到拦截器对静态资源的影响，都做了详细的分析。Spring Boot 2.0 之后拦截器的配置支持两种方式，可以根据实际情况选择不同的配置方式。最后结合实际中的使用，举了两个常用的场景，希望读者能够认真消化，掌握拦截器的使用。</p><p>课程源代码下载地址：<a href="https://gitee.com/eson15/springboot_study" target="_blank" rel="noopener">戳我下载</a></p><blockquote><p>欢迎关注我的为微信公众号：武哥聊编程</p></blockquote><h1>第14课：Spring Boot 中集成Redis</h1><h2 id="1-Redis-介绍">1. Redis 介绍</h2><p>Redis 是一种非关系型数据库（NoSQL），NoSQL 是以 key-value 的形式存储的，和传统的关系型数据库不一样，不一定遵循传统数据库的一些基本要求，比如说 SQL 标准，ACID 属性，表结构等等，这类数据库主要有以下特点：非关系型的、分布式的、开源的、水平可扩展的。<br>NoSQL 使用场景有：对数据高并发读写、对海量数据的高效率存储和访问、对数据的高可扩展性和高可用性等等。<br>Redis 的 key 可以是字符串、哈希、链表、集合和有序集合。value 类型很多，包括 String、list、set、zset。这些数据类型都支持 push/pop、add/remove、取交集和并集以及更多更丰富的操作，Redis 也支持各种不同方式的排序。为了保证效率，数据都是在缓存在内存中，它也可以周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件中。 有了 redis 有哪些好处呢？举个比较简单的例子，看下图：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/645eb739c12750e716bbb2284e5c06a0.jpeg" alt="Redis使用场景"></p><p>Redis 集群和 Mysql 是同步的，首先会从 redis 中获取数据，如果 redis 挂了，再从 mysql 中获取数据，这样网站就不会挂掉。更多关于 redis 的介绍以及使用场景，可以谷歌和百度，在这就不赘述了。</p><h2 id="2-Redis-安装">2. Redis 安装</h2><p>本课程是在 vmvare 虚拟机中来安装的 redis （centos 7），学习的时候如果有自己的阿里云服务器，也可以在阿里云中来安装 redis，都可以。只要能 ping 的通云主机或者虚拟机的 ip，然后在虚拟机或者云主机中放行对应的端口（或者关掉防火墙）即可访问 redis。下面来介绍一下 redis 的安装过程：</p><ul><li>安装 gcc 编译</li></ul><p>因为后面安装redis的时候需要编译，所以事先得先安装gcc编译。阿里云主机已经默认安装了 gcc，如果是自己安装的虚拟机，那么需要先安装一下 gcc：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install gcc-c++</span><br></pre></td></tr></table></figure><ul><li>下载 redis</li></ul><p>有两种方式下载安装包，一种是去官网上下载（<a href="https://redis.io" target="_blank" rel="noopener">https://redis.io</a>），然后将安装包考到 centos 中，另种方法是直接使用 wget 来下载：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-3.2.8.tar.gz</span><br></pre></td></tr></table></figure><p>如果没有安装过 wget，可以通过如下命令安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install wget</span><br></pre></td></tr></table></figure><ul><li>解压安装</li></ul><p>解压安装包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar –vzxf redis-3.2.8.tar.gz</span><br></pre></td></tr></table></figure><p>然后将解压的文件夹 redis-3.2.8 放到 <code>/usr/local/</code> 下，一般安装软件都放在 <code>/usr/local</code> 下。然后进入 <code>/usr/local/redis-3.2.8/</code> 文件夹下，执行 <code>make</code> 命令即可完成安装。<br>【注】如果 make 失败，可以尝试如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make MALLOC&#x3D;libc</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><ul><li>修改配置文件</li></ul><p>安装成功之后，需要修改一下配置文件，包括允许接入的 ip，允许后台执行，设置密码等等。<br>打开 redis 配置文件：<code>vi redis.conf</code><br>在命令模式下输入 <code>/bind</code> 来查找 bind 配置，按 n 来查找下一个，找到配置后，将 bind 配置成 0.0.0.0，允许任意服务器来访问 redis，即：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bind 0.0.0.0</span><br></pre></td></tr></table></figure><p>使用同样的方法，将 daemonize 改成 yes （默认为 no），允许 redis 在后台执行。<br>将 requirepass 注释打开，并设置密码为 123456（密码自己设置）。</p><ul><li>启动 redis</li></ul><p>在 redis-3.2.8 目录下，指定刚刚修改好的配置文件 redis.conf 来启动 redis：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server .&#x2F;redis.conf</span><br></pre></td></tr></table></figure><p>再启动 redis 客户端：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli</span><br></pre></td></tr></table></figure><p>由于我们设置了密码，在启动客户端之后，输入 <code>auth 123456</code> 即可登录进入客户端。<br>然后我们来测试一下，往 redis 中插入一个数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set name CSDN</span><br></pre></td></tr></table></figure><p>然后来获取 name</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get name</span><br></pre></td></tr></table></figure><p>如果正常获取到 CSDN，则说明没有问题。</p><h2 id="3-Spring-Boot-集成-Redis">3. Spring Boot 集成 Redis</h2><h3 id="3-1-依赖导入">3.1 依赖导入</h3><p>Spring Boot 集成 redis 很方便，只需要导入一个 redis 的 starter 依赖即可。如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--阿里巴巴fastjson --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.35<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里也导入阿里巴巴的 fastjson 是为了在后面我们要存一个实体，为了方便把实体转换成 json 字符串存进去。</p><h3 id="3-2-Redis-配置">3.2 Redis 配置</h3><p>导入了依赖之后，我们在 application.yml 文件里配置 redis：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment">#redis相关配置</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">5</span></span><br><span class="line">    <span class="comment"># 配置redis的主机地址，需要修改成自己的</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.48</span><span class="number">.190</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="number">5000</span></span><br><span class="line">    <span class="attr">jedis:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="comment"># 连接池中的最大空闲连接，默认值也是8。</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">500</span></span><br><span class="line">        <span class="comment"># 连接池中的最小空闲连接，默认值也是0。</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">50</span></span><br><span class="line">        <span class="comment"># 如果赋值为-1，则表示不限制；如果pool已经分配了maxActive个jedis实例，则此时pool的状态为exhausted(耗尽)</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">1000</span></span><br><span class="line">        <span class="comment"># 等待可用连接的最大时间，单位毫秒，默认值为-1，表示永不超时。如果超过等待时间，则直接抛出JedisConnectionException</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="number">2000</span></span><br></pre></td></tr></table></figure><h3 id="3-3-常用-api-介绍">3.3 常用 api 介绍</h3><p>Spring Boot 对 redis 的支持已经非常完善了，丰富的 api 已经足够我们日常的开发，这里我介绍几个最常用的供大家学习，其他 api 希望大家自己多学习，多研究。用到会去查即可。</p><p>有两个 redis 模板：RedisTemplate 和 StringRedisTemplate。我们不使用 RedisTemplate，RedisTemplate 提供给我们操作对象，操作对象的时候，我们通常是以 json 格式存储，但在存储的时候，会使用 Redis 默认的内部序列化器；导致我们存进里面的是乱码之类的东西。当然了，我们可以自己定义序列化，但是比较麻烦，所以使用 StringRedisTemplate 模板。StringRedisTemplate 主要给我们提供字符串操作，我们可以将实体类等转成 json 字符串即可，在取出来后，也可以转成相应的对象，这就是上面我导入了阿里 fastjson 的原因。</p><h4 id="3-3-1-redis-string-类型">3.3.1 redis:string 类型</h4><p>新建一个 RedisService，注入 StringRedisTemplate，使用 <code>stringRedisTemplate.opsForValue()</code> 可以获取 <code>ValueOperations&lt;String, String&gt;</code> 对象，通过该对象即可读写 redis 数据库了。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * set redis: string类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setString</span><span class="params">(String key, String value)</span></span>&#123;</span><br><span class="line">        ValueOperations&lt;String, String&gt; valueOperations = stringRedisTemplate.opsForValue();</span><br><span class="line">        valueOperations.set(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get redis: string类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getString</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>该对象操作的是 string，我们也可以存实体类，只需要将实体类转换成 json 字符串即可。下面来测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">Course14ApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(Course14ApplicationTests<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RedisService redisService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//测试redis的string类型</span></span><br><span class="line">        redisService.setString(<span class="string">"weichat"</span>,<span class="string">"程序员私房菜"</span>);</span><br><span class="line">        logger.info(<span class="string">"我的微信公众号为：&#123;&#125;"</span>, redisService.getString(<span class="string">"weichat"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是个实体，我们可以使用json工具转成json字符串，</span></span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="string">"CSDN"</span>, <span class="string">"123456"</span>);</span><br><span class="line">        redisService.setString(<span class="string">"userInfo"</span>, JSON.toJSONString(user));</span><br><span class="line">        logger.info(<span class="string">"用户信息：&#123;&#125;"</span>, redisService.getString(<span class="string">"userInfo"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先启动 redis，然后运行这个测试用例，观察控制台打印的日志如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我的微信公众号为：程序员私房菜</span><br><span class="line">用户信息：&#123;&quot;password&quot;:&quot;123456&quot;,&quot;username&quot;:&quot;CSDN&quot;&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-2-redis-hash-类型">3.3.2 redis:hash 类型</h4><p>hash 类型其实原理和 string 一样的，但是有两个 key，使用 <code>stringRedisTemplate.opsForHash()</code> 可以获取 <code>HashOperations&lt;String, Object, Object&gt;</code> 对象。比如我们要存储订单信息，所有订单信息都放在 order 下，针对不同用户的订单实体，可以通过用户的 id 来区分，这就相当于两个 key 了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * set redis: hash类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filedKey filedkey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHash</span><span class="params">(String key, String filedKey, String value)</span></span>&#123;</span><br><span class="line">        HashOperations&lt;String, Object, Object&gt; hashOperations = stringRedisTemplate.opsForHash();</span><br><span class="line">        hashOperations.put(key,filedKey, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get redis: hash类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filedkey filedkey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getHash</span><span class="params">(String key, String filedkey)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (String) stringRedisTemplate.opsForHash().get(key, filedkey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，hash 和 string 没啥两样，只不过多了个参数，Spring Boot 中操作 redis 非常简单方便。来测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Course14ApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(Course14ApplicationTests<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RedisService redisService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//测试redis的hash类型</span></span><br><span class="line">        redisService.setHash(<span class="string">"user"</span>, <span class="string">"name"</span>, JSON.toJSONString(user));</span><br><span class="line">        logger.info(<span class="string">"用户姓名：&#123;&#125;"</span>, redisService.getHash(<span class="string">"user"</span>,<span class="string">"name"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-3-redis-list-类型">3.3.3 redis:list 类型</h4><p>使用 <code>stringRedisTemplate.opsForList()</code> 可以获取 <code>ListOperations&lt;String, String&gt; listOperations</code>  redis 列表对象，该列表是个简单的字符串列表，可以支持从左侧添加，也可以支持从右侧添加，一个列表最多包含 2 ^ 32 -1 个元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * set redis:list类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">setList</span><span class="params">(String key, String value)</span></span>&#123;</span><br><span class="line">        ListOperations&lt;String, String&gt; listOperations = stringRedisTemplate.opsForList();</span><br><span class="line">        <span class="keyword">return</span> listOperations.leftPush(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get redis:list类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start start</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end end</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getList</span><span class="params">(String key, <span class="keyword">long</span> start, <span class="keyword">long</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stringRedisTemplate.opsForList().range(key, start, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，这些 api 都是一样的形式，方便记忆也方便使用。具体的 api 细节我就不展开了，大家可以自己看 api 文档。其实，这些 api 根据参数和返回值也能知道它们是做什么用的。来测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">Course14ApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(Course14ApplicationTests<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RedisService redisService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//测试redis的list类型</span></span><br><span class="line">        redisService.setList(<span class="string">"list"</span>, <span class="string">"football"</span>);</span><br><span class="line">        redisService.setList(<span class="string">"list"</span>, <span class="string">"basketball"</span>);</span><br><span class="line">        List&lt;String&gt; valList = redisService.getList(<span class="string">"list"</span>,<span class="number">0</span>,-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(String value :valList)&#123;</span><br><span class="line">            logger.info(<span class="string">"list中有：&#123;&#125;"</span>, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-总结-v7">4. 总结</h2><p>本节主要介绍了 redis 的使用场景、安装过程，以及 Spring Boot 中集成 redis 的详细步骤。在实际项目中，通常都用 redis 作为缓存，在查询数据库的时候，会先从 redis 中查找，如果有信息，则从 redis 中取；如果没有，则从数据库中查，并且同步到 redis 中，下次 redis 中就有了。更新和删除也是如此，都需要同步到 redis。redis 在高并发场景下运用的很多。</p><p>课程源代码下载地址：<a href="https://gitee.com/eson15/springboot_study" target="_blank" rel="noopener">戳我下载</a></p><blockquote><p>欢迎关注我的为微信公众号：武哥聊编程</p></blockquote><h1>第15课： Spring Boot中集成ActiveMQ</h1><h2 id="1-JMS-和-ActiveMQ-介绍">1. JMS 和 ActiveMQ 介绍</h2><h3 id="1-1-JMS-是啥">1.1 JMS 是啥</h3><p>百度百科的解释：</p><blockquote><p>JMS 即 Java 消息服务（Java Message Service）应用程序接口，是一个Java平台中关于面向消息中间件（MOM）的 API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。Java 消息服务是一个与具体平台无关的 API，绝大多数 MOM 提供商都对 JMS 提供支持。</p></blockquote><p>JMS 只是接口，不同的提供商或者开源组织对其有不同的实现，ActiveMQ 就是其中之一，它支持JMS，是 Apache 推出的。JMS 中有几个对象模型：</p><blockquote><p>连接工厂：ConnectionFactory<br>JMS连接：Connection<br>JMS会话：Session<br>JMS目的：Destination<br>JMS生产者：Producer<br>JMS消费者：Consumer<br>JMS消息两种类型：点对点和发布/订阅。</p></blockquote><p>可以看出 JMS 实际上和 JDBC 有点类似，JDBC 是可以用来访问许多不同关系数据库的 API，而 JMS 则提供同样与厂商无关的访问方法，以访问消息收发服务。本文主要使用 ActiveMQ。</p><h3 id="1-2-ActiveMQ">1.2 ActiveMQ</h3><p>ActiveMQ 是 Apache 的一个能力强劲的开源消息总线。ActiveMQ 完全支持JMS1.1和J2EE 1.4规范，尽管 JMS 规范出台已经是很久的事情了，但是 JMS 在当今的 Java EE 应用中间仍然扮演着特殊的地位。ActiveMQ 用在异步消息的处理上，所谓异步消息即消息发送者无需等待消息接收者的处理以及返回，甚至无需关心消息是否发送成功。</p><p>异步消息主要有两种目的地形式，队列（queue）和主题（topic），队列用于点对点形式的消息通信，主题用于发布/订阅式的消息通信。本章节主要来学习一下在 Spring Boot 中如何使用这两种形式的消息。</p><h2 id="2-ActiveMQ安装">2. ActiveMQ安装</h2><p>使用 ActiveMQ 首先需要去官网下载，官网地址为：<a href="http://activemq.apache.org/" target="_blank" rel="noopener">http://activemq.apache.org/</a><br>本课程使用的版本是 apache-activemq-5.15.3，下载后解压缩会有一个名为 apache-activemq-5.15.3 的文件夹，没错，这就安装好了，非常简单，开箱即用。打开文件夹会看到里面有个 <code>activemq-all-5.15.3.jar</code>，这个 jar 我们是可以加进工程里的，但是使用 maven 的话，这个 jar 我们不需要。</p><p>在使用 ActiveMQ 之前，首先得先启动，刚才解压后的目录中有个 bin 目录，里面有 win32 和 win64 两个目录，根据自己电脑选择其中一个打开运行里面的 activemq.bat 即可启动 ActiveMQ。<br>消息生产者生产消息发布到queue中，然后消息消费者从queue中取出，并且消费消息。这里需要注意：消息被消费者消费以后，queue中不再有存储，所以消息消费者不可消费到已经被消费的消息。Queue支持存在多个消息消费者，但是对一个消息而言，只会有一个消费者可以消费<br>启动完成后，在浏览器中输入 <code>http://127.0.0.1:8161/admin/</code> 来访问 ActiveMQ 的服务器，用户名和密码是 admin/admin。如下：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/33e0cacd2ab6801400123d2955c0934c.jpeg" alt="activemq"></p><p>我们可以看到有 Queues 和 Topics 这两个选项，这两个选项分别是点对点消息和发布/订阅消息的查看窗口。何为点对点消息和发布/订阅消息呢？</p><p>点对点消息：消息生产者生产消息发布到 queue 中，然后消息消费者从 queue 中取出，并且消费消息。这里需要注意：消息被消费者消费以后，queue 中不再有存储，所以消息消费者不可消费到已经被消费的消息。Queue 支持存在多个消息消费者，但是对一个消息而言，只会有一个消费者可以消费。</p><p>发布/订阅消息：消息生产者（发布）将消息发布到 topic 中，同时有多个消息消费者（订阅）消费该消息。和点对点方式不同，发布到 topic 的消息会被所有订阅者消费。下面分析具体的实现方式。</p><h2 id="3-ActiveMQ集成">3. ActiveMQ集成</h2><h3 id="3-1-依赖导入和配置">3.1 依赖导入和配置</h3><p>在 Spring Boot 中集成 ActiveMQ 需要导入如下 starter 依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-activemq<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在 application.yml 配置文件中，对 activemq 做一下配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">activemq:</span></span><br><span class="line">  <span class="comment"># activemq url</span></span><br><span class="line">    <span class="attr">broker-url:</span> <span class="string">tcp://localhost:61616</span></span><br><span class="line">    <span class="attr">in-memory:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">pool:</span></span><br><span class="line">      <span class="comment"># 如果此处设置为true，需要添加activemq-pool的依赖包，否则会自动配置失败，无法注入JmsMessagingTemplate</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="3-2-Queue-和-Topic-的创建">3.2 Queue 和 Topic 的创建</h3><p>首先我们需要创建两种消息 Queue 和 Topic，这两种消息的创建，我们放到 ActiveMqConfig 中来创建，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * activemq的配置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>  shengwu ni</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveMqConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发布/订阅模式队列名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TOPIC_NAME = <span class="string">"activemq.topic"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 点对点模式队列名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">"activemq.queue"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Destination <span class="title">topic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ActiveMQTopic(TOPIC_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Destination <span class="title">queue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ActiveMQQueue(QUEUE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出创建 Queue 和 Topic 两种消息，分别使用 <code>new ActiveMQQueue</code> 和 <code>new ActiveMQTopic</code> 来创建，分别跟上对应消息的名称即可。这样在其他地方就可以直接将这两种消息作为组件注入进来了。</p><h3 id="3-3-消息的发送接口">3.3 消息的发送接口</h3><p>在 Spring Boot 中，我们只要注入 JmsMessagingTemplate 模板即可快速发送消息，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消息发送者</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shengwu ni</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MsgProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> JmsMessagingTemplate jmsMessagingTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(Destination destination, String msg)</span> </span>&#123;</span><br><span class="line">        jmsMessagingTemplate.convertAndSend(destination, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>convertAndSend</code> 方法中第一个参数是消息发送的目的地，第二个参数是具体的消息内容。</p><h3 id="3-4-点对点消息生产与消费">3.4 点对点消息生产与消费</h3><h4 id="3-4-1-点对点消息的生产">3.4.1 点对点消息的生产</h4><p>消息的生产，我们放到 Controller 中来做，由于上面已经生成了 Queue 消息的组件，所以在 Controller 中我们直接注入进来即可。然后调用上文的消息发送方法 <code>sendMessage</code> 即可成功生产一条消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ActiveMQ controller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shengwu ni</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/activemq"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveMqController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ActiveMqController<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> MsgProducer producer;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> Destination queue;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/send/queue"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sendQueueMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">"===开始发送点对点消息==="</span>);</span><br><span class="line">        producer.sendMessage(queue, <span class="string">"Queue: hello activemq!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-4-2-点对点消息的消费">3.4.2 点对点消息的消费</h4><p>点对点消息的消费很简单，只要我们指定目的地即可，jms 监听器一直在监听是否有消息过来，如果有，则消费。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消息消费者</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shengwu ni</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接收点对点消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@JmsListener</span>(destination = ActiveMqConfig.QUEUE_NAME)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveQueueMsg</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"收到的消息为："</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，使用 <code>@JmsListener</code> 注解来指定要监听的目的地，在消息接收方法内部，我们可以根据具体的业务需求做相应的逻辑处理即可。</p><h4 id="3-4-3-测试一下">3.4.3 测试一下</h4><p>启动项目，在浏览器中输入：<code>http://localhost:8081/activemq/send/queue</code>，观察控制台的输出日志，出现下面的日志说明消息发送和消费成功。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">收到的消息为：Queue: hello activemq!</span><br></pre></td></tr></table></figure><h3 id="3-5-发布-订阅消息的生产和消费">3.5 发布/订阅消息的生产和消费</h3><h4 id="3-5-1-发布-订阅消息的生产">3.5.1 发布/订阅消息的生产</h4><p>和点对点消息一样，我们注入 topic 并调用 producer 的 <code>sendMessage</code> 方法即可发送订阅消息，如下，不再赘述：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/activemq"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveMqController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ActiveMqController<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> MsgProducer producer;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> Destination topic;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/send/topic"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sendTopicMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">"===开始发送订阅消息==="</span>);</span><br><span class="line">        producer.sendMessage(topic, <span class="string">"Topic: hello activemq!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-5-2-发布-订阅消息的消费">3.5.2 发布/订阅消息的消费</h4><p>发布/订阅消息的消费和点对点不同，订阅消息支持多个消费者一起消费。其次，Spring Boot 中默认的时点对点消息，所以在使用 topic 时，会不起作用，我们需要在配置文件 application.yml 中添加一个配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">jms:</span></span><br><span class="line">    <span class="attr">pub-sub-domain:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>该配置是 false 的话，则为点对点消息，也是 Spring Boot 默认的。这样是可以解决问题，但是如果这样配置的话，上面提到的点对点消息又不能正常消费了。所以二者不可兼得，这并非一个好的解决办法。</p><p>比较好的解决办法是，我们定义一个工厂，<code>@JmsListener</code> 注解默认只接收 queue 消息，如果要接收 topic 消息，需要设置一下 containerFactory。我们还在上面的那个 ActiveMqConfig 配置类中添加：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * activemq的配置</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shengwu ni</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveMqConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略其他内容</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * JmsListener注解默认只接收queue消息,如果要接收topic消息,需要设置containerFactory</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JmsListenerContainerFactory <span class="title">topicListenerContainer</span><span class="params">(ConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">        DefaultJmsListenerContainerFactory factory = <span class="keyword">new</span> DefaultJmsListenerContainerFactory();</span><br><span class="line">        factory.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="comment">// 相当于在application.yml中配置：spring.jms.pub-sub-domain=true</span></span><br><span class="line">        factory.setPubSubDomain(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过这样的配置之后，我们在消费的时候，在 <code>@JmsListener</code> 注解中指定这个容器工厂即可消费 topic 消息。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Topic消息消费者</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shengwu ni</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicConsumer1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接收订阅消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@JmsListener</span>(destination = ActiveMqConfig.TOPIC_NAME, containerFactory = <span class="string">"topicListenerContainer"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveTopicMsg</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"收到的消息为："</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指定 containerFactory 属性为上面我们自己配置的 topicListenerContainer 即可。由于 topic 消息可以多个消费，所以该消费的类可以拷贝几个一起测试一下，这里我就不贴代码了，可以参考我的源码测试。</p><h4 id="3-5-3-测试一下">3.5.3 测试一下</h4><p>启动项目，在浏览器中输入：<code>http://localhost:8081/activemq/send/topic</code>，观察控制台的输出日志，出现下面的日志说明消息发送和消费成功。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">收到的消息为：Topic: hello activemq!</span><br><span class="line">收到的消息为：Topic: hello activemq!</span><br></pre></td></tr></table></figure><h2 id="4-总结-v8">4. 总结</h2><p>本章主要介绍了 jms 和 activemq 的相关概念、activemq 的安装与启动。详细分析了 Spring Boot 中点对点消息和发布/订阅消息两种方式的配置、消息生产和消费方式。ActiveMQ 是能力强劲的开源消息总线，在异步消息的处理上很有用，希望大家好好消化一下。</p><p>课程源代码下载地址：<a href="https://gitee.com/eson15/springboot_study" target="_blank" rel="noopener">戳我下载</a></p><blockquote><p>欢迎关注我的为微信公众号：武哥聊编程</p></blockquote><h1>第16课：Spring Boot中集成 Shiro</h1><p>Shiro 是一个强大、简单易用的 Java 安全框架，主要用来更便捷的认证，授权，加密，会话管等等，可为任何应用提供安全保障。本课程主要来介绍 Shiro 的认证和授权功能。</p><h2 id="1-Shiro-三大核心组件">1. Shiro 三大核心组件</h2><p>Shiro 有三大核心的组件：<code>Subject</code>、<code>SecurityManager</code> 和 <code>Realm</code>。先来看一下它们之间的关系。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/c1dfca09232b37d35c2ef52d765b47f9.jpeg" alt="三大核心组件的关系"></p><ol><li>Subject：认证主体。它包含两个信息：Principals 和 Credentials。看一下这两个信息具体是什么。</li></ol><blockquote><p>Principals：身份。可以是用户名，邮件，手机号码等等，用来标识一个登录主体身份；<br>Credentials：凭证。常见有密码，数字证书等等。</p></blockquote><p>说白了，就是需要认证的东西，最常见的就是用户名密码了，比如用户在登录的时候，Shiro 需要去进行身份认证，就需要 Subject 认证主体。</p><ol start="2"><li><p>SecurityManager：安全管理员。这是 Shiro 架构的核心，它就像 Shiro 内部所有原件的保护伞一样。我们在项目中一般都会配置 SecurityManager，开发人员大部分精力主要是在 Subject 认证主体上面。我们在与 Subject 进行交互的时候，实际上是 SecurityManager 在背后做一些安全操作。</p></li><li><p>Realms：Realms 是一个域，它是连接 Shiro 和具体应用的桥梁，当需要与安全数据交互的时候，比如用户账户、访问控制等，Shiro 就会从一个或多个 Realms 中去查找。我们一般会自己定制 Realm，这在下文会详细说明。</p></li></ol><h2 id="1-Shiro-身份和权限认证">1. Shiro 身份和权限认证</h2><h3 id="1-2-Shiro-身份认证">1.2 Shiro 身份认证</h3><p>我们来分析一下 Shiro 身份认证的过程，看一下官方的一个认证图：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/7658e202f5f035bb3436a1f35e058e60.jpeg" alt="认证过程"></p><p>Step1：应用程序代码在调用 <code>Subject.login(token)</code> 方法后，传入代表最终用户的身份和凭证的 AuthenticationToken 实例 token。</p><p>Step2：将 Subject 实例委托给应用程序的 SecurityManager（Shiro的安全管理）来开始实际的认证工作。这里开始真正的认证工作了。</p><p>Step3，4，5：然后 SecurityManager 就会根据具体的 realm 去进行安全认证了。 从图中可以看出，realm 可以自定义（Custom Realm）。</p><h3 id="1-3-Shiro-权限认证">1.3 Shiro 权限认证</h3><p>权限认证，也就是访问控制，即在应用中控制谁能访问哪些资源。在权限认证中，最核心的三个要素是：权限，角色和用户。</p><blockquote><p>权限（permission）：即操作资源的权利，比如访问某个页面，以及对某个模块的数据的添加，修改，删除，查看的权利；<br>角色（role）：指的是用户担任的的角色，一个角色可以有多个权限；<br>用户（user）：在 Shiro 中，代表访问系统的用户，即上面提到的 Subject 认证主体。</p></blockquote><p>它们之间的的关系可以用下图来表示：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/8fcdf9be7e8b4df5df09b7c4b6aedfce.jpeg" alt="用户、角色和权限的关系"></p><p>一个用户可以有多个角色，而不同的角色可以有不同的权限，也可由有相同的权限。比如说现在有三个角色，1是普通角色，2也是普通角色，3是管理员，角色1只能查看信息，角色2只能添加信息，管理员都可以，而且还可以删除信息，类似于这样。</p><h2 id="2-Spring-Boot-集成-Shiro-过程">2. Spring Boot 集成 Shiro 过程</h2><h3 id="2-1-依赖导入-v3">2.1 依赖导入</h3><p>Spring Boot 2.0.3 集成 Shiro 需要导入如下 starter 依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-2-数据库表数据初始化">2.2 数据库表数据初始化</h3><p>这里主要涉及到三张表：用户表、角色表和权限表，其实在 demo 中，我们完全可以自己模拟一下，不用建表，但是为了更加接近实际情况，我们还是加入 mybatis，来操作数据库。下面是数据库表的脚本。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t_role`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'主键'</span>,</span><br><span class="line">  <span class="string">`rolename`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'角色名称'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">4</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t_user`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'用户主键'</span>,</span><br><span class="line">  <span class="string">`username`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户名'</span>,</span><br><span class="line">  <span class="string">`password`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'密码'</span>,</span><br><span class="line">  <span class="string">`role_id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'外键关联role表'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`role_id`</span> (<span class="string">`role_id`</span>),</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> <span class="string">`t_user_ibfk_1`</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (<span class="string">`role_id`</span>) <span class="keyword">REFERENCES</span> <span class="string">`t_role`</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">4</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t_permission`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'主键'</span>,</span><br><span class="line">  <span class="string">`permissionname`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'权限名'</span>,</span><br><span class="line">  <span class="string">`role_id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'外键关联role'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`role_id`</span> (<span class="string">`role_id`</span>),</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> <span class="string">`t_permission_ibfk_1`</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (<span class="string">`role_id`</span>) <span class="keyword">REFERENCES</span> <span class="string">`t_role`</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">3</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8</span><br></pre></td></tr></table></figure><p>其中，t_user，t_role 和 t_permission，分别存储用户信息，角色信息和权限信息，表建立好了之后，我们往表里插入一些测试数据。<br>t_user 表：</p><table><thead><tr><th style="text-align:center">id</th><th style="text-align:center">username</th><th style="text-align:center">password</th><th style="text-align:center">role_id</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">csdn1</td><td style="text-align:center">123456</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">csdn2</td><td style="text-align:center">123456</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">csdn3</td><td style="text-align:center">123456</td><td style="text-align:center">3</td></tr></tbody></table><p>t_role 表：</p><table><thead><tr><th style="text-align:center">id</th><th style="text-align:center">rolename</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">admin</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">teacher</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">student</td></tr></tbody></table><p>t_permission 表：</p><table><thead><tr><th style="text-align:center">id</th><th style="text-align:center">permissionname</th><th style="text-align:center">role_id</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center"><code>user:*</code></td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center"><code>student:*</code></td><td style="text-align:center">2</td></tr></tbody></table><p>解释一下这里的权限：<code>user:*</code>表示权限可以是 <code>user:create</code> 或者其他，<code>*</code> 处表示一个占位符，我们可以自己定义，具体的会在下文 Shiro 配置那里说明。</p><h3 id="2-2-自定义-Realm">2.2 自定义 Realm</h3><p>有了数据库表和数据之后，我们开始自定义 realm，自定义 realm 需要继承 AuthorizingRealm 类，因为该类封装了很多方法，它也是一步步继承自 Realm 类的，继承了 AuthorizingRealm 类后，需要重写两个方法：</p><blockquote><p><code>doGetAuthenticationInfo()</code> 方法：用来验证当前登录的用户，获取认证信息<br><code>doGetAuthorizationInfo()</code> 方法：用来为当前登陆成功的用户授予权限和角色</p></blockquote><p>具体实现如下，相关的解释我放在代码的注释中，这样更加方便直观：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义realm</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shengwu ni</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRealm</span> <span class="keyword">extends</span> <span class="title">AuthorizingRealm</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthorizationInfo <span class="title">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principalCollection)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取用户名</span></span><br><span class="line">        String username = (String) principalCollection.getPrimaryPrincipal();</span><br><span class="line">        SimpleAuthorizationInfo authorizationInfo = <span class="keyword">new</span> SimpleAuthorizationInfo();</span><br><span class="line">        <span class="comment">// 给该用户设置角色，角色信息存在t_role表中取</span></span><br><span class="line">        authorizationInfo.setRoles(userService.getRoles(username));</span><br><span class="line">        <span class="comment">// 给该用户设置权限，权限信息存在t_permission表中取</span></span><br><span class="line">        authorizationInfo.setStringPermissions(userService.getPermissions(username));</span><br><span class="line">        <span class="keyword">return</span> authorizationInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthenticationInfo <span class="title">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken authenticationToken)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        <span class="comment">// 根据token获取用户名，如果您不知道该该token怎么来的，先可以不管，下文会解释</span></span><br><span class="line">        String username = (String) authenticationToken.getPrincipal();</span><br><span class="line">        <span class="comment">// 根据用户名从数据库中查询该用户</span></span><br><span class="line">        User user = userService.getByUsername(username);</span><br><span class="line">        <span class="keyword">if</span>(user != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 把当前用户存到session中</span></span><br><span class="line">            SecurityUtils.getSubject().getSession().setAttribute(<span class="string">"user"</span>, user);</span><br><span class="line">            <span class="comment">// 传入用户名和密码进行身份认证，并返回认证信息</span></span><br><span class="line">            AuthenticationInfo authcInfo = <span class="keyword">new</span> SimpleAuthenticationInfo(user.getUsername(), user.getPassword(), <span class="string">"myRealm"</span>);</span><br><span class="line">            <span class="keyword">return</span> authcInfo;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面两个方法中可以看出：验证身份的时候是根据用户输入的用户名先从数据库中查出该用户名对应的用户，这时候并没有涉及到密码，也就是说到这一步的时候，即使用户输入的密码不对，也是可以查出来该用户的，然后将该用户的正确信息封装到 authcInfo 中返回给 Shiro，接下来就是Shiro的事了，它会根据这里面的真实信息与用户前台输入的用户名和密码进行校验， 这个时候也要校验密码了，如果校验通过就让用户登录，否则跳转到指定页面。同理，权限验证的时候也是先根据用户名从数据库中获取与该用户名有关的角色和权限，然后封装到 authorizationInfo 中返回给 Shiro。</p><h3 id="2-3-Shiro-配置">2.3 Shiro 配置</h3><p>自定义的 realm 写好了，接下来需要对 Shiro 进行配置了。我们主要配置三个东西：自定义 realm、安全管理器 SecurityManager 和 Shiro 过滤器。如下：</p><p>配置自定义 realm：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShiroConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ShiroConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注入自定义的realm</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> MyRealm</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyRealm <span class="title">myAuthRealm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MyRealm myRealm = <span class="keyword">new</span> MyRealm();</span><br><span class="line">        logger.info(<span class="string">"====myRealm注册完成====="</span>);</span><br><span class="line">        <span class="keyword">return</span> myRealm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置安全管理器 SecurityManager：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShiroConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ShiroConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注入安全管理器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> SecurityManager</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SecurityManager <span class="title">securityManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将自定义realm加进来</span></span><br><span class="line">        DefaultWebSecurityManager securityManager = <span class="keyword">new</span> DefaultWebSecurityManager(myAuthRealm());</span><br><span class="line">        logger.info(<span class="string">"====securityManager注册完成===="</span>);</span><br><span class="line">        <span class="keyword">return</span> securityManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置 SecurityManager 时，需要将上面的自定义 realm 添加进来，这样的话 Shiro 才会走到自定义的 realm 中。</p><p>配置 Shiro 过滤器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShiroConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ShiroConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注入Shiro过滤器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> securityManager 安全管理器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ShiroFilterFactoryBean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ShiroFilterFactoryBean <span class="title">shiroFilter</span><span class="params">(SecurityManager securityManager)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义shiroFactoryBean</span></span><br><span class="line">        ShiroFilterFactoryBean shiroFilterFactoryBean=<span class="keyword">new</span> ShiroFilterFactoryBean();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置自定义的securityManager</span></span><br><span class="line">        shiroFilterFactoryBean.setSecurityManager(securityManager);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置默认登录的url，身份认证失败会访问该url</span></span><br><span class="line">        shiroFilterFactoryBean.setLoginUrl(<span class="string">"/login"</span>);</span><br><span class="line">        <span class="comment">// 设置成功之后要跳转的链接</span></span><br><span class="line">        shiroFilterFactoryBean.setSuccessUrl(<span class="string">"/success"</span>);</span><br><span class="line">        <span class="comment">// 设置未授权界面，权限认证失败会访问该url</span></span><br><span class="line">        shiroFilterFactoryBean.setUnauthorizedUrl(<span class="string">"/unauthorized"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// LinkedHashMap是有序的，进行顺序拦截器配置</span></span><br><span class="line">        Map&lt;String,String&gt; filterChainMap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 配置可以匿名访问的地址，可以根据实际情况自己添加，放行一些静态资源等，anon表示放行</span></span><br><span class="line">        filterChainMap.put(<span class="string">"/css/**"</span>, <span class="string">"anon"</span>);</span><br><span class="line">        filterChainMap.put(<span class="string">"/imgs/**"</span>, <span class="string">"anon"</span>);</span><br><span class="line">        filterChainMap.put(<span class="string">"/js/**"</span>, <span class="string">"anon"</span>);</span><br><span class="line">        filterChainMap.put(<span class="string">"/swagger-*/**"</span>, <span class="string">"anon"</span>);</span><br><span class="line">        filterChainMap.put(<span class="string">"/swagger-ui.html/**"</span>, <span class="string">"anon"</span>);</span><br><span class="line">        <span class="comment">// 登录url 放行</span></span><br><span class="line">        filterChainMap.put(<span class="string">"/login"</span>, <span class="string">"anon"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// “/user/admin” 开头的需要身份认证，authc表示要身份认证</span></span><br><span class="line">        filterChainMap.put(<span class="string">"/user/admin*"</span>, <span class="string">"authc"</span>);</span><br><span class="line">        <span class="comment">// “/user/student” 开头的需要角色认证，是“admin”才允许</span></span><br><span class="line">        filterChainMap.put(<span class="string">"/user/student*/**"</span>, <span class="string">"roles[admin]"</span>);</span><br><span class="line">        <span class="comment">// “/user/teacher” 开头的需要权限认证，是“user:create”才允许</span></span><br><span class="line">        filterChainMap.put(<span class="string">"/user/teacher*/**"</span>, <span class="string">"perms[\"user:create\"]"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 配置logout过滤器</span></span><br><span class="line">        filterChainMap.put(<span class="string">"/logout"</span>, <span class="string">"logout"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置shiroFilterFactoryBean的FilterChainDefinitionMap</span></span><br><span class="line">        shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainMap);</span><br><span class="line">        logger.info(<span class="string">"====shiroFilterFactoryBean注册完成===="</span>);</span><br><span class="line">        <span class="keyword">return</span> shiroFilterFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置 Shiro 过滤器时会传入一个安全管理器，可以看出，这是一环套一环，reaml -&gt; SecurityManager -&gt; filter。在过滤器中，我们需要定义一个 shiroFactoryBean，然后将 SecurityManager 添加进来，结合上面代码可以看出，要配置的东西主要有：</p><blockquote><p>默认登录的 url：身份认证失败会访问该 url<br>认证成功之后要跳转的 url<br>权限认证失败会访问该 url<br>需要拦截或者放行的 url：这些都放在一个 map 中</p></blockquote><p>从上述代码中可以看出，在 map 中，针对不同的 url，有不同的权限要求，这里总结一下常用的几个权限。</p><table><thead><tr><th style="text-align:center">Filter</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">anon</td><td style="text-align:center">开放权限，可以理解为匿名用户或游客，可以直接访问的</td></tr><tr><td style="text-align:center">authc</td><td style="text-align:center">需要身份认证的</td></tr><tr><td style="text-align:center">logout</td><td style="text-align:center">注销，执行后会直接跳转到 <code>shiroFilterFactoryBean.setLoginUrl();</code> 设置的 url，即登录页面</td></tr><tr><td style="text-align:center">roles[admin]</td><td style="text-align:center">参数可写多个，表示是某个或某些角色才能通过，多个参数时写 roles[“admin，user”]，当有多个参数时必须每个参数都通过才算通过</td></tr><tr><td style="text-align:center">perms[user]</td><td style="text-align:center">参数可写多个，表示需要某个或某些权限才能通过，多个参数时写 perms[“user, admin”]，当有多个参数时必须每个参数都通过才算通过</td></tr></tbody></table><h3 id="2-4-使用-Shiro-进行认证">2.4 使用 Shiro 进行认证</h3><p>到这里，我们对 Shiro 的准备工作都做完了，接下来开始使用 Shiro 进行认证工作。我们首先来设计几个接口：</p><blockquote><p>接口一： 使用 <code>http://localhost:8080/user/admin</code> 来验证身份认证<br>接口二： 使用 <code>http://localhost:8080/user/student</code> 来验证角色认证<br>接口三： 使用 <code>http://localhost:8080/user/teacher</code> 来验证权限认证<br>接口四： 使用 <code>http://localhost:8080/user/login</code> 来实现用户登录</p></blockquote><p>然后来一下认证的流程：</p><blockquote><p>流程一： 直接访问接口一（此时还未登录），认证失败，跳转到 login.html 页面让用户登录，登录会请求接口四，实现用户登录功能，此时 Shiro 已经保存了用户信息了。<br>流程二： 再次访问接口一（此时用户已经登录），认证成功，跳转到 success.html 页面，展示用户信息。<br>流程三： 访问接口二，测试角色认证是否成功。<br>流程四： 访问接口三，测试权限认证是否成功。</p></blockquote><h4 id="2-4-1-身份、角色、权限认证接口">2.4.1 身份、角色、权限认证接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 身份认证测试接口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/admin"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">admin</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        Object user = request.getSession().getAttribute(<span class="string">"user"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 角色认证测试接口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/student"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">student</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 权限认证测试接口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/teacher"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">teacher</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这三个接口很简单，直接返回到指定页面展示即可，只要认证成功就会正常跳转，如果认证失败，就会跳转到上文 ShrioConfig 中配置的页面进行展示。</p><h4 id="2-4-2-用户登录接口">2.4.2 用户登录接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户登录接口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> user user</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/login"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(User user, HttpServletRequest request)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据用户名和密码创建token</span></span><br><span class="line">        UsernamePasswordToken token = <span class="keyword">new</span> UsernamePasswordToken(user.getUsername(), user.getPassword());</span><br><span class="line">        <span class="comment">// 获取subject认证主体</span></span><br><span class="line">        Subject subject = SecurityUtils.getSubject();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 开始认证，这一步会跳到我们自定义的realm中</span></span><br><span class="line">            subject.login(token);</span><br><span class="line">            request.getSession().setAttribute(<span class="string">"user"</span>, user);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            request.getSession().setAttribute(<span class="string">"user"</span>, user);</span><br><span class="line">            request.setAttribute(<span class="string">"error"</span>, <span class="string">"用户名或密码错误！"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"login"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们重点分析一下这个登录接口，首先会根据前端传过来的用户名和密码，创建一个 token，然后使用 SecurityUtils 来创建一个认证主体，接下来开始调用 <code>subject.login(token)</code> 开始进行身份认证了，注意这里传了刚刚创建的 token，就如注释中所述，这一步会跳转到我们自定义的 realm 中，进入 <code>doGetAuthenticationInfo</code> 方法，所以到这里，您就会明白该方法中那个参数 token 了。然后就是上文分析的那样，开始进行身份认证。</p><h4 id="2-4-3-测试一下">2.4.3 测试一下</h4><p>最后，启动项目，测试一下：<br>浏览器请求 <code>http://localhost:8080/user/admin</code> 会进行身份认证，因为此时未登录，所以会跳转到 IndexController 中的 <code>/login</code> 接口，然后跳转到 <code>login.html</code> 页面让我们登录，使用用户名密码为 csdn/123456 登录之后，我们在浏览器中请求 <code>http://localhost:8080/user/student</code> 接口，会进行角色认证，因为数据库中 csdn1 的用户角色是 admin，所以和配置中的吻合，认证通过；我们再请求 <code>http://localhost:8080/user/teacher</code> 接口，会进行权限认证，因为数据库中 csdn1 的用户权限为 <code>user:*</code>，满足配置中的 <code>user:create</code>，所以认证通过。</p><p>接下来，我们点退出，系统会注销重新让我们登录，我们使用 csdn2 这个用户来登录，重复上述操作，当在进行角色认证和权限认证这两步时，就认证不通过了，因为数据库中 csdn2 这个用户存的角色和权限与配置中的不同，所以认证不通过。</p><h2 id="3-总结-v3">3. 总结</h2><p>本节主要介绍了 Shiro 安全框架与 Spring Boot 的整合。先介绍了 Shiro 的三大核心组件已经它们的作用；然后介绍了 Shiro 的身份认证、角色认证和权限认证；最后结合代码，详细介绍了 Spring Boot 中是如何整合 Shiro 的，并设计了一套测试流程，逐步分析 Shiro 的工作流程和原理，让读者更直观地体会出 Shiro 的整套工作流程。Shiro 使用的很广泛，希望读者将其掌握，并能运用到实际项目中。</p><p>课程源代码下载地址：<a href="https://gitee.com/eson15/springboot_study" target="_blank" rel="noopener">戳我下载</a></p><blockquote><p>欢迎关注我的为微信公众号：武哥聊编程</p></blockquote><h1>第17课：Spring Boot中集成Lucence</h1><h2 id="1-Lucence-和全文检索">1. Lucence 和全文检索</h2><p>Lucene 是什么？看一下百度百科：</p><blockquote><p>Lucene是一套用于全文检索和搜寻的开源程式库，由 Apache 软件基金会支持和提供。Lucene 提供了一个简单却强大的应用程式接口，能够做全文索引和搜寻。在 Java 开发环境里 Lucene 是一个成熟的免费开源工具。就其本身而言，Lucene 是当前以及最近几年最受欢迎的免费 Java 信息检索程序库。——《百度百科》</p></blockquote><h3 id="1-1-全文检索">1.1 全文检索</h3><p>这里提到了全文检索的概念，我们先来分析一下什么是全文检索，理解了全文检索之后，再理解 Lucene 的原理就非常简单了。</p><p>何为全文检索？举个例子，比如现在要在一个文件中查找某个字符串，最直接的想法就是从头开始检索，查到了就OK，这种对于小数据量的文件来说，很实用，但是对于大数据量的文件来说，就有点吃力了。或者说找包含某个字符串的文件，也是这样，如果在一个拥有几十个 G 的硬盘中找那效率可想而知，是很低的。</p><p>文件中的数据是属于非结构化数据，也就是说它没有什么结构可言，要解决上面提到的效率问题，首先我们得将非结构化数据中的一部分信息提取出来，重新组织，使其变得有一定结构，然后对这些有一定结构的数据进行搜索，从而达到搜索相对较快的目的。这就叫全文搜索。即先建立索引，再对索引进行搜索的过程。</p><h3 id="1-2-Lucene-建立索引的方式">1.2 Lucene 建立索引的方式</h3><p>那么 Lucene 中是如何建立索引的呢？假设现在有两篇文章，内容如下：</p><blockquote><p>文章1的内容为：Tom lives in Guangzhou, I live in Guangzhou too.<br>文章2的内容为：He once lived in Shanghai.</p></blockquote><p>首先第一步是将文档传给分词组件（Tokenizer），分词组件会将文档分成一个个单词，并去除标点符号和停词。所谓的停词指的是没有特别意义的词，比如英文中的 a，the，too 等。经过分词后，得到词元（Token） 。如下：</p><blockquote><p>文章1经过分词后的结果：<code>[Tom]</code> <code>[lives]</code> <code>[Guangzhou]</code> <code>[I]</code> <code>[live]</code> <code>[Guangzhou]</code><br>文章2经过分词后的结果：<code>[He]</code> <code>[lives]</code> <code>[Shanghai]</code></p></blockquote><p>然后将词元传给语言处理组件（Linguistic Processor），对于英语，语言处理组件一般会将字母变为小写，将单词缩减为词根形式，如 ”lives” 到 ”live” 等，将单词转变为词根形式，如 ”drove” 到 ”drive” 等。然后得到词（Term）。如下：</p><blockquote><p>文章1经过处理后的结果：<code>[tom]</code> <code>[live]</code> <code>[guangzhou]</code> <code>[i]</code> <code>[live]</code> <code>[guangzhou]</code><br>文章2经过处理后的结果：<code>[he]</code> <code>[live]</code> <code>[shanghai]</code></p></blockquote><p>最后将得到的词传给索引组件（Indexer），索引组件经过处理，得到下面的索引结构：</p><table><thead><tr><th style="text-align:center">关键词</th><th style="text-align:center">文章号[出现频率]</th><th style="text-align:center">出现位置</th></tr></thead><tbody><tr><td style="text-align:center">guangzhou</td><td style="text-align:center">1[2]</td><td style="text-align:center">3,6</td></tr><tr><td style="text-align:center">he</td><td style="text-align:center">2[1]</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">i</td><td style="text-align:center">1[1]</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">live</td><td style="text-align:center">1[2],2[1]</td><td style="text-align:center">2,5,2</td></tr><tr><td style="text-align:center">shanghai</td><td style="text-align:center">2[1]</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">tom</td><td style="text-align:center">1[1]</td><td style="text-align:center">1</td></tr></tbody></table><p>以上就是Lucene 索引结构中最核心的部分。它的关键字是按字符顺序排列的，因此 Lucene 可以用二元搜索算法快速定位关键词。实现时 Lucene 将上面三列分别作为词典文件（Term Dictionary）、频率文件（frequencies）和位置文件（positions）保存。其中词典文件不仅保存有每个关键词，还保留了指向频率文件和位置文件的指针，通过指针可以找到该关键字的频率信息和位置信息。<br>搜索的过程是先对词典二元查找、找到该词，通过指向频率文件的指针读出所有文章号，然后返回结果，然后就可以在具体的文章中根据出现位置找到该词了。所以 Lucene 在第一次建立索引的时候可能会比较慢，但是以后就不需要每次都建立索引了，就快了。</p><p>理解了 Lucene 的分词原理，接下来我们在 Spring Boot 中集成 Lucene 并实现索引和搜索的功能。</p><h2 id="2-Spring-Boot-中集成-Lucence">2. Spring Boot 中集成 Lucence</h2><h3 id="2-1-依赖导入-v4">2.1 依赖导入</h3><p>首先需要导入 Lucene 的依赖，它的依赖有好几个，如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Lucence核心包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.lucene<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lucene-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Lucene查询解析包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.lucene<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lucene-queryparser<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 常规的分词（英文） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.lucene<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lucene-analyzers-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--支持分词高亮  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.lucene<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lucene-highlighter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--支持中文分词  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.lucene<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lucene-analyzers-smartcn<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最后一个依赖是用来支持中文分词的，因为默认是支持英文的。那个高亮的分词依赖是最后我要做一个搜索，然后将搜到的内容高亮显示，模拟当前互联网上的做法，大家可以运用到实际项目中去。</p><h3 id="2-2-快速入门">2.2 快速入门</h3><p>根据上文的分析，全文检索有两个步骤，先建立索引，再检索。所以为了测试这个过程，我新建两个 java 类，一个用来建立索引的，另一个用来检索。</p><h4 id="2-2-1-建立索引">2.2.1 建立索引</h4><p>我们自己弄几个文件，放到 <code>D:\lucene\data</code> 目录下，新建一个 Indexer 类来实现建立索引功能。首先在构造方法中初始化标准分词器和写索引实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Indexer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写索引实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> IndexWriter writer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法，实例化IndexWriter</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> indexDir</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Indexer</span><span class="params">(String indexDir)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Directory dir = FSDirectory.open(Paths.get(indexDir));</span><br><span class="line">        <span class="comment">//标准分词器，会自动去掉空格啊，is a the等单词</span></span><br><span class="line">        Analyzer analyzer = <span class="keyword">new</span> StandardAnalyzer();</span><br><span class="line">        <span class="comment">//将标准分词器配到写索引的配置中</span></span><br><span class="line">        IndexWriterConfig config = <span class="keyword">new</span> IndexWriterConfig(analyzer);</span><br><span class="line">        <span class="comment">//实例化写索引对象</span></span><br><span class="line">        writer = <span class="keyword">new</span> IndexWriter(dir, config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在构造放发中传一个存放索引的文件夹路径，然后构建标准分词器（这是英文的），再使用标准分词器来实例化写索引对象。接下来就开始建立索引了，我将解释放到代码注释里，方便大家跟进。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 索引指定目录下的所有文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dataDir</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexAll</span><span class="params">(String dataDir)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 获取该路径下的所有文件</span></span><br><span class="line">    File[] files = <span class="keyword">new</span> File(dataDir).listFiles();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != files) &#123;</span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            <span class="comment">//调用下面的indexFile方法，对每个文件进行索引</span></span><br><span class="line">            indexFile(file);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回索引的文件数</span></span><br><span class="line">    <span class="keyword">return</span> writer.numDocs();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 索引指定的文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">indexFile</span><span class="params">(File file)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"索引文件的路径："</span> + file.getCanonicalPath());</span><br><span class="line">    <span class="comment">//调用下面的getDocument方法，获取该文件的document</span></span><br><span class="line">    Document doc = getDocument(file);</span><br><span class="line">    <span class="comment">//将doc添加到索引中</span></span><br><span class="line">    writer.addDocument(doc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取文档，文档里再设置每个字段，就类似于数据库中的一行记录</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Document <span class="title">getDocument</span><span class="params">(File file)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Document doc = <span class="keyword">new</span> Document();</span><br><span class="line">    <span class="comment">//开始添加字段</span></span><br><span class="line">    <span class="comment">//添加内容</span></span><br><span class="line">    doc.add(<span class="keyword">new</span> TextField(<span class="string">"contents"</span>, <span class="keyword">new</span> FileReader(file)));</span><br><span class="line">    <span class="comment">//添加文件名，并把这个字段存到索引文件里</span></span><br><span class="line">    doc.add(<span class="keyword">new</span> TextField(<span class="string">"fileName"</span>, file.getName(), Field.Store.YES));</span><br><span class="line">    <span class="comment">//添加文件路径</span></span><br><span class="line">    doc.add(<span class="keyword">new</span> TextField(<span class="string">"fullPath"</span>, file.getCanonicalPath(), Field.Store.YES));</span><br><span class="line">    <span class="keyword">return</span> doc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就建立好索引了，我们在该类中写一个 main 方法测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//索引保存到的路径</span></span><br><span class="line">        String indexDir = <span class="string">"D:\\lucene"</span>;</span><br><span class="line">        <span class="comment">//需要索引的文件数据存放的目录</span></span><br><span class="line">        String dataDir = <span class="string">"D:\\lucene\\data"</span>;</span><br><span class="line">        Indexer indexer = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> indexedNum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//记录索引开始时间</span></span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 开始构建索引</span></span><br><span class="line">            indexer = <span class="keyword">new</span> Indexer(indexDir);</span><br><span class="line">            indexedNum = indexer.indexAll(dataDir);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != indexer) &#123;</span><br><span class="line">                    indexer.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//记录索引结束时间</span></span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"索引耗时"</span> + (endTime - startTime) + <span class="string">"毫秒"</span>);</span><br><span class="line">        System.out.println(<span class="string">"共索引了"</span> + indexedNum + <span class="string">"个文件"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我搞了两个 tomcat 相关的文件放到 <code>D:\lucene\data</code> 下了，执行完之后，看到控制台输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">索引文件的路径：D:\lucene\data\catalina.properties</span><br><span class="line">索引文件的路径：D:\lucene\data\logging.properties</span><br><span class="line">索引耗时882毫秒</span><br><span class="line">共索引了2个文件</span><br></pre></td></tr></table></figure><p>然后我们去 <code>D:\lucene\</code> 目录下可以看到一些索引文件，这些文件不能删除，删除了就需要重新构建索引，否则没了索引，就无法去检索内容了。</p><p>####2.2.2 检索内容</p><p>上面把这两个文件的索引建立好了，接下来我们就可以写检索程序了，在这两个文件中查找特定的词。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Searcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">search</span><span class="params">(String indexDir, String q)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取要查询的路径，也就是索引所在的位置</span></span><br><span class="line">        Directory dir = FSDirectory.open(Paths.get(indexDir));</span><br><span class="line">        IndexReader reader = DirectoryReader.open(dir);</span><br><span class="line">        <span class="comment">//构建IndexSearcher</span></span><br><span class="line">        IndexSearcher searcher = <span class="keyword">new</span> IndexSearcher(reader);</span><br><span class="line">        <span class="comment">//标准分词器，会自动去掉空格啊，is a the等单词</span></span><br><span class="line">        Analyzer analyzer = <span class="keyword">new</span> StandardAnalyzer();</span><br><span class="line">        <span class="comment">//查询解析器</span></span><br><span class="line">        QueryParser parser = <span class="keyword">new</span> QueryParser(<span class="string">"contents"</span>, analyzer);</span><br><span class="line">        <span class="comment">//通过解析要查询的String，获取查询对象，q为传进来的待查的字符串</span></span><br><span class="line">        Query query = parser.parse(q);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录索引开始时间</span></span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//开始查询，查询前10条数据，将记录保存在docs中</span></span><br><span class="line">        TopDocs docs = searcher.search(query, <span class="number">10</span>);</span><br><span class="line">        <span class="comment">//记录索引结束时间</span></span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"匹配"</span> + q + <span class="string">"共耗时"</span> + (endTime-startTime) + <span class="string">"毫秒"</span>);</span><br><span class="line">        System.out.println(<span class="string">"查询到"</span> + docs.totalHits + <span class="string">"条记录"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//取出每条查询结果</span></span><br><span class="line">        <span class="keyword">for</span>(ScoreDoc scoreDoc : docs.scoreDocs) &#123;</span><br><span class="line">            <span class="comment">//scoreDoc.doc相当于docID,根据这个docID来获取文档</span></span><br><span class="line">            Document doc = searcher.doc(scoreDoc.doc);</span><br><span class="line">            <span class="comment">//fullPath是刚刚建立索引的时候我们定义的一个字段，表示路径。也可以取其他的内容，只要我们在建立索引时有定义即可。</span></span><br><span class="line">            System.out.println(doc.get(<span class="string">"fullPath"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        reader.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ok，这样我们检索的代码就写完了，每一步解释我写在代码中的注释上了，下面写个 main 方法来测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String indexDir = <span class="string">"D:\\lucene"</span>;</span><br><span class="line">    <span class="comment">//查询这个字符串</span></span><br><span class="line">    String q = <span class="string">"security"</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        search(indexDir, q);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查一下 <code>security</code> 这个字符串，执行一下看控制台打印的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">匹配security共耗时23毫秒</span><br><span class="line">查询到1条记录</span><br><span class="line">D:\lucene\data\catalina.properties</span><br></pre></td></tr></table></figure><p>可以看出，耗时了23毫秒在两个文件中找到了 security 这个字符串，并输出了文件的名称。上面的代码我写的很详细，这个代码已经比较全了，可以用在生产环境上。</p><h3 id="2-3-中文分词检索高亮实战">2.3 中文分词检索高亮实战</h3><p>上文已经写了建立索引和检索的代码，但是在实际项目中，我们往往是结合页面做一些查询结果的展示，比如我要查某个关键字，查到了之后，将相关的信息点展示出来，并将查询的关键字高亮等等。这种需求在实际项目中非常常见，而且大多数网站中都会有这种效果。所以这一小节我们就使用 Lucene 来实现这种效果。</p><h4 id="2-3-1-中文分词">2.3.1 中文分词</h4><p>我们新建一个 ChineseIndexer 类来建立中文索引，建立过程和英文索引一样的，不同的地方在于使用的是中文分词器。除此之外，这里我们不用通过读取文件去建立索引，我们模拟一下用字符串来建立，因为在实际项目中，绝大部分情况是获取到一些文本字符串，然后根据一些关键字去查询相关内容等等。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChineseIndexer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存放索引的位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Directory dir;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//准备一下用来测试的数据</span></span><br><span class="line">    <span class="comment">//用来标识文档</span></span><br><span class="line">    <span class="keyword">private</span> Integer ids[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> String citys[] = &#123;<span class="string">"上海"</span>, <span class="string">"南京"</span>, <span class="string">"青岛"</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> String descs[] = &#123;</span><br><span class="line">            <span class="string">"上海是个繁华的城市。"</span>,</span><br><span class="line">            <span class="string">"南京是一个文化的城市南京，简称宁，是江苏省会，地处中国东部地区，长江下游，濒江近海。全市下辖11个区，总面积6597平方公里，2013年建成区面积752.83平方公里，常住人口818.78万，其中城镇人口659.1万人。[1-4] “江南佳丽地，金陵帝王州”，南京拥有着6000多年文明史、近2600年建城史和近500年的建都史，是中国四大古都之一，有“六朝古都”、“十朝都会”之称，是中华文明的重要发祥地，历史上曾数次庇佑华夏之正朔，长期是中国南方的政治、经济、文化中心，拥有厚重的文化底蕴和丰富的历史遗存。[5-7] 南京是国家重要的科教中心，自古以来就是一座崇文重教的城市，有“天下文枢”、“东南第一学”的美誉。截至2013年，南京有高等院校75所，其中211高校8所，仅次于北京上海；国家重点实验室25所、国家重点学科169个、两院院士83人，均居中国第三。[8-10] 。"</span>,</span><br><span class="line">            <span class="string">"青岛是一个美丽的城市。"</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> indexDir</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">index</span><span class="params">(String indexDir)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        dir = FSDirectory.open(Paths.get(indexDir));</span><br><span class="line">        <span class="comment">// 先调用 getWriter 获取IndexWriter对象</span></span><br><span class="line">        IndexWriter writer = getWriter();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ids.length; i++) &#123;</span><br><span class="line">            Document doc = <span class="keyword">new</span> Document();</span><br><span class="line">            <span class="comment">// 把上面的数据都生成索引，分别用id、city和desc来标识</span></span><br><span class="line">            doc.add(<span class="keyword">new</span> IntField(<span class="string">"id"</span>, ids[i], Field.Store.YES));</span><br><span class="line">            doc.add(<span class="keyword">new</span> StringField(<span class="string">"city"</span>, citys[i], Field.Store.YES));</span><br><span class="line">            doc.add(<span class="keyword">new</span> TextField(<span class="string">"desc"</span>, descs[i], Field.Store.YES));</span><br><span class="line">            <span class="comment">//添加文档</span></span><br><span class="line">            writer.addDocument(doc);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//close了才真正写到文档中</span></span><br><span class="line">        writer.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取IndexWriter实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> IndexWriter <span class="title">getWriter</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//使用中文分词器</span></span><br><span class="line">        SmartChineseAnalyzer analyzer = <span class="keyword">new</span> SmartChineseAnalyzer();</span><br><span class="line">        <span class="comment">//将中文分词器配到写索引的配置中</span></span><br><span class="line">        IndexWriterConfig config = <span class="keyword">new</span> IndexWriterConfig(analyzer);</span><br><span class="line">        <span class="comment">//实例化写索引对象</span></span><br><span class="line">        IndexWriter writer = <span class="keyword">new</span> IndexWriter(dir, config);</span><br><span class="line">        <span class="keyword">return</span> writer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ChineseIndexer().index(<span class="string">"D:\\lucene2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们用 id、city、desc 分别代表 id、城市名称和城市描述，用他们作为关键字来建立索引，后面我们获取内容的时候，主要来获取城市描述。南京的描述我故意写的长一点，因为下文检索的时候，根据不同的关键字会检索到不同部分的信息，有个权重的概念在里面。<br>然后执行一下 main 方法，将索引保存到 <code>D:\lucene2\</code> 中。</p><h4 id="2-3-2-中文分词查询">2.3.2 中文分词查询</h4><p>中文分词查询代码逻辑和默认的查询差不多，有一些区别在于，我们需要将查询出来的关键字标红加粗等需要处理，需要计算出一个得分片段，这是什么意思呢？比如我搜索 “南京文化” 跟搜索 “南京文明”，这两个搜索结果应该根据关键字出现的位置，返回的结果不一样才对，这在下文会测试。我们先看一下代码和注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChineseSearch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ChineseSearch<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">search</span><span class="params">(String indexDir, String q)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取要查询的路径，也就是索引所在的位置</span></span><br><span class="line">        Directory dir = FSDirectory.open(Paths.get(indexDir));</span><br><span class="line">        IndexReader reader = DirectoryReader.open(dir);</span><br><span class="line">        IndexSearcher searcher = <span class="keyword">new</span> IndexSearcher(reader);</span><br><span class="line">        <span class="comment">//使用中文分词器</span></span><br><span class="line">        SmartChineseAnalyzer analyzer = <span class="keyword">new</span> SmartChineseAnalyzer();</span><br><span class="line">        <span class="comment">//由中文分词器初始化查询解析器</span></span><br><span class="line">        QueryParser parser = <span class="keyword">new</span> QueryParser(<span class="string">"desc"</span>, analyzer);</span><br><span class="line">        <span class="comment">//通过解析要查询的String，获取查询对象</span></span><br><span class="line">        Query query = parser.parse(q);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录索引开始时间</span></span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//开始查询，查询前10条数据，将记录保存在docs中</span></span><br><span class="line">        TopDocs docs = searcher.search(query, <span class="number">10</span>);</span><br><span class="line">        <span class="comment">//记录索引结束时间</span></span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        logger.info(<span class="string">"匹配&#123;&#125;共耗时&#123;&#125;毫秒"</span>, q, (endTime - startTime));</span><br><span class="line">        logger.info(<span class="string">"查询到&#123;&#125;条记录"</span>, docs.totalHits);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果不指定参数的话，默认是加粗，即&lt;b&gt;&lt;b/&gt;</span></span><br><span class="line">        SimpleHTMLFormatter simpleHTMLFormatter = <span class="keyword">new</span> SimpleHTMLFormatter(<span class="string">"&lt;b&gt;&lt;font color=red&gt;"</span>,<span class="string">"&lt;/font&gt;&lt;/b&gt;"</span>);</span><br><span class="line">        <span class="comment">//根据查询对象计算得分，会初始化一个查询结果最高的得分</span></span><br><span class="line">        QueryScorer scorer = <span class="keyword">new</span> QueryScorer(query);</span><br><span class="line">        <span class="comment">//根据这个得分计算出一个片段</span></span><br><span class="line">        Fragmenter fragmenter = <span class="keyword">new</span> SimpleSpanFragmenter(scorer);</span><br><span class="line">        <span class="comment">//将这个片段中的关键字用上面初始化好的高亮格式高亮</span></span><br><span class="line">        Highlighter highlighter = <span class="keyword">new</span> Highlighter(simpleHTMLFormatter, scorer);</span><br><span class="line">        <span class="comment">//设置一下要显示的片段</span></span><br><span class="line">        highlighter.setTextFragmenter(fragmenter);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//取出每条查询结果</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(ScoreDoc scoreDoc : docs.scoreDocs) &#123;</span><br><span class="line">            <span class="comment">//scoreDoc.doc相当于docID,根据这个docID来获取文档</span></span><br><span class="line">            Document doc = searcher.doc(scoreDoc.doc);</span><br><span class="line">            logger.info(<span class="string">"city:&#123;&#125;"</span>, doc.get(<span class="string">"city"</span>));</span><br><span class="line">            logger.info(<span class="string">"desc:&#123;&#125;"</span>, doc.get(<span class="string">"desc"</span>));</span><br><span class="line">            String desc = doc.get(<span class="string">"desc"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//显示高亮</span></span><br><span class="line">            <span class="keyword">if</span>(desc != <span class="keyword">null</span>) &#123;</span><br><span class="line">                TokenStream tokenStream = analyzer.tokenStream(<span class="string">"desc"</span>, <span class="keyword">new</span> StringReader(desc));</span><br><span class="line">                String summary = highlighter.getBestFragment(tokenStream, desc);</span><br><span class="line">                logger.info(<span class="string">"高亮后的desc:&#123;&#125;"</span>, summary);</span><br><span class="line">                list.add(summary);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        reader.close();</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每一步的注释我写的很详细，在这就不赘述了。接下来我们来测试一下效果。</p><h4 id="2-3-3-测试一下">2.3.3 测试一下</h4><p>这里我们使用 thymeleaf 来写个简单的页面来展示获取到的数据，并高亮展示。在 controller 中我们指定索引的目录和需要查询的字符串，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/lucene"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 索引所在的目录</span></span><br><span class="line">        String indexDir = <span class="string">"D:\\lucene2"</span>;</span><br><span class="line">        <span class="comment">// 要查询的字符</span></span><br><span class="line"><span class="comment">//        String q = "南京文明";</span></span><br><span class="line">        String q = <span class="string">"南京文化"</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;String&gt; list = ChineseSearch.search(indexDir, q);</span><br><span class="line">            model.addAttribute(<span class="string">"list"</span>, list);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"result"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接返回到 result.html 页面，该页面主要来展示一下 model 中的数据即可。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:each</span>=<span class="string">"desc : $&#123;list&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">th:utext</span>=<span class="string">"$&#123;desc&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里注意一下，不能使用 <code>th:test</code>，否则字符串中的 html 标签都会被转义，不会被渲染到页面。下面启动服务，在浏览器中输入 <code>http://localhost:8080/lucene/test</code>，测试一下效果，我们搜索的是 “南京文化”。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/816e6bb95429247797028f234b4c0b2a.jpeg" alt="南京文化"></p><p>再将 controller 中的搜索关键字改成 “南京文明”，看下命中的效果。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/a3a849c0ed0e0255bf2f6fdb15564e36.jpeg" alt="南京文明"></p><p>可以看出，不同的关键词，它会计算一个得分片段，也就是说不同的关键字会命中不同位置的内容，然后将关键字根据我们自己设定的形式高亮显示。从结果中可以看出，Lucene 也可以很智能的将关键字拆分命中，这在实际项目中会很好用。</p><h2 id="3-总结-v4">3. 总结</h2><p>本节课首先详细的分析了全文检索的理论规则，然后结合 Lucene，系统的讲述了在 Spring Boot 的集成步骤，首先快速带领大家从直观上感受 Lucene 如何建立索引已经如果检索，其次通过中文检索的具体实例，展示了 Lucene 在全文检索中的广泛应用。Lucene 不难，主要就是步骤比较多，代码不用死记硬背，拿到项目中根据实际情况做对应的修改即可。</p><p>课程源代码下载地址：<a href="https://gitee.com/eson15/springboot_study" target="_blank" rel="noopener">戳我下载</a></p><blockquote><p>欢迎关注我的为微信公众号：武哥聊编程</p></blockquote><h1>第18课：Spring Boot搭建实际项目开发中的架构</h1><p>前面的课程中，我主要给大家讲解了 Spring Boot 中常用的一些技术点，这些技术点在实际项目中可能不会全部用得到，因为不同的项目可能使用的技术不同，但是希望大家都能掌握如何使用，并能自己根据实际项目中的需求进行相应的扩展。</p><p>不知道大家了不了解单片机，单片机里有个最小系统，这个最小系统搭建好了之后，就可以在此基础上进行人为的扩展。这节课我们要做的就是搭建一个 “Spring Boot 最小系统架构” 。拿着这个架构，可以在此基础上根据实际需求做相应的扩展。</p><p>从零开始搭建一个环境，主要要考虑几点：统一封装的数据结构、可调式的接口、json的处理、模板引擎的使用（本文不写该项，因为现在大部分项目都前后端分离了，但是考虑到也还有非前后端分离的项目，所以我在源代码里也加上了 thymeleaf）、持久层的集成、拦截器（这个也是可选的）和全局异常处理。一般包括这些东西的话，基本上一个 Spring Boot 项目环境就差不多了，然后就是根据具体情况来扩展了。</p><p>结合前面的课程和以上的这些点，本节课手把手带领大家搭建一个实际项目开发中可用的 Spring Boot 架构。整个项目工程如下图所示，学习的时候，可以结合我的源码，这样效果会更好。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/651b62a918a5bc06073d701b8b296aed.jpeg" alt="工程架构"></p><h2 id="1-统一的数据封装">1. 统一的数据封装</h2><p>由于封装的 json 数据的类型不确定，所以在定义统一的 json 结构时，我们需要用到泛型。统一的 json 结构中属性包括数据、状态码、提示信息即可，构造方法可以根据实际业务需求做相应的添加即可，一般来说，应该有默认的返回结构，也应该有用户指定的返回结构。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 统一返回对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shengwu ni</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonResult</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">    <span class="keyword">private</span> String code;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 若没有数据返回，默认状态码为0，提示信息为：操作成功！</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JsonResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = <span class="string">"0"</span>;</span><br><span class="line">        <span class="keyword">this</span>.msg = <span class="string">"操作成功！"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 若没有数据返回，可以人为指定状态码和提示信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> code</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JsonResult</span><span class="params">(String code, String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有数据返回时，状态码为0，默认提示信息为：操作成功！</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JsonResult</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.code = <span class="string">"0"</span>;</span><br><span class="line">        <span class="keyword">this</span>.msg = <span class="string">"操作成功！"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有数据返回，状态码为0，人为指定提示信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JsonResult</span><span class="params">(T data, String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.code = <span class="string">"0"</span>;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用自定义异常作为参数传递状态码和提示信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msgEnum</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JsonResult</span><span class="params">(BusinessMsgEnum msgEnum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = msgEnum.code();</span><br><span class="line">        <span class="keyword">this</span>.msg = msgEnum.msg();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省去get和set方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家可以根据自己项目中所需要的一些东西，合理的修改统一结构中的字段信息。</p><h2 id="2-json的处理">2. json的处理</h2><p>Json 处理工具很多，比如阿里巴巴的 fastjson，不过 fastjson 对有些未知类型的 null 无法转成空字符串，这可能是 fastjson 自身的缺陷，可扩展性也不是太好，但是使用起来方便，使用的人也蛮多的。这节课里面我们主要集成 Spring Boot 自带的 jackson。主要是对 jackson 做一下对 null 的配置即可，然后就可以在项目中使用了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * jacksonConfig</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shengwu ni</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JacksonConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span>(ObjectMapper<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">ObjectMapper</span> <span class="title">jacksonObjectMapper</span>(<span class="title">Jackson2ObjectMapperBuilder</span> <span class="title">builder</span>) </span>&#123;</span><br><span class="line">        ObjectMapper objectMapper = builder.createXmlMapper(<span class="keyword">false</span>).build();</span><br><span class="line">        objectMapper.getSerializerProvider().setNullValueSerializer(<span class="keyword">new</span> JsonSerializer&lt;Object&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serialize</span><span class="params">(Object o, JsonGenerator jsonGenerator, SerializerProvider serializerProvider)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                jsonGenerator.writeString(<span class="string">""</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> objectMapper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里先不测试，等下面 swagger2 配置好了之后，我们一起来测试一下。</p><h2 id="3-swagger2在线可调式接口">3. swagger2在线可调式接口</h2><p>有了 swagger，开发人员不需要给其他人员提供接口文档，只要告诉他们一个 Swagger 地址，即可展示在线的 API 接口文档，除此之外，调用接口的人员还可以在线测试接口数据，同样地，开发人员在开发接口时，同样也可以利用 Swagger 在线接口文档测试接口数据，这给开发人员提供了便利。使用 swagger 需要对其进行配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * swagger配置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shengwu ni</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger</span>2</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">createRestApi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                <span class="comment">// 指定构建api文档的详细信息的方法：apiInfo()</span></span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                <span class="comment">// 指定要生成api接口的包路径，这里把controller作为包路径，生成controller中的所有接口</span></span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="string">"com.itcodai.course18.controller"</span>))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建api文档的详细信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ApiInfo <span class="title">apiInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiInfoBuilder()</span><br><span class="line">                <span class="comment">// 设置页面标题</span></span><br><span class="line">                .title(<span class="string">"Spring Boot搭建实际项目中开发的架构"</span>)</span><br><span class="line">                <span class="comment">// 设置接口描述</span></span><br><span class="line">                .description(<span class="string">"跟武哥一起学Spring Boot第18课"</span>)</span><br><span class="line">                <span class="comment">// 设置联系方式</span></span><br><span class="line">                .contact(<span class="string">"倪升武，"</span> + <span class="string">"微信公众号：程序员私房菜"</span>)</span><br><span class="line">                <span class="comment">// 设置版本</span></span><br><span class="line">                .version(<span class="string">"1.0"</span>)</span><br><span class="line">                <span class="comment">// 构建</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，可以先测试一下，写一个 Controller，弄一个静态的接口测试一下上面集成的内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Api</span>(value = <span class="string">"用户信息接口"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/getUser/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="meta">@ApiOperation</span>(value = <span class="string">"根据用户唯一标识获取用户信息"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> JsonResult&lt;User&gt; <span class="title">getUserInfo</span><span class="params">(@PathVariable @ApiParam(value = <span class="string">"用户唯一标识"</span>)</span> Long id) </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User(id, <span class="string">"倪升武"</span>, <span class="string">"123456"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JsonResult&lt;&gt;(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后启动项目，在浏览器中输入 <code>localhost:8080/swagger-ui.html</code> 即可看到 swagger 接口文档页面，调用一下上面这个接口，即可看到返回的 json 数据。</p><h2 id="4-持久层集成">4. 持久层集成</h2><p>每个项目中是必须要有持久层的，与数据库交互，这里我们主要来集成 mybatis，集成 mybatis 首先要在 application.yml 中进行配置。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务端口号</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据库地址</span></span><br><span class="line"><span class="attr">datasource:</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">localhost:3306/blog_test</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span> <span class="comment"># 数据库配置</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://$&#123;datasource.url&#125;?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;allowMultiQueries=true&amp;autoReconnect=true&amp;failOverReadOnly=false&amp;maxReconnects=10</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">hikari:</span></span><br><span class="line">      <span class="attr">maximum-pool-size:</span> <span class="number">10</span> <span class="comment"># 最大连接池数</span></span><br><span class="line">      <span class="attr">max-lifetime:</span> <span class="number">1770000</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="comment"># 指定别名设置的包为所有entity</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.itcodai.course18.entity</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">map-underscore-to-camel-case:</span> <span class="literal">true</span> <span class="comment"># 驼峰命名规范</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="comment"># mapper映射文件位置</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">classpath:mapper/*.xml</span></span><br></pre></td></tr></table></figure><p>配置好了之后，接下来我们来写一下 dao 层，实际中我们使用注解比较多，因为比较方便，当然也可以使用 xml 的方式，甚至两种同时使用都行，这里我们主要使用注解的方式来集成，关于 xml 的方式，大家可以查看前面课程，实际中根据项目情况来定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"select * from user where id = #&#123;id&#125;"</span>)</span><br><span class="line">    <span class="meta">@Results</span>(&#123;</span><br><span class="line">            <span class="meta">@Result</span>(property = <span class="string">"username"</span>, column = <span class="string">"user_name"</span>),</span><br><span class="line">            <span class="meta">@Result</span>(property = <span class="string">"password"</span>, column = <span class="string">"password"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="function">User <span class="title">getUser</span><span class="params">(Long id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"select * from user where id = #&#123;id&#125; and user_name=#&#123;name&#125;"</span>)</span><br><span class="line">    <span class="function">User <span class="title">getUserByIdAndName</span><span class="params">(@Param(<span class="string">"id"</span>)</span> Long id, @<span class="title">Param</span><span class="params">(<span class="string">"name"</span>)</span> String username)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"select * from user"</span>)</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">getAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于 service 层我就不在文章中写代码了，大家可以结合我的源代码学习，这一节主要带领大家来搭建一个 Spring Boot 空架构。最后别忘了在启动类上添加注解扫描 <code>@MapperScan(&quot;com.itcodai.course18.dao&quot;)</code></p><h2 id="5-拦截器">5. 拦截器</h2><p>拦截器在项目中使用的是非常多的（但不是绝对的），比如拦截一些置顶的 url，做一些判断和处理等等。除此之外，还需要将常用的静态页面或者 swagger 页面放行，不能将这些静态资源给拦截了。首先先自定义一个拦截器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(MyInterceptor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">"执行方法之前执行(Controller方法调用之前)"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"执行完方法之后进执行(Controller方法调用之后)，但是此时还没进行视图渲染"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"整个请求都处理完咯，DispatcherServlet也渲染了对应的视图咯，此时我可以做一些清理的工作了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后将自定义的拦截器加入到拦截器配置中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptorConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实现WebMvcConfigurer不会导致静态资源被拦截</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> MyInterceptor())</span><br><span class="line">                <span class="comment">// 拦截所有url</span></span><br><span class="line">                .addPathPatterns(<span class="string">"/**"</span>)</span><br><span class="line">                <span class="comment">// 放行swagger</span></span><br><span class="line">                .excludePathPatterns(<span class="string">"/swagger-resources/**"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Spring Boot 中，我们通常会在如下目录里存放一些静态资源：</p><blockquote><p>classpath:/static<br>classpath:/public<br>classpath:/resources<br>classpath:/META-INF/resources</p></blockquote><p>上面代码中配置的 <code>/**</code> 是对所有 url 都进行了拦截，但我们实现了 WebMvcConfigurer 接口，不会导致 Spring Boot 对上面这些目录下的静态资源实施拦截。但是我们平时访问的 swagger 会被拦截，所以要将其放行。swagger 页面在 swagger-resources 目录下，放行该目录下所有文件即可。</p><p>然后在浏览器中输入一下 swagger 页面，若能正常显示 swagger，说明放行成功。同时可以根据后台打印的日志判断代码执行的顺序。</p><h2 id="6-全局异常处理">6. 全局异常处理</h2><p>全局异常处理是每个项目中必须用到的东西，在具体的异常中，我们可能会做具体的处理，但是对于没有处理的异常，一般会有一个统一的全局异常处理。在异常处理之前，最好维护一个异常提示信息枚举类，专门用来保存异常提示信息的。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> BusinessMsgEnum &#123;</span><br><span class="line">    <span class="comment">/** 参数异常 */</span></span><br><span class="line">    PARMETER_EXCEPTION(<span class="string">"102"</span>, <span class="string">"参数异常!"</span>),</span><br><span class="line">    <span class="comment">/** 等待超时 */</span></span><br><span class="line">    SERVICE_TIME_OUT(<span class="string">"103"</span>, <span class="string">"服务调用超时！"</span>),</span><br><span class="line">    <span class="comment">/** 参数过大 */</span></span><br><span class="line">    PARMETER_BIG_EXCEPTION(<span class="string">"102"</span>, <span class="string">"输入的图片数量不能超过50张!"</span>),</span><br><span class="line">    <span class="comment">/** 500 : 发生异常 */</span></span><br><span class="line">    UNEXPECTED_EXCEPTION(<span class="string">"500"</span>, <span class="string">"系统发生异常，请联系管理员！"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String code;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">BusinessMsgEnum</span><span class="params">(String code, String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">code</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">msg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在全局统一异常处理类中，我们一般会对自定义的业务异常最先处理，然后去处理一些常见的系统异常，最后会来一个一劳永逸（Exception 异常）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拦截业务异常，返回业务异常信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(BusinessErrorException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseStatus</span>(<span class="title">value</span> </span>= HttpStatus.INTERNAL_SERVER_ERROR)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> JsonResult <span class="title">handleBusinessError</span><span class="params">(BusinessErrorException ex)</span> </span>&#123;</span><br><span class="line">        String code = ex.getCode();</span><br><span class="line">        String message = ex.getMessage();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JsonResult(code, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 空指针异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ex NullPointerException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(NullPointerException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseStatus</span>(<span class="title">value</span> </span>= HttpStatus.INTERNAL_SERVER_ERROR)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> JsonResult <span class="title">handleTypeMismatchException</span><span class="params">(NullPointerException ex)</span> </span>&#123;</span><br><span class="line">        logger.error(<span class="string">"空指针异常，&#123;&#125;"</span>, ex.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JsonResult(<span class="string">"500"</span>, <span class="string">"空指针异常了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 系统异常 预期以外异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseStatus</span>(<span class="title">value</span> </span>= HttpStatus.INTERNAL_SERVER_ERROR)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> JsonResult <span class="title">handleUnexpectedServer</span><span class="params">(Exception ex)</span> </span>&#123;</span><br><span class="line">        logger.error(<span class="string">"系统异常："</span>, ex);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JsonResult(BusinessMsgEnum.UNEXPECTED_EXCEPTION);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，BusinessErrorException 是自定义的业务异常，继承一下 RuntimeException 即可，具体可以看我的源代码，文章中就不贴代码了。<br>在 UserController 中有个 testException 方法，用来测试全局异常的，打开 swagger 页面，调用一下该接口，可以看出返回用户提示信息：”系统发生异常，请联系管理员！“。当然了，实际情况中，需要根据不同的业务提示不同的信息。</p><h2 id="7-总结">7. 总结</h2><p>本文主要手把手带领大家快速搭建一个项目中可以使用的 Spring Boot 空架构，主要从统一封装的数据结构、可调式的接口、json的处理、模板引擎的使用（代码中体现）、持久层的集成、拦截器和全局异常处理。一般包括这些东西的话，基本上一个 Spring Boot 项目环境就差不多了，然后就是根据具体情况来扩展了。</p><p>课程源代码下载地址：<a href="https://gitee.com/eson15/springboot_study" target="_blank" rel="noopener">戳我下载</a></p><p>tAll();<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">关于 service 层我就不在文章中写代码了，大家可以结合我的源代码学习，这一节主要带领大家来搭建一个 Spring Boot 空架构。最后别忘了在启动类上添加注解扫描 &#96;@MapperScan(&quot;com.itcodai.course18.dao&quot;)&#96;</span><br><span class="line"></span><br><span class="line">## 5. 拦截器</span><br><span class="line"></span><br><span class="line">拦截器在项目中使用的是非常多的（但不是绝对的），比如拦截一些置顶的 url，做一些判断和处理等等。除此之外，还需要将常用的静态页面或者 swagger 页面放行，不能将这些静态资源给拦截了。首先先自定义一个拦截器。</span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">public class MyInterceptor implements HandlerInterceptor &#123;</span><br><span class="line"></span><br><span class="line">    private static final Logger logger &#x3D; LoggerFactory.getLogger(MyInterceptor.class);</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        logger.info(&quot;执行方法之前执行(Controller方法调用之前)&quot;);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;</span><br><span class="line">        logger.info(&quot;执行完方法之后进执行(Controller方法调用之后)，但是此时还没进行视图渲染&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;</span><br><span class="line">        logger.info(&quot;整个请求都处理完咯，DispatcherServlet也渲染了对应的视图咯，此时我可以做一些清理的工作了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后将自定义的拦截器加入到拦截器配置中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptorConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实现WebMvcConfigurer不会导致静态资源被拦截</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> MyInterceptor())</span><br><span class="line">                <span class="comment">// 拦截所有url</span></span><br><span class="line">                .addPathPatterns(<span class="string">"/**"</span>)</span><br><span class="line">                <span class="comment">// 放行swagger</span></span><br><span class="line">                .excludePathPatterns(<span class="string">"/swagger-resources/**"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Spring Boot 中，我们通常会在如下目录里存放一些静态资源：</p><blockquote><p>classpath:/static<br>classpath:/public<br>classpath:/resources<br>classpath:/META-INF/resources</p></blockquote><p>上面代码中配置的 <code>/**</code> 是对所有 url 都进行了拦截，但我们实现了 WebMvcConfigurer 接口，不会导致 Spring Boot 对上面这些目录下的静态资源实施拦截。但是我们平时访问的 swagger 会被拦截，所以要将其放行。swagger 页面在 swagger-resources 目录下，放行该目录下所有文件即可。</p><p>然后在浏览器中输入一下 swagger 页面，若能正常显示 swagger，说明放行成功。同时可以根据后台打印的日志判断代码执行的顺序。</p><h2 id="6-全局异常处理-v2">6. 全局异常处理</h2><p>全局异常处理是每个项目中必须用到的东西，在具体的异常中，我们可能会做具体的处理，但是对于没有处理的异常，一般会有一个统一的全局异常处理。在异常处理之前，最好维护一个异常提示信息枚举类，专门用来保存异常提示信息的。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> BusinessMsgEnum &#123;</span><br><span class="line">    <span class="comment">/** 参数异常 */</span></span><br><span class="line">    PARMETER_EXCEPTION(<span class="string">"102"</span>, <span class="string">"参数异常!"</span>),</span><br><span class="line">    <span class="comment">/** 等待超时 */</span></span><br><span class="line">    SERVICE_TIME_OUT(<span class="string">"103"</span>, <span class="string">"服务调用超时！"</span>),</span><br><span class="line">    <span class="comment">/** 参数过大 */</span></span><br><span class="line">    PARMETER_BIG_EXCEPTION(<span class="string">"102"</span>, <span class="string">"输入的图片数量不能超过50张!"</span>),</span><br><span class="line">    <span class="comment">/** 500 : 发生异常 */</span></span><br><span class="line">    UNEXPECTED_EXCEPTION(<span class="string">"500"</span>, <span class="string">"系统发生异常，请联系管理员！"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String code;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">BusinessMsgEnum</span><span class="params">(String code, String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">code</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">msg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在全局统一异常处理类中，我们一般会对自定义的业务异常最先处理，然后去处理一些常见的系统异常，最后会来一个一劳永逸（Exception 异常）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拦截业务异常，返回业务异常信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(BusinessErrorException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseStatus</span>(<span class="title">value</span> </span>= HttpStatus.INTERNAL_SERVER_ERROR)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> JsonResult <span class="title">handleBusinessError</span><span class="params">(BusinessErrorException ex)</span> </span>&#123;</span><br><span class="line">        String code = ex.getCode();</span><br><span class="line">        String message = ex.getMessage();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JsonResult(code, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 空指针异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ex NullPointerException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(NullPointerException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseStatus</span>(<span class="title">value</span> </span>= HttpStatus.INTERNAL_SERVER_ERROR)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> JsonResult <span class="title">handleTypeMismatchException</span><span class="params">(NullPointerException ex)</span> </span>&#123;</span><br><span class="line">        logger.error(<span class="string">"空指针异常，&#123;&#125;"</span>, ex.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JsonResult(<span class="string">"500"</span>, <span class="string">"空指针异常了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 系统异常 预期以外异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseStatus</span>(<span class="title">value</span> </span>= HttpStatus.INTERNAL_SERVER_ERROR)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> JsonResult <span class="title">handleUnexpectedServer</span><span class="params">(Exception ex)</span> </span>&#123;</span><br><span class="line">        logger.error(<span class="string">"系统异常："</span>, ex);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JsonResult(BusinessMsgEnum.UNEXPECTED_EXCEPTION);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，BusinessErrorException 是自定义的业务异常，继承一下 RuntimeException 即可，具体可以看我的源代码，文章中就不贴代码了。<br>在 UserController 中有个 testException 方法，用来测试全局异常的，打开 swagger 页面，调用一下该接口，可以看出返回用户提示信息：”系统发生异常，请联系管理员！“。当然了，实际情况中，需要根据不同的业务提示不同的信息。</p><h2 id="7-总结-v2">7. 总结</h2><p>本文主要手把手带领大家快速搭建一个项目中可以使用的 Spring Boot 空架构，主要从统一封装的数据结构、可调式的接口、json的处理、模板引擎的使用（代码中体现）、持久层的集成、拦截器和全局异常处理。一般包括这些东西的话，基本上一个 Spring Boot 项目环境就差不多了，然后就是根据具体情况来扩展了。</p><p>课程源代码下载地址：<a href="https://gitee.com/eson15/springboot_study" target="_blank" rel="noopener">戳我下载</a></p>]]></content>
    
    
    <summary type="html">&lt;h1&gt;导读：课程概览&lt;/h1&gt;
&lt;h2 id=&quot;1-Spring-Boot是什么&quot;&gt;1. Spring Boot是什么&lt;/h2&gt;
&lt;p&gt;我们知道，从 2002 年开始，Spring 一直在飞速的发展，如今已经成为了在Java EE（Java Enterprise Edition）开发中真正意义上的标准，但是随着技术的发展，Java EE使用 Spring 逐渐变得笨重起来，大量的 XML 文件存在于项目之中。&lt;strong&gt;繁琐的配置，整合第三方框架的配置问题，导致了开发和部署效率的降低&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://www.shawn22.xyz/categories/Java/"/>
    
    
    <category term="SpringBoot" scheme="https://www.shawn22.xyz/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Shiro1.9学习笔记</title>
    <link href="https://www.shawn22.xyz/posts/8b3a3556.html"/>
    <id>https://www.shawn22.xyz/posts/8b3a3556.html</id>
    <published>2023-03-05T16:17:57.000Z</published>
    <updated>2023-03-05T16:30:19.166Z</updated>
    
    <content type="html"><![CDATA[<h1>一、Shiro概述</h1><h2 id="1、Shiro简介">1、Shiro简介</h2><h3 id="1-1-介绍">1.1 介绍</h3><blockquote><p>官网：<a href="https://shiro.apache.org/" target="_blank" rel="noopener" title="https://shiro.apache.org/">https://shiro.apache.org/</a></p></blockquote><p>Apache Shiro 是一个功能强大且易于使用的 Java 安全(权限)框架。Shiro 可以完成：认证、授权、加密、会话管理、与 Web 集成、缓存 等。借助 Shiro 您可以快速轻松地保护任何应用程序——从最小的移动应用程序到最大的 Web 和企业应用程序。</p><a id="more"></a><h3 id="1-2-Shiro特点">1.2 Shiro特点</h3><ul><li>易于使用：使用 Shiro 构建系统安全框架非常简单。就算第一次接触也可以快速掌握</li><li>全面：Shiro 包含系统安全框架需要的功能，满足安全需求的“一站式服务”</li><li>灵活：Shiro 可以在任何应用程序环境中工作。虽然它可以在 Web、EJB 和 IoC 环境中工作，但不需要依赖它们。Shiro 也没有强制要求任何规范，甚至没有很多依赖项</li><li>强力支持 Web：Shiro 具有出色的 Web 应用程序支持，可以基于应用程序 URL 和 Web 协议（例如 REST）创建灵活的安全策略，同时还提供一组 JSP 库来控制页面输出</li><li>兼容性强：Shiro 的设计模式使其易于与其他框架和应用程序集成。Shiro 与 Spring、Grails、Wicket、Tapestry、Mule、Apache Camel、Vaadin 等框架无缝集成</li><li>社区支持：Shiro 是 Apache 软件基金会的一个开源项目，有完备的社区支持，文档支持。如果需要，像 Katasoft 这样的商业公司也会提供专业的支持和服务</li></ul><h2 id="2、Shiro与SpringSecurity的对比">2、Shiro与SpringSecurity的对比</h2><blockquote><p>SpringSecurity参考：<a href="https://blog.csdn.net/lemon_TT/article/details/124675493" target="_blank" rel="noopener" title="Spring Security学习笔记">Spring Security学习笔记</a></p></blockquote><ul><li>Spring Security 基于 Spring 开发，项目若使用 Spring 作为基础，配合 Spring Security 做权限更加方便，而 Shiro 需要和 Spring 进行整合开发；</li><li>Spring Security 功能比 Shiro 更加丰富些，例如安全维护方面；</li><li>Spring Security 社区资源相对比 Shiro 更加丰富；</li><li>Shiro 的配置和使用比较简单，Spring Security 上手复杂些；</li><li>Shiro 依赖性低，不需要任何框架和容器，可以独立运行。Spring Security 依赖 Spring 容器；</li><li>shiro 不仅仅可以使用在 web 中，它可以工作在任何应用环境中。在集群会话时 Shiro 最重要的一个好处或许就是它的会话是独立于容器的</li></ul><h2 id="3、Shiro基本功能">3、Shiro基本功能</h2><p><img src="https://img-blog.csdnimg.cn/b6bdec1b05374474af540cb7f2b46c26.png#pic_center" alt="在这里插入图片描述"></p><ul><li><strong>Authentication</strong>：身份认证/登录，验证用户是不是拥有相应的身份；</li><li><strong>Authorization</strong>：授权，即权限验证，验证某个已认证的用户是否拥有某个权限；即判断用 户是否能进行什么操作，如：验证某个用户是否拥有某个角色。或者细粒度的验证某个用户 对某个资源是否具有某个权限；</li><li>Session Manager：会话管理，即用户登录后就是一次会话，在没有退出之前，它的所有信息都在会话中；会话可以是普通 JavaSE 环境，也可以是 Web 环境的；</li><li><strong>Cryptography</strong>：加密，保护数据的安全性，如密码加密存储到数据库，而不是明文存储；</li><li>Web Support：Web 支持，可以非常容易的集成到 Web 环境；</li><li>Caching：缓存，比如用户登录后，其用户信息、拥有的角色/权限不必每次去查，这样可以提高效率；</li><li>Concurrency：Shiro 支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能把权限自动传播过去；</li><li>Testing：提供测试支持；</li><li>Run As：允许一个用户假装为另一个用户（如果他们允许）的身份进行访问；</li><li>Remember Me：记住我，这个是非常常见的功能，即一次登录后，下次再来的话不用登录了</li></ul><h2 id="4、Shiro原理">4、Shiro原理</h2><h3 id="4-1-Shiro-架构-外部">4.1 Shiro 架构(外部)</h3><p>从外部来看 Shiro ，即从应用程序角度的来观察如何使用Shiro 完成工作</p><p><img src="https://img-blog.csdnimg.cn/841908a9635940fbad8820c8cc41b28f.png#pic_center" alt="在这里插入图片描述"></p><ul><li><code>Subject</code>：应用代码直接交互的对象是 Subject，也就是说 Shiro 的对外 API 核心 就是 Subject。Subject 代表了当前“用户”， 这个用户不一定 是一个具体的人，与当前应用交互的任何东西都是 Subject，如网络爬虫， 机器人等；与 Subject 的所有交互都会委托给 SecurityManager； Subject 其实是一个门面，SecurityManager 才是实际的执行者；</li><li><code>SecurityManager</code>：安全管理器；即所有与安全有关的操作都会与 SecurityManager交互；且其管理着所有 Subject；可以看出它是** Shiro 的核心**，它负责与 Shiro 的其他组件进行交互，它相当于 SpringMVC 中 DispatcherServlet 的角色</li><li><code>Realm</code>：Shiro 从 Realm 获取安全数据（如用户、角色、权限），就是说SecurityManager 要验证用户身份，那么它需要从 Realm 获取相应的用户 进行比较以确定用户身份是否合法；也需要从 Realm 得到用户相应的角色/ 权限进行验证用户是否能进行操作；<strong>可以把 Realm 看成 DataSource</strong></li></ul><h3 id="4-2-shiro架构-内部">4.2 shiro架构(内部)</h3><p><img src="https://img-blog.csdnimg.cn/da93879df56a448bb5550e68f364739f.png#pic_center" alt="在这里插入图片描述"></p><ul><li><code>Subject</code>：任何可以与应用交互的“用户”；</li><li><code>SecurityManager</code> ：相当于 SpringMVC 中的 DispatcherServlet；是 Shiro 的心脏； 所有具体的交互都通过 SecurityManager 进行控制；它管理着所有 Subject、且负责进 行认证、授权、会话及缓存的管理。</li><li><code>Authenticator</code>：负责 Subject 认证，是一个扩展点，可以自定义实现；可以使用认证策略（Authentication Strategy），即什么情况下算用户认证通过了；</li><li><code>Authorizer</code>：授权器、即访问控制器，用来决定主体是否有权限进行相应的操作；即控制着用户能访问应用中的哪些功能；</li><li><code>Realm</code>：可以有 1 个或多个 Realm，可以认为是安全实体数据源，即用于获取安全实体的；可以是 JDBC 实现，也可以是内存实现等等；由用户提供；所以一般在应用中都需要实现自己的 Realm；</li><li><code>SessionManager</code>：管理 Session 生命周期的组件；而 Shiro 并不仅仅可以用在 Web环境，也可以用在如普通的 JavaSE 环境</li><li><code>CacheManager</code>：缓存控制器，来管理如用户、角色、权限等的缓存的；因为这些数据 基本上很少改变，放到缓存中后可以提高访问的性能</li><li><code>Cryptography</code>：密码模块，Shiro 提高了一些常见的加密组件用于如密码加密/解密。</li></ul><h1>二、Shiro基本使用</h1><h2 id="1、环境准备">1、环境准备</h2><p>引入shiro依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>创建ini文件，因为Shiro获取权限相关信息可以通过数据库获取，也可以通过ini配置文件获取，后期放数据库</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[users]</span></span><br><span class="line"><span class="attr">shawn</span>=<span class="number">123456</span></span><br><span class="line"><span class="attr">leo</span>=<span class="number">123456</span></span><br></pre></td></tr></table></figure><h2 id="2、登录认证">2、登录认证</h2><h3 id="2-1-登录认证概念">2.1 登录认证概念</h3><ul><li>身份验证：一般需要提供如身份ID等一些标识信息来表明登录者的身份，如提供email，用户名/密码来证明</li><li>在shiro中，用户需要提供**principals（身份）**和credentials（证明）给shiro，从而应用能验证用户身份</li><li>principals：身份，即主体的标识属性，可以是任何属性，如用户名、邮箱等，唯一即可。一个主体可以有多个principals，但<strong>只有一个Primary principals</strong>，一般是用户名/邮箱/手机号</li><li>credentials：证明/凭证，即只有主体知道的安全值，如密码/数字证书等。</li><li>最常见的principals和credentials组合就是用户名/密码</li></ul><h3 id="2-2-登录认证基本流程">2.2 登录认证基本流程</h3><ul><li>收集用户身份/凭证，即如用户名/密码</li><li>调用 <code>Subject.login</code> 进行登录，如果失败将得到相应 的 <code>AuthenticationException</code>异常，根据异常提示用户错误信息；否则登录成功</li><li>创建自定义的 <code>Realm</code>类，继承 <code>org.apache.shiro.realm.AuthenticatingRealm</code>类,实现 <code>doGetAuthenticationInfo()</code> 方法</li></ul><h3 id="2-3-登录认证实例">2.3 登录认证实例</h3><ul><li>初始化获取SecurityManager</li><li>获取subject对象</li><li>创建token对象，web应用用户名密码从页面传递</li><li>完成登录</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//1初始化获取SecurityManager</span></span><br><span class="line">       Factory&lt;SecurityManager&gt; factory = <span class="keyword">new</span> IniSecurityManagerFactory(<span class="string">"classpath:shiro.ini"</span>);</span><br><span class="line">       SecurityManager securityManager = factory.getInstance();</span><br><span class="line">       SecurityUtils.setSecurityManager(securityManager);</span><br><span class="line">       <span class="comment">//2获取Subject对象</span></span><br><span class="line">       Subject subject = SecurityUtils.getSubject();</span><br><span class="line">       <span class="comment">//3创建token对象，web应用用户名密码从页面传递</span></span><br><span class="line">       AuthenticationToken token = <span class="keyword">new</span> UsernamePasswordToken(<span class="string">"shawn"</span>,<span class="string">"123456"</span>);</span><br><span class="line">       <span class="comment">//4完成登录</span></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           subject.login(token);</span><br><span class="line">           System.out.println(<span class="string">"登录成功"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">catch</span> (UnknownAccountException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">           System.out.println(<span class="string">"用户不存在"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">catch</span> (IncorrectCredentialsException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">           System.out.println(<span class="string">"密码错误"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">catch</span> (AuthenticationException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-身份认证源码流程">2.4 身份认证源码流程</h3><ul><li>首先调用 <code>Subject.login(token) </code>进行登录，其会自动委托给 <code>SecurityManager</code></li><li><code>SecurityManager</code>负责真正的身份验证逻辑；它会委托给 <code>Authenticator</code>进行身份验证</li><li><strong>Authenticator 才是真正的身份验证者</strong>，Shiro API 中核心的身份 认证入口点，此处可以自定义插入自己的实现；</li><li>Authenticator 可能会委托给相应的 <code>AuthenticationStrategy </code>进 行多 Realm 身份验证，默认 <code>ModularRealmAuthenticator</code>会调用 <code>AuthenticationStrategy</code>进行多 Realm 身份验证；</li><li><strong>Authenticator 会把相应的 token 传入 Realm</strong>，从 Realm 获取 身份验证信息，如果没有返回/抛出异常表示身份验证失败了。此处可以配置多个Realm，将按照相应的顺序及策略进行访问。</li></ul><h2 id="3、角色与授权">3、角色与授权</h2><h3 id="3-1-授权概念">3.1 授权概念</h3><ul><li><strong>授权</strong>，也叫访问控制，即在应用中控制谁访问哪些资源（如访问页面/编辑数据/页面 操作等）。在授权中需了解的几个关键对象：<code>主体（Subject）</code>、<code>资源（Resource）</code>、<code>权限 （Permission）</code>、<code>角色（Role）</code></li><li><strong>主体(Subject)</strong>：访问应用的用户，在 Shiro 中使用 Subject 代表该用户。用户只有授权 后才允许访问相应的资源</li><li><strong>资源(Resource)</strong>：在应用中用户可以访问的 URL，比如访问 JSP 页面、查看/编辑 某些 数据、访问某个业务方法、打印文本等等都是资源。用户只要授权后才能访问</li><li><strong>权限(Permission)</strong>：安全策略中的原子授权单位，通过权限我们可以表示在应用中用户 有没有操作某个资源的权力。即权限表示在应用中用户能不能访问某个资源，如：访问用 户列表页面查看/新增/修改/删除用户数据（即很多时候都是CRUD（增查改删）式权限控 制）等。权限代表了用户有没有操作某个资源的权利，即反映在某个资源上的操作允不允 许。</li><li><strong>Shiro 支持粗粒度权限</strong>（如用户模块的所有权限）和细粒度权限（操作某个用户的权限， 即实例级别的）</li><li><strong>角色(Role)</strong>：<code>权限的集合</code>，一般情况下会赋予用户角色而不是权限，即这样用户可以拥有 一组权限，赋予权限时比较方便。典型的如：项目经理、技术总监、CTO、开发工程师等 都是角色，不同的角色拥有一组不同的权限</li></ul><h3 id="3-2-授权方式">3.2 授权方式</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编程式</span></span><br><span class="line">subject.hasRole(<span class="string">"admin"</span>)</span><br><span class="line"><span class="comment">//注解式</span></span><br><span class="line"><span class="meta">@RequiresRoles</span>(<span class="string">"admin"</span>)</span><br><span class="line"><span class="comment">// JSP/GSP 标签</span></span><br><span class="line">&lt;shiro:hasRole name=<span class="string">"admin"</span>&gt;</span><br><span class="line">&lt;/shiro:hasRole&gt;</span><br></pre></td></tr></table></figure><h3 id="3-3-授权流程">3.3 授权流程</h3><ul><li>首先调用Subject.isPermitted的<code>/hasRole</code>接口，其会委托给<code>SecurityManager</code>，而SecurityManager接着会委托给 Authorizer；</li><li><strong>Authorizer是真正的授权者</strong>，如果调用如isPermitted(“user:view”)，其首先会通过PermissionResolver把字符串转换成相应的Permission实例；</li><li>在进行授权之前，其会调用相应的Realm获取Subject相应的角色/权限用于匹配传入的角色/权限；</li><li>Authorizer会判断Realm的角色/权限是否和传入的匹配，如果有多个Realm，会委托给ModularRealmAuthorizer进行循环判断，如果匹配如isPermitted<code>/hasRole</code> 会返回 true，否则返回false表示授权失败</li></ul><h3 id="3-4-代码实例">3.4 代码实例</h3><p>首先修改resource下的<code>shiro.ini</code>文件</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[users]</span></span><br><span class="line"><span class="attr">zhangsan</span>=<span class="number">7174</span>f64b13022acd3c56e2781e098a5f</span><br><span class="line"><span class="attr">shawn</span>=<span class="number">123456</span>,role1,role2</span><br><span class="line"></span><br><span class="line"><span class="section">[roles]</span></span><br><span class="line"><span class="attr">role1</span>=user:insert,user:select</span><br></pre></td></tr></table></figure><p>修改主函数进行测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1初始化获取SecurityManager</span></span><br><span class="line">    DefaultSecurityManager securityManager=<span class="keyword">new</span> DefaultSecurityManager();</span><br><span class="line">    IniRealm iniRealm=<span class="keyword">new</span> IniRealm(<span class="string">"classpath:shiro.ini"</span>);</span><br><span class="line">    securityManager.setRealm(iniRealm);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其中 shiro.ini 在 resources 的根目录下，此方法已经过期</span></span><br><span class="line">    <span class="comment">// Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory("classpath:shiro.ini");</span></span><br><span class="line">    <span class="comment">// SecurityManager securityManager = factory.getInstance();</span></span><br><span class="line">    SecurityUtils.setSecurityManager(securityManager);</span><br><span class="line">    <span class="comment">//2获取Subject对象</span></span><br><span class="line">    Subject subject = SecurityUtils.getSubject();</span><br><span class="line">    <span class="comment">//3创建token对象，web应用用户名密码从页面传递</span></span><br><span class="line">    AuthenticationToken token = <span class="keyword">new</span> UsernamePasswordToken(<span class="string">"shawn"</span>,<span class="string">"123456"</span>);</span><br><span class="line">    <span class="comment">//4完成登录</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        subject.login(token);</span><br><span class="line">        System.out.println(<span class="string">"登录成功"</span>);</span><br><span class="line">        <span class="comment">//5判断角色</span></span><br><span class="line">        <span class="keyword">boolean</span> hasRole = subject.hasRole(<span class="string">"role1"</span>);</span><br><span class="line">        System.out.println(<span class="string">"是否拥有此角色 = "</span> + hasRole);</span><br><span class="line">        <span class="comment">//6判断权限</span></span><br><span class="line">        <span class="keyword">boolean</span> permitted = subject.isPermitted(<span class="string">"user:insert1111"</span>);</span><br><span class="line">        System.out.println(<span class="string">"是否拥有此权限 = "</span> + permitted);</span><br><span class="line">        <span class="comment">//也可以用checkPermission方法，但没有返回值，没权限抛AuthenticationException</span></span><br><span class="line">        subject.checkPermission(<span class="string">"user:select1111"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (UnknownAccountException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        System.out.println(<span class="string">"用户不存在"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IncorrectCredentialsException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        System.out.println(<span class="string">"密码错误"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (AuthenticationException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、Shiro加密">4、Shiro加密</h2><p>实际系统开发中，一些敏感信息需要进行加密，比如说用户的密码。Shiro 内嵌很多 常用的加密算法，比如 MD5 加密。Shiro 可以很简单的使用信息加密。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//密码明文</span></span><br><span class="line">    String password = <span class="string">"shawn"</span>;</span><br><span class="line">    <span class="comment">//使用md5加密</span></span><br><span class="line">    Md5Hash md5Hash = <span class="keyword">new</span> Md5Hash(password);</span><br><span class="line">    System.out.println(<span class="string">"md5加密 = "</span> + md5Hash.toHex());</span><br><span class="line">    <span class="comment">//带盐的md5加密，盐就是在密码明文后拼接新字符串，然后再进行加密</span></span><br><span class="line">    Md5Hash md5Hash2 = <span class="keyword">new</span> Md5Hash(password,<span class="string">"salt"</span>);</span><br><span class="line">    System.out.println(<span class="string">"带盐的md5加密 = "</span> + md5Hash2.toHex());</span><br><span class="line">    <span class="comment">//为了保证安全，避免被破解还可以多次迭代加密，保证数据安全</span></span><br><span class="line">    Md5Hash md5Hash3 = <span class="keyword">new</span> Md5Hash(password,<span class="string">"salt"</span>,<span class="number">3</span>);</span><br><span class="line">    System.out.println(<span class="string">"md5带盐的3次加密 = "</span> + md5Hash3.toHex());</span><br><span class="line">    <span class="comment">//使用父类进行加密</span></span><br><span class="line">    SimpleHash simpleHash = <span class="keyword">new</span> SimpleHash(</span><br><span class="line">            <span class="string">"MD5"</span>,password,<span class="string">"salt"</span>,<span class="number">3</span>);</span><br><span class="line">    System.out.println(<span class="string">"父类带盐的3次加密 = "</span> + simpleHash.toHex());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、自定义登陆认证">5、自定义登陆认证</h2><p>Shiro 默认的登录认证是不带加密的，如果想要实现加密认证需要自定义登录认证， 自定义 Realm；首先是创建自定义Realm</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRealm</span> <span class="keyword">extends</span> <span class="title">AuthenticatingRealm</span> </span>&#123;</span><br><span class="line">    <span class="comment">//自定义登录认证方法，shiro的login方法底层会调用该类的认证方法进行认证</span></span><br><span class="line">    <span class="comment">//需要配置自定义的realm生效，在ini文件中配置，在Springboot中配置</span></span><br><span class="line">    <span class="comment">//该方法只是获取进行对比的信息，认证逻辑还是按照shiro底层认证逻辑完成</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthenticationInfo <span class="title">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken authenticationToken)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        <span class="comment">//1获取身份信息</span></span><br><span class="line">        String principal = authenticationToken.getPrincipal().toString();</span><br><span class="line">        <span class="comment">//2获取凭证信息</span></span><br><span class="line">        String password = <span class="keyword">new</span> String((<span class="keyword">char</span>[])authenticationToken.getCredentials());</span><br><span class="line">        System.out.println(<span class="string">"认证用户信息："</span>+principal+<span class="string">"---"</span>+password);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3获取数据库中存储的用户信息</span></span><br><span class="line">        <span class="keyword">if</span>(principal.equals(<span class="string">"shawn"</span>))&#123;</span><br><span class="line">            <span class="comment">//3.1数据库中存储的加盐3次迭代的密码</span></span><br><span class="line">            <span class="comment">// 第二种方法密码，需要自己进行加密</span></span><br><span class="line"><span class="comment">//            String pwdInfo = "123456 ";</span></span><br><span class="line">            <span class="comment">// 第一种方法</span></span><br><span class="line">            String pwdInfo = <span class="string">"d1b129656359e35e95ebd56a63d7b9e0"</span>;</span><br><span class="line">            <span class="comment">//4创建封装校验逻辑对象，封装数据返回</span></span><br><span class="line">            AuthenticationInfo info = <span class="keyword">new</span> SimpleAuthenticationInfo(</span><br><span class="line">                    authenticationToken.getPrincipal(),</span><br><span class="line">                    pwdInfo,</span><br><span class="line">                    ByteSource.Util.bytes(<span class="string">"salt"</span>),</span><br><span class="line">                    authenticationToken.getPrincipal().toString()</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">return</span> info;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一种方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1初始化获取SecurityManager</span></span><br><span class="line">    Factory&lt;SecurityManager&gt; factory = <span class="keyword">new</span> IniSecurityManagerFactory(<span class="string">"classpath:shiro.ini"</span>);</span><br><span class="line">    SecurityManager securityManager = factory.getInstance();</span><br><span class="line">    SecurityUtils.setSecurityManager(securityManager);</span><br><span class="line">    <span class="comment">//2获取Subject对象</span></span><br><span class="line">    Subject subject = SecurityUtils.getSubject();</span><br><span class="line">    <span class="comment">//3创建token对象，web应用用户名密码从页面传递</span></span><br><span class="line">    AuthenticationToken token = <span class="keyword">new</span> UsernamePasswordToken(<span class="string">"shawn"</span>,<span class="string">"123456"</span>);</span><br><span class="line">    <span class="comment">//4完成登录</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        subject.login(token);</span><br><span class="line">        System.out.println(<span class="string">"登录成功"</span>);</span><br><span class="line">        <span class="comment">//5判断角色</span></span><br><span class="line">        <span class="keyword">boolean</span> hasRole = subject.hasRole(<span class="string">"role1"</span>);</span><br><span class="line">        System.out.println(<span class="string">"是否拥有此角色 = "</span> + hasRole);</span><br><span class="line">        <span class="comment">//6判断权限</span></span><br><span class="line">        <span class="keyword">boolean</span> permitted = subject.isPermitted(<span class="string">"user:insert1111"</span>);</span><br><span class="line">        System.out.println(<span class="string">"是否拥有此权限 = "</span> + permitted);</span><br><span class="line">        <span class="comment">//也可以用checkPermission方法，但没有返回值，没权限抛AuthenticationException</span></span><br><span class="line">        subject.checkPermission(<span class="string">"user:select1111"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (UnknownAccountException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        System.out.println(<span class="string">"用户不存在"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IncorrectCredentialsException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        System.out.println(<span class="string">"密码错误"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (AuthenticationException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时在Ini文件添加</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[main]</span></span><br><span class="line"><span class="attr">md5CredentialsMatcher</span>=org.apache.shiro.authc.credential.Md5CredentialsMatcher</span><br><span class="line"><span class="attr">md5CredentialsMatcher.hashIterations</span>=<span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="attr">myrealm</span>=com.atguigu.shirotest.MyRealm</span><br><span class="line"><span class="attr">myrealm.credentialsMatcher</span>=<span class="variable">$md5CredentialsMatcher</span></span><br><span class="line"><span class="attr">securityManager.realms</span>=<span class="variable">$myrealm</span></span><br></pre></td></tr></table></figure><p>第二种方法，新的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1初始化获取SecurityManager</span></span><br><span class="line">    DefaultSecurityManager securityManager=<span class="keyword">new</span> DefaultSecurityManager(<span class="keyword">new</span> MyRealm());</span><br><span class="line">    SecurityUtils.setSecurityManager(securityManager);</span><br><span class="line">    <span class="comment">//2获取Subject对象</span></span><br><span class="line">    Subject subject = SecurityUtils.getSubject();</span><br><span class="line">    <span class="comment">//3创建token对象，web应用用户名密码从页面传递</span></span><br><span class="line">    AuthenticationToken token = <span class="keyword">new</span> UsernamePasswordToken(<span class="string">"shawn"</span>,<span class="string">"123456"</span>);</span><br><span class="line">    <span class="comment">//4完成登录</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        subject.login(token);</span><br><span class="line">        System.out.println(<span class="string">"登录成功"</span>);</span><br><span class="line">        <span class="comment">//5判断角色</span></span><br><span class="line">        <span class="keyword">boolean</span> hasRole = subject.hasRole(<span class="string">"role1"</span>);</span><br><span class="line">        System.out.println(<span class="string">"是否拥有此角色 = "</span> + hasRole);</span><br><span class="line">        <span class="comment">//6判断权限</span></span><br><span class="line">        <span class="keyword">boolean</span> permitted = subject.isPermitted(<span class="string">"user:insert1111"</span>);</span><br><span class="line">        System.out.println(<span class="string">"是否拥有此权限 = "</span> + permitted);</span><br><span class="line">        <span class="comment">//也可以用checkPermission方法，但没有返回值，没权限抛AuthenticationException</span></span><br><span class="line">        subject.checkPermission(<span class="string">"user:select1111"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (UnknownAccountException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        System.out.println(<span class="string">"用户不存在"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IncorrectCredentialsException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        System.out.println(<span class="string">"密码错误"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (AuthenticationException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>三、Shiro整合Springboot</h1><h2 id="1、登录认证准备">1、登录认证准备</h2><h3 id="1-1-环境准备">1.1 环境准备</h3><p>首先创建SpringBoot脚手架项目，导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-spring-boot-web-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--mybatis-plus--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--mysql--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.30<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置Thymeleaf与Shrio的整合依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.theborakompanioni<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>thymeleaf-extras-shiro<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--Shiro整合EhCache--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-ehcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.10.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.11.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Mysql脚本，配置好mysql</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="string">`shirodb`</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8mb4;</span><br><span class="line"><span class="keyword">USE</span> <span class="string">`shirodb`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`user`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'编号'</span>,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户名'</span>,</span><br><span class="line">  <span class="string">`pwd`</span> <span class="built_in">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'密码'</span>,</span><br><span class="line">  <span class="string">`rid`</span> <span class="built_in">BIGINT</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'角色编号'</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span>(<span class="string">`id`</span>) </span><br><span class="line">) <span class="keyword">ENGINE</span> = <span class="keyword">INNODB</span> AUTO_INCREMENT = <span class="number">2</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span> = utf8 <span class="keyword">COMMENT</span> = <span class="string">'用户表'</span>;</span><br></pre></td></tr></table></figure><p>配置application.yaml文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mapper/*.xml</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.zaxxer.hikari.HikariDataSource</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/shirodb?characterEncoding=utf-8&amp;useSSL=false</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">  <span class="attr">jackson:</span></span><br><span class="line">    <span class="attr">date-format:</span> <span class="string">yyyy-MM-dd</span> <span class="string">HH:mm:ss</span></span><br><span class="line">    <span class="attr">time-zone:</span> <span class="string">GMT+8</span></span><br><span class="line"><span class="comment"># 未认证的请求重定向地址</span></span><br><span class="line"><span class="attr">shiro:</span></span><br><span class="line">  <span class="attr">loginUrl:</span> <span class="string">/myController/login</span></span><br></pre></td></tr></table></figure><h3 id="1-2-后端整合">1.2 后端整合</h3><p>创建各个模块和类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实体类</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String pwd;</span><br><span class="line">    <span class="keyword">private</span> Integer rid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Mapper层</span></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Service层，接口类自己定义(方法抽取一下即可)</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUserInfoByName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">        wrapper.eq(<span class="string">"name"</span>,name);</span><br><span class="line">        User user = userMapper.selectOne(wrapper);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// controller层</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"myController"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username 用户名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> password 密码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> String&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"userLogin"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(@RequestParam(<span class="string">"username"</span>)</span> String username, @<span class="title">RequestParam</span><span class="params">(<span class="string">"password"</span>)</span> String password)</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 默认30分钟过期</span></span><br><span class="line">        <span class="comment">//永不过期,在登陆最开始加上</span></span><br><span class="line">        <span class="comment">//SecurityUtils.getSubject().getSession().setTimeout(-1000L);</span></span><br><span class="line">        <span class="comment">//其他时间 单位毫秒</span></span><br><span class="line">        <span class="comment">//SecurityUtils.getSubject().getSession().setTimeout(1800000);</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        Subject subject = SecurityUtils.getSubject();</span><br><span class="line">        UsernamePasswordToken usernamePasswordToken = <span class="keyword">new</span> UsernamePasswordToken(username, password);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            subject.login(usernamePasswordToken);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建自定义realm</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRealm</span> <span class="keyword">extends</span> <span class="title">AuthorizingRealm</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义授权</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> principals 权限</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> AuthorizationInfo&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthorizationInfo <span class="title">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义身份验证</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token 令牌</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> AuthenticationInfo&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> AuthenticationException 身份验证异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthenticationInfo <span class="title">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        <span class="comment">//1. 获取用户身份信息</span></span><br><span class="line">        String name = token.getPrincipal().toString();</span><br><span class="line">        <span class="comment">//2. 调用业务层获取用户信息</span></span><br><span class="line">        User user = userService.getUserInfoByName(name);</span><br><span class="line">        <span class="comment">//3. 非空判断,将数据封装返回</span></span><br><span class="line">        <span class="keyword">if</span> (user != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SimpleAuthenticationInfo(</span><br><span class="line">                    token.getPrincipal(),</span><br><span class="line">                    user.getPwd(),</span><br><span class="line">                    ByteSource.Util.bytes(<span class="string">"salt"</span>),</span><br><span class="line">                    name</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShiroConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyRealm myRealm;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置SecurityManager</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DefaultWebSecurityManager <span class="title">defaultWebSecurityManager</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//1创建defaultWebSecurityManager 对象</span></span><br><span class="line">        DefaultWebSecurityManager defaultWebSecurityManager = <span class="keyword">new</span> DefaultWebSecurityManager();</span><br><span class="line">        <span class="comment">//2创建加密对象，设置相关属性</span></span><br><span class="line">        HashedCredentialsMatcher matcher = <span class="keyword">new</span> HashedCredentialsMatcher();</span><br><span class="line">        <span class="comment">//2.1采用md5加密</span></span><br><span class="line">        matcher.setHashAlgorithmName(<span class="string">"md5"</span>);</span><br><span class="line">        <span class="comment">//2.2迭代加密次数</span></span><br><span class="line">        matcher.setHashIterations(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//3将加密对象存储到myRealm中</span></span><br><span class="line">        myRealm.setCredentialsMatcher(matcher);</span><br><span class="line">        <span class="comment">//4将myRealm存入defaultWebSecurityManager 对象</span></span><br><span class="line">        defaultWebSecurityManager.setRealm(myRealm);</span><br><span class="line">        <span class="comment">//5返回</span></span><br><span class="line">        <span class="keyword">return</span> defaultWebSecurityManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置Shiro内置过滤器拦截范围</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DefaultShiroFilterChainDefinition <span class="title">shiroFilterChainDefinition</span><span class="params">()</span></span>&#123;</span><br><span class="line">        DefaultShiroFilterChainDefinition definition = <span class="keyword">new</span> DefaultShiroFilterChainDefinition();</span><br><span class="line">        <span class="comment">//设置不认证可以访问的资源</span></span><br><span class="line">        definition.addPathDefinition(<span class="string">"/myController/userLogin"</span>,<span class="string">"anon"</span>);</span><br><span class="line">        definition.addPathDefinition(<span class="string">"/myController/login"</span>,<span class="string">"anon"</span>);</span><br><span class="line">        <span class="comment">//设置需要进行登录认证的拦截范围</span></span><br><span class="line">        definition.addPathDefinition(<span class="string">"/**"</span>,<span class="string">"authc"</span>);</span><br><span class="line">        <span class="keyword">return</span>  definition;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-前端thymeleaf整合">1.3 前端thymeleaf整合</h3><p>引入thymeleaf依赖后，在<code>resource/templares</code>创建<code>login.html</code>和<code>main.html</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--login.html--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Shiro 登录认证<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/myController/userLogin"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"登录"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--main.html--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    Shiro 登录认证后主页面<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    登录用户为： <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;session.user&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>改造controller，让其返回走视图处理器，去除@ResponseBody</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"myController"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//跳转登录页面</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"login"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"login"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"userLogin"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(@RequestParam(<span class="string">"username"</span>)</span> String username, @<span class="title">RequestParam</span><span class="params">(<span class="string">"password"</span>)</span> String password,HttpSession session)</span>&#123;</span><br><span class="line">        <span class="comment">//1 获取  Subject 对象</span></span><br><span class="line">        Subject subject = SecurityUtils.getSubject();</span><br><span class="line">        <span class="comment">//2 封装请求数据到 token 对象中</span></span><br><span class="line">        AuthenticationToken token = <span class="keyword">new</span> UsernamePasswordToken(username,password);</span><br><span class="line">        <span class="comment">//3 调用  login 方法进行登录认证</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            subject.login(token);</span><br><span class="line">            session.setAttribute(<span class="string">"user"</span>,token.getPrincipal().toString());</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"main"</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AuthenticationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">"登录失败"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"登录失败"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、多-realm-认证策略">2、多 realm 认证策略</h2><h3 id="2-1-实现原理">2.1 实现原理</h3><p>当应用程序配置多个 Realm 时，例如：<strong>用户名密码校验、手机号验证码校验等等</strong>。 Shiro 的 <code>ModularRealmAuthenticator </code>会使用内部的<code>AuthenticationStrategy </code>组件判断认证是成功还是失败。  </p><p><code>AuthenticationStrategy </code>是一个无状态的组件，它在身份验证尝试中被询问 4 次（这 4 次交互所需的任何必要的状态将被作为方法参数）：</p><ul><li>在所有 Realm 被调用之前</li><li>在调用 Realm 的 getAuthenticationInfo 方法之前</li><li>在调用 Realm 的 getAuthenticationInfo 方法之后</li><li>在所有 Realm 被调用之后</li></ul><p>认证策略的另外一项工作就是聚合所有 Realm 的结果信息封装至一个AuthenticationInfo 实例中，并将此信息返回，以此作为 Subject 的身份信息。Shiro 中定义了 3 种认证策略的实现：</p><table><thead><tr><th><strong>认证策略类</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>AtLeastOneSuccessfulStrategy</td><td>只要有一个（或更多）的 Realm 验证成功，那么认证将视为成功</td></tr><tr><td>FirstSuccessfulStrategy</td><td>第一个 Realm 验证成功，整体认证将视为成功，且后续 Realm 将被忽略</td></tr><tr><td>AllSuccessfulStrategy</td><td>所有 Realm 成功，认证才视为成功</td></tr></tbody></table><p><code>ModularRealmAuthenticator</code> 内置的认证策略默认实现是 <code>AtLeastOneSuccessfulStrategy</code> 方式。可以通过配置修改策略</p><h3 id="2-2-配置修改">2.2 配置修改</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DefaultWebSecurityManager <span class="title">defaultWebSecurityManager</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1 创建  defaultWebSecurityManager 对象</span></span><br><span class="line">    DefaultWebSecurityManager defaultWebSecurityManager = <span class="keyword">new</span> DefaultWebSecurityManager();</span><br><span class="line">    <span class="comment">//2 创建认证对象，并设置认证策略</span></span><br><span class="line">    ModularRealmAuthenticator modularRealmAuthenticator = <span class="keyword">new</span> ModularRealmAuthenticator();</span><br><span class="line">    modularRealmAuthenticator.setAuthenticationStrategy(<span class="keyword">new</span> AllSuccessfulStrategy());</span><br><span class="line">    defaultWebSecurityManager.setAuthenticator(modularRealmAuthenticator);</span><br><span class="line">    <span class="comment">//3 封装  myRealm 集合</span></span><br><span class="line">    List&lt;Realm&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(myRealm);</span><br><span class="line">    list.add(myRealm2);</span><br><span class="line">    <span class="comment">//4 将 myRealm 存入 defaultWebSecurityManager 对象</span></span><br><span class="line">    defaultWebSecurityManager.setRealms(list);</span><br><span class="line">    <span class="comment">//5 返回</span></span><br><span class="line">    <span class="keyword">return</span> defaultWebSecurityManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、remember-me">3、remember me</h2><h3 id="3-1-实现原理">3.1 实现原理</h3><p>Shiro 提供了记住我（RememberMe）的功能，比如访问一些网站时，关闭了浏览器， 下次再打开时还是能记住你是谁， 下次访问时无需再登录即可访问。</p><p><strong>基本流程</strong></p><ul><li>首先在登录页面选中 RememberMe 然后登录成功；如果是浏览器登录，一般会 把 RememberMe 的 Cookie 写到客户端并保存下来；</li><li>关闭浏览器再重新打开；会发现浏览器还是记住你的；</li><li>访问一般的网页服务器端，仍然知道你是谁，且能正常访问；</li><li>但是，如果我们访问电商平台时，如果要查看我的订单或进行支付时，此时还是需要再进行身份认证的，以确保当前用户还是你。</li></ul><h3 id="3-2-代码实现">3.2 代码实现</h3><blockquote><p>过滤器可以参考：<a href="https://blog.csdn.net/m0_67266787/article/details/123792654" target="_blank" rel="noopener" title="Shiro学习之过滤器详解">Shiro学习之过滤器详解</a></p></blockquote><p>修改配置类，注意未认证的重定向在yml中进行配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShiroConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyRealm myRealm;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置 SecurityManager</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DefaultWebSecurityManager <span class="title">defaultWebSecurityManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1 创建  defaultWebSecurityManager 对象</span></span><br><span class="line">        DefaultWebSecurityManager defaultWebSecurityManager = <span class="keyword">new</span> DefaultWebSecurityManager();</span><br><span class="line">        <span class="comment">//2 创建加密对象，并设置相关属性</span></span><br><span class="line">        HashedCredentialsMatcher matcher = <span class="keyword">new</span> HashedCredentialsMatcher();</span><br><span class="line">        <span class="comment">//2.1 采用  md5 加密</span></span><br><span class="line">        matcher.setHashAlgorithmName(<span class="string">"md5"</span>);</span><br><span class="line">        <span class="comment">//2.2 迭代加密次数</span></span><br><span class="line">        matcher.setHashIterations(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//3 将加密对象存储到  myRealm 中</span></span><br><span class="line">        myRealm.setCredentialsMatcher(matcher);</span><br><span class="line">        <span class="comment">//4 将  myRealm 存入 defaultWebSecurityManager 对象</span></span><br><span class="line">        defaultWebSecurityManager.setRealm(myRealm);</span><br><span class="line">        <span class="comment">//4.5 设置  rememberMe</span></span><br><span class="line">        defaultWebSecurityManager.setRememberMeManager(rememberMeManager());</span><br><span class="line">        <span class="comment">//5 返回</span></span><br><span class="line">        <span class="keyword">return</span> defaultWebSecurityManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//cookie 属性设置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SimpleCookie <span class="title">rememberMeCookie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SimpleCookie cookie = <span class="keyword">new</span> SimpleCookie(<span class="string">"rememberMe"</span>);</span><br><span class="line">        <span class="comment">//设置跨域</span></span><br><span class="line">        <span class="comment">//cookie.setDomain(domain);</span></span><br><span class="line">        cookie.setPath(<span class="string">"/"</span>);</span><br><span class="line">        cookie.setHttpOnly(<span class="keyword">true</span>);</span><br><span class="line">        cookie.setMaxAge(<span class="number">30</span> * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span>);</span><br><span class="line">        <span class="keyword">return</span> cookie;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建 Shiro 的  cookie 管理对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CookieRememberMeManager <span class="title">rememberMeManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CookieRememberMeManager cookieRememberMeManager = <span class="keyword">new</span> CookieRememberMeManager();</span><br><span class="line">        cookieRememberMeManager.setCookie(rememberMeCookie());</span><br><span class="line">        cookieRememberMeManager.setCipherKey(<span class="string">"1234567890987654"</span>.getBytes());</span><br><span class="line">        <span class="keyword">return</span> cookieRememberMeManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置 Shiro 内置过滤器拦截范围</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DefaultShiroFilterChainDefinition <span class="title">shiroFilterChainDefinition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DefaultShiroFilterChainDefinition definition = <span class="keyword">new</span> DefaultShiroFilterChainDefinition();</span><br><span class="line">        <span class="comment">//设置不认证可以访问的资源</span></span><br><span class="line">        definition.addPathDefinition(<span class="string">"/myController/userLogin"</span>, <span class="string">"anon"</span>);</span><br><span class="line">        definition.addPathDefinition(<span class="string">"/myController/login"</span>, <span class="string">"anon"</span>);</span><br><span class="line">        <span class="comment">//设置需要进行登录认证的拦截范围</span></span><br><span class="line">        definition.addPathDefinition(<span class="string">"/**"</span>, <span class="string">"authc"</span>);</span><br><span class="line">        <span class="comment">//添加存在用户的过滤器（rememberMe）</span></span><br><span class="line">        definition.addPathDefinition(<span class="string">"/**"</span>, <span class="string">"user"</span>);</span><br><span class="line">        <span class="keyword">return</span> definition;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"myController"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//跳转登录页面</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"login"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"login"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"userLogin"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">userLogin</span><span class="params">(String name, String pwd,</span></span></span><br><span class="line"><span class="function"><span class="params">                            @RequestParam(defaultValue = <span class="string">"false"</span>)</span><span class="keyword">boolean</span> rememberMe,</span></span><br><span class="line"><span class="function">                            HttpSession session)</span>&#123;</span><br><span class="line">        <span class="comment">//1获取subject对象</span></span><br><span class="line">        Subject subject  = SecurityUtils.getSubject();</span><br><span class="line">        <span class="comment">//2封装请求数据到token</span></span><br><span class="line">        AuthenticationToken token = <span class="keyword">new</span> UsernamePasswordToken(name,pwd,rememberMe);</span><br><span class="line">        <span class="comment">//3调用login方法进行登录认证</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            subject.login(token);</span><br><span class="line">            <span class="comment">//return "登录成功";</span></span><br><span class="line">            session.setAttribute(<span class="string">"user"</span>,token.getPrincipal().toString());</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"main"</span>;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (AuthenticationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">"登录失败"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"登录失败"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//登录认证验证rememberMe</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"userLoginRm"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">userLogin</span><span class="params">(HttpSession session)</span> </span>&#123;</span><br><span class="line">        session.setAttribute(<span class="string">"user"</span>,<span class="string">"rememberMe"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"main"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改造login页面</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Shiro 登录认证<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/myController/userLogin"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"pwd"</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>记住用户：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"rememberMe"</span> <span class="attr">value</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"登录"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="4、用户注销">4、用户注销</h2><p>用户登录后，配套的有登出操作。直接通过Shiro过滤器即可实现登出，首先修改main.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Shiro 登录认证后主页面<span class="tag">&lt;/<span class="name">h1</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">登录用户为：<span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;session.user&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/logout"</span>&gt;</span>登出<span class="tag">&lt;/<span class="name">a</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置类中添加logout过滤器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DefaultShiroFilterChainDefinition <span class="title">shiroFilterChainDefinition</span><span class="params">()</span></span>&#123; </span><br><span class="line">    DefaultShiroFilterChainDefinition definition = <span class="keyword">new</span> DefaultShiroFilterChainDefinition();</span><br><span class="line">    <span class="comment">//设置不认证可以访问的资源</span></span><br><span class="line">    definition.addPathDefinition(<span class="string">"/myController/userLogin"</span>,<span class="string">"anon"</span>); </span><br><span class="line">    definition.addPathDefinition(<span class="string">"/myController/login"</span>,<span class="string">"anon"</span>); </span><br><span class="line">    <span class="comment">//配置登出过滤器</span></span><br><span class="line">    definition.addPathDefinition(<span class="string">"/logout"</span>,<span class="string">"logout"</span>); </span><br><span class="line">    <span class="comment">//设置需要进行登录认证的拦截范围</span></span><br><span class="line">    definition.addPathDefinition(<span class="string">"/**"</span>,<span class="string">"authc"</span>); </span><br><span class="line">    <span class="comment">//添加存在用户的过滤器（rememberMe） </span></span><br><span class="line">    definition.addPathDefinition(<span class="string">"/**"</span>,<span class="string">"user"</span>); </span><br><span class="line">    <span class="keyword">return</span>  definition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、授权、角色认证">5、授权、角色认证</h2><p>用户登录后，需要验证是否具有指定角色指定权限。Shiro也提供了方便的工具进行判断。这个工具就是<strong>Realm的doGetAuthorizationInfo方法</strong>进行判断，触发权限判断的有两种方式</p><ul><li>在页面中通过<strong>shiro:属性判断</strong></li><li><strong>在接口服务中通过注解@Requires</strong>进行判断</li></ul><h3 id="5-1-后端接口服务注解">5.1 后端接口服务注解</h3><p>通过给接口服务方法添加注解可以实现权限校验，<strong>可以加在控制器方法上，也可以加<br>在业务方法上</strong>，一般加在控制器方法上。常用注解如下：</p><ul><li><p><code>@RequiresAuthentication</code>  </p><p>验证用户是否登录，等同于方法<strong>subject.isAuthenticated()</strong></p><p><code>@RequiresUser</code>  </p><p>验证用户是否被记忆：  登录认证成功<strong>subject.isAuthenticated()为true</strong> ；登录后被记忆<strong>subject.isRemembered()为true</strong></p></li><li><p><code>@RequiresGuest</code>  </p><p>验证是否是一个guest的请求，是否是游客的请求 ，此时<strong>subject.getPrincipal()为null</strong></p></li><li><p><code>@RequiresRoles</code>  </p><p>验证subject是否有相应角色，有角色访问方法，没有则会抛出异常 <code>AuthorizationException</code>。例如：<code>@RequiresRoles(&quot;aRoleName&quot;)  void someMethod();</code>  只有subject有aRoleName角色才能访问方法someMethod()</p></li><li><p><code>@RequiresPermissions</code>  </p><p>验证subject是否有相应权限，有权限访问方法，没有则会抛出异常 <code>AuthorizationException</code>。  </p><p>例如：<code>@RequiresPermissions (&quot;file:read&quot;,&quot;wite:aFile.txt&quot;) void someMethod();</code>subject必须同时含有file:read和wite:aFile.txt权限才能访问方someMethod()</p></li></ul><h3 id="5-2-授权验证-获取角色验证">5.2 授权验证-获取角色验证</h3><p>首先添加数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`role`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'编号'</span>, </span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'角色名'</span>,</span><br><span class="line">  <span class="string">`desc`</span> <span class="built_in">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'描述'</span>,</span><br><span class="line">  <span class="string">`realname`</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'角色显示名'</span>, </span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">INNODB</span> AUTO_INCREMENT=<span class="number">2</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'角色表'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`role_user`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'编号'</span>, </span><br><span class="line">  <span class="string">`uid`</span> <span class="built_in">BIGINT</span>(<span class="number">20</span>)  <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户  id'</span>,</span><br><span class="line">  <span class="string">`rid`</span> <span class="built_in">BIGINT</span>(<span class="number">20</span>)  <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'角色  id'</span>, </span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">INNODB</span> AUTO_INCREMENT=<span class="number">2</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'角色用户映射表'</span>;</span><br></pre></td></tr></table></figure><p>mapper</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"SELECT NAME FROM role WHERE id IN (SELECT rid FROM role_user WHERE uid=(SELECT id FROM USER WHERE NAME=#&#123;principal&#125;))"</span>)</span><br><span class="line">    <span class="function">List&lt;String&gt; <span class="title">getUserRoleInfoMapper</span><span class="params">(@Param(<span class="string">"principal"</span>)</span> String principal)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>service服务实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getUserRoleInfo</span><span class="params">(String principal)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> userMapper.getUserRoleInfoMapper(principal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MyRealm 授权认证方法改造</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> AuthorizationInfo <span class="title">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principalCollection)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"进入自定义授权方法"</span>); </span><br><span class="line">    <span class="comment">//获取当前用户身份信息</span></span><br><span class="line">    String principal = principalCollection.getPrimaryPrincipal().toString();</span><br><span class="line">    <span class="comment">//调用接口方法获取用户的角色信息</span></span><br><span class="line">    List&lt;String&gt; roles = userService.getUserRoleInfo(principal); </span><br><span class="line">    System.out.println(<span class="string">"当前用户角色信息："</span>+roles);</span><br><span class="line">    <span class="comment">//创建对象，存储当前登录的用户的权限和角色</span></span><br><span class="line">    SimpleAuthorizationInfo info = <span class="keyword">new</span> SimpleAuthorizationInfo(); </span><br><span class="line">    <span class="comment">//存储角色,测试的话可以直接塞String的角色</span></span><br><span class="line">    info.addRoles(roles);</span><br><span class="line">    <span class="comment">//返回 </span></span><br><span class="line">    <span class="keyword">return</span> info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后controller添加授权方法，在mian.html添加<code>&lt;a href=&quot;/myController/userLoginRoles&quot;&gt;测试授权-角色验证&lt;/a&gt;</code>测试链接即可进行测试(数据库数据自行添加)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//登录认证验证角色</span></span><br><span class="line"><span class="meta">@RequiresRoles</span>(<span class="string">"admin"</span>)</span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"userLoginRoles"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">userLoginRoles</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"登录认证验证角色"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"验证角色成功"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-授权验证-获取权限验证">5.3 授权验证-获取权限验证</h3><p>创建权限数据表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`permissions`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'编号'</span>, </span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'权限名'</span>,</span><br><span class="line">  <span class="string">`info`</span> <span class="built_in">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'权限信息'</span>, </span><br><span class="line">  <span class="string">`desc`</span> <span class="built_in">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'描述'</span>, </span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">INNODB</span> AUTO_INCREMENT=<span class="number">2</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'权限表'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`role_ps`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'编号'</span>, </span><br><span class="line">  <span class="string">`rid`</span> <span class="built_in">BIGINT</span>(<span class="number">20</span>)  <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'角色  id'</span>,</span><br><span class="line">  <span class="string">`pid`</span> <span class="built_in">BIGINT</span>(<span class="number">20</span>)  <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'权限  id'</span>, </span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">INNODB</span> AUTO_INCREMENT=<span class="number">2</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'角色权限映射表'</span>;</span><br></pre></td></tr></table></figure><p>创建方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Mapper类</span></span><br><span class="line"><span class="meta">@Select</span>(&#123;</span><br><span class="line">        <span class="string">"&lt;script&gt;"</span>,</span><br><span class="line">        <span class="string">"select info FROM permissions WHERE id IN "</span>,</span><br><span class="line">        <span class="string">"(SELECT pid FROM role_ps WHERE rid IN ("</span>,</span><br><span class="line">        <span class="string">"SELECT id FROM role WHERE NAME IN "</span>,</span><br><span class="line">        <span class="string">"&lt;foreach collection='roles' item='name' open='(' separator=',' close=')'&gt;"</span>,</span><br><span class="line">        <span class="string">"#&#123;name&#125;"</span>,</span><br><span class="line">        <span class="string">"&lt;/foreach&gt;"</span>,</span><br><span class="line">        <span class="string">"))"</span>,</span><br><span class="line">        <span class="string">"&lt;/script&gt;"</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="function">List&lt;String&gt; <span class="title">getUserPermissionInfoMapper</span><span class="params">(@Param(<span class="string">"roles"</span>)</span>List&lt;String&gt; roles)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Service层</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getUserPermissionInfo</span><span class="params">(List&lt;String&gt; roles)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> userMapper.getUserPermissionInfoMapper(roles);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改MyRealm配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义授权方法：获取当前登录用户权限信息，返回给 Shiro 用来进行授权对比</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> AuthorizationInfo <span class="title">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principalCollection)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"进入自定义授权方法"</span>);</span><br><span class="line">    <span class="comment">//获取当前用户身份信息</span></span><br><span class="line">    String principal = principalCollection.getPrimaryPrincipal().toString();</span><br><span class="line">    <span class="comment">//调用接口方法获取用户的角色信息</span></span><br><span class="line">    List&lt;String&gt; roles = userService.getUserRoleInfo(principal);</span><br><span class="line">    System.out.println(<span class="string">"当前用户角色信息："</span>+roles);</span><br><span class="line">    <span class="comment">//调用接口方法获取用户角色的权限信息</span></span><br><span class="line">    List&lt;String&gt; permissions = userService.getUserPermissionInfo(roles);</span><br><span class="line">    System.out.println(<span class="string">"当前用户权限信息："</span>+permissions);</span><br><span class="line">    <span class="comment">//创建对象，存储当前登录的用户的权限和角色</span></span><br><span class="line">    SimpleAuthorizationInfo info = <span class="keyword">new</span> SimpleAuthorizationInfo();</span><br><span class="line">    <span class="comment">//存储角色</span></span><br><span class="line">    info.addRoles(roles);</span><br><span class="line">    <span class="comment">//存储权限信息</span></span><br><span class="line">    info.addStringPermissions(permissions);</span><br><span class="line">    <span class="comment">//返回 </span></span><br><span class="line">    <span class="keyword">return</span> info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>controller层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//登录认证验证权限</span></span><br><span class="line"><span class="meta">@RequiresPermissions</span>(<span class="string">"user:delete"</span>)</span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"userPermissions"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">userLoginPermissions</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"登录认证验证权限"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"验证权限成功"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改main.html文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Shiro 登录认证后主页面<span class="tag">&lt;/<span class="name">h1</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">登录用户为：<span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;session.user&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/logout"</span>&gt;</span>登出<span class="tag">&lt;/<span class="name">a</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/myController/userLoginRoles"</span>&gt;</span>测试授权-角色验证<span class="tag">&lt;/<span class="name">a</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/myController/userPermissions"</span>&gt;</span>测试授权-权限验证<span class="tag">&lt;/<span class="name">a</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="5-4-权限验证异常处理类">5.4 权限验证异常处理类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PermissionsException</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(UnauthorizedException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">String</span> <span class="title">unauthorizedException</span>(<span class="title">Exception</span> <span class="title">e</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"无权限"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(AuthorizationException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">String</span> <span class="title">authorizationException</span>(<span class="title">Exception</span> <span class="title">e</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"权限认证失败"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-5-前端页面授权验证">5.5 前端页面授权验证</h3><p>前端可以根据不同的权限显示不同的信息，首先添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.theborakompanioni<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>thymeleaf-extras-shiro<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置类，用于解析 thymeleaf 中的 shiro:相关属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ShiroDialect <span class="title">shiroDialect</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ShiroDialect(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Thymeleaf 中常用的 shiro:属性</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--guest 标签：用户没有身份验证时显示相应信息，即游客访问信息--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">shiro:guest</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">shiro:guest</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--user标签：用户已经身份验证/记住我登录后显示相应的信息--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">shiro:user</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">shiro:user</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--authenticated 标签：用户已经身份验证通过，即 Subject.login 登录成功，不是记住我登录的--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">shiro:authenticated</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">shiro:authenticated</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--notAuthenticated 标签：用户已经身份验证通过，即没有调用 Subject.login 进行登录，包括记住我自动登录的</span></span><br><span class="line"><span class="comment">也属于未进行身份验证--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">shiro:notAuthenticated</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">shiro:notAuthenticated</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--principal 标签：当于((User)Subject.getPrincipals()).getUsername()--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">shiro:</span> <span class="attr">principal</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">shiro:principal</span> <span class="attr">property</span>=<span class="string">"username"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--lacksPermission 标签：如果当前 Subject 没有权限将显示 body 体内容--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">shiro:lacksPermission</span> <span class="attr">name</span>=<span class="string">"org:create"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">shiro:lacksPermission</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--hasRole标签：如果当前 Subject 有角色将显示 body 体内容--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">shiro:hasRole</span> <span class="attr">name</span>=<span class="string">"admin"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">shiro:hasRole</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--hasAnyRoles 标签标签：如果当前 Subject 有任意一个角色（或的关系）将显示 body 体内容--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">shiro:hasAnyRoles</span> <span class="attr">name</span>=<span class="string">"admin,user"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">shiro:hasAnyRoles</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--lacksRole标签：如果当前 Subject 没有角色将显示 body 体内容--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">shiro:lacksRole</span> <span class="attr">name</span>=<span class="string">"abc"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">shiro:lacksRole</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--lacksPermission 标签：如果当前 Subject 有权限将显示 body 体内容--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">shiro:hasPermission</span> <span class="attr">name</span>=<span class="string">"user:create"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">shiro:hasPermission</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="6、缓存管理">6、缓存管理</h2><h3 id="6-1-缓存工具EhCache">6.1 缓存工具EhCache</h3><p>EhCache是一种广泛使用的开源Java分布式缓存。主要面向通用缓存，Java EE和轻量级容器。可以和大部分Java项目无缝整合，例如：Hibernate中的缓存就是基于EhCache实现的。<strong>EhCache支持内存和磁盘存储，默认存储在内存中</strong>，如内存不够时把缓存数据同步到磁盘中。EhCache支持基于Filter的Cache实现，也支持Gzip压缩算法。</p><p>EhCache直接在JVM虚拟机中缓存，速度快，效率高；EhCache缺点是缓存共享麻烦，集群分布式应用使用不方便</p><h3 id="6-2-Ehcache简单搭建">6.2 Ehcache简单搭建</h3><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.sf.ehcache<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ehcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>创建配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ehcache</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--磁盘的缓存位置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">diskStore</span> <span class="attr">path</span>=<span class="string">"java.io.tmpdir/ehcache"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--默认缓存--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">defaultCache</span></span></span><br><span class="line"><span class="tag">            <span class="attr">maxEntriesLocalHeap</span>=<span class="string">"10000"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">eternal</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">timeToIdleSeconds</span>=<span class="string">"120"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">timeToLiveSeconds</span>=<span class="string">"120"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">maxEntriesLocalDisk</span>=<span class="string">"10000000"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">diskExpiryThreadIntervalSeconds</span>=<span class="string">"120"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">memoryStoreEvictionPolicy</span>=<span class="string">"LRU"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">persistence</span> <span class="attr">strategy</span>=<span class="string">"localTempSwap"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">defaultCache</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--helloworld缓存--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache</span> <span class="attr">name</span>=<span class="string">"HelloWorldCache"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">maxElementsInMemory</span>=<span class="string">"1000"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">eternal</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">timeToIdleSeconds</span>=<span class="string">"5"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">timeToLiveSeconds</span>=<span class="string">"5"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">overflowToDisk</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">memoryStoreEvictionPolicy</span>=<span class="string">"LRU"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">     defaultCache：默认缓存策略，当ehcache找不到定义的缓存时，则使用这个缓存策略。只能定义一个。</span></span><br><span class="line"><span class="comment">   --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">      name:缓存名称。</span></span><br><span class="line"><span class="comment">      maxElementsInMemory:缓存最大数目</span></span><br><span class="line"><span class="comment">      maxElementsOnDisk：硬盘最大缓存个数。</span></span><br><span class="line"><span class="comment">      eternal:对象是否永久有效，一但设置了，timeout将不起作用。</span></span><br><span class="line"><span class="comment">      overflowToDisk:是否保存到磁盘，当系统宕机时</span></span><br><span class="line"><span class="comment">      timeToIdleSeconds:设置对象在失效前的允许闲置时间（单位：秒）。仅当eternal=false对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。</span></span><br><span class="line"><span class="comment">      timeToLiveSeconds:设置对象在失效前允许存活时间（单位：秒）。最大时间介于创建时间和失效时间之间。仅当eternal=false对象不是永久有效时使用，默认是0.，也就是对象存活时间无穷大。</span></span><br><span class="line"><span class="comment">      diskPersistent：是否缓存虚拟机重启期数据 Whether the disk store persists between restarts of the Virtual Machine. The default value is false.</span></span><br><span class="line"><span class="comment">      diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。</span></span><br><span class="line"><span class="comment">      diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。</span></span><br><span class="line"><span class="comment">      memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。</span></span><br><span class="line"><span class="comment">      clearOnFlush：内存数量最大时是否清除。</span></span><br><span class="line"><span class="comment">      memoryStoreEvictionPolicy:可选策略有：LRU（最近最少使用，默认策略）、FIFO（先进先出）、LFU（最少访问次数）。</span></span><br><span class="line"><span class="comment">      FIFO，first in first out，这个是大家最熟的，先进先出。</span></span><br><span class="line"><span class="comment">      LFU， Less Frequently Used，就是上面例子中使用的策略，直白一点就是讲一直以来最少被使用的。如上面所讲，缓存的元素有一个hit属性，hit值最小的将会被清出缓存。</span></span><br><span class="line"><span class="comment">      LRU，Least Recently Used，最近最少使用的，缓存的元素有一个时间戳，当缓存容量满了，而又需要腾出地方来缓存新的元素的时候，那么现有缓存元素中时间戳离当前时间最远的元素将被清出缓存。</span></span><br><span class="line"><span class="comment">   --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取编译目录下的资源的流对象</span></span><br><span class="line">    InputStream input = TestEH.class.getClassLoader().getResourceAsStream("ehcache.xml");</span><br><span class="line">    <span class="comment">//获取EhCache的缓存管理对象</span></span><br><span class="line">    CacheManager cacheManager = <span class="keyword">new</span> CacheManager(input);</span><br><span class="line">    <span class="comment">//获取缓存对象</span></span><br><span class="line">    Cache cache = cacheManager.getCache(<span class="string">"HelloWorldCache"</span>);</span><br><span class="line">    <span class="comment">//创建缓存数据</span></span><br><span class="line">    Element element = <span class="keyword">new</span> Element(<span class="string">"name"</span>,<span class="string">"shawn"</span>);</span><br><span class="line">    <span class="comment">//存入缓存</span></span><br><span class="line">    cache.put(element);</span><br><span class="line">    <span class="comment">//从缓存中取出数据输出</span></span><br><span class="line">    Element element1 = cache.get(<span class="string">"name"</span>);</span><br><span class="line">    System.out.println(<span class="string">"缓存中数据 = "</span> + element1.getObjectValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3-Shiro整合EhCache">6.3 Shiro整合EhCache</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Shiro整合EhCache--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-ehcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.10.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.11.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在resources下添加配置文件<code>ehcache/ehcache-shiro.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ehcache</span> <span class="attr">name</span>=<span class="string">"ehcache"</span> <span class="attr">updateCheck</span>=<span class="string">"false"</span>&gt;</span> <span class="comment">&lt;!--磁盘的缓存位置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">diskStore</span> <span class="attr">path</span>=<span class="string">"java.io.tmpdir"</span>/&gt;</span> <span class="comment">&lt;!--默认缓存--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">defaultCache</span></span></span><br><span class="line"><span class="tag">            <span class="attr">maxEntriesLocalHeap</span>=<span class="string">"1000"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">eternal</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">timeToIdleSeconds</span>=<span class="string">"3600"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">timeToLiveSeconds</span>=<span class="string">"3600"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">overflowToDisk</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">defaultCache</span>&gt;</span> <span class="comment">&lt;!--登录认证信息缓存：缓存用户角色权限--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache</span> <span class="attr">name</span>=<span class="string">"loginRolePsCache"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">maxEntriesLocalHeap</span>=<span class="string">"2000"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">eternal</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">timeToIdleSeconds</span>=<span class="string">"600"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">timeToLiveSeconds</span>=<span class="string">"0"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">overflowToDisk</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">statistics</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最后修改Shiro配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShiroConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyRealm myRealm;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置SecurityManager</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DefaultWebSecurityManager <span class="title">defaultWebSecurityManager</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//1创建defaultWebSecurityManager 对象</span></span><br><span class="line">        DefaultWebSecurityManager defaultWebSecurityManager = <span class="keyword">new</span> DefaultWebSecurityManager();</span><br><span class="line">        <span class="comment">//2创建加密对象，设置相关属性</span></span><br><span class="line">        HashedCredentialsMatcher matcher = <span class="keyword">new</span> HashedCredentialsMatcher();</span><br><span class="line">        <span class="comment">//2.1采用md5加密</span></span><br><span class="line">        matcher.setHashAlgorithmName(<span class="string">"md5"</span>);</span><br><span class="line">        <span class="comment">//2.2迭代加密次数</span></span><br><span class="line">        matcher.setHashIterations(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//3将加密对象存储到myRealm中</span></span><br><span class="line">        myRealm.setCredentialsMatcher(matcher);</span><br><span class="line">        <span class="comment">//4将myRealm存入defaultWebSecurityManager 对象</span></span><br><span class="line">        defaultWebSecurityManager.setRealm(myRealm);</span><br><span class="line">        <span class="comment">//4.5设置rememberMe</span></span><br><span class="line">        defaultWebSecurityManager.setRememberMeManager(rememberMeManager());</span><br><span class="line">        <span class="comment">//4.6设置缓存管理器</span></span><br><span class="line">        defaultWebSecurityManager.setCacheManager(getEhCacheManager());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5返回</span></span><br><span class="line">        <span class="keyword">return</span> defaultWebSecurityManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//缓存管理器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EhCacheManager <span class="title">getEhCacheManager</span><span class="params">()</span></span>&#123;</span><br><span class="line">        EhCacheManager ehCacheManager = <span class="keyword">new</span> EhCacheManager();</span><br><span class="line">        InputStream is =<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            is = ResourceUtils.getInputStreamForPath(<span class="string">"classpath:ehcache/ehcache-shiro.xml"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        CacheManager cacheManager = <span class="keyword">new</span> CacheManager(is);</span><br><span class="line">        ehCacheManager.setCacheManager(cacheManager);</span><br><span class="line">        <span class="keyword">return</span> ehCacheManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//cookie 属性设置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SimpleCookie <span class="title">rememberMeCookie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SimpleCookie cookie = <span class="keyword">new</span> SimpleCookie(<span class="string">"rememberMe"</span>);</span><br><span class="line">        <span class="comment">//设置跨域</span></span><br><span class="line">        <span class="comment">//cookie.setDomain(domain);</span></span><br><span class="line">        cookie.setPath(<span class="string">"/"</span>);</span><br><span class="line">        cookie.setHttpOnly(<span class="keyword">true</span>);</span><br><span class="line">        cookie.setMaxAge(<span class="number">30</span> * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span>);</span><br><span class="line">        <span class="keyword">return</span> cookie;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建 Shiro 的  cookie 管理对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CookieRememberMeManager <span class="title">rememberMeManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CookieRememberMeManager cookieRememberMeManager = <span class="keyword">new</span> CookieRememberMeManager();</span><br><span class="line">        cookieRememberMeManager.setCookie(rememberMeCookie());</span><br><span class="line">        cookieRememberMeManager.setCipherKey(<span class="string">"1234567890987654"</span>.getBytes());</span><br><span class="line">        <span class="keyword">return</span> cookieRememberMeManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置 Shiro 内置过滤器拦截范围</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DefaultShiroFilterChainDefinition <span class="title">shiroFilterChainDefinition</span><span class="params">()</span></span>&#123;</span><br><span class="line">        DefaultShiroFilterChainDefinition definition = <span class="keyword">new</span> DefaultShiroFilterChainDefinition();</span><br><span class="line">        <span class="comment">//设置不认证可以访问的资源</span></span><br><span class="line">        definition.addPathDefinition(<span class="string">"/myController/userLogin"</span>,<span class="string">"anon"</span>);</span><br><span class="line">        definition.addPathDefinition(<span class="string">"/myController/login"</span>,<span class="string">"anon"</span>);</span><br><span class="line">        <span class="comment">//配置登出过滤器</span></span><br><span class="line">        definition.addPathDefinition(<span class="string">"/logout"</span>,<span class="string">"logout"</span>);</span><br><span class="line">        <span class="comment">//设置需要进行登录认证的拦截范围</span></span><br><span class="line">        definition.addPathDefinition(<span class="string">"/**"</span>,<span class="string">"authc"</span>);</span><br><span class="line">        <span class="comment">//添加存在用户的过滤器（rememberMe）</span></span><br><span class="line">        definition.addPathDefinition(<span class="string">"/**"</span>,<span class="string">"user"</span>);</span><br><span class="line">        <span class="keyword">return</span>  definition;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后访问权限测试，发现其成功缓存</p><h2 id="7、会话管理">7、会话管理</h2><h3 id="7-1-SessionManager">7.1 SessionManager</h3><p>会话管理器，负责创建和管理用户的会话（Session）生命周期，它能够在任何环境中在本地管理用户会话，即使没有Web/Servlet/EJB容器，也一样可以保存会话。默认情况下，Shiro会检测当前环境中现有的会话机制（比如Servlet容器）进行适配，如果没有（比如独立应用程序或者非Web环境），它将会使用内置的企业会话管理器来提供相应的会话管理服务，其中还涉及一个名为SessionDAO的对象。SessionDAO负责Session的持久化操作（CRUD），允许Session数据写入到后端持久化数据库</p><h3 id="7-2-会话管理实现">7.2 会话管理实现</h3><p>SessionManager由SecurityManager管理。Shiro提供了三种实现</p><ul><li>DefaultSessionManager：用于JavaSE环境</li><li>ServletContainerSessionManager：用于web环境，直接使用Servlet容器的会话</li><li>DefaultWebSessionManager：用于web环境，自己维护会话（不使用Servlet容器的会话管理）</li></ul><h3 id="7-3-获得session方式">7.3 获得session方式</h3><ul><li><strong>实现</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Session session = SecurityUtils.getSubject().getSession();</span><br><span class="line">session.setAttribute(<span class="string">"key"</span>,<span class="string">"value"</span>)</span><br></pre></td></tr></table></figure><ul><li><p><strong>说明</strong></p><p> Controller中的request，在shiro过滤器中的doFilerInternal方法，被包装成ShiroHttpServletRequest。</p><p>SecurityManager和SessionManager会话管理器决定session来源于ServletRequest还是由Shiro管理的会话。 无论是通过request.getSession或subject.getSession获取到session，操作session，两者都是等价的。</p></li></ul><hr><p>参考：</p><p><a href="https://blog.csdn.net/m0_67401920/article/details/124022820" target="_blank" rel="noopener" title="shiro框架如何保持登录状态">shiro框架如何保持登录状态</a></p><p><a href="https://www.bilibili.com/video/BV11e4y1n7BH" target="_blank" rel="noopener" title="https://www.bilibili.com/video/BV11e4y1n7BH">https://www.bilibili.com/video/BV11e4y1n7BH</a></p>]]></content>
    
    
    <summary type="html">&lt;h1&gt;一、Shiro概述&lt;/h1&gt;
&lt;h2 id=&quot;1、Shiro简介&quot;&gt;1、Shiro简介&lt;/h2&gt;
&lt;h3 id=&quot;1-1-介绍&quot;&gt;1.1 介绍&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;官网：&lt;a href=&quot;https://shiro.apache.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; title=&quot;https://shiro.apache.org/&quot;&gt;https://shiro.apache.org/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Apache Shiro 是一个功能强大且易于使用的 Java 安全(权限)框架。Shiro 可以完成：认证、授权、加密、会话管理、与 Web 集成、缓存 等。借助 Shiro 您可以快速轻松地保护任何应用程序——从最小的移动应用程序到最大的 Web 和企业应用程序。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://www.shawn22.xyz/categories/Java/"/>
    
    
    <category term="中间件" scheme="https://www.shawn22.xyz/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Nginx自动封禁可疑Ip</title>
    <link href="https://www.shawn22.xyz/posts/4efc0d8e.html"/>
    <id>https://www.shawn22.xyz/posts/4efc0d8e.html</id>
    <published>2023-03-05T16:17:49.000Z</published>
    <updated>2023-03-05T16:31:04.200Z</updated>
    
    <content type="html"><![CDATA[<h1>一、Nginx封禁ip</h1><h2 id="1、简介">1、简介</h2><p>在网站维护过程中，有时候我们需要对一些IP地址或是一些IP段进行封锁拉黑，使其不能访问网站。 如果你的网站服务器的网站运行环境是由nginx搭建的，那么nginx中禁止ip的方法可以有效的防止网站被黑。</p><a id="more"></a><h2 id="2、nignx-禁止IP访问">2、nignx 禁止IP访问</h2><h3 id="2-1-方法一">2.1 方法一</h3><ul><li>在 nginx 的安装目录中(一般在<code>/etc/nginx/</code>)，找到 nginx.conf 文件(可以看一下<code>access.log</code>日志在哪，后面脚本要用)，并在当前目录创建 <code>blocksip.conf</code> 文件</li><li>编辑 <code>blocksip.conf</code> 文件，并加入以下代码</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deny 127.0.0.1;</span><br><span class="line"><span class="comment"># 127.0.0.1 为要封禁的 IP 地址</span></span><br></pre></td></tr></table></figure><ul><li>编辑 nginx.conf 文件，在ngnix的HTTP的配置中添加如下内容</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据自己实际需求修改实际路径，这里暂时是当前目录</span></span><br><span class="line">include blocksip.conf;</span><br></pre></td></tr></table></figure><ul><li>重启 nginx 即可，然后你就会看到IP被封禁了，喜提403</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/nginx/sbin/nginx -s reload</span><br></pre></td></tr></table></figure><h3 id="2-2-方法二">2.2 方法二</h3><p>编辑 配置目录下的 <code>nginx.conf</code> 文件，在** http{} 或 server{}** 中添加以下代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deny 127.0.0.1;</span><br><span class="line"><span class="comment"># 127.0.0.1：为要封禁的 IP 地址</span></span><br><span class="line"><span class="comment"># 单个网站屏蔽IP的方法，放到网址对应的server&#123;&#125;模块</span></span><br><span class="line"><span class="comment"># 所有网站屏蔽IP的方法，放到http &#123;&#125;模块</span></span><br></pre></td></tr></table></figure><p>最后重启 nginx 即可</p><h2 id="3、关于-deny-的使用">3、关于 deny 的使用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nginx封锁禁止单个IP</span></span><br><span class="line">deny 127.0.0.1;</span><br><span class="line"><span class="comment"># nginx 封锁禁止多个IP,多个IP地址由空格分开</span></span><br><span class="line">deny 127.0.0.1 196.0.0.1;</span><br><span class="line"><span class="comment"># nginx封整个段即从127.0.0.1到127.255.255.254的命令</span></span><br><span class="line">deny 127.0.0.0/8;</span><br><span class="line"><span class="comment"># nginx 封IP段即从127.255.0.1到127.255.255.254的命令</span></span><br><span class="line">deny 127.255.0.0/16</span><br><span class="line"><span class="comment"># nginx 封IP段即从127.255.255.1到127.255.255.254的命令是</span></span><br><span class="line">deny 127.255.255.0/24</span><br><span class="line"><span class="comment"># 屏蔽所有ip访问</span></span><br><span class="line">deny all;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许单个ip访问,和上面同理</span></span><br><span class="line">allow IP; </span><br><span class="line"><span class="comment"># 允许所有ip访问</span></span><br><span class="line">allow all;</span><br></pre></td></tr></table></figure><h1>二、脚本自动封禁Ip</h1><h2 id="1、流程介绍">1、流程介绍</h2><ul><li>AWK统计<code>access.log</code>(/var/log/nginx/)，记录每分钟访问超过60次的ip，然后配合nginx进行封禁</li><li>编写shell脚本</li><li>crontab定时跑脚本</li></ul><h2 id="2、脚本实战">2、脚本实战</h2><h3 id="2-1-核心脚本解释">2.1 核心脚本解释</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'&#123;print $1&#125;'</span> access.log | sort | uniq -<span class="built_in">cd</span> | awk <span class="string">'&#123;if($1&gt;60)print $0&#125;'</span></span><br></pre></td></tr></table></figure><ul><li>AWK统计<code>access.log</code>，记录每分钟访问超过60次的ip</li><li><code>awk '{print $1}' access.log</code>  取出access.log的第一列即为ip</li><li><code>sort | uniq -cd</code> 去重和排序</li><li><code>awk '{if($1&gt;60)print $0}'</code> 判断重复的数量是否超过60个，超过60个就展示出来</li></ul><h3 id="2-2-编写shell脚本">2.2 编写shell脚本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#不能把别人IP一直封着吧，这里就清除掉了</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">""</span> &gt; /usr/<span class="built_in">local</span>/nginx/conf/blockip.conf</span><br><span class="line"></span><br><span class="line"><span class="comment">#前面最开始编写的统计数据功能</span></span><br><span class="line">ip_list=$(awk <span class="string">'&#123;print $1&#125;'</span> access.log | sort | uniq -<span class="built_in">cd</span> | awk <span class="string">'&#123;if($1&gt;60)print $0&#125;'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#判断这个变量是否为空</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> -z <span class="string">"<span class="variable">$ip_list</span>"</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">        <span class="comment">#为空写入 11.log中，并重新启动ngnix</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"为空"</span>  &gt;&gt; /usr/<span class="built_in">local</span>/nginx/logs/11.log</span><br><span class="line">        /usr/<span class="built_in">local</span>/nginx/sbin/nginx -s reload</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        <span class="comment">#如果不为空 前面加上 deny格式和ip写入blockip.conf中</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"deny"</span> <span class="variable">$ip_list</span> &gt; /usr/<span class="built_in">local</span>/nginx/conf/blockip.conf</span><br><span class="line">   </span><br><span class="line">        <span class="comment">#因为前面携带了行数，所有我们需要去除掉前面的行数，写入后在读取一次</span></span><br><span class="line">        ip_list2=$(awk <span class="string">'&#123;print $3&#125;'</span> /usr/<span class="built_in">local</span>/nginx/conf/blockip.conf)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#最后再把读取出来的值，在次写入到blockip.conf中</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"deny"</span> <span class="variable">$ip_list2</span><span class="string">";"</span>&gt; /usr/<span class="built_in">local</span>/nginx/conf/blockip.conf</span><br><span class="line"></span><br><span class="line">        <span class="comment">#重启ngnix</span></span><br><span class="line">        /usr/<span class="built_in">local</span>/nginx/sbin/nginx -s reload</span><br><span class="line">        <span class="comment">#清空之前的日志，从最新的开始截取</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">""</span> &gt; /usr/<span class="built_in">local</span>/nginx/logs/access.log</span><br><span class="line"></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h3 id="2-3-crontab定时">2.3 crontab定时</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">crontab -e </span><br><span class="line">* * * * * <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/nginx/logs/ &amp;&amp; sh ip_test.sh  <span class="comment">#每一分钟运行一次</span></span><br><span class="line">systemctl restart crond.service <span class="comment">#重启一下配置既可</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1&gt;一、Nginx封禁ip&lt;/h1&gt;
&lt;h2 id=&quot;1、简介&quot;&gt;1、简介&lt;/h2&gt;
&lt;p&gt;在网站维护过程中，有时候我们需要对一些IP地址或是一些IP段进行封锁拉黑，使其不能访问网站。 如果你的网站服务器的网站运行环境是由nginx搭建的，那么nginx中禁止ip的方法可以有效的防止网站被黑。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://www.shawn22.xyz/categories/Java/"/>
    
    
    <category term="中间件" scheme="https://www.shawn22.xyz/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>NAT网络与内网穿透详解</title>
    <link href="https://www.shawn22.xyz/posts/f53c829d.html"/>
    <id>https://www.shawn22.xyz/posts/f53c829d.html</id>
    <published>2023-03-05T16:17:41.000Z</published>
    <updated>2023-03-05T16:32:28.989Z</updated>
    
    <content type="html"><![CDATA[<h1>一、概述</h1><h2 id="1、简介">1、简介</h2><p>大家有没有想过，为什么在公司里访问不了家里的电脑？这是因为IPv4地址有限，最大42亿个。为了更好的利用这有限的IP数量，网络分为<strong>局域网</strong>和<strong>广域网</strong>，将IP分为了<strong>私有IP和公网IP</strong>，一个局域网里的N多台机器都可以<strong>共用一个公网IP</strong>，从而大大增加了&quot;可用IP数量&quot;。<br><img src="https://img-blog.csdnimg.cn/5b171760cc4f4b148c1074e3fbd46073.png" alt="图片"></p><a id="more"></a><p>收发数据就像收发快递，当我们需要发送网络包的时候，在IP层，需要填入源IP地址，和目的IP地址，也就是对应快递的发货地址和收货地址<br><img src="https://img-blog.csdnimg.cn/b56d8440d3ad4515aaa9b67e143c41e3.png" alt="IP报头里含有发送和接收IP地址"></p><h2 id="2、NAT基本介绍">2、NAT基本介绍</h2><p>我们家里的局域网内，基本上都用<code>192.168.xx.xx</code>这样的<strong>私有IP</strong>，如果我们在发送网络包的时候，这么填。对方在回数据包的时候该怎么回？毕竟千家万户人用的都是<code>192.168.0.1</code>，网络怎么知道该发给谁？所以肯定需要将这个<code>192.168.xx</code>私有IP转换<strong>成公有IP</strong>。<br>局域网内用的是私有IP，公网用的都是公有IP。一个局域网里的私有IP想访问局域网外的公有IP，必然要做个IP转换，这是在哪里做的转换呢？<br><img src="https://img-blog.csdnimg.cn/7073942473134124bce25184e01e6ba0.png" alt="在这里插入图片描述"><br>答案是<strong>NAT设备，全称Network Address Translation</strong>，网络地址转换。基本上家用路由器都支持这功能。</p><h1>二、NAT的工作原理</h1><p>为了简单，我们假设你很富，你家里分到了一个公网 IP 地址 <code>20.20.20.20</code>，对应配到了你家自带 NAT 功能的<strong>家用路由器上</strong>，你家里需要上网的设备有很多，比如你的手机，电脑都需要上网，他们构成了一个<strong>局域网</strong>，用的都是<strong>私有 IP</strong>，比如<code>192.168.xx</code>。其中你在电脑上执行<code>ifconfig</code>命令，发现家里的电脑IP是<code>192.168.30.5</code>。你要访问的公网 IP 地址是<code>30.30.30.30</code><br><img src="https://img-blog.csdnimg.cn/d37bf972d91840c586fb211d782177f1.png" alt="在这里插入图片描述"><br>当你准备发送数据包的时候，你的电脑内核协议栈就会构造一个IP数据包。这个IP数据包报头里的<strong>发送端</strong>IP地址填的就是<code>192.168.30.5</code>，<strong>接收端</strong>IP地址就是<code>30.30.30.30</code>。将数据包发到NAT路由器中。</p><p>此时NAT路由器会将IP数据包里的<strong>源IP地址</strong>修改一下，私有IP地址<code>192.168.30.5</code>改写为公网IP地址<code>20.20.20.20</code>，这叫<strong>SNAT</strong>（<strong>S</strong>ource <strong>N</strong>etwork <strong>A</strong>ddress <strong>T</strong>ranslation，源地址转换）。并且还会在NAT路由器内部留下一条 <code>192.168.30.5 -&gt; 20.20.20.20</code>的映射记录，这个信息会在后面用到。之后IP数据包经过公网里各个路由器的转发，发到了接收端<code>30.30.30.30</code>，到这里<strong>发送流程</strong>结束。<br><img src="https://img-blog.csdnimg.cn/ec168d8b48e6443590860b726fe36059.png" alt="在这里插入图片描述"><br>如果接收端处理完数据了，需要发一个响应给你的电脑，那就需要将<strong>发送端</strong>IP地址填上自己的<code>30.30.30.30</code>，将<strong>接收端</strong>地址填为你的公网IP地址<code>20.20.20.20</code>，发往NAT路由器。NAT路由器收到公网来的消息之后，会检查下自己之前留下的映射信息，发现之前留下了这么一条 <code>192.168.30.5 -&gt; 20.20.20.20</code>记录，就会将这个数据包的<strong>目的IP地址</strong>修改一下，变成内网IP地址<code>192.168.30.5</code>, 这也叫<code>DNAT</code>（<strong>D</strong>estination <strong>N</strong>etwork <strong>A</strong>ddress <strong>T</strong>ranslation，目的地址转换）。之后将其转发给你的电脑上。<br><img src="https://img-blog.csdnimg.cn/f2dc9ddd396e4484b1490dbff420e264.png" alt="在这里插入图片描述"><br>整个过程下来，NAT悄悄的改了IP数据包的发送和接收端IP地址，但对真正的发送方和接收方来说，他们却<strong>对这件事情，一无所知</strong>。这就是NAT的工作原理。</p><h1>三、NAPT的原理</h1><h2 id="1、概述">1、概述</h2><p>到这里，相信大家都有一个很大的疑问。局域网里并不只有一台机器，局域网内每台机器都在 NAT 下留下的映射信息都会是 <code>192.168.xx.xx -&gt; 20.20.20.20</code>，发送消息是没啥事，但<strong>接收</strong>消息的时候就不知道该回给谁了。<br><img src="https://img-blog.csdnimg.cn/1d2cdad2fde54f6c90e3326cb220004d.png" alt="在这里插入图片描述"><br>这问题相当致命，因此<strong>实际上大部分时候不会使用普通的 NAT</strong>。那怎么办呢？问题出在我们没办法区分内网里的多个网络连接。于是乎。我们可以<strong>加入其他信息去区分内网里的各个网络连接，很自然就能想到端口。</strong></p><h2 id="2、NAPT原理详解">2、NAPT原理详解</h2><p>IP数据包（<strong>网络层</strong>）本身是没有端口信息的。常见的<strong>传输层</strong>协议TCP和UDP数据报文里才有<strong>端口</strong>的信息<br><img src="https://img-blog.csdnimg.cn/03d3d5899dbb424da56cc45d32379a7c.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/5a636dc902bd48de998b2114894f2639.png" alt="在这里插入图片描述">于是流程就变成了下面这样子。当你准备发送数据包的时候，你的电脑内核协议栈就会先构造一个TCP或者UDP数据报头，里面写入端口号，比如发送端口是<code>5000</code>，接收端口是<code>3000</code>，然后在这个基础上，加入 IP 数据报头，填入发送端和接收端的 IP 地址。那数据包长这样。<br><img src="https://img-blog.csdnimg.cn/50db6cc289974608b96603e687c6946d.png" alt="在这里插入图片描述"></p><h2 id="3、发送与接收过程">3、发送与接收过程</h2><p>假设，<strong>发送端</strong>IP地址填的就是<code>192.168.30.5</code>，<strong>接收端</strong>IP地址就是<code>30.30.30.30</code>。将数据包发到NAT路由器中。此时NAT路由器会将IP数据包里的<strong>源IP地址和端口号</strong>修改一下，从<code>192.168.30.5:5000</code>改写成<code>20.20.20.20:6000</code>。并且还会在NAT路由器内部留下一条 <code>192.168.30.5:5000 -&gt; 20.20.20.20:6000</code>的映射记录。之后数据包经过公网里各个路由器的转发，发到了接收端<code>30.30.30.30:3000</code>，到这里<strong>发送流程</strong>结束。<br><img src="https://img-blog.csdnimg.cn/ce59f1167519477c95e4c5033166e435.png" alt="在这里插入图片描述"><br>接收端响应时，就会在数据包里填入<strong>发送端</strong>地址是<code>30.30.30.30:3000</code>，将<strong>接收端</strong>是<code>20.20.20.20:6000</code>，发往NAT路由器。NAT路由器发现下自己之前留下过这么一条 <code>192.168.30.5:5000 -&gt; 20.20.20.20:6000</code>的记录，就会将这个数据包的<strong>目的IP地址和端口</strong>修改一下，变回原来的<code>192.168.30.5:5000</code>。之后将其转发给你的电脑上。<br><img src="https://img-blog.csdnimg.cn/fe3c7a2fd9b04e928d91bc815667aa68.png" alt="在这里插入图片描述"><br>如果局域网内有多个设备，他们就会映射到不同的公网端口上，毕竟端口最大可达 65535，完全够用。这样大家都可以相安无事。像这种同时转换 <strong>IP 和端口</strong>的技术，就是<strong>NAPT</strong>（Network Address Port Transfer , <strong>网络地址端口转换</strong> ）。</p><h2 id="4、ping命令">4、ping命令</h2><p>看到这里，问题就来了。那这么说<strong>只有用到端口的网络协议才能被 NAT 识别出来并转发？<strong>但这怎么解释<code>ping</code>命令？ping基于 ICMP 协议，而 ICMP 协议报文里并不带<code>端口</code>信息。我依然可以正常的ping通公网机器并收到回包。<br><img src="https://img-blog.csdnimg.cn/282f07f8fe5641eabf8ad6a34858468a.png" alt="在这里插入图片描述"><br>实上针对 ICMP 协议，NAT 路由器做了特殊处理。ping 报文头里有个<code>Identifier</code>的信息，它其实指的是放出ping命令的</strong>进程id</strong>。对 NAT 路由器来说，这个<code>Identifier</code>的作用就跟<code>端口</code>一样。另外，当我们去抓包的时候，就会发现有两个<code>Identifier</code>，一个后面带个<code>BE（Big Endian）</code>，另一个带个<code>LE（Little Endian）</code>。其实他们都是<strong>同一个数值</strong>，只不过<strong>大小端不同</strong>，读出来的值不一样。就好像同样的数字345，反着读就成了543。这是为了兼容不同操作系统（比如linux和Windows）下大小端不同的情况。<br><img src="https://img-blog.csdnimg.cn/6207dea8b8694480bd6593c7329ea3e1.png" alt="在这里插入图片描述"></p><h1>四、内网穿透</h1><h2 id="1、概述-v2">1、概述</h2><p>使用了NAT上网的话，前提得<strong>内网机器主动请求公网 IP</strong>，这样NAT才能将内网的 <strong>IP 端口</strong>转成外网 <strong>IP 端口</strong>。反过来公网的机器想主动请求内网机器，就会被拦在 NAT 路由器上，此时由于 NAT 路由器并没有任何相关的 IP 端口的<strong>映射记录</strong>，因此也就不会转发数据给内网里的任何一台机器。举个现实中的场景就是，你在你家里的电脑上启动了一个 HTTP 服务，地址是192.168.30.5:5000，此时你在公司办公室里想通过手机去访问一下，却发现访问不了。那问题就来了，有没有办法让外网机器访问到内网的服务？有。大家应该听过一句话叫，“<strong>没有什么是加中间层不能解决的，如果有，那就再加一层</strong>”。放在这里，依然适用。</p><p>说到底，因为 NAT 的存在，我们只能从内网主动发起连接，否则 NAT 设备不会记录相应的映射关系，没有映射关系也就不能转发数据。所以我们就在<strong>公网上</strong>加一台服务器 x，并暴露一个访问域名，再让内网的服务<strong>主动</strong>连接服务器 x，这样NAT路由器上就有对应的<strong>映射关系</strong>。接着，所有人都去访问服务器x，服务器x将数据转发给内网机器，再原路返回响应，这样数据就都通了。这就是所谓的<strong>内网穿透</strong>。<br>像上面提到的服务器x，你也不需要自己去搭，已经有很多现成的方案，花钱就完事了，比如花某壳。<br><img src="https://img-blog.csdnimg.cn/d2c72ad3ee18482d95ef322aded43aa9.png" alt><br>到这里，我们就可以回答这个问题：<strong>为什么我在公司里访问不了家里的电脑</strong>？那是因为家里的电脑在局域网内，局域网和广域网之间有个 NAT 路由器。由于 NAT 路由器的存在，外网服务无法主动连通局域网内的电脑。</p><h2 id="2、两个内网的聊天软件如何建立通讯">2、两个内网的聊天软件如何建立通讯</h2><p>我家机子是在我们小区的局域网里，班花家的机子也是在她们小区的局域网里。都在局域网里，且 NAT 只能从内网连到外网，那我电脑上登录的QQ是怎么和班花电脑里的QQ连上的呢？<br><img src="https://img-blog.csdnimg.cn/e2f49c46497d47589890752f5440c3e9.png" alt="在这里插入图片描述"><br>上面这个问法其实是存在个误解，误以为两个 qq 客户端应用是直接建立连接的。然而实际上并不是，两个 qq 客户端之间还隔了一个服务器<br><img src="https://img-blog.csdnimg.cn/8b09afe17dad41a08b8f35af6a1f7a4c.png" alt="在这里插入图片描述"><br>也就是说，两个在内网的客户端登录 qq 时都会<strong>主动</strong>向公网的聊天服务器建立连接，这时两方的 NAT 路由器中都会记录有相应的映射关系。当在其中一个 qq 上发送消息时，数据会先到服务器，再通过服务器转发到另外一个客户端上。反过来也一样，通过这个方式让两台内网的机子进行数据传输。</p><h2 id="3、两个内网的应用如何直接建立连接">3、两个内网的应用如何直接建立连接</h2><p>两端通信，比如 P2P 下载，这种该怎么办呢？这种情况下，其实也还是离不开第三方服务器的帮助。假设还是 A 和 B 两个<strong>局域网内</strong>的机子，A内网对应的NAT设备叫<code>NAT_A</code>，B内网里的NAT设备叫<code>NAT_B</code>，和一个第三方服务器<code>server</code>。流程如下。</p><ul><li><strong>step1和2</strong>: A 主动去连 server，此时 A 对应的<code>NAT_A</code>就会留下 A 的内网地址和外网地址的<strong>映射关系</strong>，server 也拿到了 A 对应的外网 IP 地址和端口。</li><li><strong>step3和4</strong>: B 的操作和 A 一样，主动连第三方 server，<code>NAT_B</code>内留下 B 的内网地址和外网地址的<strong>映射关系</strong>，然后 server 也拿到了 B 对应的外网 IP 地址和端口。</li><li><strong>step5和step6以及step7</strong>: 重点来了。此时 server 发消息给 A，让 A 主动发<code>UDP</code>消息到 B 的外网 IP 地址和端口。此时 NAT_B 收到这个 A 的UDP数据包时，这时候<strong>根据 NAT_B 的设置不同</strong>，导致这时候<strong>有可能</strong> NAT_B 能直接转发数据到 B，那此时 A 和 B 就通了。但也<strong>有可能不通</strong>，直接丢包，不过丢包没关系，这个操作的<strong>目的是</strong>给 NAT_A 上留下<strong>有关 B 的映射关系</strong>。</li><li><strong>step8和step9以及step10</strong>: 跟step5一样熟悉的配方，此时 server 再发消息给 B，让 B 主动发<code>UDP</code>消息到 A 的外网 IP 地址和端口。NAT_B 上也留下了关于 A 的映射关系，这时候由于之前 NAT_A 上有过关于 B 的映射关系，此时 NAT_A 就能正常接受 B 的数据包，并将其转发给 A。到这里 A 和 B 就能正常进行数据通信了。这就是所谓的 <strong>NAT 打洞</strong>。</li><li><strong>step11</strong>: 注意，之前我们都是用的 <strong>UDP 数据包</strong>，目的只是为了在两个局域网的 NAT 上<strong>打个洞</strong>出来，实际上大部分应用用的都是 TCP 连接，所以，这时候我们还需要在 A 主动向 B 发起 TCP 连接。到此，我们就完成了两端之间的通信。<br><img src="https://img-blog.csdnimg.cn/7eeb0e73467144ba94df12831a597779.png" alt="在这里插入图片描述"><br>这里可能会有疑惑，端口已经被udp用过了，TCP再用，<strong>那岂不是端口重复占用（address already in use）</strong>？其实并不会，端口重复占用的报错<strong>常见于</strong>两个TCP连接在不使用<code>SO_REUSEADDR</code>的情况下，重复使用了某个IP端口。而UDP和TCP之间却不会报这个错。之所以会有这个错，主要是因为在一个linux内核中，内核收到网络数据时，会通过五元组（<code>传输协议，源IP，目的IP，源端口，目的端口</code>）去唯一确定数据接受者。当五元组都一模一样的时候，内核就不知道该把数据发给谁。而UDP和TCP之间&quot;传输协议&quot;不同，因此五元组也不同，所以也就不会有上面的问题。</li></ul><p><img src="https://img-blog.csdnimg.cn/778a64faef6f4965b5417c5c359b8ef7.png" alt="在这里插入图片描述"></p><h1>五、不同类型NAT详解</h1><h2 id="1-、简介">1 、简介</h2><p>NAT分为两大类，基本的NAT和NAPT（即端口NAT，英文全称为Network Address/Port Translator）<br><img src="https://img-blog.csdnimg.cn/4db0be1a7fb941418b792c4294c0aa72.png" alt="在这里插入图片描述"></p><h2 id="2、基本NAT与NAPT">2、基本NAT与NAPT</h2><p>基本NAT分为静态NAT、动态NAT：</p><ul><li><strong>静态转换 （Static Nat）</strong> 是指将内部网络的私有IP地址转换为公有IP地址，IP地址对是一一对应的，不变的，某个私有IP地址只转换为某个公有IP地址</li><li><strong>动态转换 （Dynamic Nat）</strong>， 动态转换可以使用多个合法外部地址集，在将内部网络的私有IP地址转换为公用IP地址时，IP地址对是不确定的，而是随机的，其私有IP地址可随机转换为任何指定该地址集内的IP</li></ul><p>NAPT又分为<strong>锥型（Cone）和对称型（Symmetric）</strong>：</p><ul><li>对于<strong>锥形NAT</strong>，假设已经有client A用内网的123 port与server A完成通信，并且NAT将公网的456 port分配给client A的123 port，此时若client A再用123 port向server B发起通信，则NAT仍然会将公网的456 port分给client A的123 port</li><li>对于<strong>对称型NAT</strong>，仍然假设已经有client A用内网的123 port与server A完成通信，并且NAT将公网的456 port分配给client A的123 port，此时若client A想向server B发起通信，则NAT就不会在将公网的456 port分给client A，比如会将789 port分配给client A</li><li>对于非对称型NAT与对称型NAT的区别概括为一句话就是：<strong>对于非对称型NAT，映射关系与目的地址无关， 只要源地址相同，client内网IP端口与NAT公网IP端口映射关系就相同；而对称的NAT，映射关系还与目的地址有关</strong></li></ul><h2 id="3、锥型（Cone）NAT分类">3、锥型（Cone）NAT分类</h2><p>锥形NAT又可分为：<strong>完全圆锥体（Full Cone NAT）</strong>、<strong>受限制的圆锥体（Restricted Cone NAT）</strong>、<strong>端口受限制的圆锥体NAT（Port Restricted Cone NAT）三种</strong></p><p>假设 client A 已经用内网的 123 port 与 server A 完成通信，并且 NAT 将公网的 456 port 分配给 client A 的 123 port，下面举例说明三种锥型NAT定义区别：</p><ul><li><strong>完全圆锥体（Full Cone NAT）</strong>：server B的所有端口都可以直接通过公网的 456 port 与 client A的123 port通信，当然也包括 server A的所有端口<br>（对IP、port没有限制）</li><li><strong>受限制的圆锥体（Restricted Cone NAT）</strong>：需要client A已经向server B发送过消息，server B才能够通过公网的 456 port 与 client A 的 123 port 通信，在此前提下，server A、server B的所有端口数据都可以通过公网的 456 port与client A的123 port通信<br>（在完全圆锥基础上加了对IP的限制）</li><li><strong>端口受限制的圆锥体NAT（Port Restricted Cone NAT）</strong>：需要client A已经向server B发送过消息，server B的X端口才能通过公网的 456 port 与 client A的123 port通信，注意只有server A、server B的X端口才能与client A的123 port通信，其他端口若想与client A通信需要再单独建立连接<br>（在受限制圆锥基础上加了对port的限制）</li></ul><p><strong>client A在使用这三种锥型NAT与server A、server B通信时，分配给client A的公网一直是456 port，不会变</strong></p><h2 id="4、对称NAT概念的补充">4、对称NAT概念的补充</h2><p>假设有client A的123 port与server A的789 port、server B的789 port，若client A、server A想通信需要：<strong>client A的123先向server A的789发送消息</strong></p><p>并且分配给client A公网port 为456，则有：server A只能使用789与clientA的123通信，server A的其他端口不能与client A通信；server B若想与client A通信，需要client A先向server B发送消息，并且分配给client A的公网的port不会是456，故打洞困难</p><h2 id="5、总结">5、总结</h2><p>基本的NAT，它仅将内网主机的私有IP地址转换成公网IP地址，但并不将TCP/UDP端口信息进行转换，有动态与静态之区分。由于现在大部分都属于另一种类型，即NAPT，其中对称NAT打洞困难很高，但是安全性好；而锥型nat打洞比较容易。</p><p>实际上大部运营商提供的<strong>光猫上网服务都是锥形nat的</strong>。<strong>而光纤入户，3g 4g网络，公共wifi登因为安全因素都是对称nat</strong>，另外目前<strong>绝大多数的路由器都是非对称型NAT(Cone NAT)</strong>。只要请求链接的对方是非端口限制锥型nat就都能实现打洞p2p链接的。只有双方都是对称是一定无法实现，或一方对称一方是端口限制锥型nat的情况也无法实现打洞。下面是各种类型打洞总结</p><table><thead><tr><th>发送端</th><th>接收端</th><th>能否打洞</th></tr></thead><tbody><tr><td>完全锥形NAT</td><td>完全锥形NAT</td><td>√</td></tr><tr><td>完全锥形NAT</td><td>IP限制性锥形NAT</td><td>√</td></tr><tr><td>完全锥形NAT</td><td>端口限制性锥形NAT</td><td>√</td></tr><tr><td>完全锥形NAT</td><td>对称式NAT</td><td>√</td></tr><tr><td>IP限制性锥形NAT</td><td>IP限制性锥形NAT</td><td>√</td></tr><tr><td>IP限制性锥形NAT</td><td>端口限制性锥形NAT</td><td>√</td></tr><tr><td>IP限制性锥形NAT</td><td>对称式NAT</td><td>√</td></tr><tr><td>端口限制性锥形NAT</td><td>端口限制性锥形NAT</td><td>√</td></tr><tr><td>端口限制性锥形NAT</td><td>对称式NAT</td><td>×</td></tr><tr><td>对称式NAT</td><td>对称式NAT</td><td>×</td></tr></tbody></table><h1>六、家用网络低延迟方案</h1><h2 id="1、NAT简单回顾">1、NAT简单回顾</h2><p>NAT有4个类型，它们分别是：<strong>NAT1、NAT2、NAT3、NAT4</strong></p><ul><li><strong>NAT1: Full Cone NAT</strong>，全锥形NAT，这是最宽松的网络环境，你想做什么，基本没啥限制IP和端口都不受限</li><li><strong>NAT2: Address-Restricted Cone NAT</strong>，受限锥型NAT，相比NAT1，NAT2增加了地址限制，也就是IP受限，而端口不受限</li><li><strong>NAT3: Port-Restricted Cone NAT</strong>，端口受限锥型，相比NAT2，NAT3 增加了端口限制，即IP、端口都受限</li><li><strong>NAT4: Symmetric NAT</strong>，对称型NAT，对称型NAT具有端口受限锥型的受限特性，内部地址每一次请求一个特定的外部地址，都会绑定到一个新的端口。这种类型基本上就告别P2P了</li></ul><p>从NAT1到NAT4限制越来越多，为了满足各种需求，我们希望提升NAT类型。提升NAT类型的好处有，浏览网页、观看视频、游戏等更顺畅，下载速度更稳定快速，特别是对那些玩游戏的，提升改善NAT类型后联机速度更快，游戏体验明显提高</p><h2 id="2、低延迟方案讲解">2、低延迟方案讲解</h2><blockquote><p>想要游戏网速快，延迟低，就要nat1，公网，桥接，unpn，硬件nat加速</p></blockquote><ul><li><strong>修改光猫工作模式</strong></li></ul><p>把光猫工作模式设置为桥接模式(需要超级管理员账号密码，很多都是默认，可以根据地区上网搜索，新款的直接联系维修工人)，修改模式，因为运营商一般默认设置光猫工作在路由模式。无线路由器直接连到猫上就可以上网的，那么光猫是路由模式。<strong>无线路由器需要PPPoE拨号上网的就是桥接模式</strong>。</p><ul><li><strong>更改路由器设置</strong></li></ul><p>启用无线路由器的uPnP功能，uPnP大部分路由器都支持。把要提升NAT类型的主机IP设置为静态，然后开启DMZ(通过路由器拨号，路由器最好要刷机，然后选择NAT1模式)</p><h2 id="3、总结">3、总结</h2><ul><li>路由器层数越少，越可能得到NAT1和NAT2类型</li><li>NAT1是最宽松的网络环境，基本没限制。NAT4是最严格的网络环境，可能会玩不了游戏、P2P下载都没速度</li><li>如果光猫是桥接模式，路由器拨号上网的有可能是NAT2和NAT3，对上网、游戏和下载都没有太多限制</li><li>拨号能获得公网IP的，可以优化到NAT1，拨号获得内网IP基本是NAT4</li><li>中国电信、中国联通宽带一般是公网IP，中国移动、中国广电、长宽等基本是内网IP。</li></ul><h1>七、总结</h1><ul><li>IPV4 地址有限，但通过 NAT 路由器，可以使得整个内网 N 多台机器，对外只使用一个公网 IP，大大节省了 IP 资源</li><li>内网机子主动连接公网 IP，中间的 NAT 会将内网机子的内网 IP 转换为公网 IP，从而实现内网和外网的数据交互</li><li>普通的 NAT 技术，只会修改网络包中的发送端和接收端 IP 地址，当内网设备较多时，将有可能导致冲突。因此一般都会使用 NAPT 技术，同时修改发送端和接收端的 IP 地址和端口</li><li>由于 NAT 的存在，公网 IP 是无法访问内网服务的，但通过内网穿透技术，就可以让公网 IP 访问内网服务。一波操作下来，就可以在公司的网络里访问家里的电脑。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1&gt;一、概述&lt;/h1&gt;
&lt;h2 id=&quot;1、简介&quot;&gt;1、简介&lt;/h2&gt;
&lt;p&gt;大家有没有想过，为什么在公司里访问不了家里的电脑？这是因为IPv4地址有限，最大42亿个。为了更好的利用这有限的IP数量，网络分为&lt;strong&gt;局域网&lt;/strong&gt;和&lt;strong&gt;广域网&lt;/strong&gt;，将IP分为了&lt;strong&gt;私有IP和公网IP&lt;/strong&gt;，一个局域网里的N多台机器都可以&lt;strong&gt;共用一个公网IP&lt;/strong&gt;，从而大大增加了&amp;quot;可用IP数量&amp;quot;。&lt;br&gt;
&lt;img src=&quot;https://img-blog.csdnimg.cn/5b171760cc4f4b148c1074e3fbd46073.png&quot; alt=&quot;图片&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Linux运维" scheme="https://www.shawn22.xyz/categories/Linux%E8%BF%90%E7%BB%B4/"/>
    
    
    <category term="linux基础" scheme="https://www.shawn22.xyz/tags/linux%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>MySQL8.0基础篇</title>
    <link href="https://www.shawn22.xyz/posts/775449cf.html"/>
    <id>https://www.shawn22.xyz/posts/775449cf.html</id>
    <published>2023-03-05T16:17:32.000Z</published>
    <updated>2023-03-05T16:33:08.324Z</updated>
    
    <content type="html"><![CDATA[<h1>一、MySQL概述</h1><h2 id="1、数据库概述">1、数据库概述</h2><h3 id="1-1-数据库作用">1.1 数据库作用</h3><ul><li>持久化（persistence）：把数据保存到可掉电式存储设备中以供之后使用</li><li>持久化的主要作用是将内存中的数据存储在关系型数据库中，当然也可以存储在磁盘文件、XML数据文件中</li></ul><h3 id="1-2-数据库的相关概念">1.2 数据库的相关概念</h3><ul><li><strong>DB</strong>：数据库（Database）即存储数据的“仓库”，其本质是一个文件系统。它保存了一系列有组织的数据</li><li><strong>DBMS</strong>：数据库管理系统（Database Management System）是一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库，对数据库进行统一管理和 控制。用户通过数据库管理系统访问数据库中表内的数据。</li><li><strong>SQL</strong>：结构化查询语言（Structured Query Language），专门用来与数据库通信的语言</li></ul><p>目前互联网上常见的数据库管理软件有 Oracle、MySQL、MS SQL Server、DB2、PostgreSQL、Access、SyBase、Informix这几种（查看数据库最新排名：<a href="https://db-engines.com/en/ranking" target="_blank" rel="noopener">https://db-engines.com/en/ranking</a>）</p><a id="more"></a><h2 id="2、MySQL概述">2、MySQL概述</h2><h3 id="2-1-概述">2.1 概述</h3><p>MySQL是一个开放源码的关系型数据库管理系统，由瑞典 MySQL AB（创始人Michael Widenius）公司1995年开发，迅速成为开源数据库的No.1。2008年被Sun收购（10亿美金），2009年Sun被Oracle收购。MariaDB应运而生。（MySQL的创造者担心MySQL有闭源的风险，因此创建了MySQL的分支项目MariaDB）。MySQL6.x版本之后分为社区版和商业版。MySQL是一种关联数据库管理系统，将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。<br>MySQL是开源的，所以你不需要支付额外的费用。MySQL是可以定制的，采用了GPL（GUN General Public License）协议，你可以需改源码来开发自己的MySQL系统。MySQL支持大型的数据库。可以处理拥有上千万条记录的大型数据库。MySQL支持大型数据库，支持5000万条记录的数据仓库 ，32位系统表文件最大可支持4GB，64位系统支持最大的表文件为8TB。MySQL使用标准的SQL数据语言形式。MySQL可以允许运行于多个系统上，并且支持多种语言。这些编程语言包括C、C++、Python、Java、Perl、PHP、和Ruby等<br><img src="https://img-blog.csdnimg.cn/img_convert/b432391d9a994063550fe5bc9d23ff99.png" alt="image.png"></p><h3 id="2-2-RDBMS与非RDBMS">2.2 RDBMS与非RDBMS</h3><p><strong>关系型数据库的优点</strong>：复杂查询可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询；事务支持使得对于安全性能很高的数据访问要求得以实现。<br><strong>非关系型数据库</strong>，可看成传统关系型数据库的功能阉割版本，基于键值对存储数据，不需要经过SQL层的解析，性能非常高。同时通过减少不常用的功能，进一步提高性能</p><h2 id="3、MySQL环境安装">3、MySQL环境安装</h2><h3 id="3-1-MySQL的下载、安装、配置-win">3.1 MySQL的下载、安装、配置(win)</h3><blockquote><p>官网下载：<a href="https://dev.mysql.com/downloads/" target="_blank" rel="noopener">https://dev.mysql.com/downloads/</a></p></blockquote><p>下载之前先进行卸载(关闭mysql服务，卸载MySQL，清理文件，清理注册表(可选)，删除环境变量配置)，MySQL有四个版本</p><ul><li><strong>MySQL Community Server 社区版本</strong> ，开源免费，自由下载，但不提供官方技术支持，适用于大多数普通用户</li><li>MySQL Enterprise Edition 企业版本 ，需付费，不能在线下载，可以试用 30 天。提供了更多的功能和更完备的技术支持，更适合于对数据库的功能和可靠性要求较高的企业客户</li><li>MySQL Cluster 集群版 ，开源免费。用于架设集群服务器，可将几个MySQL Server封装成一个Server。需要在社区版或企业版的基础上使用</li><li>MySQL Cluster CGE 高级集群版 ，需付费</li></ul><p>此外，官方还提供了MySQL Workbench（GUITOOL）一款专为MySQL设计的图形界面管理工具。MySQLWorkbench又分为两个版本，分别是社区版（MySQL Workbench OSS）、商用版（MySQLWorkbenchSE）。<strong>Windows平台下提供两种安装文件：MySQL二进制分发版（.msi安装文件）和免安装版（.zip压缩文件）</strong>。一般来讲，应当使用二进制分发版，因为该版本提供了图形化的安装向导过程，比其他的分发版使用起来要简单，不再需要其他工具启动就可以运行MySQL。最后需要将mysql的bin目录放在环境变量中</p><h3 id="3-2-MySQL登录">3.2 MySQL登录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动　MySQL　服务命令</span></span><br><span class="line">net　start　MySQL服务名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止　MySQL　服务命令</span></span><br><span class="line">net　stop　MySQL服务名</span><br><span class="line"><span class="comment"># 也可以进入服务自己去打开</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录</span></span><br><span class="line">mysql -h 主机名 -P 端口号 -u 用户名 -p密码</span><br><span class="line">mysql -h localhost -P 3306 -u root -pabc123</span><br><span class="line">mysql -V</span><br><span class="line"><span class="comment"># 进入mysql后</span></span><br><span class="line">select version();</span><br><span class="line"><span class="built_in">exit</span>/quit</span><br></pre></td></tr></table></figure><h3 id="3-3-MySQL演示使用">3.3 MySQL演示使用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看所有数据库</span></span><br><span class="line">show databases;</span><br></pre></td></tr></table></figure><ul><li><strong>information_schema</strong>是 MySQL 系统自带的数据库，主要保存 MySQL 数据库服务器的系统信息，比如数据库的名称、数据表的名称、字段名称、存取权限、数据文件 所在的文件夹和系统使用的文件夹，等等。</li><li><strong>performance_schema</strong>是 MySQL 系统自带的数据库，可以用来监控 MySQL 的各类性能指标。</li><li><strong>sys</strong>数据库是 MySQL 系统自带的数据库，主要作用是以一种更容易被理解的方式展示 MySQL 数据库服务器的各类性能指标，帮助系统管理员和开发人员监控 MySQL 的技术性能。</li><li><strong>mysql</strong>数据库保存了 MySQL 数据库服务器运行时需要的系统信息，比如数据文件夹、当前使用的字符集、约束检查信息，等等。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据库的默认编码改为utf8mb4，见下面的ini修改，记得重启服务</span></span><br><span class="line"><span class="comment"># 创建自己的数据库</span></span><br><span class="line">create database 数据库名;</span><br><span class="line"><span class="comment"># 使用自己的数据库</span></span><br><span class="line">use 数据库名;</span><br><span class="line"><span class="comment"># 查看某个库的所有表格</span></span><br><span class="line">show tables;  <span class="comment">#要求前面有use语句</span></span><br><span class="line">show tables from 数据库名;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建新的表格</span></span><br><span class="line">create table 表名称(</span><br><span class="line">字段名 数据类型,</span><br><span class="line">字段名 数据类型</span><br><span class="line">);</span><br><span class="line"><span class="comment">#创建学生表</span></span><br><span class="line">create table student(</span><br><span class="line">id int,</span><br><span class="line">name varchar(20)  <span class="comment">#说名字最长不超过 20 个字符</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看一个表的数据</span></span><br><span class="line">select * from 数据库表名称;</span><br><span class="line"><span class="comment">#查看学生表的数据</span></span><br><span class="line">select * from student;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加一条记录</span></span><br><span class="line">insert into 表名称 values(值列表);</span><br><span class="line"><span class="comment">#添加两条记录到student表中</span></span><br><span class="line">insert into student values( 1 ,<span class="string">'张三'</span>);</span><br><span class="line">insert into student values( 2 ,<span class="string">'李四'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看表的创建信息</span></span><br><span class="line">show create table 表名称\G</span><br><span class="line"><span class="comment">#查看student表的详细创建信息</span></span><br><span class="line">show create table student\G</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看数据库的创建信息</span></span><br><span class="line">show create database 数据库名\G</span><br><span class="line"><span class="comment">#查看atguigudb数据库的详细创建信息</span></span><br><span class="line">show create database atguigudb\G</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除表格</span></span><br><span class="line">drop table 表名称;</span><br><span class="line"><span class="comment">#删除学生表</span></span><br><span class="line">drop table student;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除数据库</span></span><br><span class="line">drop database 数据库名;</span><br><span class="line"><span class="comment">#删除atguigudb数据库</span></span><br><span class="line">drop database atguigudb;</span><br></pre></td></tr></table></figure><p>MySQL图形化管理工具极大地方便了数据库的操作与管理，常用的图形化管理工具有：<strong>MySQL Workbench、phpMyAdmin、</strong><a href="https://www.navicat.com.cn/" target="_blank" rel="noopener"><strong>Navicat Preminum</strong></a><strong>、MySQLDumper、SQLyog、dbeaver、MySQL ODBCConnector(推荐navicate)</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果图形化连接出现错误，原因是MySQL8之前的版本中加密规则是mysql_native_password，而在MySQL8之后，加密规则是caching_sha2_password</span></span><br><span class="line"><span class="comment"># 解决问题方法有两种，第一种是升级图形界面工具版本，第二种是把MySQL8用户登录密码加密规则还原成mysql_native_password</span></span><br><span class="line"><span class="comment">#使用mysql数据库</span></span><br><span class="line">USE mysql;</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改'root'@'localhost'用户的密码规则和密码</span></span><br><span class="line">ALTER USER <span class="string">'root'</span>@<span class="string">'localhost'</span> IDENTIFIED WITH mysql_native_password BY <span class="string">'abc123'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#刷新权限</span></span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure><p>如果root密码忘记</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过任务管理器或者服务管理，关掉mysqld(服务进程)</span></span><br><span class="line"><span class="comment"># 通过命令行+特殊参数开启</span></span><br><span class="line">mysqld mysqld – defaults-file=<span class="string">"D:\ProgramFiles\mysql\MySQLServer5.7Data\my.ini"</span> –skip-grant-tables</span><br><span class="line"><span class="comment"># 此时，mysqld服务进程已经打开。并且不需要权限检查</span></span><br><span class="line"><span class="comment"># 无密码登陆服务器</span></span><br><span class="line">mysql -uroot </span><br><span class="line"><span class="comment"># 修改权限表</span></span><br><span class="line">use mysql;</span><br><span class="line">update user <span class="built_in">set</span> authentication_string=password(<span class="string">'新密码'</span>) <span class="built_in">where</span> user=<span class="string">'root'</span> and Host=<span class="string">'localhost;</span></span><br><span class="line"><span class="string">flush privileges;</span></span><br><span class="line"><span class="string"># 最后重启mysql服务</span></span><br></pre></td></tr></table></figure><h3 id="3-4-MySQL目录结构与源码">3.4 MySQL目录结构与源码</h3><table><thead><tr><th><strong>MySQL的目录结构</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>bin目录</td><td>所有MySQL的可执行文件。如：mysql.exe</td></tr><tr><td>MySQLInstanceConfig.exe</td><td>数据库的配置向导，在安装时出现的内容</td></tr><tr><td>data目录</td><td>系统数据库所在的目录</td></tr><tr><td>my.ini文件</td><td>MySQL的主要配置文件</td></tr><tr><td>D:\software\mysql\data</td><td>用户创建的数据库所在的目录</td></tr></tbody></table><p>这是我的my.ini配置文件，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"><span class="comment"># 设置3306端口</span></span><br><span class="line">port=3306</span><br><span class="line"><span class="comment"># 设置mysql的安装目录</span></span><br><span class="line">basedir=D:\\software\\mysql</span><br><span class="line"><span class="comment"># 设置mysql数据库的数据的存放目录</span></span><br><span class="line">datadir=D:\\software\\mysql\\data</span><br><span class="line"><span class="comment"># 允许最大连接数</span></span><br><span class="line">max_connections=200</span><br><span class="line"><span class="comment"># 允许连接失败的次数。这是为了防止有人从该主机试图攻击数据库系统</span></span><br><span class="line">max_connect_errors=10</span><br><span class="line"><span class="comment"># 服务端使用的字符集默认为UTFMB4</span></span><br><span class="line">character-set-server=utf8mb4</span><br><span class="line"><span class="comment"># 创建新表时将使用的默认存储引擎</span></span><br><span class="line">default-storage-engine=INNODB</span><br><span class="line"><span class="comment"># 默认使用“mysql_native_password”插件认证</span></span><br><span class="line">default_authentication_plugin=mysql_native_password</span><br><span class="line">[mysql]</span><br><span class="line"><span class="comment"># 设置mysql客户端默认字符集</span></span><br><span class="line">default-character-set=utf8mb4</span><br><span class="line">[client]</span><br><span class="line"><span class="comment"># 设置mysql客户端连接服务端时默认使用的端口</span></span><br><span class="line">port=3306</span><br><span class="line">default-character-set=utf8mb4</span><br></pre></td></tr></table></figure><p>MySQL 源代码获取，首先，你要进入 MySQL下载界面。 这里你不要选择用默认的“Microsoft Windows”，而是要通过下拉栏，找到“Source Code”，在下面的操作系统版本里面， 选择 Windows（Architecture Independent），然后点击下载。接下来，把下载下来的压缩文件解压，我们就得到了 MySQL 的源代码。MySQL 是用 C++ 开发而成的，我简单介绍一下源代码的组成。mysql-8.0.22 目录下的各个子目录，包含了 MySQL 各部分组件的源代码</p><ul><li>sql 子目录是 MySQL 核心代码；</li><li>libmysql 子目录是客户端程序 API；</li><li>mysql-test 子目录是测试工具；</li><li>mysys 子目录是操作系统相关函数和辅助函数</li></ul><h1>二、SQL查询</h1><h2 id="1、SQL详情">1、SQL详情</h2><h3 id="1-1-SQL分类">1.1 SQL分类</h3><ul><li><strong>DDL（Data Definition Languages、数据定义语言）</strong> ，这些语句定义了不同的数据库、表、视图、索引等数据库对象，还可以用来创建、删除、修改数据库和数据表的结构。主要的语句关键字包括CREATE、DROP、ALTER等</li><li>**DML（Data Manipulation Language、数据操作语言） **，用于添加、删除、更新和查询数据库记录，并检查数据完整性。主要的语句关键字包括INSERT、DELETE、UPDATE、SELECT等。SELECT是SQL语言的基础，最为重要。</li><li><strong>DCL（Data Control Language、数据控制语言）</strong> ，用于定义数据库、表、字段、用户的访问权限和安全级别。主要的语句关键字包括GRANT、REVOKE、COMMIT、ROLLBACK、SAVEPOINT等。</li></ul><blockquote><p>因为查询语句使用的非常的频繁，所以很多人把查询语句单拎出来一类：DQL（数据查询语言）。还有单独将COMMIT、ROLLBACK 取出来称为TCL （Transaction Control Language，事务控制语言）。</p></blockquote><h3 id="1-2-SQL语言的规则与规范">1.2 SQL语言的规则与规范</h3><p><strong>基本规则</strong></p><ul><li>SQL 可以写在一行或者多行。为了提高可读性，各子句分行写，必要时使用缩进</li><li>每条命令以 ; 或 \g 或 \G 结束</li><li>关键字不能被缩写也不能分行</li><li>关于标点符号<ul><li>必须保证所有的()、单引号、双引号是成对结束的</li><li>必须使用英文状态下的半角输入方式</li><li>字符串型和日期时间类型的数据可以使用单引号（’ '）表示</li><li>列的别名，尽量使用双引号（&quot; &quot;），而且不建议省略as</li></ul></li></ul><p><strong>SQL大小写规范 （建议遵守）</strong></p><ul><li><strong>MySQL 在 Windows 环境下是大小写不敏感的</strong></li><li><strong>MySQL 在 Linux 环境下是大小写敏感的</strong><ul><li>数据库名、表名、表的别名、变量名是严格区分大小写的</li><li>关键字、函数名、列名(或字段名)、列的别名(字段的别名) 是忽略大小写的。</li></ul></li><li><strong>推荐采用统一的书写规范：</strong><ul><li>数据库名、表名、表别名、字段名、字段别名等都小写</li><li>SQL 关键字、函数名、绑定变量等都大写</li></ul></li></ul><p><strong>注释</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">单行注释：<span class="comment">#注释文字(MySQL特有的方式)</span></span><br><span class="line">单行注释：<span class="comment">-- 注释文字(--后面必须包含一个空格。)</span></span><br><span class="line">多行注释：<span class="comment">/* 注释文字 */</span></span><br></pre></td></tr></table></figure><p><strong>命名规则（暂时了解）</strong></p><ul><li>数据库、表名不得超过 30 个字符，变量名限制为 29 个</li><li>必须只能包含 A–Z, a–z, 0–9, _共 63 个字符</li><li>数据库名、表名、字段名等对象名中间不要包含空格</li><li>同一个MySQL软件中，数据库不能同名；同一个库中，表不能重名；同一个表中，字段不能重名</li><li>必须保证你的字段没有和保留字、数据库系统或常用方法冲突。如果坚持使用，请在SQL语句中使用`（着重号）引起来</li><li>保持字段名和类型的一致性，在命名字段并为其指定数据类型的时候一定要保证一致性。假如数据类型在一个表里是整数，那在另一个表里可就别变成字符型了</li></ul><p><strong>数据导入指令</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据导入指令，需要用命令行</span></span><br><span class="line">source d:\xxx.sql</span><br><span class="line"><span class="comment"># 通过FOREIGN_KEY_CHECKS解决，用法如下</span></span><br><span class="line"><span class="keyword">set</span> FOREIGN_KEY_CHECKS=<span class="number">0</span>;  <span class="comment">#在导入前设置为不检查外键约束</span></span><br><span class="line"><span class="keyword">set</span> FOREIGN_KEY_CHECKS=<span class="number">1</span>;  <span class="comment">#在导入后恢复检查外键约束</span></span><br></pre></td></tr></table></figure><h2 id="2、-基本的SELECT语句">2、 基本的SELECT语句</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> departments;</span><br><span class="line"><span class="comment">-- 重命名一个列,as也可以省略；别名使用双引号，以便在别名中包含空格或特 殊的字符并区分大小写</span></span><br><span class="line"><span class="keyword">SELECT</span> last_name <span class="keyword">AS</span> <span class="keyword">name</span>, commission_pct comm <span class="keyword">FROM</span> employees;</span><br><span class="line"><span class="comment">-- 去除重复行，如果有多个列，就会去重全部列的</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> department_id <span class="keyword">FROM</span> employees;</span><br><span class="line"><span class="comment">--  空值参与运算</span></span><br><span class="line"><span class="comment">-- 空值：null ( 不等同于0, '', 'null' )实际问题的解决方案：引入IFNULL</span></span><br><span class="line"><span class="comment">--  空值不等于空字符串。一个空字符串的长度是 0，而一个空值的长 度是空。而且，在 MySQL 里面，空值是占用空间的</span></span><br><span class="line"><span class="keyword">SELECT</span> employee_id, salary <span class="string">"月工资"</span>, salary * (<span class="number">1</span> + <span class="keyword">IFNULL</span>(commission_pct, <span class="number">0</span>)) * <span class="number">12</span> <span class="string">"年工资"</span> <span class="keyword">FROM</span> employees;</span><br><span class="line"><span class="comment">-- 着重号 ``,保证你的字段没有和保留字、数据库系统或常见方法冲突</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`order`</span>;</span><br><span class="line"><span class="comment">-- 查询常数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">'小张科技'</span> <span class="keyword">as</span> <span class="string">"公司名"</span>, employee_id, last_name <span class="keyword">FROM</span> employees;</span><br><span class="line"><span class="comment">-- 显示表中字段的详细信息</span></span><br><span class="line"><span class="keyword">DESCRIBE</span> employees;</span><br><span class="line">DESC employees;</span><br><span class="line"><span class="comment">-- 过滤数据</span></span><br><span class="line"><span class="keyword">SELECT</span> employee_id, last_name, job_id, department_id <span class="keyword">FROM</span> employeesWHERE department_id = <span class="number">90</span>;</span><br></pre></td></tr></table></figure><ul><li>Field：表示字段名称。</li><li>Type：表示字段类型，这里 barcode、goodsname 是文本型的，price 是整数类型的。</li><li>Null：表示该列是否可以存储NULL值。</li><li>Key：表示该列是否已编制索引。</li><li>PRI表示该列是表主键的一部分；</li><li>UNI表示该列是UNIQUE索引的一 部分；</li><li>MUL表示在列中某个给定值允许出现多次。</li><li>Default：表示该列是否有默认值，如果有，那么值是多少。</li><li>Extra：表示可以获取的与给定列有关的附加信息，例如AUTO_INCREMENT等</li></ul><h2 id="3、运算符">3、运算符</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- DUAL 伪表</span></span><br><span class="line"><span class="comment">-- 算术运算符</span></span><br><span class="line"><span class="comment">-- 一个整数类型的值对整数进行加法和减法操作，结果还是一个整数；</span></span><br><span class="line"><span class="comment">-- 一个整数类型的值对浮点数进行加法和减法操作，结果是一个浮点数；</span></span><br><span class="line"><span class="comment">-- 在Java中， + 的左右两边如果有字符串，那么表示字符串的拼接。但是在MySQL中 + 只表示数值相加。如果遇到非数值类型，先尝试转成数值，如果转失败，就按0计算。（注：MySQL 中字符串拼接要使用字符串函数CONCAT()实现）</span></span><br><span class="line"><span class="comment">-- 在数学运算中，0不能用作除数，在MySQL中，一个数除以0为NULL</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">100</span> + <span class="number">0</span>, <span class="number">100</span> + <span class="number">50</span> * <span class="number">30</span>, <span class="number">100</span> - <span class="number">35.5</span> <span class="keyword">FROM</span> DUAL;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 比较运算符</span></span><br><span class="line"><span class="comment">-- 比较的结果为真则返回1，比较的结果 为假则返回0，其他情况则返回NULL</span></span><br><span class="line"><span class="comment">-- 如果等号两边的值、字符串或表达式中有一个为NULL，则比较结果为NULL</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">1</span> = <span class="number">1</span>, <span class="number">1</span> = <span class="string">'1'</span>, <span class="number">1</span> = <span class="number">0</span>, <span class="string">'a'</span> = <span class="string">'a'</span>, (<span class="number">5</span> + <span class="number">3</span>) = (<span class="number">2</span> + <span class="number">6</span>), <span class="string">''</span> = <span class="literal">NULL</span> , <span class="literal">NULL</span> = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">1</span> = <span class="number">2</span>, <span class="number">0</span> = <span class="string">'abc'</span>, <span class="number">1</span> = <span class="string">'abc'</span> <span class="keyword">FROM</span> DUAL;</span><br><span class="line"><span class="comment">-- 如果等号两边的值、字符串或表达式都为字符串，则MySQL会按照字符串进行比较，其比较的 是每个字符串中字符的ANSI编码是否相等</span></span><br><span class="line"><span class="comment">-- 如果等号两边的值都是整数，则MySQL会按照整数来比较两个值的大小。 </span></span><br><span class="line"><span class="comment">-- 如果等号两边的值一个是整数，另一个是字符串，则MySQL会将字符串转化为数字进行比较。 </span></span><br><span class="line"><span class="comment">-- 如果等号两边的值、字符串或表达式中有一个为NULL，则比较结果为NULL</span></span><br><span class="line"><span class="comment">-- &lt;=&gt; 使用安全等于运算符时，两边的操作数的值都为NULL时，返回的结果为1而不是NULL，其他返回结果与等于运算符相同</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">1</span> &lt;=&gt; <span class="string">'1'</span>, <span class="number">1</span> &lt;=&gt; <span class="number">0</span>, <span class="string">'a'</span> &lt;=&gt; <span class="string">'a'</span>, (<span class="number">5</span> + <span class="number">3</span>) &lt;=&gt; (<span class="number">2</span> + <span class="number">6</span>), <span class="string">''</span> &lt;=&gt; <span class="literal">NULL</span>,<span class="literal">NULL</span> &lt;=&gt; <span class="literal">NULL</span> <span class="keyword">FROM</span> dual</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 不等于运算符</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">1</span> &lt;&gt; <span class="number">1</span>, <span class="number">1</span> != <span class="number">2</span>, <span class="string">'a'</span> != <span class="string">'b'</span>, (<span class="number">3</span>+<span class="number">4</span>) &lt;&gt; (<span class="number">2</span>+<span class="number">6</span>), <span class="string">'a'</span> != <span class="literal">NULL</span>, <span class="literal">NULL</span> &lt;&gt; <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="literal">NULL</span> <span class="keyword">IS</span> <span class="literal">NULL</span>, <span class="keyword">ISNULL</span>(<span class="literal">NULL</span>), <span class="keyword">ISNULL</span>(<span class="string">'a'</span>), <span class="number">1</span> <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="literal">NULL</span> <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>, <span class="string">'a'</span> <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>, <span class="number">1</span> <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/af4bf61c1a3e126e0d5cbfa13966d3ce.png" alt="image.png"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 最小值运算符</span></span><br><span class="line"><span class="comment">-- 语法格式为：LEAST(值 1 ，值 2 ，…，值n)。其中，“值n”表示参数列表中有n个值。在有两个或多个参数的情况下，返回最小值</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">LEAST</span> ( <span class="number">1</span> , <span class="number">0</span> , <span class="number">2</span> ), <span class="keyword">LEAST</span>(<span class="string">'b'</span>,<span class="string">'a'</span>,<span class="string">'c'</span>), <span class="keyword">LEAST</span>( <span class="number">1</span> ,<span class="literal">NULL</span>, <span class="number">2</span> );</span><br><span class="line"><span class="comment">-- 最大值运算符</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">GREATEST</span>( <span class="number">1</span> , <span class="number">0</span> , <span class="number">2</span> ), <span class="keyword">GREATEST</span>(<span class="string">'b'</span>,<span class="string">'a'</span>,<span class="string">'c'</span>), <span class="keyword">GREATEST</span>( <span class="number">1</span> ,<span class="literal">NULL</span>, <span class="number">2</span> );</span><br><span class="line"><span class="comment">-- BETWEEN AND运算符</span></span><br><span class="line"><span class="comment">-- BETWEEN运算符使用的格式通常为SELECT D FROM TABLE WHERE C BETWEEN A AND B，此时，当C大于或等于A，并且C小于或等于B时，结果为 1 ，否则结果为 0</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">BETWEEN</span> <span class="number">0</span> <span class="keyword">AND</span> <span class="number">1</span> , <span class="number">10</span> <span class="keyword">BETWEEN</span> <span class="number">11</span> <span class="keyword">AND</span> <span class="number">12</span> , <span class="string">'b'</span> <span class="keyword">BETWEEN</span> <span class="string">'a'</span> <span class="keyword">AND</span> <span class="string">'c'</span>;</span><br><span class="line"><span class="keyword">SELECT</span> last_name, salary <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> salary <span class="keyword">BETWEEN</span> <span class="number">2500</span> <span class="keyword">AND</span> <span class="number">3500</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- IN运算符</span></span><br><span class="line"><span class="comment">-- IN运算符用于判断给定的值是否是IN列表中的一个值，如果是则返回 1 ，否则返回 0 。如果给定的值为NULL，或者IN列表中存在NULL，则结果为NULL</span></span><br><span class="line"><span class="keyword">SELECT</span> employee_id, last_name, salary, manager_id <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> manager_id <span class="keyword">IN</span> (<span class="number">100</span> ,<span class="number">101</span> ,<span class="number">201</span>);</span><br><span class="line"><span class="comment">-- NOT IN运算符</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">'a'</span> <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>), <span class="number">1</span> <span class="keyword">NOT</span> <span class="keyword">IN</span> ( <span class="number">2</span> , <span class="number">3</span> );</span><br><span class="line"><span class="comment">-- LIKE运算符,如果给定的值或者匹配条件为NULL，则返回结果为NULL</span></span><br><span class="line"><span class="comment">-- "%"：匹配 0 个或多个字符</span></span><br><span class="line"><span class="comment">-- "_"：只能匹配一个字符</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="literal">NULL</span> <span class="keyword">LIKE</span> <span class="string">'abc'</span>, <span class="string">'abc'</span> <span class="keyword">LIKE</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">SELECT</span> last_name <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> last_name <span class="keyword">LIKE</span> <span class="string">'_o%'</span>;</span><br><span class="line"><span class="comment">-- 回避特殊符号的： 使用转义符 例如：将[%]转为[$%]、[]转为[$]，然后再加上[ESCAPE'$']即可</span></span><br><span class="line"><span class="comment">-- 默认 \是转义</span></span><br><span class="line"><span class="keyword">SELECT</span> job_id <span class="keyword">FROM</span> jobs <span class="keyword">WHERE</span> job_id <span class="keyword">LIKE</span> <span class="string">'IT\_%'</span>;</span><br><span class="line"><span class="keyword">SELECT</span> job_id <span class="keyword">FROM</span> jobs <span class="keyword">WHERE</span> job_id <span class="keyword">LIKE</span> <span class="string">'IT$_%'</span> escape <span class="string">'$'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- REGEXP运算符</span></span><br><span class="line"><span class="comment">-- REGEXP运算符用来匹配字符串，语法格式为：expr REGEXP 匹配条件</span></span><br><span class="line"><span class="comment">-- '^'匹配以该字符后面的字符开头的字符串。</span></span><br><span class="line"><span class="comment">-- '$'匹配以该字符前面的字符结尾的字符串。</span></span><br><span class="line"><span class="comment">-- '.'匹配任何一个单字符。</span></span><br><span class="line"><span class="comment">-- "[...]"匹配在方括号内的任何字符。例如，"[abc]"匹配"a"或"b"或"c"。为了命名字符的范围，使用一个'-'。"[a-z]"匹配任何字母，而"[0-9]"匹配任何数字。</span></span><br><span class="line"><span class="comment">-- '*'匹配零个或多个在它前面的字符。例如，"x*"匹配任何数量的'x'字符，"[0-9]*"匹配任何数量的数字，而"*"匹配任何数量的任何字符。</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">'atguigu'</span> REGEXP <span class="string">'gu.gu'</span>, <span class="string">'atguigu'</span> REGEXP <span class="string">'[ab]'</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/c4d1a68aa6cdd18e422bca3e7bb139cd.png" alt="image.png"><br><strong>逻辑运算符</strong>主要用来判断表达式的真假，在MySQL中，逻辑运算符的返回结果为1、0或者NULL<br><img src="https://img-blog.csdnimg.cn/img_convert/f59a13f6fbb56116986899481246330a.png" alt="image.png"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 逻辑非（NOT或!）运算符表示当给定的值为 0 时返回 1 ；当给定的值为非 0 值时返回 0 ；当给定的值为NULL时，返回NULL</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">NOT</span> <span class="number">1</span> , <span class="keyword">NOT</span> <span class="number">0</span> , <span class="keyword">NOT</span>( <span class="number">1</span> + <span class="number">1</span> ), <span class="keyword">NOT</span>! <span class="number">1</span> , <span class="keyword">NOT</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">-- 逻辑与（AND或&amp;&amp;）运算符是当给定的所有值均为非 0 值，并且都不为NULL时，返回1 ；当给定的一个值或者多个值为 0 时则返回 0 ；否则返回NULL</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">AND</span> - <span class="number">1</span> , <span class="number">0</span> <span class="keyword">AND</span> <span class="number">1</span> , <span class="number">0</span> <span class="keyword">AND</span> <span class="literal">NULL</span>, <span class="number">1</span> <span class="keyword">AND</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">-- 逻辑或（OR或||）运算符是当给定的值都不为NULL，并且任何一个值为非 0 值时，则返回 1 ，否则返回 0 ；当一个值为NULL，并且另一个值为非 0 值时，返回 1 ，否则返回NULL；当两个值都为NULL时，返回NULL</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">OR</span> - <span class="number">1</span> , <span class="number">1</span> <span class="keyword">OR</span> <span class="number">0</span> , <span class="number">1</span> <span class="keyword">OR</span> <span class="literal">NULL</span>, <span class="number">0</span> || <span class="literal">NULL</span>, <span class="literal">NULL</span> || <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">-- 逻辑异或（XOR）运算符是当给定的值中任意一个值为NULL时，则返回NULL；如果两个非NULL的值都是 0 或者都不等于 0 时，则返回 0 ；如果一个值为 0 ，另一个值不为 0 时，则返回 1</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">XOR</span> - <span class="number">1</span> , <span class="number">1</span> <span class="keyword">XOR</span> <span class="number">0</span> , <span class="number">0</span> <span class="keyword">XOR</span> <span class="number">0</span> , <span class="number">1</span> <span class="keyword">XOR</span> <span class="literal">NULL</span>, <span class="number">1</span> <span class="keyword">XOR</span> <span class="number">1</span> <span class="keyword">XOR</span> <span class="number">1</span> , <span class="number">0</span> <span class="keyword">XOR</span> <span class="number">0</span> <span class="keyword">XOR</span> <span class="number">0</span> ;</span><br><span class="line"><span class="comment">-- AND优先级高于OR</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/b93df1f4c44b5d9ae475f3a17f1831f9.png" alt="image.png"><br><strong>位运算符</strong>是在二进制数上进行计算的运算符。位运算符会先将操作数变成二进制数，然后进行位运算， 最后将计算结果从二进制变回十进制数<br><img src="https://img-blog.csdnimg.cn/img_convert/97e13622b2e42d3c75015eb9992afefb.png" alt="image.png"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 按位与（&amp;）运算符将给定值对应的二进制数逐位进行逻辑与运算。当给定值对应的二进制位的数值都为 1 时，则该位返回 1 ，否则返回 0 。</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">1</span> &amp; <span class="number">10</span> , <span class="number">20</span> &amp; <span class="number">30</span> ;</span><br><span class="line"><span class="comment">-- 按位或（|）运算符将给定的值对应的二进制数逐位进行逻辑或运算。当给定值对应的二进制位的数值有一个或两个为 1 时，则该位返回 1 ，否则返回 0 </span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">1</span> | <span class="number">10</span> , <span class="number">20</span> | <span class="number">30</span> ;</span><br><span class="line"><span class="comment">-- 按位异或（^）运算符将给定的值对应的二进制数逐位进行逻辑异或运算。当给定值对应的二进制位的数值不同时，则该位返回 1 ，否则返回 0</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">1</span> ^ <span class="number">10</span> , <span class="number">20</span> ^ <span class="number">30</span> ;</span><br><span class="line"><span class="comment">-- 按位取反（~）运算符将给定的值的二进制数逐位进行取反操作，即将 1 变为 0 ，将 0 变为 1 。</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">10</span> &amp; ~<span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 按位右移（&gt;&gt;）运算符将给定的值的二进制数的所有位右移指定的位数。右移指定的位数后，右边低位的数值被移出并丢弃，左边高位空出的位置用 0 补齐</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">1</span> &gt;&gt; <span class="number">2</span> , <span class="number">4</span> &gt;&gt; <span class="number">2</span> ;</span><br><span class="line"><span class="comment">-- 按位左移（&lt;&lt;）运算符将给定的值的二进制数的所有位左移指定的位数。左移指定的位数后，左边高位的数值被移出并丢弃，右边低位空出的位置用 0 补齐</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">1</span> &lt;&lt; <span class="number">2</span> , <span class="number">4</span> &lt;&lt; <span class="number">2</span> ;</span><br></pre></td></tr></table></figure><h2 id="4、排序和分页">4、排序和分页</h2><h3 id="4-1-排序规则">4.1 排序规则</h3><ul><li>使用 ORDER BY 子句排序<ul><li>ASC（ascend）: 升序</li><li>DESC（descend）:降序</li></ul></li><li>ORDER BY 子句在SELECT语句的结尾，列的别名只能在order by使用，不能在where使用，where需要在from后面</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--  单列排序</span></span><br><span class="line"><span class="keyword">SELECT</span> last_name, job_id, department_id, hire_date <span class="keyword">FROM</span> employees <span class="keyword">ORDER</span> <span class="keyword">BY</span> hire_date;</span><br><span class="line"><span class="comment">-- 多列排序</span></span><br><span class="line"><span class="comment">-- 可以使用不在SELECT列表中的列排序 </span></span><br><span class="line"><span class="comment">-- 在对多列进行排序的时候，首先排序的第一列必须有相同的列值，才会对第二列进行排序。</span></span><br><span class="line"><span class="comment">-- 如果第一列数据中所有值都是唯一的，将不再对第二列进行排序</span></span><br></pre></td></tr></table></figure><h3 id="4-2-分页">4.2 分页</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--前10条记录：</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> 表名 <span class="keyword">LIMIT</span> <span class="number">0</span>,<span class="number">10</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> 表名 <span class="keyword">LIMIT</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment">--第11至20条记录：</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> 表名 <span class="keyword">LIMIT</span> <span class="number">10</span>,<span class="number">10</span>;</span><br><span class="line"><span class="comment">--第21至30条记录：</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> 表名 <span class="keyword">LIMIT</span> <span class="number">20</span>,<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- MySQL 8.0中可以使用“LIMIT 3 OFFSET 4”，意思是获取从第5条记录开始后面的3条记录，和“LIMIT 4,3;”返回的结果相同。</span></span><br><span class="line"><span class="comment">-- SELECT * FROM table LIMIT(PageNo - 1) * PageSize, PageSize;</span></span><br></pre></td></tr></table></figure><p>LIMIT 子句必须放在整个SELECT语句的最后，约束返回结果的数量可以 减少数据表的网络传输量 ，也可以提升查询效率</p><h2 id="5、多表查询-重要">5、多表查询(重要)</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 自连接</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CONCAT</span>(worker.last_name , <span class="string">' works for '</span>, manager.last_name)</span><br><span class="line"><span class="keyword">FROM</span> employees worker, employees manager</span><br><span class="line"><span class="keyword">WHERE</span> worker.manager_id = manager.employee_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 内连接与外连接</span></span><br><span class="line"><span class="comment">-- 内连接: 合并具有同一列的两个以上的表的行, 结果集中不包含一个表与另一个表不匹配的行，会产生笛卡尔积</span></span><br><span class="line"><span class="comment">-- SQL92语法</span></span><br><span class="line"><span class="keyword">SELECT</span> emp.employee_id, dep.department_name</span><br><span class="line"><span class="keyword">FROM</span> employee emp, department dep</span><br><span class="line"><span class="keyword">WHERE</span> emp.<span class="string">`department_id`</span> = dep.<span class="string">`department_id`</span>;</span><br><span class="line"><span class="comment">-- SQL99语法</span></span><br><span class="line"><span class="keyword">SELECT</span> emp.employee_id, dep.department_name</span><br><span class="line"><span class="keyword">FROM</span> employee emp <span class="keyword">JOIN</span> department dep</span><br><span class="line"><span class="keyword">ON</span> emp.<span class="string">`department_id`</span> = dep.<span class="string">`department_id`</span>;</span><br><span class="line"><span class="comment">-- 外连接: 两个表在连接过程中除了返回满足连接条件的行以外还返回左（或右）表中不满足条件的 行 ，这种连接称为左（或右） 外连接。没有匹配的行时, 结果表中相应的列为空(NULL)。 </span></span><br><span class="line"><span class="comment">-- 如果是左外连接，则连接条件中左边的表也称为 主表 ，右边的表称为 从表</span></span><br><span class="line"><span class="keyword">SELECT</span> last_name, department_name</span><br><span class="line"><span class="keyword">FROM</span> employees emp <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> department dep</span><br><span class="line"><span class="keyword">ON</span> emp.<span class="string">`department_id`</span> = dep.<span class="string">`department_id`</span>;</span><br><span class="line"><span class="comment">-- 如果是右外连接，则连接条件中右边的表也称为 主表 ，左边的表称为 从表</span></span><br><span class="line"><span class="keyword">SELECT</span> last_name, department_name</span><br><span class="line"><span class="keyword">FROM</span> employees emp <span class="keyword">RIGHT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> department dep</span><br><span class="line"><span class="keyword">ON</span> emp.<span class="string">`department_id`</span> = dep.<span class="string">`department_id`</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- UNION的使用</span></span><br><span class="line"><span class="comment">-- 利用UNION关键字，可以给出多条SELECT语句，并将它们的结果组合成单个结果集。</span></span><br><span class="line"><span class="comment">-- UNION 操作符返回两个查询的结果集的并集，去除重复记录</span></span><br><span class="line"><span class="comment">-- UNION ALL操作符返回两个查询的结果集的并集。对于两个结果集的重复部分，不去重</span></span><br><span class="line"><span class="comment">-- 执行UNION ALL语句时所需要的资源比UNION语句少</span></span><br><span class="line"><span class="comment">-- 查询部门编号&gt;90或邮箱包含a的员工信息</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> email <span class="keyword">LIKE</span> <span class="string">'%a%'</span> <span class="keyword">OR</span> department_id&gt;<span class="number">90</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> email <span class="keyword">LIKE</span> <span class="string">'%a%'</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> department_id&gt;<span class="number">90</span>;</span><br><span class="line"><span class="comment">-- 查询中国用户中男性的信息以及美国用户中年男性的用户信息</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>,cname <span class="keyword">FROM</span> t_chinamale <span class="keyword">WHERE</span> csex=<span class="string">'男'</span></span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>,tname <span class="keyword">FROM</span> t_usmale <span class="keyword">WHERE</span> tGender=<span class="string">'male'</span>;</span><br></pre></td></tr></table></figure><p>七种SQL JOINS的实现<br><img src="https://img-blog.csdnimg.cn/img_convert/26f349d44cacfa4cecc5080047749542.png" alt="image.png"><br><strong>SQL99语法的新特性(了解即可)</strong><br>QL99 在 SQL92 的基础上提供了一些特殊语法，<strong>比如 NATURAL JOIN 用来表示自然连接</strong>。我们可以把 自然连接理解为 SQL92 中的等值连接。它会帮你自动查询两张连接表中所有相同的字段 ，然后进行 等值 连接(MySQL复杂链接 (左/右/全外)链接只能使用SQL99语法，SQL92<strong>不支持</strong>)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- SQL92</span></span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.<span class="string">`department_id`</span> = d.<span class="string">`department_id`</span></span><br><span class="line"><span class="keyword">AND</span> e.<span class="string">`manager_id`</span> = d.<span class="string">`manager_id`</span>;</span><br><span class="line"><span class="comment">-- SQL99</span></span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> departments d;</span><br></pre></td></tr></table></figure><p>当我们进行连接的时候，SQL99还支持使用 USING 指定数据表里的 同名字段 进行等值连接。但是只能配 合JOIN一起使用。比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">USING</span> (department_id);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 和下面的是一样的</span></span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e ,departments d</span><br><span class="line"><span class="keyword">WHERE</span> e.department_id = d.department_id;</span><br></pre></td></tr></table></figure><h2 id="6、内置函数">6、内置函数</h2><h3 id="6-1-数值函数">6.1 数值函数</h3><p>基本函数</p><table><thead><tr><th><strong>函数</strong></th><th><strong>用法</strong></th></tr></thead><tbody><tr><td>ABS(x)</td><td>返回x的绝对值</td></tr><tr><td>SIGN(X)</td><td>单元格</td></tr><tr><td>PI()</td><td>返回圆周率的值</td></tr><tr><td>CEIL(x)，CEILING(x)</td><td>返回大于或等于某个值的最小整数</td></tr><tr><td>FLOOR(x)</td><td>返回小于或等于某个值的最大整数</td></tr><tr><td>LEAST(e1,e2,e3…)</td><td>返回列表中的最小值</td></tr><tr><td>GREATEST(e1,e2,e3…)</td><td>返回列表中的最大值</td></tr><tr><td>MOD(x,y)</td><td>返回X除以Y后的余数</td></tr><tr><td>RAND()</td><td>返回0~1的随机值</td></tr><tr><td>RAND(x)</td><td>返回0~1的随机值，其中x的值用作种子值，相同的X值会产生相同的随机 数</td></tr><tr><td>ROUND(x)</td><td>返回一个对x的值进行四舍五入后，最接近于X的整数</td></tr><tr><td>ROUND(x,y)</td><td>返回一个对x的值进行四舍五入后最接近X的值，并保留到小数点后面Y位</td></tr><tr><td>TRUNCATE(x,y)</td><td>返回数字x截断为y位小数的结果</td></tr><tr><td>SQRT(x)</td><td>返回x的平方根。当X的值为负数时，返回NULL</td></tr></tbody></table><p>角度与弧度互换函数</p><table><thead><tr><th><strong>函数</strong></th><th><strong>用法</strong></th></tr></thead><tbody><tr><td>RADIANS(x)</td><td>将角度转化为弧度，其中，参数x为角度值</td></tr><tr><td>DEGREES(x)</td><td>将弧度转化为角度，其中，参数x为弧度值</td></tr></tbody></table><p>三角函数</p><table><thead><tr><th><strong>函数</strong></th><th><strong>用法</strong></th></tr></thead><tbody><tr><td>SIN(x)</td><td>将角度转化为弧度，其中，参数x为角度值</td></tr><tr><td>ASIN(x)</td><td>将弧度转化为角度，其中，参数x为弧度值</td></tr><tr><td>COS(x)</td><td>返回x的余弦值，其中，参数x为弧度值</td></tr><tr><td>ACOS(x)</td><td>返回x的反余弦值，即获取余弦为x的值。如果x的值不在-1到1之间，则返回NULL</td></tr><tr><td>TAN(x)</td><td>返回x的正切值，其中，参数x为弧度值</td></tr><tr><td>ATAN(x)</td><td>返回x的反正切值，即返回正切值为x的值</td></tr><tr><td>ATAN2(m,n)</td><td>返回两个参数的反正切值</td></tr><tr><td>COT(x)</td><td>返回x的余切值，其中，X为弧度值</td></tr></tbody></table><p>指数与对数函数</p><table><thead><tr><th><strong>函数</strong></th><th><strong>用法</strong></th></tr></thead><tbody><tr><td>POW(x,y)，POWER(X,Y)</td><td>返回x的y次方</td></tr><tr><td>EXP(X)</td><td>返回e的X次方，其中e是一个常数，2.718281828459045</td></tr><tr><td>LN(X)，LOG(X)</td><td>返回以e为底的X的对数，当X &lt;= 0 时，返回的结果为NULL</td></tr><tr><td>LOG10(X)</td><td>返回以10为底的X的对数，当X &lt;= 0 时，返回的结果为NULL</td></tr><tr><td>LOG2(X)</td><td>返回以2为底的X的对数，当X &lt;= 0 时，返回NULL</td></tr></tbody></table><p>进制间的转换</p><table><thead><tr><th><strong>函数</strong></th><th><strong>用法</strong></th></tr></thead><tbody><tr><td>BIN(x)</td><td>返回x的二进制编码</td></tr><tr><td>HEX(x)</td><td>返回x的十六进制编码</td></tr><tr><td>OCT(x)</td><td>返回x的八进制编码</td></tr><tr><td>CONV(x,f1,f2)</td><td>返回f1进制数变成f2进制数</td></tr></tbody></table><h3 id="6-2-字符串函数">6.2 字符串函数</h3><p>MySQL中，字符串的位置是从1开始的</p><table><thead><tr><th><strong>函数</strong></th><th><strong>用法</strong></th></tr></thead><tbody><tr><td>ASCII(S)</td><td>返回字符串S中的第一个字符的ASCII码值</td></tr><tr><td>CHAR_LENGTH(s)</td><td>返回字符串s的字符数。作用与CHARACTER_LENGTH(s)相同</td></tr><tr><td>LENGTH(s)</td><td>返回字符串s的字节数，和字符集有关</td></tr><tr><td>CONCAT(s1,s2,…,sn)</td><td>连接s1,s2,…,sn为一个字符串</td></tr><tr><td>CONCAT_WS(x, s1,s2,…,sn)</td><td>同CONCAT(s1,s2,…)函数，但是每个字符串之间要加上x</td></tr><tr><td>INSERT(str, idx, len, replacestr)</td><td>将字符串str从第idx位置开始，len个字符长的子串替换为字符串replacestr</td></tr><tr><td>REPLACE(str, a, b)</td><td>用字符串b替换字符串str中所有出现的字符串a</td></tr><tr><td>UPPER(s) 或 UCASE(s)</td><td>将字符串s的所有字母转成大写字母</td></tr><tr><td>LOWER(s) 或LCASE(s)</td><td>将字符串s的所有字母转成小写字母</td></tr><tr><td>LEFT(str,n)</td><td>返回字符串str最左边的n个字符</td></tr><tr><td>RIGHT(str,n)</td><td>返回字符串str最右边的n个字符</td></tr><tr><td>LPAD(str, len, pad)</td><td>用字符串pad对str最左边进行填充，直到str的长度为len个字符</td></tr><tr><td>RPAD(str ,len, pad)</td><td>用字符串pad对str最右边进行填充，直到str的长度为len个字符</td></tr><tr><td>LTRIM(s)</td><td>去掉字符串s左侧的空格</td></tr><tr><td>RTRIM(s)</td><td>去掉字符串s右侧的空格</td></tr><tr><td>TRIM(s)</td><td>去掉字符串s开始与结尾的空格</td></tr><tr><td>TRIM(s1 FROM s)</td><td>去掉字符串s开始与结尾的s1</td></tr><tr><td>TRIM(LEADING s1 FROM s)</td><td>去掉字符串s开始处的s1</td></tr><tr><td>TRIM(TRAILING s1 FROM s)</td><td>去掉字符串s结尾处的s1</td></tr><tr><td>REPEAT(str, n)</td><td>返回str重复n次的结果</td></tr><tr><td>SPACE(n)</td><td>返回n个空格</td></tr><tr><td>STRCMP(s1,s2)</td><td>比较字符串s1,s2的ASCII码值的大小</td></tr><tr><td>SUBSTR(s,index,len)</td><td>返回从字符串s的index位置其len个字符，作用与SUBSTRING(s,n,len)、 MID(s,n,len)相同</td></tr><tr><td>LOCATE(substr,str)</td><td>返回字符串substr在字符串str中首次出现的位置，作用于POSITION(substr IN str)、INSTR(str,substr)相同。未找到，返回0</td></tr><tr><td>ELT(m,s1,s2,…,sn)</td><td>返回指定位置的字符串，如果m=1，则返回s1，如果m=2，则返回s2，如果m=n，则返回sn</td></tr><tr><td>FIELD(s,s1,s2,…,sn)</td><td>返回字符串s在字符串列表中第一次出现的位置</td></tr><tr><td>FIND_IN_SET(s1,s2)</td><td>返回字符串s1在字符串s2中出现的位置。其中，字符串s2是一个以逗号分隔的字符串</td></tr><tr><td>REVERSE(s)</td><td>返回s反转后的字符串</td></tr><tr><td>NULLIF(value1,value2)</td><td>比较两个字符串，如果value1与value2相等，则返回NULL，否则返回 value1</td></tr></tbody></table><h3 id="6-3-日期和时间函数">6.3 日期和时间函数</h3><table><thead><tr><th><strong>函数</strong></th><th><strong>用法</strong></th></tr></thead><tbody><tr><td><strong>CURDATE() ，CURRENT_DATE()</strong></td><td>返回当前日期，只包含年、月、日</td></tr><tr><td><strong>CURTIME() ， CURRENT_TIME()</strong></td><td>返回当前时间，只包含时、分、秒</td></tr><tr><td><strong>NOW() / SYSDATE() / CURRENT_TIMESTAMP() / LOCALTIME() / LOCALTIMESTAMP()</strong></td><td>返回当前系统日期和时间</td></tr><tr><td>UTC_DATE()</td><td>返回UTC（世界标准时间）日期</td></tr><tr><td>UTC_TIME()</td><td>返回UTC（世界标准时间）时间</td></tr><tr><td>UNIX_TIMESTAMP()</td><td>以UNIX时间戳的形式返回当前时间。SELECT UNIX_TIMESTAMP() - &gt;1634348884</td></tr><tr><td>UNIX_TIMESTAMP(date)</td><td>将时间date以UNIX时间戳的形式返回。</td></tr><tr><td>FROM_UNIXTIME(timestamp)</td><td>将UNIX时间戳的时间转换为普通格式的时间</td></tr><tr><td>YEAR(date) / MONTH(date) / DAY(date)</td><td>返回具体的日期值</td></tr><tr><td>HOUR(time)/MINUTE(time)/SECOND(time)</td><td>返回具体的时间值</td></tr><tr><td>MONTHNAME(date)</td><td>返回月份：January，…</td></tr><tr><td>DAYNAME(date)</td><td>返回星期几：MONDAY，TUESDAY……SUNDAY</td></tr><tr><td>WEEKDAY(date)</td><td>返回周几，注意，周1是0，周2是1，…周日是6</td></tr><tr><td>QUARTER(date)</td><td>返回日期对应的季度，范围为 1 ～ 4</td></tr><tr><td>WEEK(date) ， WEEKOFYEAR(date)</td><td>返回一年中的第几周</td></tr><tr><td>DAYOFYEAR(date)</td><td>返回日期是一年中的第几天</td></tr><tr><td>DAYOFMONTH(date)</td><td>返回日期位于所在月份的第几天</td></tr><tr><td>DAYOFWEEK(date)</td><td>返回周几，注意：周日是 1 ，周一是 2 ，…周六是7</td></tr><tr><td>EXTRACT(type FROM date)</td><td>返回指定日期中特定的部分，type指定返回的值</td></tr><tr><td>TIME_TO_SEC(time)</td><td>将time转化为秒并返回结果值。转化的公式为：小时 * 3600+分钟 * 60+秒</td></tr><tr><td>SEC_TO_TIME(seconds)</td><td>将 seconds 描述转化为包含小时、分钟和秒的时间</td></tr><tr><td>DATE_ADD(datetime, INTERVAL expr type)，ADDDATE(date,INTERVAL expr type)</td><td>返回与给定日期时间相差INTERVAL时间段的日期时间</td></tr><tr><td>DATE_SUB(date,INTERVAL expr type)，SUBDATE(date,INTERVAL expr type)</td><td>返回与date相差INTERVAL时间间隔的日期</td></tr><tr><td>ADDTIME(time1,time2)</td><td>返回time1加上time2的时间。当time2为一个数字时，代表的是秒，可以为负数</td></tr><tr><td>SUBTIME(time1,time2)</td><td>返回time1减去time2后的时间。当time2为一个数字时，代表的是秒，可以为负数</td></tr><tr><td>DATEDIFF(date1,date2)</td><td>返回date1 - date2的日期间隔天数</td></tr><tr><td>TIMEDIFF(time1, time2)</td><td>返回time1 - time2的时间间隔</td></tr><tr><td>FROM_DAYS(N)</td><td>返回从 0000 年 1 月 1 日起，N天以后的日期</td></tr><tr><td>TO_DAYS(date)</td><td>返回日期date距离 0000 年 1 月 1 日的天数</td></tr><tr><td>LAST_DAY(date)</td><td>返回date所在月份的最后一天的日期</td></tr><tr><td>MAKEDATE(year,n)</td><td>针对给定年份与所在年份中的天数返回一个日期</td></tr><tr><td>MAKETIME(hour,minute,second)</td><td>将给定的小时、分钟和秒组合成时间并返回</td></tr><tr><td>PERIOD_ADD(time,n)</td><td>返回time加上n后的时间</td></tr><tr><td>DATE_FORMAT(date,fmt)</td><td>按照字符串fmt格式化日期date值</td></tr><tr><td>TIME_FORMAT(time,fmt)</td><td>按照字符串fmt格式化时间time值</td></tr><tr><td>GET_FORMAT(date_type,format_type)</td><td>返回日期字符串的显示格式</td></tr><tr><td>STR_TO_DATE(str, fmt)</td><td>按照字符串fmt对str进行解析，解析为一个日期</td></tr></tbody></table><p>EXTRACT(type FROM date)函数中type的取值与含义：<br><img src="https://img-blog.csdnimg.cn/img_convert/b210fd46503324cef746606a71d9c6aa.png" alt="image.png"><br>上述非GET_FORMAT函数中fmt参数常用的格式符</p><table><thead><tr><th><strong>格式符</strong></th><th><strong>说明</strong></th><th><strong>格式符</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>%Y</td><td>4 位数字表示年份</td><td>%y</td><td>表示两位数字表示年份</td></tr><tr><td>%M</td><td>月名表示月份（January,….）</td><td>%m</td><td>两位数字表示月份（01,02,03…）</td></tr><tr><td>%b</td><td>缩写的月名（Jan.，Feb.，….）</td><td>%c</td><td>数字表示月份（1,2,3,…）</td></tr><tr><td>%D</td><td>英文后缀表示月中的天数（1st,2nd,3rd,…）</td><td>%d</td><td>两位数字表示月中的天数(01,02…)</td></tr><tr><td>%e</td><td>数字形式表示月中的天数（1,2,3,4,5……）</td><td></td><td></td></tr><tr><td>%H</td><td>两位数字表示小数， 24 小时制（01,02…）</td><td>%h和%I</td><td>两位数字表示小时， 12 小时制（01,02…）</td></tr><tr><td>%k</td><td>数字形式的小时， 24 小时制(1,2,3)</td><td>%l</td><td>数字形式表示小时， 12 小时制（1,2,3,4….）</td></tr><tr><td>%i</td><td>两位数字表示分钟（00,01,02）</td><td>%S和%s</td><td>两位数字表示秒(00,01,02…)</td></tr><tr><td>%W</td><td>一周中的星期名称（Sunday…）</td><td>%a</td><td>一周中的星期缩写（Sun.，Mon.,Tues.，…）</td></tr><tr><td>%w</td><td>以数字表示周中的天数(0=Sunday,1=Monday….)</td><td></td><td></td></tr><tr><td>%j</td><td>以 3 位数字表示年中的天数(001,002…)</td><td>%U</td><td>以数字表示年中的第几周，（1,2,3…）其中Sunday为周中第一天</td></tr><tr><td>%u</td><td>以数字表示年中的第几周，（1,2,3…）其中Monday为周中第一天</td><td></td><td></td></tr><tr><td>%T</td><td>24 小时制</td><td>%r</td><td>12 小时制</td></tr><tr><td>%p</td><td>AM或PM</td><td>%%</td><td>表示%</td></tr></tbody></table><p>GET_FORMAT函数中date_type和format_type参数取值如下<br><img src="https://img-blog.csdnimg.cn/img_convert/5e08e7c7026403b2fe13d481d21200be.png" alt="image.png"></p><h3 id="6-4-流程控制函数">6.4 流程控制函数</h3><p>流程处理函数可以根据不同的条件，执行不同的处理流程，可以在SQL语句中实现不同的条件选择。MySQL中的流程处理函数主要包括IF()、IFNULL()和CASE()函数</p><table><thead><tr><th><strong>函数</strong></th><th><strong>用法</strong></th></tr></thead><tbody><tr><td>IF(value,value1,value2)</td><td>如果value的值为TRUE，返回value1，否则返回value</td></tr><tr><td>IFNULL(value1, value2)</td><td>如果value1不为NULL，返回value1，否则返回value</td></tr><tr><td>CASE WHEN 条件1 THEN 结果1 WHEN 条件2 THEN 结果 2 …. [ELSE resultn] END</td><td>相当于Java的if…else if…else…</td></tr><tr><td>CASE expr WHEN 常量值1 THEN 值1 WHEN 常量值1 THEN 值1 …. [ELSE 值n] END</td><td>相当于Java的switch…case…</td></tr></tbody></table><h3 id="6-5-加密与解密函数">6.5 加密与解密函数</h3><p>加密与解密函数主要用于对数据库中的数据进行加密和解密处理，以防止数据被他人窃取。这些函数在保证数据库安全时非常有用，下面ENCODE(value,password_seed)函数与DECODE(value,password_seed)函数互为反函数</p><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>PASSWORD(str)</td><td>返回字符串str的加密版本，41位长的字符串。加密结果不可逆 ，常用于用户的密码加密</td></tr><tr><td>MD5(str)</td><td>返回字符串str的md5加密后的值，也是一种加密方式。若参数为 NULL，则会返回NULL</td></tr><tr><td>SHA(str)</td><td>从原明文密码str计算并返回加密后的密码字符串，当参数为 NULL时，返回NULL。 SHA加密算法比MD5更加安全 。</td></tr><tr><td>ENCODE(value,password_seed)</td><td>返回使用password_seed作为加密密码加密value</td></tr><tr><td>DECODE(value,password_seed)</td><td>返回使用password_seed作为加密密码解密value</td></tr></tbody></table><h3 id="6-6-MySQL信息函数">6.6 MySQL信息函数</h3><p>MySQL中内置了一些可以查询MySQL信息的函数，这些函数主要用于帮助数据库开发或运维人员更好地对数据库进行维护工作</p><table><thead><tr><th><strong>函数</strong></th><th><strong>用法</strong></th></tr></thead><tbody><tr><td>VERSION()</td><td>返回当前MySQL的版本号</td></tr><tr><td>CONNECTION_ID()</td><td>返回当前MySQL服务器的连接数</td></tr><tr><td>DATABASE()，SCHEMA()</td><td>返回MySQL命令行当前所在的数据库</td></tr><tr><td>USER()，CURRENT_USER()、SYSTEM_USER()，SESSION_USER()</td><td>返回当前连接MySQL的用户名，返回结果格式为“主机名@用户名”</td></tr><tr><td>CHARSET(value)</td><td>返回字符串value自变量的字符集</td></tr><tr><td>COLLATION(value)</td><td>返回字符串value的比较规则</td></tr></tbody></table><h3 id="6-7-其他函数">6.7 其他函数</h3><p>MySQL中有些函数无法对其进行具体的分类，但是这些函数在MySQL的开发和运维过程中也是不容忽视的</p><table><thead><tr><th><strong>函数</strong></th><th><strong>用法</strong></th></tr></thead><tbody><tr><td>FORMAT(value,n)</td><td>返回对数字value进行格式化后的结果数据。n表示四舍五入后保留到小数点后n位</td></tr><tr><td>CONV(value,from,to)</td><td>将value的值进行不同进制之间的转换</td></tr><tr><td>INET_ATON(ipvalue)</td><td>将以点分隔的IP地址转化为一个数字</td></tr><tr><td>INET_NTOA(value)</td><td>将数字形式的IP地址转化为以点分隔的IP地址</td></tr><tr><td>BENCHMARK(n,expr)</td><td>将表达式expr重复执行n次。用于测试MySQL处理expr表达式所耗费的时间</td></tr><tr><td>CONVERT(value USING char_code)</td><td>将value所使用的字符编码修改为char_code</td></tr></tbody></table><h2 id="7、聚合函数">7、聚合函数</h2><h3 id="7-1-聚合函数介绍">7.1 聚合函数介绍</h3><p>聚合（或聚集、分组）函数，它是对一组数据进行汇总的函数，输入的是一组数据的集合，输出的是单个值。<strong>聚合函数类型：AVG()、SUM()、MAX()、MIN()、COUNT()</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- AVG和SUM函数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(salary), <span class="keyword">MAX</span>(salary),<span class="keyword">MIN</span>(salary), <span class="keyword">SUM</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> job_id <span class="keyword">LIKE</span> <span class="string">'%REP%'</span>;</span><br><span class="line"><span class="comment">-- MIN和MAX函数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MIN</span>(hire_date), <span class="keyword">MAX</span>(hire_date)</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br><span class="line"><span class="comment">-- COUNT函数，适用于 任意数据类型 </span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*)</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id = <span class="number">50</span>;</span><br><span class="line"><span class="comment">-- COUNT(expr) 返回 expr不为空 的记录总数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(commission_pct)</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id = <span class="number">50</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 用count(*)，count(1)，count(列名)谁好呢</span></span><br><span class="line"><span class="comment">-- 其实，对于MyISAM引擎的表是没有区别的。这种引擎内部有一计数器在维护着行数。</span></span><br><span class="line"><span class="comment">-- Innodb引擎的表用count(*),count(1)直接读行数，复杂度是O(n)，因为innodb真的要去数一遍。但好于具体的count(列名)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 能不能使用count(列名)替换count(*)?</span></span><br><span class="line"><span class="comment">-- 不要使用 count(列名)来替代 count(*)，count(*)是 SQL92 定义的标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关</span></span><br><span class="line"><span class="comment">-- count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行</span></span><br></pre></td></tr></table></figure><h3 id="7-2-GROUP-BY">7.2 GROUP BY</h3><p>可以使用GROUP BY子句将表中的数据分成若干组，WHERE一定放在FROM后面</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span>, group_function(<span class="keyword">column</span>)</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">table</span></span><br><span class="line">[<span class="keyword">WHERE</span> condition]</span><br><span class="line">[<span class="keyword">GROUP</span> <span class="keyword">BY</span> group_by_expression]</span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">column</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在SELECT列表中所有未包含在组函数中的列都应该包含在 GROUP BY子句中</span></span><br><span class="line"><span class="keyword">SELECT</span> department_id, <span class="keyword">AVG</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 包含在 GROUP BY 子句中的列不必包含在SELECT 列表中</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用多个列分组</span></span><br><span class="line"><span class="keyword">SELECT</span> department_id dept_id, job_id, <span class="keyword">SUM</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id, job_id ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- GROUP BY中使用WITH ROLLUP</span></span><br><span class="line"><span class="comment">-- 当使用ROLLUP时，不能同时使用ORDER BY子句进行结果排序，即ROLLUP和ORDER BY是互相排斥的</span></span><br><span class="line"><span class="comment">-- 使用WITH ROLLUP关键字之后，在所有查询出的分组记录之后增加一条记录，该记录计算查询出的所有记录的总和，即统计记录数量</span></span><br><span class="line"><span class="keyword">SELECT</span> department_id,<span class="keyword">AVG</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id &gt; <span class="number">80</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id <span class="keyword">WITH</span> <span class="keyword">ROLLUP</span>;</span><br></pre></td></tr></table></figure><h3 id="7-3-HAVING">7.3 HAVING</h3><p>过滤分组：HAVING子句、行已经被分组、使用了聚合函数、满足HAVING 子句中条件的分组将被显示、<strong>HAVING 不能单独使用，必须要跟 GROUP BY 一起使用</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department_id, <span class="keyword">MAX</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">MAX</span>(salary)&gt; <span class="number">10000</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 非法使用聚合函数 ： 不能在 WHERE 子句中使用聚合函数</span></span><br></pre></td></tr></table></figure><p><strong>WHERE和HAVING的对比</strong></p><ul><li>区别 1 ：<strong>WHERE 可以直接使用表中的字段作为筛选条件，但不能使用分组中的计算函数作为筛选条件</strong>；HAVING 必须要与 GROUP BY 配合使用，可以把分组计算的函数和分组字段作为筛选条件。这决定了，在需要对数据进行分组统计的时候，HAVING 可以完成 WHERE 不能完成的任务。这是因为，在查询语法结构中，WHERE 在 GROUP BY 之前，所以无法对分组结果进行筛选。HAVING 在 GROUP BY 之后，可以使用分组字段和分组中的计算函数，对分组的结果集进行筛选，这个功能是 WHERE 无法完成的。另外，WHERE排除的记录不再包括在分组中。</li><li>区别 2 ：如果需要通过连接从关联表中获取需要的数据，WHERE 是先筛选后连接，而 HAVING 是先连接后筛选。 这一点，就决定了在关联查询中，WHERE 比 HAVING 更高效。因为 WHERE 可以先筛选，用一个筛选后的较小数据集和关联表进行连接，这样占用的资源比较少，执行效率也比较高。HAVING 则需要先把结果集准备好，也就是用未被筛选的数据集进行关联，然后对这个大的数据集进行筛选，这样占用的资源就比较多，执行效率也较低。<br>|<table><thead><tr><th><strong>优点</strong></th><th><strong>缺点</strong></th></tr></thead><tbody><tr><td>WHERE</td><td>先筛选数据再关联，执行效率高</td></tr><tr><td>HAVING</td><td>可以使用分组中的计算函数</td></tr></tbody></table></li></ul><h3 id="7-4-SELECT的执行过程">7.4 SELECT的执行过程</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#方式 1 ：</span></span><br><span class="line"><span class="keyword">SELECT</span> ...,....,...</span><br><span class="line"><span class="keyword">FROM</span> ...,...,....</span><br><span class="line"><span class="keyword">WHERE</span> 多表的连接条件</span><br><span class="line"><span class="keyword">AND</span> 不包含组函数的过滤条件</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> ...,...</span><br><span class="line"><span class="keyword">HAVING</span> 包含组函数的过滤条件</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> ... <span class="keyword">ASC</span>/<span class="keyword">DESC</span></span><br><span class="line"><span class="keyword">LIMIT</span> ...,...</span><br><span class="line"></span><br><span class="line"><span class="comment">#方式 2 ：</span></span><br><span class="line"><span class="keyword">SELECT</span> ...,....,...</span><br><span class="line"><span class="keyword">FROM</span> ... <span class="keyword">JOIN</span> ...</span><br><span class="line"><span class="keyword">ON</span> 多表的连接条件</span><br><span class="line"><span class="keyword">JOIN</span> ...</span><br><span class="line"><span class="keyword">ON</span> ...</span><br><span class="line"><span class="keyword">WHERE</span> 不包含组函数的过滤条件</span><br><span class="line"><span class="keyword">AND</span>/<span class="keyword">OR</span> 不包含组函数的过滤条件</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> ...,...</span><br><span class="line"><span class="keyword">HAVING</span> 包含组函数的过滤条件</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> ... <span class="keyword">ASC</span>/<span class="keyword">DESC</span></span><br><span class="line"><span class="keyword">LIMIT</span> ...,...</span><br><span class="line"></span><br><span class="line"><span class="comment">#其中：</span></span><br><span class="line"><span class="comment">#（ 1 ）from：从哪些表中筛选</span></span><br><span class="line"><span class="comment">#（ 2 ）on：关联多表查询时，去除笛卡尔积</span></span><br><span class="line"><span class="comment">#（ 3 ）where：从表中筛选的条件</span></span><br><span class="line"><span class="comment">#（ 4 ）group by：分组依据</span></span><br><span class="line"><span class="comment">#（ 5 ）having：在统计结果中再次筛选</span></span><br><span class="line"><span class="comment">#（ 6 ）order by：排序</span></span><br><span class="line"><span class="comment">#（ 7 ）limit：分页</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- sql语句执行</span></span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> ... <span class="keyword">JOIN</span> ... <span class="keyword">ON</span> ... <span class="keyword">WHERE</span> ... <span class="keyword">GROUP</span> <span class="keyword">BY</span> ... <span class="keyword">HAVING</span> ... <span class="keyword">ORDER</span> <span class="keyword">BY</span> ... LIMIT...</span><br><span class="line"><span class="comment">-- 语句执行顺序</span></span><br><span class="line"><span class="keyword">FROM</span> -&gt; <span class="keyword">ON</span> -&gt; (<span class="keyword">JOIN</span>) -&gt; <span class="keyword">WHERE</span> -&gt; <span class="keyword">GROUP</span> <span class="keyword">BY</span> -&gt; <span class="keyword">HAVING</span> -&gt; <span class="keyword">SELECT</span> 的字段 -&gt; <span class="keyword">DISTINCT</span> -&gt; <span class="keyword">ORDER</span> <span class="keyword">BY</span> -&gt; <span class="keyword">LIMIT</span></span><br><span class="line"><span class="comment">-- 在 SELECT 语句执行这些步骤的时候，每个步骤都会产生一个虚拟表，然后将这个虚拟表传入下一个步骤中作为输入。需要注意的是，这些步骤隐含在 SQL 的执行过程中，对于我们来说是不可见的</span></span><br></pre></td></tr></table></figure><p><strong>SQL的执行原理</strong><br>SELECT 是先执行 FROM 这一步的。在这个阶段，如果是多张表联查，还会经历下面的几个步骤：</p><ol><li>首先先通过 CROSS JOIN 求笛卡尔积，相当于得到虚拟表 vt（virtual table）1-1；</li><li>通过 ON 进行筛选，在虚拟表 vt1-1 的基础上进行筛选，得到虚拟表 vt1-2；</li><li>添加外部行。如果我们使用的是左连接、右链接或者全连接，就会涉及到外部行，也就是在虚拟<br>表 vt1-2 的基础上增加外部行，得到虚拟表 vt1-3。</li></ol><p>当然如果我们操作的是两张以上的表，还会重复上面的步骤，直到所有表都被处理完为止。这个过程得到是我们的原始数据。当我们拿到了查询数据表的原始数据，也就是最终的虚拟表 vt1，就可以在此基础上再进行 WHERE 阶段。在这个阶段中，会根据 vt1 表的结果进行筛选过滤，得到虚拟表 vt2。然后进入第三步和第四步，也就是 GROUP 和 HAVING 阶段。在这个阶段中，实际上是在虚拟表 vt2 的基础上进行分组和分组过滤，得到中间的虚拟表 vt3 和 vt4。<br>当我们完成了条件筛选部分之后，就可以筛选表中提取的字段，也就是进入到 SELECT 和 DISTINCT<br>阶段。首先在 SELECT 阶段会提取想要的字段，然后在 DISTINCT 阶段过滤掉重复的行，分别得到中间的虚拟表vt5- 1 和 vt5- 2 。当我们提取了想要的字段数据之后，就可以按照指定的字段进行排序，也就是 ORDER BY 阶段，得到虚拟表 vt6。最后在 vt6 的基础上，取出指定行的记录，也就是 LIMIT 阶段，得到最终的结果，对应的是虚拟表vt7。<br>当然我们在写 SELECT 语句的时候，不一定存在所有的关键字，相应的阶段就会省略。同时因为 SQL 是一门类似英语的结构化查询语言，所以我们在写 SELECT 语句的时候，还要注意相应的关键字顺序， <strong>所谓底层运行的原理，就是我们刚才讲到的执行顺序。</strong></p><h2 id="8、子查询-重要">8、子查询(重要)</h2><h3 id="8-1-子查询基本使用">8.1 子查询基本使用</h3><ul><li>查询（内查询）在主查询之前一次执行完成</li><li>子查询的结果被主查询（外查询）使用</li></ul><p><strong>注意事项</strong></p><ul><li>子查询要包含在括号内</li><li>将子查询放在比较条件的右侧</li><li>单行操作符对应单行子查询，多行操作符对应多行子查询</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 方式一：</span></span><br><span class="line"><span class="keyword">SELECT</span> salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> last_name = <span class="string">'Abel'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> last_name,salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary &gt; <span class="number">11000</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 方式二：自连接</span></span><br><span class="line"><span class="keyword">SELECT</span> e2.last_name,e2.salary</span><br><span class="line"><span class="keyword">FROM</span> employees e1,employees e</span><br><span class="line"><span class="keyword">WHERE</span> e1.last_name = <span class="string">'Abel'</span></span><br><span class="line"><span class="keyword">AND</span> e1.<span class="string">`salary`</span> &lt; e2.<span class="string">`salary`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 方式三：子查询</span></span><br><span class="line"><span class="keyword">SELECT</span> last_name,salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary &gt; (</span><br><span class="line"><span class="keyword">SELECT</span> salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> last_name = <span class="string">'Abel'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>子查询的分类</strong><br>我们按内查询的结果返回一条还是多条记录，将子查询分为<strong>单行子查询、多行子查询</strong><br>我们按内查询是否被执行多次，将子查询划分为<strong>相关(或关联)子查询和不相关(或非关联)子查询</strong>。子查询从数据表中查询了数据结果，如果这个数据结果只执行一次，然后这个数据结果作为主查询的条件进行执行，那么这样的子查询叫做不相关子查询。同样，如果子查询需要执行多次，即采用循环的方式，先从外部查询开始，每次都传入子查询进行查询，然后再将结果反馈给外部，这种嵌套的执行方式就称为相关子查询</p><h3 id="8-1-单行子查询">8.1 单行子查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询与 141 号或 174 号员工的manager_id和department_id相同的其他员工的employee_id，manager_id，department_id</span></span><br><span class="line"><span class="keyword">SELECT</span> employee_id, manager_id, department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> (manager_id, department_id) <span class="keyword">IN</span></span><br><span class="line">(<span class="keyword">SELECT</span> manager_id, department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> employee_id <span class="keyword">IN</span> (<span class="number">141</span>,<span class="number">174</span>))</span><br><span class="line"><span class="keyword">AND</span> employee_id <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="number">141</span>,<span class="number">174</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 显式员工的employee_id,last_name和location</span></span><br><span class="line"><span class="keyword">SELECT</span> employee_id, last_name,</span><br><span class="line">(<span class="keyword">CASE</span> department_id</span><br><span class="line"><span class="keyword">WHEN</span></span><br><span class="line">(<span class="keyword">SELECT</span> department_id <span class="keyword">FROM</span> departments <span class="keyword">WHERE</span> location_id = <span class="number">1800</span>)</span><br><span class="line"><span class="keyword">THEN</span> <span class="string">'Canada'</span> <span class="keyword">ELSE</span> <span class="string">'USA'</span> <span class="keyword">END</span>) location</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure><h3 id="8-2-多行子查询">8.2 多行子查询</h3><table><thead><tr><th><strong>操作符</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>IN</td><td>等于列表中的<strong>任意一个</strong></td></tr><tr><td>ANY</td><td>需要和单行比较操作符一起使用，和子查询返回的 <strong>某一个</strong> 值比较</td></tr><tr><td>ALL</td><td>需要和单行比较操作符一起使用，和子查询返回的 <strong>所有</strong> 值比较</td></tr><tr><td>SOME</td><td>实际上是ANY的别名，作用相同，一般常使用ANY</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- mysql聚合函数不能嵌套使用</span></span><br><span class="line"><span class="comment">-- 查询平均工资最低的部门id</span></span><br><span class="line"><span class="keyword">SELECT</span> department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">AVG</span>(salary) &lt;= <span class="keyword">ALL</span> (</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(salary) avg_sal</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 空值问题，包含了null</span></span><br><span class="line"><span class="keyword">SELECT</span> last_name</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> employee_id <span class="keyword">NOT</span> <span class="keyword">IN</span> (</span><br><span class="line"><span class="keyword">SELECT</span> manager_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="comment">--where manager_id is not NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="8-3-相关子查询">8.3 相关子查询</h3><p>如果子查询的执行依赖于外部查询，通常情况下都是因为子查询中的表用到了外部的表，并进行了条件关联，因此每执行一次外部查询，子查询都要重新计算一次，这样的子查询就称之为关联子查询。相关子查询按照一行接一行的顺序执行，主查询的每一行都执行一次子查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询员工的id,salary,按照department_name 排序</span></span><br><span class="line"><span class="keyword">SELECT</span> employee_id,salary</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> (</span><br><span class="line"><span class="keyword">SELECT</span> department_name</span><br><span class="line"><span class="keyword">FROM</span> departments d</span><br><span class="line"><span class="keyword">WHERE</span> e.<span class="string">`department_id`</span> = d.<span class="string">`department_id`</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在许多 DBMS 的处理过程中，对于自连接的处理速度要比子查询快得多</span></span><br><span class="line"><span class="comment">-- 子查询实际上是通过未知表进行查询后的条件判断，而自连接是通过已知的自身数据表进行条件判断，因此在大部分 DBMS 中都对自连接处理进行了优化</span></span><br></pre></td></tr></table></figure><h1>三、创建和管理表</h1><h2 id="1、基础知识">1、基础知识</h2><h3 id="1-1-标识符命名规则">1.1 标识符命名规则</h3><p>从系统架构的层次上看，MySQL 数据库系统从大到小依次是数据库服务器、数据库、数据表、数据表的行与列，命名标识：</p><ul><li>数据库名、表名不得超过 30 个字符，变量名限制为 29 个</li><li>必须只能包含 A–Z, a–z, 0 – 9 , _共 63 个字符</li><li>数据库名、表名、字段名等对象名中间不要包含空格</li><li>同一个MySQL软件中，数据库不能同名；同一个库中，表不能重名；同一个表中，字段不能重名</li><li>必须保证你的字段没有和保留字、数据库系统或常用方法冲突。如果坚持使用，请在SQL语句中使用`（着重号）引起来</li><li>保持字段名和类型的一致性：在命名字段并为其指定数据类型的时候一定要保证一致性，假如数据类型在一个表里是整数，那在另一个表里可就别变成字符型了</li></ul><h3 id="1-2-MySQL中的数据类型">1.2 MySQL中的数据类型</h3><table><thead><tr><th><strong>类型</strong></th><th><strong>类型举例</strong></th></tr></thead><tbody><tr><td>整数类型</td><td>TINYINT、SMALLINT、MEDIUMINT、 <strong>INT(或INTEGER)</strong> 、BIGINT</td></tr><tr><td>浮点类型</td><td>FLOAT、DOUBLE</td></tr><tr><td>定点数类型</td><td><strong>DECIMAL</strong></td></tr><tr><td>位类型</td><td>BIT</td></tr><tr><td>日期时间类型</td><td>YEAR、TIME、 <strong>DATE</strong> 、DATETIME、TIMESTAMP</td></tr><tr><td>文本字符串类型</td><td>CHAR、 <strong>VARCHAR</strong> 、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT</td></tr><tr><td>枚举类型</td><td>ENUM</td></tr><tr><td>集合类型</td><td>SET</td></tr><tr><td>二进制字符串类型</td><td>BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB、LONGBLOB</td></tr><tr><td>JSON类型</td><td>JSON对象、JSON数组</td></tr><tr><td>空间数据类型</td><td>单值：GEOMETRY、POINT、LINESTRING、POLYGON；</td></tr><tr><td>集合：MULTIPOINT、MULTILINESTRING、MULTIPOLYGON、GEOMETRYCOLLECTION</td><td></td></tr></tbody></table><p>常用的几类类型介绍如下：</p><table><thead><tr><th><strong>数据类型</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>INT</td><td>从-2<sup>31到2</sup>31-1的整型数据。存储大小为 4 个字节</td></tr><tr><td>CHAR(size)</td><td>定长字符数据。若未指定，默认为 1 个字符，最大长度 255</td></tr><tr><td>VARCHAR(size)</td><td>可变长字符数据，根据字符串实际长度保存， 必须指定长度</td></tr><tr><td>FLOAT(M,D)</td><td>单精度，占用 4 个字节，M=整数位+小数位，D=小数位。 D&lt;=M&lt;=255,0&lt;=D&lt;=30，默认M+D&lt;=6</td></tr><tr><td>DOUBLE(M,D)</td><td>双精度，占用 8 个字节，D&lt;=M&lt;=255,0&lt;=D&lt;=30，默认M+D&lt;=15</td></tr><tr><td>DECIMAL(M,D)</td><td>高精度小数，占用M+2个字节，D&lt;=M&lt;=65，0&lt;=D&lt;=30，最大取值范围与DOUBLE相同。</td></tr><tr><td>DATE</td><td>日期型数据，格式’YYYY-MM-DD’</td></tr><tr><td>BLOB</td><td>二进制形式的长文本数据，最大可达4G</td></tr><tr><td>TEXT</td><td>长文本数据，最大可达4G</td></tr></tbody></table><h2 id="2、创建和管理数据库">2、创建和管理数据库</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建数据库</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> 数据库名;</span><br><span class="line"><span class="comment">-- 创建数据库并指定字符集，例如utf8mb4</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> 数据库名 <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> 字符集;</span><br><span class="line"><span class="comment">-- 判断数据库是否已经存在，不存在则创建数据库（推荐）</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> 数据库名;</span><br><span class="line"><span class="comment">-- 如果MySQL中已经存在相关的数据库，则忽略创建语句，不再创建数据库</span></span><br><span class="line"><span class="comment">-- 注意，DATABASE 不能改名。一些可视化工具可以改名，它是建新库，把所有表复制到新库，再删旧库完成的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看当前所有的数据库</span></span><br><span class="line"><span class="comment">-- 有一个S，代表多个数据库</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">DATABASES</span>;</span><br><span class="line"><span class="comment">-- 查看当前正在使用的数据库，使用的一个 mysql 中的全局函数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DATABASE</span>();</span><br><span class="line"><span class="comment">-- 查看指定库下所有的表</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">TABLES</span> <span class="keyword">FROM</span> 数据库名;</span><br><span class="line"><span class="comment">-- 查看数据库的创建信息</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> 数据库名;</span><br><span class="line"><span class="comment">-- 或者</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> 数据库名\G</span><br><span class="line"><span class="comment">-- 使用/切换数据库</span></span><br><span class="line"><span class="keyword">USE</span> 数据库名;</span><br><span class="line"><span class="comment">-- 注意：要操作表格和数据之前必须先说明是对哪个数据库进行操作，否则就要对所有对象加上“数据库名.”</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 更改数据库字符集</span></span><br><span class="line"><span class="comment">-- 比如：gbk、utf8等</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">DATABASE</span> 数据库名 <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> 字符集;  </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除数据库</span></span><br><span class="line"><span class="comment">-- 删除指定的数据库</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">DATABASE</span> 数据库名;</span><br><span class="line"><span class="comment">-- 删除指定的数据库（推荐）</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">DATABASE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> 数据库名;</span><br></pre></td></tr></table></figure><h2 id="3、创建表">3、创建表</h2><p>创建表必须具备<strong>CREATE TABLE权限和存储空间</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 第一种方式创建</span></span><br><span class="line"><span class="comment">-- 加上了IF NOT EXISTS关键字，则表示：如果当前数据库中不存在要创建的数据表，则创建数据表；</span></span><br><span class="line"><span class="comment">-- 如果当前数据库中已经存在要创建的数据表，则忽略建表语句，不再创建数据表。</span></span><br><span class="line"><span class="comment">-- 必须指定表名，列名(或字段名)，数据类型， 长度；可选约束条件，默认值</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [<span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] 表名(</span><br><span class="line">字段<span class="number">1</span>, 数据类型 [约束条件] [默认值],</span><br><span class="line">字段<span class="number">2</span>, 数据类型 [约束条件] [默认值],</span><br><span class="line">字段<span class="number">3</span>, 数据类型 [约束条件] [默认值],</span><br><span class="line">......</span><br><span class="line">[表约束条件]</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 举例</span></span><br><span class="line"><span class="comment">-- 创建表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp (</span><br><span class="line"><span class="comment">-- int类型</span></span><br><span class="line">emp_id <span class="built_in">INT</span>,</span><br><span class="line"><span class="comment">-- 最多保存 20 个中英文字符</span></span><br><span class="line">emp_name <span class="built_in">VARCHAR</span>( <span class="number">20</span> ),</span><br><span class="line"><span class="comment">-- 总位数不超过 15 位</span></span><br><span class="line">salary <span class="keyword">DOUBLE</span>,</span><br><span class="line"><span class="comment">-- 日期类型</span></span><br><span class="line">birthday <span class="built_in">DATE</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 查看一下表格</span></span><br><span class="line"><span class="comment">-- 在MySQL 8.x版本中，不再推荐为INT类型指定显示长度，并在未来的版本中可能去掉这样的语法</span></span><br><span class="line">DESC emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 举例2</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> dept(</span><br><span class="line"><span class="comment">-- int类型，自增</span></span><br><span class="line">deptno <span class="built_in">INT</span>( <span class="number">2</span> ) AUTO_INCREMENT,</span><br><span class="line">dname <span class="built_in">VARCHAR</span>( <span class="number">14</span> ),</span><br><span class="line">loc <span class="built_in">VARCHAR</span>( <span class="number">13</span> ),</span><br><span class="line"><span class="comment">-- 主键</span></span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (deptno)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 第二种方式创建</span></span><br><span class="line"><span class="comment">-- 使用 AS subquery 选项， 将创建表和插入数据结合起来，指定的列和子查询中的列要一一对应，通过列名和默认值定义列</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp1 <span class="keyword">AS</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees;</span><br><span class="line"><span class="comment">-- 创建的emp2是空表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp2 <span class="keyword">AS</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> <span class="number">1</span> = <span class="number">2</span> ;</span><br><span class="line"><span class="comment">-- 创建</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> dept</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> employee_id, last_name, salary* <span class="number">12</span> ANNSAL, hire_date</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id = <span class="number">80</span> ;</span><br><span class="line"><span class="comment">-- 查看一下</span></span><br><span class="line"><span class="keyword">DESCRIBE</span> dept80;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看数据表结构</span></span><br><span class="line"><span class="comment">-- 在MySQL中创建好数据表之后，可以查看数据表的结构。MySQL支持使用DESCRIBE/DESC语句查看数据表结构，</span></span><br><span class="line"><span class="comment">-- 也支持使用SHOW CREATE TABLE语句查看数据表结构</span></span><br><span class="line"><span class="comment">-- 使用SHOW CREATE TABLE语句不仅可以查看表创建时的详细语句，还可以查看存储引擎和字符编码</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名\G</span><br></pre></td></tr></table></figure><h2 id="4、修改表">4、修改表</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 修改表指的是修改数据库中已经存在的数据表的结构</span></span><br><span class="line"><span class="comment">-- 追加一个列</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> 【<span class="keyword">COLUMN</span>】 字段名 字段类型 【<span class="keyword">FIRST</span>|<span class="keyword">AFTER</span> 字段名】;</span><br><span class="line"><span class="comment">-- 举例</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> dept</span><br><span class="line"><span class="keyword">ADD</span> job_id <span class="built_in">varchar</span>( <span class="number">15</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改一个列，可以修改列的数据类型，长度、默认值和位置</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">MODIFY</span> 【<span class="keyword">COLUMN</span>】 字段名 <span class="number">1</span> 字段类型 【<span class="keyword">DEFAULT</span> 默认值】【<span class="keyword">FIRST</span>|<span class="keyword">AFTER</span> 字段名<span class="number">2</span>】;</span><br><span class="line"><span class="comment">-- 举例，对默认值的修改只影响今后对表的修改</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> dept</span><br><span class="line"><span class="keyword">MODIFY</span> salary <span class="keyword">double</span>( <span class="number">9</span> , <span class="number">2</span> ) <span class="keyword">default</span> <span class="number">1000</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 重命名一个列，使用 CHANGE old_column new_column dataType子句重命名列</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">CHANGE</span> 【<span class="keyword">column</span>】 列名 新列名 新数据类型;</span><br><span class="line"><span class="comment">-- 举例</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> dept</span><br><span class="line"><span class="keyword">CHANGE</span> department_name dept_name <span class="built_in">varchar</span>( <span class="number">15</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除一个列</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">DROP</span> 【<span class="keyword">COLUMN</span>】字段名</span><br><span class="line"><span class="comment">-- 举例</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> dept</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">COLUMN</span> job_id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 重命名表，必须是对象的拥有者</span></span><br><span class="line"><span class="keyword">RENAME</span> <span class="keyword">TABLE</span> emp <span class="keyword">TO</span> myemp;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">table</span> dept <span class="keyword">RENAME</span> [<span class="keyword">TO</span>] detail_dept;  <span class="comment">-- [TO]可以省略</span></span><br></pre></td></tr></table></figure><h2 id="5、删除表">5、删除表</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除表</span></span><br><span class="line"><span class="comment">-- 在MySQL中，当一张数据表没有与其他任何数据表形成关联关系时，可以将当前数据表直接删除。</span></span><br><span class="line"><span class="comment">-- 数据和结构都被删除，所有正在运行的相关事务被提交，所有相关索引被删除</span></span><br><span class="line"><span class="comment">-- IF EXISTS的含义为：如果当前数据库中存在相应的数据表，则删除数据表；如果当前数据库中不存在相应的数据表，则忽略删除语句，不再执行删除数据表的操作。</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> [<span class="keyword">IF</span> <span class="keyword">EXISTS</span>] 数据表<span class="number">1</span> [, 数据表<span class="number">2</span>, ..., 数据表n];</span><br><span class="line"><span class="comment">-- 举例，DROP TABLE 语句不能回滚</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> dept80;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 清空表</span></span><br><span class="line"><span class="comment">-- TRUNCATE TABLE语句删除表中所有的数据，释放表的存储空间</span></span><br><span class="line"><span class="comment">-- TRUNCATE语句 不能回滚 ，而使用 DELETE 语句删除数据，可以回滚</span></span><br><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> detail_dept;</span><br><span class="line"><span class="comment">-- TRUNCATE语句 不能回滚 ，而使用 DELETE 语句删除数据，可以回滚，举例</span></span><br><span class="line"><span class="keyword">SET</span> autocommit = <span class="literal">FALSE</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> emp2;</span><br><span class="line"><span class="comment">-- TRUNCATE TABLE emp2;</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp2;</span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp2;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少，但 TRUNCATE 无事务且不触发 TRIGGER，有可能造成事故，故不建议在开发代码中使用此语句</span></span><br><span class="line"><span class="comment">-- TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同。</span></span><br></pre></td></tr></table></figure><h2 id="6、内容扩展">6、内容扩展</h2><h3 id="6-1-MySQL字段命名">6.1 MySQL字段命名</h3><ul><li>【强制】表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。<ul><li>正例：aliyun_admin，rdc_config，level3_name</li><li>反例：AliyunAdmin，rdcConfig，level_3_name</li></ul></li><li>【强制】禁用保留字，如 desc、range、match、delayed 等，请参考 MySQL 官方保留字。</li><li>【强制】表必备三字段：id, gmt_create, gmt_modified。<ul><li>说明：其中id必为主键，类型为BIGINT UNSIGNED、单表时自增、步长为1。gmt_create,gmt_modified 的类型均为 DATETIME 类型，前者现在时表示主动式创建，后者过去分词表示被动式更新</li></ul></li><li>【推荐】表的命名最好是遵循 “业务名称_表的作用”。<ul><li>正例：alipay_task 、 force_project、 trade_config</li></ul></li><li>【推荐】库名与应用名称尽量一致。</li><li>【参考】合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。<ul><li>正例：无符号值可以避免误存负数，且扩大了表示范围。</li></ul></li></ul><h3 id="6-2-清空表、删除表等操作需谨慎">6.2 清空表、删除表等操作需谨慎</h3><p>表删除操作将把表的定义和表中的数据一起删除，并且MySQL在执行删除操作时，不会有任何的确认信息提示，因此执行删除操时应当慎重。在删除表前，最好对表中的数据进行备份，这样当操作失误时可以对数据进行恢复，以免造成无法挽回的后果。<br>同样的，在使用 ALTER TABLE 进行表的基本修改操作时，在执行操作过程之前，也应该确保对数据进行完整的备份，因为数据库的改变是无法撤销的，如果添加了一个不需要的字段，可以将其删除；相同的，如果删除了一个需要的列，该列下面的所有数据都将会丢失。</p><h3 id="6-3-MySQL-8-新特性—DDL的原子化">6.3 MySQL 8 新特性—DDL的原子化</h3><p>在MySQL 8.0版本中，InnoDB表的DDL支持事务完整性，即DDL操作要么成功要么回滚。DDL操作回滚日志写入到data dictionary数据字典表mysql.innodb_ddl_log（该表是隐藏的表，通过show tables无法看到）中，用于回滚操作。通过设置参数，可将DDL操作日志打印输出到MySQL错误日志中。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> mytest;</span><br><span class="line"><span class="keyword">USE</span> mytest;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> book1(</span><br><span class="line">book_id <span class="built_in">INT</span> ,</span><br><span class="line">book_name <span class="built_in">VARCHAR</span>( <span class="number">255</span> )</span><br><span class="line">);</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">TABLES</span>;</span><br><span class="line">ROP TABLE book1,book2;</span><br><span class="line"><span class="comment">-- mysql5.7 book1被删除</span></span><br><span class="line"><span class="comment">-- mysql8.0 没有被删除</span></span><br></pre></td></tr></table></figure><h1>四、数据处理之增删改</h1><h2 id="1、插入数据">1、插入数据</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- VALUES的方式添加</span></span><br><span class="line"><span class="comment">-- 为表的所有字段按默认顺序插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名 <span class="keyword">VALUES</span> (value1,value2,....);</span><br><span class="line"><span class="comment">-- 举例</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> departments <span class="keyword">VALUES</span> ( <span class="number">100</span> , <span class="string">'Finance'</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 为表的指定字段插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名(column1 [, column2, ..., columnn]) <span class="keyword">VALUES</span> (value1 [,value2, ..., valuen]);</span><br><span class="line"><span class="comment">-- 为表的指定字段插入数据，就是在INSERT语句中只向部分字段中插入值，而其他字段的值为表定义时的默认值</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> departments(department_id, department_name) <span class="keyword">VALUES</span> ( <span class="number">80</span> , <span class="string">'IT'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 同时插入多条记录</span></span><br><span class="line"><span class="comment">-- INSERT语句可以同时向数据表中插入多条记录，插入时指定多个值列表，每个值列表之间用逗号分隔开</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">(value1 [,value2, ..., valuen]),</span><br><span class="line">(value1 [,value2, ..., valuen]),</span><br><span class="line">......</span><br><span class="line">(value1 [,value2, ..., valuen]);</span><br><span class="line"><span class="comment">-- 使用INSERT同时插入多条记录时，MySQL会返回一些在执行单行插入时没有的额外信息</span></span><br><span class="line"><span class="comment">-- Records：表明插入的记录条数，Duplicates：表明插入时被忽略的记录，原因可能是这些记录包含了重复的主键值，Warnings：表明有问题的数据值，例如发生数据类型转换</span></span><br><span class="line"><span class="comment">-- 一个同时插入多行记录的INSERT语句等同于多个单行插入的INSERT语句，但是多行的INSERT语句在处理过程中效率更高</span></span><br><span class="line"><span class="comment">-- VALUES也可以写成VALUE，但是VALUES是标准写法</span></span><br><span class="line"><span class="comment">-- 字符和日期型数据应包含在单引号中</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将查询结果插入到表中</span></span><br><span class="line"><span class="comment">-- INSERT还可以将SELECT语句查询的结果插入到表中，此时不需要把每一条记录的值一个一个输入，只需要使用一条INSERT语句和一条SELECT语句组成的组合语句即可快速地从一个或多个表中向一个表中插入多行</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 目标表名</span><br><span class="line">(tar_column1 [, tar_column2, ..., tar_columnn])</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">(src_column1 [, src_column2, ..., src_columnn])</span><br><span class="line"><span class="keyword">FROM</span> 源表名</span><br><span class="line">[<span class="keyword">WHERE</span> condition]</span><br><span class="line"><span class="comment">-- 举例，子查询中的值列表应与 INSERT 子句中的列名对应</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp</span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id = <span class="number">90</span> ;</span><br></pre></td></tr></table></figure><h2 id="2、更新数据">2、更新数据</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> table_name</span><br><span class="line"><span class="keyword">SET</span> column1=value1, column2=value2, ... , <span class="keyword">column</span>=valuen</span><br><span class="line">[<span class="keyword">WHERE</span> condition]</span><br><span class="line"><span class="comment">-- 可以一次更新 多条 数据</span></span><br><span class="line"><span class="comment">-- 如果需要回滚数据，需要保证在DML前，进行设置： SET AUTOCOMMIT = FALSE;</span></span><br><span class="line"><span class="comment">-- 使用 WHERE 子句指定需要更新的数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 如果省略 WHERE 子句，则表中的所有数据都将被更新</span></span><br><span class="line"><span class="keyword">UPDATE</span> copy_emp</span><br><span class="line"><span class="keyword">SET</span> department_id = <span class="number">110</span> ;</span><br><span class="line"><span class="comment">-- 注意约束问题，会报错</span></span><br><span class="line"><span class="keyword">UPDATE</span> employees <span class="keyword">SET</span> department_id = <span class="number">55</span> <span class="keyword">WHERE</span> department_id = <span class="number">110</span> ;</span><br></pre></td></tr></table></figure><h2 id="3、删除数据">3、删除数据</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- table_name指定要执行删除操作的表；“[WHERE ]”为可选参数，指定删除条件，如果没有WHERE子句，DELETE语句将删除表中的所有记录</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name [<span class="keyword">WHERE</span> &lt;condition&gt;];</span><br><span class="line"><span class="comment">-- 举例</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> departments <span class="keyword">WHERE</span> department_name = <span class="string">'Finance'</span>;</span><br><span class="line"><span class="comment">-- 注意约束问题，会报错</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> departments <span class="keyword">WHERE</span> department_id = <span class="number">60</span> ;</span><br></pre></td></tr></table></figure><h2 id="4、MySQL-8-新特性：计算列">4、MySQL 8 新特性：计算列</h2><blockquote><p>什么叫计算列呢？简单来说就是某一列的值是通过别的列计算得来的。例如，a列值为 1 、b列值为 2 ，c列不需要手动插入，定义a+b的结果为c的值，那么c就是计算列，是通过别的列计算得来的</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 举例：定义数据表tb1，然后定义字段id、字段a、字段b和字段c，其中字段c为计算列，用于计算a+b的值。 首先创建测试表tb1</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tb1(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">INT</span>,</span><br><span class="line">a <span class="built_in">INT</span>,</span><br><span class="line">b <span class="built_in">INT</span>,</span><br><span class="line">c <span class="built_in">INT</span> <span class="keyword">GENERATED</span> <span class="keyword">ALWAYS</span> <span class="keyword">AS</span> (a + b) <span class="keyword">VIRTUAL</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 插入演示数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb1(a,b) <span class="keyword">VALUES</span> ( <span class="number">100</span> , <span class="number">200</span> );</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tb1;</span><br><span class="line"><span class="keyword">UPDATE</span> tb1 <span class="keyword">SET</span> a = <span class="number">500</span> ;</span><br></pre></td></tr></table></figure><h2 id="5、综合案例">5、综合案例</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1、创建数据库test01_library</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> test01_library <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> <span class="string">'utf8'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#指定使用哪个数据库</span></span><br><span class="line"><span class="keyword">USE</span> test01_library;</span><br><span class="line"></span><br><span class="line"><span class="comment">#2、创建表 books</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> books(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">INT</span>,</span><br><span class="line"><span class="keyword">name</span> <span class="built_in">VARCHAR</span>( <span class="number">50</span> ),</span><br><span class="line"><span class="string">`authors`</span> <span class="built_in">VARCHAR</span>( <span class="number">100</span> ) ,</span><br><span class="line">price <span class="built_in">FLOAT</span>,</span><br><span class="line">pubdate <span class="keyword">YEAR</span> ,</span><br><span class="line">note <span class="built_in">VARCHAR</span>( <span class="number">100</span> ),</span><br><span class="line"><span class="keyword">num</span> <span class="built_in">INT</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">#3、向books表中插入记录</span></span><br><span class="line">1）不指定字段名称，插入第一条记录</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> books</span><br><span class="line"><span class="keyword">VALUES</span>( <span class="number">1</span> ,<span class="string">'Tal of AAA'</span>,<span class="string">'Dickes'</span>, <span class="number">23</span> , <span class="number">1995</span> ,<span class="string">'novel'</span>, <span class="number">11</span> );</span><br><span class="line">2）指定所有字段名称，插入第二记录</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> books (<span class="keyword">id</span>,<span class="keyword">name</span>,<span class="string">`authors`</span>,price,pubdate,note,<span class="keyword">num</span>)</span><br><span class="line"><span class="keyword">VALUES</span>( <span class="number">2</span> ,<span class="string">'EmmaT'</span>,<span class="string">'Jane lura'</span>, <span class="number">35</span> , <span class="number">1993</span> ,<span class="string">'Joke'</span>, <span class="number">22</span> );</span><br><span class="line">3）同时插入多条记录（剩下的所有记录）</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> books (<span class="keyword">id</span>,<span class="keyword">name</span>,<span class="string">`authors`</span>,price,pubdate,note,<span class="keyword">num</span>) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">3</span> ,<span class="string">'Story of Jane'</span>,<span class="string">'Jane Tim'</span>, <span class="number">40</span> , <span class="number">2001</span> ,<span class="string">'novel'</span>, <span class="number">0</span>),</span><br><span class="line">(<span class="number">4</span> ,<span class="string">'Lovey Day'</span>,<span class="string">'George Byron'</span>, <span class="number">20</span> , <span class="number">2005</span> ,<span class="string">'novel'</span>, <span class="number">30</span>),</span><br><span class="line">(<span class="number">5</span> ,<span class="string">'Old land'</span>,<span class="string">'Honore Blade'</span>, <span class="number">30</span> , <span class="number">2010</span> ,<span class="string">'Law'</span>, <span class="number">0</span>),</span><br><span class="line">(<span class="number">6</span> ,<span class="string">'The Battle'</span>,<span class="string">'Upton Sara'</span>, <span class="number">30</span> , <span class="number">1999</span> ,<span class="string">'medicine'</span>, <span class="number">40</span>),</span><br><span class="line">(<span class="number">7</span> ,<span class="string">'Rose Hood'</span>,<span class="string">'Richard haggard'</span>, <span class="number">28</span> , <span class="number">2008</span> ,<span class="string">'cartoon'</span>, <span class="number">28</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4、将小说类型(novel)的书的价格都增加 5 。</span></span><br><span class="line"><span class="keyword">UPDATE</span> books <span class="keyword">SET</span> price=price+ <span class="number">5</span> <span class="keyword">WHERE</span> note = <span class="string">'novel'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5、将名称为EmmaT的书的价格改为 40 ，并将说明改为drama。</span></span><br><span class="line"><span class="keyword">UPDATE</span> books <span class="keyword">SET</span> price= <span class="number">40</span> ,note=<span class="string">'drama'</span> <span class="keyword">WHERE</span> <span class="keyword">name</span>=<span class="string">'EmmaT'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6、删除库存为 0 的记录。</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> books <span class="keyword">WHERE</span> <span class="keyword">num</span>= <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 7、统计书名中包含a字母的书</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> books <span class="keyword">WHERE</span> <span class="keyword">name</span> <span class="keyword">LIKE</span> <span class="string">'%a%'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 8、统计书名中包含a字母的书的数量和库存总量</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*),<span class="keyword">SUM</span>(<span class="keyword">num</span>) <span class="keyword">FROM</span> books <span class="keyword">WHERE</span> <span class="keyword">name</span> <span class="keyword">LIKE</span> <span class="string">'%a%'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 9、找出“novel”类型的书，按照价格降序排列</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> books <span class="keyword">WHERE</span> note = <span class="string">'novel'</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> price <span class="keyword">DESC</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 10、查询图书信息，按照库存量降序排列，如果库存量相同的按照note升序排列</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> books <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">num</span> <span class="keyword">DESC</span>,note <span class="keyword">ASC</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 11、按照note分类统计书的数量</span></span><br><span class="line"><span class="keyword">SELECT</span> note,<span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> books <span class="keyword">GROUP</span> <span class="keyword">BY</span> note;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 12、按照note分类统计书的库存量，显示库存量超过 30 本的</span></span><br><span class="line"><span class="keyword">SELECT</span> note,<span class="keyword">SUM</span>(<span class="keyword">num</span>) <span class="keyword">FROM</span> books <span class="keyword">GROUP</span> <span class="keyword">BY</span> note <span class="keyword">HAVING</span> <span class="keyword">SUM</span>(<span class="keyword">num</span>)&gt; <span class="number">30</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 13、查询所有图书，每页显示 5 本，显示第二页</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> books <span class="keyword">LIMIT</span> <span class="number">5</span> , <span class="number">5</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 14、按照note分类统计书的库存量，显示库存量最多的</span></span><br><span class="line"><span class="keyword">SELECT</span> note,<span class="keyword">SUM</span>(<span class="keyword">num</span>) sum_num <span class="keyword">FROM</span> books <span class="keyword">GROUP</span> <span class="keyword">BY</span> note <span class="keyword">ORDER</span> <span class="keyword">BY</span> sum_num <span class="keyword">DESC</span> <span class="keyword">LIMIT</span> <span class="number">0</span> , <span class="number">1</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 15、查询书名达到 10 个字符的书，不包括里面的空格</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> books <span class="keyword">WHERE</span> <span class="keyword">CHAR_LENGTH</span>(<span class="keyword">REPLACE</span>(<span class="keyword">name</span>,<span class="string">' '</span>,<span class="string">''</span>))&gt;= <span class="number">10</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">16 、查询书名和类型，</span></span><br><span class="line"><span class="comment">其中note值为 novel显示小说，law显示法律，medicine显示医药，cartoon显示卡通，joke显示笑话</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span> <span class="keyword">AS</span> <span class="string">"书名"</span> ,note, <span class="keyword">CASE</span> note</span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'novel'</span> <span class="keyword">THEN</span> <span class="string">'小说'</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'law'</span> <span class="keyword">THEN</span> <span class="string">'法律'</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'medicine'</span> <span class="keyword">THEN</span> <span class="string">'医药'</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'cartoon'</span> <span class="keyword">THEN</span> <span class="string">'卡通'</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'joke'</span> <span class="keyword">THEN</span> <span class="string">'笑话'</span></span><br><span class="line"><span class="keyword">END</span> <span class="keyword">AS</span> <span class="string">"类型"</span></span><br><span class="line"><span class="keyword">FROM</span> books;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 17、查询书名、库存，其中num值超过 30 本的，显示滞销，大于 0 并低于 10 的，显示畅销，为 0 的显示需要无货</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span>,<span class="keyword">num</span>,<span class="keyword">CASE</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="keyword">num</span>&gt; <span class="number">30</span> <span class="keyword">THEN</span> <span class="string">'滞销'</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="keyword">num</span>&gt; <span class="number">0</span> <span class="keyword">AND</span> <span class="keyword">num</span>&lt; <span class="number">10</span> <span class="keyword">THEN</span> <span class="string">'畅销'</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="keyword">num</span>= <span class="number">0</span> <span class="keyword">THEN</span> <span class="string">'无货'</span></span><br><span class="line"><span class="keyword">ELSE</span> <span class="string">'正常'</span></span><br><span class="line"><span class="keyword">END</span> <span class="keyword">AS</span> <span class="string">"库存状态"</span></span><br><span class="line"><span class="keyword">FROM</span> books;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 18、统计每一种note的库存量，并合计总量</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">IFNULL</span>(note,<span class="string">'合计总库存量'</span>) <span class="keyword">AS</span> note,<span class="keyword">SUM</span>(<span class="keyword">num</span>) <span class="keyword">FROM</span> books <span class="keyword">GROUP</span> <span class="keyword">BY</span> note <span class="keyword">WITH</span> <span class="keyword">ROLLUP</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 19、统计每一种note的数量，并合计总量</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">IFNULL</span>(note,<span class="string">'合计总数'</span>) <span class="keyword">AS</span> note,<span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> books <span class="keyword">GROUP</span> <span class="keyword">BY</span> note <span class="keyword">WITH</span> <span class="keyword">ROLLUP</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 20、统计库存量前三名的图书</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> books <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">num</span> <span class="keyword">DESC</span> <span class="keyword">LIMIT</span> <span class="number">0</span> , <span class="number">3</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 21、找出最早出版的一本书</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> books <span class="keyword">ORDER</span> <span class="keyword">BY</span> pubdate <span class="keyword">ASC</span> <span class="keyword">LIMIT</span> <span class="number">0</span> , <span class="number">1</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 22、找出novel中价格最高的一本书</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> books <span class="keyword">WHERE</span> note = <span class="string">'novel'</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> price <span class="keyword">DESC</span> <span class="keyword">LIMIT</span> <span class="number">0</span> , <span class="number">1</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 23、找出书名中字数最多的一本书，不含空格</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> books <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">CHAR_LENGTH</span>(<span class="keyword">REPLACE</span>(<span class="keyword">name</span>,<span class="string">' '</span>,<span class="string">''</span>)) <span class="keyword">DESC</span> <span class="keyword">LIMIT</span> <span class="number">0</span> ,<span class="number">1</span>;</span><br></pre></td></tr></table></figure><h1>五、MySQL数据类型精讲</h1><h2 id="1、MySQL中的数据类型">1、MySQL中的数据类型</h2><table><thead><tr><th><strong>类型</strong></th><th><strong>类型举例</strong></th></tr></thead><tbody><tr><td>整数类型</td><td>TINYINT、SMALLINT、MEDIUMINT、INT(或INTEGER)、BIGINT</td></tr><tr><td>浮点类型</td><td>FLOAT、DOUBLE</td></tr><tr><td>定点数类型</td><td>DECIMAL</td></tr><tr><td>位类型</td><td>BIT</td></tr><tr><td>日期时间类型</td><td>YEAR、TIME、DATE、DATETIME、TIMESTAMP</td></tr><tr><td>文本字符串类型</td><td>CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT</td></tr><tr><td>枚举类型</td><td>ENUM</td></tr><tr><td>集合类型</td><td>SET</td></tr><tr><td>二进制字符串类型</td><td>BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB、LONGBLOB</td></tr><tr><td>JSON类型</td><td>JSON对象、JSON数组</td></tr><tr><td>空间数据类型</td><td>单值类型：GEOMETRY、POINT、LINESTRING、POLYGON；</td></tr><tr><td>集合类型：MULTIPOINT、MULTILINESTRING、MULTIPOLYGON、GEOMETRYCOLLECTION</td><td></td></tr></tbody></table><p>常见数据类型的属性，如下</p><table><thead><tr><th><strong>MySQL关键字</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>NULL</td><td>数据列可包含NULL值</td></tr><tr><td>NOT NULL</td><td>数据列不允许包含NULL值</td></tr><tr><td>DEFAULT</td><td>默认值</td></tr><tr><td>PRIMARY KEY</td><td>主键</td></tr><tr><td>AUTO_INCREMENT</td><td>自动递增，适用于整数类型</td></tr><tr><td>UNSIGNED</td><td>无符号</td></tr><tr><td>CHARACTER SET name</td><td>指定一个字符集</td></tr></tbody></table><h2 id="2、整数类型">2、整数类型</h2><h3 id="2-1-类型介绍">2.1 类型介绍</h3><table><thead><tr><th><strong>整数类型</strong></th><th><strong>字节</strong></th><th><strong>有符号数取值范围</strong></th><th><strong>无符号数取值范围</strong></th></tr></thead><tbody><tr><td>TINYINT</td><td>1</td><td>-128 ~ 127</td><td>0 ~ 255</td></tr><tr><td>SMALLINT</td><td>2</td><td>-32768 ~ 32767</td><td>0 ~ 65535</td></tr><tr><td>MEDIUMINT</td><td>3</td><td>-8388608 ~ 8388607</td><td>0 ~ 16777215</td></tr><tr><td>INT、INTEGER</td><td>4</td><td>-2147483648~2147483647</td><td>0 ~ 4294967295</td></tr><tr><td>BIGINT</td><td>8</td><td>-9223372036854775808~9223372036854775807</td><td>0~18446744073709551615</td></tr></tbody></table><h3 id="2-2-可选参数">2.2 可选参数</h3><p>整数类型的可选属性有三个</p><ul><li>M: 表示显示宽度，M的取值范围是( 0 , 255 )。例如，int( 5 )：当数据宽度小于 5 位的时候在数字前面需要用字符填满宽度。该项功能需要配合“ZEROFILL”使用，表示用“ 0 ”填满宽度，否则指定显示宽度无效。显示宽度与类型可以存储的值范围无关。 **从MySQL 8. 0. 17 开始，整数数据类型不推荐使用显示宽度属性。**整型数据类型可以在定义表结构时指定所需要的显示宽度，如果不指定，则系统为每一种类型指定默认的宽度值。</li><li>UNSIGNED: 无符号类型（非负），所有的整数类型都有一个可选的属性UNSIGNED（无符号属性），无符号整数类型的最小取值为 0 。所以，如果需要在MySQL数据库中保存非负整数值时，可以将整数类型设置为无符号类型。int类型默认显示宽度为int(11)，无符号int类型默认显示宽度为int(10)。</li><li>ZEROFILL: 0填充,（如果某列是ZEROFILL，那么MySQL会自动为当前列添加UNSIGNED属性），如果指定了ZEROFILL只是表示不够M位时，用 0 在左边填充，如果超过M位，只要不超过数据存储范围即可。</li></ul><p>在 int(M) 中，M 的值跟 int(M) 所占多少存储空间并无任何关系。 int(3)、int(4)、int(8) 在磁盘上都是占用 4 bytes 的存储空间。也就是说，**int(M)，必须和UNSIGNED ZEROFILL一起使用才有意义。**如果整数值超过M位，就按照实际位数存储。只是无须再用字符 0 进行填充。</p><h3 id="2-3-适用场景">2.3 适用场景</h3><p>TINYINT：一般用于枚举数据，比如系统设定取值范围很小且固定的场景。<br>SMALLINT：可以用于较小范围的统计数据，比如统计工厂的固定资产库存数量等。<br>MEDIUMINT：用于较大整数的计算，比如车站每日的客流量等。<br>INT、INTEGER：取值范围足够大，一般情况下不用考虑超限问题，用得最多。比如商品编号。<br>BIGINT：只有当你处理特别巨大的整数时才会用到。比如双十一的交易量、大型门户网站点击量、证券公司衍生产品持仓等。</p><h2 id="3、浮点类型">3、浮点类型</h2><p>MySQL支持的浮点数类型，分别是 FLOAT、DOUBLE、REAL(REAL默认就是 DOUBLE。如果你把 SQL 模式设定为启用“REAL_AS_FLOAT”，那 么，MySQL 就认为REAL 是 FLOAT)</p><h3 id="3-1-数据精度说明">3.1 数据精度说明</h3><p>对于浮点类型，在MySQL中单精度值使用 4 个字节，双精度值使用 8 个字节。</p><ul><li>MySQL允许使用 非标准语法 （其他数据库未必支持，因此如果涉及到数据迁移，则最好不要这么 用）： FLOAT(M,D) 或 DOUBLE(M,D) 。这里，M称为 精度 ，D称为 标度 。(M,D)中 M=整数位+小数 位，D=小数位。 D&lt;=M&lt;=255，0&lt;=D&lt;=30。例如，定义为FLOAT(5,2)的一个列可以显示为-999.99-999.99。如果超过这个范围会报错。</li><li>FLOAT和DOUBLE类型在不指定(M,D)时，默认会按照实际的精度（由实际的硬件和操作系统决定） 来显示。</li><li>说明：浮点类型，也可以加 UNSIGNED ，但是不会改变数据范围，例如：FLOAT(3,2) UNSIGNED仍然 只能表示0-9.99的范围。</li><li>不管是否显式设置了精度(M,D)，这里MySQL的处理方案如下：<ul><li>如果存储时，整数部分超出了范围，MySQL就会报错，不允许存这样的值</li><li>如果存储时，小数点部分若超出范围，就分以下情况：<ul><li>若四舍五入后，整数部分没有超出范围，则只警告，但能成功操作并四舍五入删除多余 的小数位后保存。例如在FLOAT(5,2)列内插入999.009，近似结果是999.01。</li><li>若四舍五入后，整数部分超出范围，则MySQL报错，并拒绝处理。如FLOAT(5,2)列内插入 999.995和-999.995都会报错。</li></ul></li></ul></li><li>从MySQL 8.0.17开始，FLOAT(M,D) 和DOUBLE(M,D)用法在官方文档中已经明确不推荐使用，将来可 能被移除。另外，关于浮点型FLOAT和DOUBLE的UNSIGNED也不推荐使用了，将来也可能被移除。</li></ul><h3 id="3-2-精度误差说明">3.2 精度误差说明</h3><p>在编程中，如果用到浮点数，要特别注意误差问题(例如0. 47 + 0. 44 + 0. 19)，**因为浮点数是不准确的，所以我们要避免使用“=”来判断两个数是否相等。**同时，在一些对精确度要求较高的项目中，千万不要使用浮点数，不然会导致结果错误，甚至是造成不可挽回的损失。那么，MySQL 有没有精准的数据类型呢？当然有，这就是定点数类型：DECIMAL</p><h2 id="4、定点数类型">4、定点数类型</h2><ul><li>MySQL中的定点数类型只有 DECIMAL 一种类型。使用 DECIMAL(M,D) 的方式表示高精度小数。其中，M被称为精度，D被称为标度。0&lt;=M&lt;=65，0&lt;=D&lt;=30，D&lt;M。例如，定义DECIMAL（5,2）的类型，表示该列取值范围是-999.99~999.99。</li><li><strong>DECIMAL(M,D)的最大取值范围与DOUBLE类型一样</strong> ，但是有效的数据范围是由M和D决定的。<br>DECIMAL 的存储空间并不是固定的，由精度值M决定，总共占用的存储空间为M+2个字节。也就是说，在一些对精度要求不高的场景下，比起占用同样字节长度的定点数，浮点数表达的数值范围可以更大一些。</li><li>定点数在MySQL内部是以字符串的形式进行存储，这就决定了它一定是精准的。</li><li>当DECIMAL类型不指定精度和标度时，<strong>其默认为DECIMAL(10,0)</strong>。当数据的精度超出了定点数类型的精度范围时，则MySQL同样会进行四舍五入处理。</li><li><strong>浮点数 vs 定点数</strong><ul><li>浮点数相对于定点数的优点是在长度一定的情况下，浮点类型取值范围大，但是不精准，适用于需要取值范围大，又可以容忍微小误差的科学计算场景（比如计算化学、分子建模、流体动力学等）</li><li>定点数类型取值范围相对小，但是精准，没有误差，适合于对精度要求极高的场景 （比如涉及金额计算的场景）</li></ul></li></ul><h2 id="5、位类型：BIT">5、位类型：BIT</h2><p>BIT类型中存储的是二进制值，类似 010110 。BIT类型，如果没有指定(M)，默认是 1 位。这个 1 位，表示只能存 1 位的二进制值。这里(M)是表示二进制的位数，位数最小值为 1 ，最大值为 64 。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_bit1(</span><br><span class="line">f1 <span class="built_in">BIT</span>,</span><br><span class="line">f2 <span class="built_in">BIT</span>( <span class="number">5</span> ),</span><br><span class="line">f3 <span class="built_in">BIT</span>( <span class="number">64</span> )</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_bit1(f1)</span><br><span class="line"><span class="keyword">VALUES</span>( <span class="number">1</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">#Data too long for column 'f1' at row 1</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_bit1(f1)</span><br><span class="line"><span class="keyword">VALUES</span>( <span class="number">2</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_bit1(f2)</span><br><span class="line"><span class="keyword">VALUES</span>( <span class="number">23</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">BIN</span>(f2),<span class="keyword">HEX</span>(f2) <span class="keyword">FROM</span> test_bit1;</span><br><span class="line"><span class="comment">-- 使用b+ 0 查询数据时，可以直接查询出存储的十进制数据的值</span></span><br></pre></td></tr></table></figure><h2 id="6、日期与时间类型">6、日期与时间类型</h2><table><thead><tr><th><strong>类型</strong></th><th><strong>名称</strong></th><th><strong>字节</strong></th><th><strong>日期格式</strong></th><th><strong>最小值</strong></th><th><strong>最大值</strong></th></tr></thead><tbody><tr><td>YEAR</td><td>年</td><td>1</td><td>YYYY或YY</td><td>1901</td><td>2155</td></tr><tr><td>TIME</td><td>时间</td><td>3</td><td>HH:MM:SS</td><td>- 838 : 59 : 59</td><td>838 : 59 : 59</td></tr><tr><td>DATE</td><td>日期</td><td>3</td><td>YYYY-MM-DD</td><td>1000 - 01 - 01</td><td>9999 - 12 - 03</td></tr><tr><td>DATETIME</td><td>日期</td><td></td><td></td><td></td><td></td></tr><tr><td>时间</td><td>8</td><td>YYYY-MM-DD</td><td></td><td></td><td></td></tr><tr><td>HH:MM:SS</td><td>1000 - 01 - 01</td><td></td><td></td><td></td><td></td></tr><tr><td>00 : 00 : 00</td><td>9999 - 12 - 31</td><td></td><td></td><td></td><td></td></tr><tr><td>23 : 59 : 59</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>TIMESTAMP</td><td>日期</td><td></td><td></td><td></td><td></td></tr><tr><td>时间</td><td>4</td><td>YYYY-MM-DD</td><td></td><td></td><td></td></tr><tr><td>HH:MM:SS</td><td>1970 - 01 - 01</td><td></td><td></td><td></td><td></td></tr><tr><td>00 : 00 : 00 UTC</td><td>2038 - 01 - 19</td><td></td><td></td><td></td><td></td></tr><tr><td>03 : 14 : 07 UTC</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h3 id="6-1-YEAR类型">6.1 YEAR类型</h3><p>YEAR类型用来表示年份，在所有的日期时间类型中所占用的存储空间最小，只需要 1 个字节的存储空间。在MySQL中，YEAR有以下几种存储格式：</p><ul><li>以 4 位字符串或数字格式表示YEAR类型，其格式为YYYY，最小值为 1901 ，最大值为2155。</li><li>以 2 位字符串格式表示YEAR类型，最小值为 00 ，最大值为 99 。<ul><li>当取值为 01 到 69 时，表示 2001 到 2069 ；</li><li>当取值为 70 到 99 时，表示 1970 到 1999 ；</li><li>当取值整数的 0 或 00 添加的话，那么是 0000 年；</li><li>当取值是日期/字符串的 ‘0’ 添加的话，是 2000 年。</li></ul></li></ul><p><strong>从MySQL 5. 5. 27 开始， 2 位格式的YEAR已经不推荐使用</strong> 。YEAR默认格式就是“YYYY”，没必要写成YEAR( 4 )，从MySQL 8. 0. 19 开始，不推荐使用指定显示宽度的YEAR( 4 )数据类型。</p><h3 id="6-2-DATE类型">6.2 DATE类型</h3><p>DATE类型表示日期，没有时间部分，格式为YYYY-MM-DD，其中，YYYY表示年份，MM表示月份，DD表示日期。需要 3 个字节的存储空间。在向DATE类型的字段插入数据时，同样需要满足一定的格式条件。</p><ul><li>以YYYY-MM-DD格式或者YYYYMMDD格式表示的字符串日期，其最小取值为 1000-01-01 ，最大取值为9999-12-03 。YYYYMMDD格式会被转化为YYYY-MM-DD格式</li><li>以YY-MM-DD格式或者YYMMDD格式表示的字符串日期，此格式中，年份为两位数值或字符串满足YEAR类型的格式条件为：当年份取值为 00 到 69 时，会被转化为 2000 到 2069 ；当年份取值为70 到 99时，会被转化为 1970 到 1999</li><li>使用CURRENT_DATE()或者NOW()函数，会插入当前系统的日期</li></ul><h3 id="6-3-TIME类型">6.3 TIME类型</h3><p>TIME类型用来表示时间，不包含日期部分。在MySQL中，需要 3 个字节的存储空间来存储TIME类型的数据，可以使用“HH:MM:SS”格式来表示TIME类型，其中，HH表示小时，MM表示分钟，SS表示秒。<br>在MySQL中，向TIME类型的字段插入数据时，也可以使用几种不同的格式。</p><ul><li>可以使用带有冒号的字符串，比如’D HH:MM:SS’、‘HH:MM:SS’、‘HH:MM’、‘D HH:MM’、'D HH’或’SS’格式，都能被正确地插入TIME类型的字段中。其中D表示天，其最小值为0，最大值为34。如果使用带有D格式的字符串插入TIME类型的字段时，D会被转化为小时，计算格式为D* 24 +HH。当使用带有冒号并且不带D的字符串表示时间时，表示当天的时间，比如12 : 10表示12:10:00，而不是00 :12 : 10</li><li>可以使用不带有冒号的字符串或者数字，格式为’HHMMSS’或者’HHMMSS’。如果插入一个不合法的字符串或者数字，MySQL在存储数据时，会将其自动转化为 00 : 00 : 00 进行存储。比如1210，MySQL会将最右边的两位解析成秒，表示00 : 12 : 10 ，而不是 12 : 10 : 00</li><li>使用CURRENT_TIME()或者NOW()，会插入当前系统的时间</li></ul><h3 id="6-4-DATETIME类型">6.4 DATETIME类型</h3><p>DATETIME类型在所有的日期时间类型中占用的存储空间最大，总共需要 8 个字节的存储空间。在格式上为DATE类型和TIME类型的组合，可以表示为YYYY-MM-DD HH:MM:SS，其中YYYY表示年份，MM表示月份，DD表示日期，HH表示小时，MM表示分钟，SS表示秒。在向DATETIME类型的字段插入数据时，同样需要满足一定的格式条件</p><ul><li>以YYYY-MM-DD HH:MM:SS格式或者YYYYMMDDHHMMSS格式的字符串插入DATETIME类型的字段时，最小值为 1000-01-01 00:00:00 ，最大值为 9999-12-03 23:59:59。以YYYYMMDDHHMMSS格式的数字插入DATETIME类型的字段时，会被转化为YYYY-MM-DD HH:MM:SS格式。</li><li>以YY-MM-DD HH:MM:SS格式或者YYMMDDHHMMSS格式的字符串插入DATETIME类型的字段时，两位数的年份规则符合YEAR类型的规则， 00 到 69 表示 2000 到 2069 ；70 到 99 表示 1970 到 1999</li><li>使用函数CURRENT_TIMESTAMP()和NOW()，可以向DATETIME类型的字段插入系统的当前日期和时间</li></ul><h3 id="6-5-TIMESTAMP类型">6.5 TIMESTAMP类型</h3><p>TIMESTAMP类型也可以表示日期时间，其显示格式与DATETIME类型相同，都是YYYY-MM-DD HH:MM:SS，需要 4 个字节的存储空间。但是TIMESTAMP存储的时间范围比DATETIME要小很多，只能存储“ 1970 - 01 - 01 00 : 00 : 01 UTC”到“ 2038 - 01 - 19 03 : 14 : 07 UTC”之间的时间。其中，UTC表示世界统一时间，也叫作世界标准时间。</p><ul><li><strong>存储数据的时候需要对当前时间所在的时区进行转换，查询数据的时候再将时间转换回当前的时区。因此，使用TIMESTAMP存储的同一个时间值，在不同的时区查询时会显示不同的时间。</strong></li></ul><p>向TIMESTAMP类型的字段插入数据时，当插入的数据格式满足YY-MM-DD HH:MM:SS和YYMMDDHHMMSS时，两位数值的年份同样符合YEAR类型的规则条件，只不过表示的时间范围要小很多。如果向TIMESTAMP类型的字段插入的时间超出了TIMESTAMP类型的范围，则MySQL会抛出错误信息。<br><strong>TIMESTAMP和DATETIME的区别：</strong></p><ul><li>TIMESTAMP存储空间比较小，表示的日期时间范围也比较小</li><li>底层存储方式不同，TIMESTAMP底层存储的是毫秒值，距离1970-1-1 0:0:0 0 毫秒的毫秒值。</li><li>两个日期比较大小或日期计算时，TIMESTAMP更方便、更快。</li><li>TIMESTAMP和时区有关。TIMESTAMP会根据用户的时区不同，显示不同的结果。而DATETIME则只能反映出插入时当地的时区，其他时区的人查看数据必然会有误差的</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 一般存注册时间、商品发布时间等，不建议使用DATETIME存储，而是使用时间戳，其他建议datetime</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">UNIX_TIMESTAMP</span>();</span><br></pre></td></tr></table></figure><h2 id="7、文本字符串类型">7、文本字符串类型</h2><p>MySQL中，文本字符串总体上分为CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、<br>LONGTEXT、ENUM、SET等类型<br><img src="https://img-blog.csdnimg.cn/img_convert/b26e23a8220164973a0c849d1aeba97c.png" alt="image.png"></p><h3 id="7-1-CHAR与VARCHAR类型">7.1 CHAR与VARCHAR类型</h3><table><thead><tr><th><strong>字符串(文本)类型</strong></th><th><strong>特点</strong></th><th><strong>长度</strong></th><th><strong>长度范围</strong></th><th><strong>占用的存储空间</strong></th></tr></thead><tbody><tr><td>CHAR(M)</td><td>固定长度</td><td>M</td><td>0 &lt;= M &lt;= 255</td><td>M个字节</td></tr><tr><td>VARCHAR(M)</td><td>可变长度</td><td>M</td><td>0 &lt;= M &lt;= 65535</td><td>(实际长度 + 1 ) 个字节</td></tr></tbody></table><p><strong>CHAR类型：</strong></p><ul><li>CHAR(M) 类型一般需要预先定义字符串长度。如果不指定(M)，则表示长度默认是 1 个字符。</li><li>如果保存时，数据的实际长度比CHAR类型声明的长度小，则会在右侧填充空格以达到指定的长度。当MySQL检索CHAR类型的数据时，CHAR类型的字段会去除尾部的空格。</li><li>定义CHAR类型字段时，声明的字段长度即为CHAR类型字段所占的存储空间的字节数。</li></ul><p><strong>VARCHAR类型：</strong></p><ul><li>VARCHAR(M) 定义时，必须指定长度M，否则报错。</li><li>MySQL4.0版本以下，varchar(20)：指的是 20 字节，如果存放UTF8汉字时，只能存 6 个（每个汉字 3 字节） ；MySQL5.0版本以上，varchar(20)：指的是 20 字符。</li><li>检索VARCHAR类型的字段数据时，会保留数据尾部的空格。VARCHAR类型的字段所占用的存储空间为字符串实际长度加 1 个字节。</li></ul><p><strong>哪些情况使用 CHAR 或 VARCHAR 更好</strong><br>情况 1 ：存储很短的信息。比如门牌号码 101 ，201……这样很短的信息应该用char，因为varchar还要占个byte用于存储信息长度，本来打算节约存储的，结果得不偿失。<br>情况 2 ：固定长度的。比如使用uuid作为主键，那用char应该更合适。因为他固定长度，varchar动态根据长度的特性就消失了，而且还要占个长度信息。<br>情况 3 ：十分频繁改变的column。因为varchar每次存储都要有额外的计算，得到长度等工作，如果一个非常频繁改变的，那就要有很多的精力用于计算，而这些对于char来说是不需要的。<br>情况 4 ：具体存储引擎中的情况：</p><ul><li>MyISAM 数据存储引擎和数据列：MyISAM数据表，最好使用固定长度(CHAR)的数据列代替可变长度(VARCHAR)的数据列。这样使得整个表静态化，从而使数据检索更快，用空间换时间。</li><li>MEMORY 存储引擎和数据列：MEMORY数据表目前都使用固定长度的数据行存储，因此无论使用CHAR或VARCHAR列都没有关系，两者都是作为CHAR类型处理的。</li><li>InnoDB存储引擎，<strong>建议使用VARCHAR类型</strong>。因为对于InnoDB数据表，内部的行存储格式并没有区分固定长度和可变长度列（所有数据行都使用指向数据列值的头指针），而且 <strong>主要影响性能的因素是数据行使用的存储总量</strong> ，由于char平均占用的空间多于varchar，所以除了简短并且固定长度的，其他考虑varchar。这样节省空间，对磁盘I/O和数据存储总量比较好。</li></ul><h3 id="7-2-TEXT类型">7.2 TEXT类型</h3><p>在MySQL中，TEXT用来保存文本类型的字符串，总共包含 4 种类型，分别为TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT 类型。在向TEXT类型的字段保存和查询数据时，系统自动按照实际长度存储，不需要预先定义长度。这一点和VARCHAR类型相同</p><table><thead><tr><th><strong>文本字符串类型</strong></th><th><strong>特点</strong></th><th><strong>长度</strong></th><th><strong>长度范围</strong></th><th><strong>占用的存储空间</strong></th></tr></thead><tbody><tr><td>TINYTEXT</td><td>小文本、可变长度</td><td>L</td><td>0 &lt;= L &lt;= 255</td><td>L + 2 个字节</td></tr><tr><td>TEXT</td><td>文本、可变长度</td><td>L</td><td>0 &lt;= L &lt;= 65535</td><td>L + 2 个字节</td></tr><tr><td>MEDIUMTEXT</td><td>中等文本、可变长度</td><td>L</td><td>0 &lt;= L &lt;= 16777215</td><td>L + 3 个字节</td></tr><tr><td>LONGTEXT</td><td>大文本、可变长度</td><td>L</td><td>0 &lt;= L&lt;= 4294967295（相当于4GB）</td><td>L + 4 个字节</td></tr></tbody></table><p><strong>由于实际存储的长度不确定，MySQL 不允许 TEXT 类型的字段做主键</strong> 。遇到这种情况，你只能采用CHAR(M)，或者 VARCHAR(M)。另外TEXT文本类型，可以存比较大的文本段，搜索速度稍慢，因此如果不是特别大的内容，建议使用CHAR，VARCHAR来代替。还有TEXT类型不用加默认值，加了也没用。而且text和blob类型的数据删除后容易导致“空洞”，使得文件碎片比较多，所以频繁使用的表不建议包含TEXT类型字段，建议单独分出去，单独用一个表</p><h3 id="7-3-ENUM类型">7.3 ENUM类型</h3><p>ENUM类型也叫作枚举类型，ENUM类型的取值范围需要在定义字段时进行指定。设置字段值时，ENUM类型只允许从成员中选取单个值，不能一次选取多个值</p><table><thead><tr><th><strong>文本字符串类型</strong></th><th><strong>长度</strong></th><th><strong>长度范围</strong></th><th><strong>占用的存储空间</strong></th></tr></thead><tbody><tr><td>ENUM</td><td>L</td><td>1 &lt;= L &lt;= 65535</td><td>1 或 2 个字节</td></tr></tbody></table><ul><li>当ENUM类型包含 1 ～ 255 个成员时，需要 1 个字节的存储空间；</li><li>当ENUM类型包含 256 ～ 65535 个成员时，需要 2 个字节的存储空间</li><li>ENUM类型的成员个数的上限为 65535 个</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_enum(</span><br><span class="line">season ENUM(<span class="string">'春'</span>,<span class="string">'夏'</span>,<span class="string">'秋'</span>,<span class="string">'冬'</span>,<span class="string">'unknow'</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_enum</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">'春'</span>),(<span class="string">'秋'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略大小写</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_enum</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">'UNKNOW'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许按照角标的方式获取指定索引位置的枚举值</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_enum</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">'1'</span>),( <span class="number">3</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment"># Data truncated for column 'season' at row 1</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_enum</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">'ab'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当ENUM类型的字段没有声明为NOT NULL时，插入NULL也是有效的</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_enum</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><h3 id="7-4-SET类型">7.4 SET类型</h3><p>SET表示一个字符串对象，可以包含 0 个或多个成员，但成员个数的上限为 64 。设置字段值时，可以取取值范围内的 0 个或多个值。当SET类型包含的成员个数不同时，其所占用的存储空间也是不同的</p><table><thead><tr><th><strong>成员个数范围（L表示实际成员个数）</strong></th><th><strong>占用的存储空间</strong></th></tr></thead><tbody><tr><td>1 &lt;= L &lt;= 8</td><td>1 个字节</td></tr><tr><td>9 &lt;= L &lt;= 16</td><td>2 个字节</td></tr><tr><td>17 &lt;= L &lt;= 24</td><td>3 个字节</td></tr><tr><td>25 &lt;= L &lt;= 32</td><td>4 个字节</td></tr><tr><td>33 &lt;= L &lt;= 64</td><td>8 个字节</td></tr></tbody></table><p>SET类型在存储数据时成员个数越多，其占用的存储空间越大。注意：SET类型在选取成员时，可以一次选择多个成员，这一点与ENUM类型不同。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> temp_mul(</span><br><span class="line">gender ENUM(<span class="string">'男'</span>,<span class="string">'女'</span>),</span><br><span class="line">hobby <span class="keyword">SET</span>(<span class="string">'吃饭'</span>,<span class="string">'睡觉'</span>,<span class="string">'打豆豆'</span>,<span class="string">'写代码'</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> temp_mul <span class="keyword">VALUES</span>(<span class="string">'男'</span>,<span class="string">'睡觉,打豆豆'</span>); <span class="comment">#成功</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Data truncated for column 'gender' at row 1</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> temp_mul <span class="keyword">VALUES</span>(<span class="string">'男,女'</span>,<span class="string">'睡觉,写代码'</span>); <span class="comment">#失败</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Data truncated for column 'gender' at row 1</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> temp_mul <span class="keyword">VALUES</span>(<span class="string">'妖'</span>,<span class="string">'睡觉,写代码'</span>);<span class="comment">#失败</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> temp_mul <span class="keyword">VALUES</span>(<span class="string">'男'</span>,<span class="string">'睡觉,写代码,吃饭'</span>); <span class="comment">#成功</span></span><br></pre></td></tr></table></figure><h2 id="8、二进制于JSON">8、二进制于JSON</h2><h3 id="8-1-二进制字符串类型">8.1 二进制字符串类型</h3><p>MySQL中的二进制字符串类型主要存储一些二进制数据，比如可以存储图片、音频和视频等二进制数据。MySQL中支持的二进制字符串类型主要包括BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB 和LONGBLOB类型。<br><strong>BINARY与VARBINARY类型</strong><br>BINARY和VARBINARY类似于CHAR和VARCHAR，只是它们存储的是二进制字符串。BINARY (M)为固定长度的二进制字符串，M表示最多能存储的字节数，取值范围是 0 ~ 255 个字符。如果未指定(M)，表示只能存储 1 个字节。例如BINARY ( 8 )，表示最多能存储 8 个字节，如果字段值不足(M)个字节，将在右边填充’\ 0’以补齐指定长度。VARBINARY (M)为可变长度的二进制字符串，M表示最多能存储的字节数，总字节数不能超过行的字节长度限制 65535 ，另外还要考虑额外字节开销，VARBINARY类型的数据除了存储数据本身外，还需要 1 或 2 个字节来存储数据的字节数。VARBINARY类型必须指定(M)，否则报错。</p><table><thead><tr><th><strong>二进制字符串类型</strong></th><th><strong>特点</strong></th><th><strong>值的长度</strong></th><th><strong>占用空间</strong></th></tr></thead><tbody><tr><td>BINARY(M)</td><td>固定长度</td><td>M（ 0 &lt;= M &lt;= 255 ）</td><td>M个字节</td></tr><tr><td>VARBINARY(M)</td><td>可变长度</td><td>M（ 0 &lt;= M &lt;= 65535 ）</td><td>M+ 1 个字节</td></tr></tbody></table><p><strong>BLOB类型</strong><br>BLOB是一个二进制大对象，可以容纳可变数量的数据。MySQL中的BLOB类型包括TINYBLOB、BLOB、MEDIUMBLOB和LONGBLOB 4种类型，它们可容纳值的最大长度不同。可以存储一个二进制的大对象，比如图片、音频和视频等。需要注意的是，在实际工作中，往往不会在MySQL数据库中使用BLOB类型存储大对象数据，通常会将图片、音频和视频文件存储到服务器的磁盘上，并将图片、音频和视频的访问路径存储到MySQL中。</p><table><thead><tr><th><strong>二进制字符串类型</strong></th><th><strong>值的长度</strong></th><th><strong>长度范围</strong></th><th><strong>占用空间</strong></th></tr></thead><tbody><tr><td>TINYBLOB</td><td>L</td><td>0 &lt;= L &lt;= 255</td><td>L + 1 个字节</td></tr><tr><td>BLOB</td><td>L</td><td>0 &lt;= L &lt;= 65535（相当于64KB）</td><td>L + 2 个字节</td></tr><tr><td>MEDIUMBLOB</td><td>L</td><td>0 &lt;= L &lt;= 16777215 （相当于16MB）</td><td>L + 3 个字节</td></tr><tr><td>LONGBLOB</td><td>L</td><td>0 &lt;= L &lt;= 4294967295（相当于4GB）</td><td>L + 4 个字节</td></tr></tbody></table><p><strong>TEXT和BLOB的使用注意事项</strong><br>在使用text和blob字段类型时要注意以下几点，以便更好的发挥数据库的性能。</p><ul><li>BLOB和TEXT值也会引起自己的一些问题，特别是执行了大量的删除或更新操作的时候。删除这种值会在数据表中留下很大的”空洞“，以后填入这些”空洞”的记录可能长度不同。为了提高性能，建议定期使用 OPTIMIZE TABLE 功能对这类表进行碎片整理。</li><li>如果需要对大文本字段进行模糊查询，MySQL 提供了前缀索引。但是仍然要在不必要的时候避免检索大型的BLOB或TEXT值。例如，SELECT * 查询就不是很好的想法，除非你能够确定作为约束条件的WHERE子句只会找到所需要的数据行。否则，你可能毫无目的地在网络上传输大量的值。</li><li>把BLOB或TEXT列分离到单独的表中。在某些环境中，如果把这些数据列移动到第二张数据表中，可以让你把原数据表中的数据列转换为固定长度的数据行格式，那么它就是有意义的。这会减少主表中的碎片，使你得到固定长度数据行的性能优势。它还使你在主数据表上运行 SELECT * 查询的时候不会通过网络传输大量的BLOB或TEXT值</li></ul><h3 id="8-2-JSON类型">8.2 JSON类型</h3><p>JSON（JavaScript Object Notation）是一种轻量级的数据交换格式。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。它易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。 <strong>JSON 可以将 JavaScript 对象中表示的一组数据转换为字符串，然后就可以在网络或者程序之间轻松地传递这个字符串，并在需要的时候将它还原为各编程语言所支持的数据格式。</strong><br>在MySQL 5.7中，就已经支持JSON数据类型。在MySQL 8.x版本中，JSON类型提供了可以进行自动验证的JSON文档和优化的存储结构，使得在MySQL中存储和读取JSON类型的数据更加方便和高效</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_json(</span><br><span class="line">js <span class="keyword">json</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_json (js)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">'&#123;"name":"songhk", "age":18, "address":&#123;"province":"beijing",</span></span><br><span class="line"><span class="string">"city":"beijing"&#125;&#125;'</span>);</span><br><span class="line"><span class="comment">-- 查询</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> test_json;</span><br><span class="line"><span class="comment">-- 当需要检索JSON类型的字段中数据的某个具体值时，可以使用“-&gt;”和“-&gt;&gt;”符号</span></span><br><span class="line"><span class="keyword">SELECT</span> js -&gt; <span class="string">'$.name'</span> <span class="keyword">AS</span> <span class="keyword">NAME</span>,js -&gt; <span class="string">'$.age'</span> <span class="keyword">AS</span> age ,js -&gt; <span class="string">'$.address.province'</span> <span class="keyword">AS</span> province, js -&gt; <span class="string">'$.address.city'</span> <span class="keyword">AS</span> city -&gt; <span class="keyword">FROM</span> test_json;</span><br></pre></td></tr></table></figure><h3 id="8-3-空间类型">8.3 空间类型</h3><p>MySQL 空间类型扩展支持地理特征的生成、存储和分析。这里的地理特征表示世界上具有位置的任何东西，可以是一个实体，例如一座山；可以是空间，例如一座办公楼；也可以是一个可定义的位置，例如一个十字路口等等。MySQL中使用Geometry（几何）来表示所有地理特征。Geometry指一个点或点的集合，代表世界上任何具有位置的事物。</p><h1>六、约束</h1><h2 id="1、约束-constraint-概述">1、约束(constraint)概述</h2><h3 id="1-1-为什么需要约束">1.1 为什么需要约束</h3><p>数据完整性（Data Integrity）是指数据的精确性（Accuracy）和可靠性（Reliability）。它是防止数据库中存在不符合语义规定的数据和防止因错误信息的输入输出造成无效操作或错误信息而提出的。为了保证数据的完整性，SQL规范以约束的方式对<strong>表数据进行额外的条件限制</strong>。从以下四个方面考虑：</p><ul><li>实体完整性（Entity Integrity）：例如，同一个表中，不能存在两条完全相同无法区分的记录</li><li>域完整性（Domain Integrity）：例如：年龄范围0-120，性别范围“男/女”</li><li>引用完整性（Referential Integrity）：例如：员工所在部门，在部门表中要能找到这个部门</li><li>用户自定义完整性（User-defined Integrity）：例如：用户名唯一、密码不能为空等，本部门经理的工资不得高于本部门职工的平均工资的 5 倍。</li></ul><h3 id="1-2-什么是约束">1.2 什么是约束</h3><p>约束是表级的强制规定。可以在 <strong>创建表时规定约束（通过 CREATE TABLE 语句）</strong> ，或者在 <strong>表创建之后通过 ALTER TABLE 语句规定约束</strong></p><h3 id="1-3-约束的分类">1.3 约束的分类</h3><ul><li>根据约束数据列的限制， 约束可分为：<ul><li>单列约束 ：每个约束只约束一列</li><li>多列约束 ：每个约束可约束多列数据</li></ul></li><li>根据约束的作用范围 ，约束可分为：<ul><li>列级约束 ：只能作用在一个列上，跟在列的定义后面</li><li>表级约束 ：可以作用在多个列上，不与列一起，而是单独定义</li></ul></li><li>根据约束起的作用 ，约束可分为：<ul><li>NOT NULL 非空约束，规定某个字段不能为空</li><li>UNIQUE 唯一约束 ， 规定某个字段在整个表中是唯一的</li><li>PRIMARY KEY 主键(非空且唯一)约束</li><li>FOREIGN KEY 外键约束</li><li>CHECK 检查约束</li><li>DEFAULT 默认值约束</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 注意： MySQL不支持check约束，但可以使用check约束，而没有任何效果</span></span><br><span class="line"><span class="comment">-- information_schema数据库名（系统库）</span></span><br><span class="line"><span class="comment">-- table_constraints表名称（专门存储各个表的约束）</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> information_schema.table_constraints</span><br><span class="line"><span class="keyword">WHERE</span> table_name = <span class="string">'表名称'</span>;</span><br></pre></td></tr></table></figure><h2 id="2、非空约束">2、非空约束</h2><p>NOT NULL，限定某个字段/某列的值不允许为空</p><ul><li>默认，所有的类型的值都可以是NULL，包括INT、FLOAT等数据类型</li><li>非空约束只能出现在表对象的列上，只能某个列单独限定非空，不能组合非空</li><li>一个表可以有很多列都分别限定了非空</li><li>空字符串’'不等于NULL， 0 也不等于NULL</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名称(</span><br><span class="line">字段名 数据类型,</span><br><span class="line">字段名 数据类型 <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">字段名 数据类型 <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 建表后修改</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名称 <span class="keyword">modify</span> 字段名 数据类型 <span class="keyword">not</span> <span class="literal">null</span>;</span><br><span class="line"><span class="comment">-- 删除非空约束</span></span><br><span class="line"><span class="comment">-- 去掉not null，相当于修改某个非注解字段，该字段允许为空</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名称 <span class="keyword">modify</span> 字段名 数据类型 <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">-- 去掉not null，相当于修改某个非注解字段，该字段允许为空</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名称 <span class="keyword">modify</span> 字段名 数据类型;</span><br></pre></td></tr></table></figure><h2 id="3、唯一性约束">3、唯一性约束</h2><p>UNIQUE，用来限制某个字段/某列的值不能重复。</p><ul><li>同一个表可以有多个唯一约束。</li><li>唯一约束可以是某一个列的值唯一，也可以多个列组合的值唯一。</li><li>唯一性约束允许列值为空。</li><li>在创建唯一约束的时候，如果不给唯一约束命名，就默认和列名相同。</li><li><strong>MySQL会给唯一约束的列上默认创建一个唯一索引。</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 建表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名称(</span><br><span class="line">字段名 数据类型,</span><br><span class="line">字段名 数据类型 <span class="keyword">unique</span>,</span><br><span class="line">字段名 数据类型 <span class="keyword">unique</span> <span class="keyword">key</span>,</span><br><span class="line">字段名 数据类型</span><br><span class="line">);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名称(</span><br><span class="line">字段名 数据类型,</span><br><span class="line">字段名 数据类型,</span><br><span class="line">字段名 数据类型,</span><br><span class="line">[<span class="keyword">constraint</span> 约束名] <span class="keyword">unique</span> <span class="keyword">key</span>(字段名)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 建表后指定唯一键约束</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名称 <span class="keyword">add</span> <span class="keyword">unique</span> <span class="keyword">key</span>(字段列表);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名称 <span class="keyword">modify</span> 字段名 字段类型 <span class="keyword">unique</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 关于复合唯一约束，例如</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student_course(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span>,</span><br><span class="line"><span class="keyword">sid</span> <span class="built_in">int</span>,</span><br><span class="line">cid <span class="built_in">int</span>,</span><br><span class="line">score <span class="built_in">int</span>,</span><br><span class="line"><span class="keyword">unique</span> <span class="keyword">key</span>(<span class="keyword">sid</span>,cid)  <span class="comment">#复合唯一</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 删除约束</span></span><br><span class="line"><span class="comment">-- 添加唯一性约束的列上也会自动创建唯一索引</span></span><br><span class="line"><span class="comment">-- 删除唯一约束只能通过删除唯一索引的方式删除</span></span><br><span class="line"><span class="comment">-- 删除时需要指定唯一索引名，唯一索引名就和唯一约束名一样</span></span><br><span class="line"><span class="comment">-- 如果创建唯一约束时未指定名称，如果是单列，就默认和列名相同；如果是组合列，那么默认和()中排在第一个的列名相同。也可以自定义唯一性约束名</span></span><br><span class="line"><span class="comment">-- 查看都有哪些约束</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> information_schema.table_constraints <span class="keyword">WHERE</span> table_name = <span class="string">'表名'</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">USER</span> <span class="keyword">DROP</span> <span class="keyword">INDEX</span> uk_name_pwd;</span><br><span class="line"><span class="comment">-- 可以通过 show index from 表名称;查看表的索引</span></span><br></pre></td></tr></table></figure><h2 id="4、PRIMARY-KEY-约束">4、PRIMARY KEY 约束</h2><p>primary key，用来唯一标识表中的一行记录</p><ul><li>一个表最多只能有一个主键约束，建立主键约束可以在列级别创建，也可以在表级别上创建。</li><li>主键约束对应着表中的一列或者多列（复合主键）</li><li>如果是多列组合的复合主键约束，那么这些列都不允许为空值，并且组合的值不允许重复。</li><li><strong>MySQL的主键名总是PRIMARY</strong> ，就算自己命名了主键约束名也没用。</li><li>当创建主键约束时，系统默认会在所在的列或列组合上建立对应的 <strong>主键索引</strong> （能够根据主键查询的，就根据主键查询，效率更高）。如果删除主键约束了，主键约束对应的索引就自动删除了。</li><li>需要注意的一点是，不要修改主键字段的值。因为主键是数据记录的唯一标识，如果修改了主键的值，就有可能会破坏数据的完整性。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名称(</span><br><span class="line">字段名 数据类型 primary <span class="keyword">key</span>, <span class="comment">--列级模式</span></span><br><span class="line">字段名 数据类型,</span><br><span class="line">字段名 数据类型</span><br><span class="line">);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名称(</span><br><span class="line">字段名 数据类型,</span><br><span class="line">字段名 数据类型,</span><br><span class="line">字段名 数据类型,</span><br><span class="line">[<span class="keyword">constraint</span> 约束名] primary <span class="keyword">key</span>(字段名) <span class="comment">--表级模式</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 建表后增加主键约束</span></span><br><span class="line"><span class="comment">-- 字段列表可以是一个字段，也可以是多个字段，如果是多个字段的话，是复合主键</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名称 <span class="keyword">ADD</span> PRIMARY <span class="keyword">KEY</span>(字段列表);</span><br><span class="line"><span class="comment">-- 举例</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> emp5 <span class="keyword">ADD</span> PRIMARY <span class="keyword">KEY</span>(<span class="keyword">NAME</span>,pwd);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除主键约束</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名称 <span class="keyword">drop</span> primary <span class="keyword">key</span>;</span><br><span class="line"><span class="comment">-- 删除主键约束，不需要指定主键名，因为一个表只有一个主键，删除主键约束后，非空还存在</span></span><br></pre></td></tr></table></figure><h2 id="5、AUTO-INCREMENT">5、AUTO_INCREMENT</h2><p>auto_increment，某个字段的值自增</p><ul><li>一个表最多只能有一个自增长列</li><li>当需要产生唯一标识符或顺序值时，可设置自增长</li><li>自增长列约束的列必须是键列（主键列，唯一键列）</li><li>自增约束的列的数据类型必须是整数类型</li><li>如果自增列指定了 0 和 null，会在当前最大值的基础上自增；如果自增列手动指定了具体值，直接赋值为具体值</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 建表时</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名称(</span><br><span class="line">    字段名 数据类型 primary <span class="keyword">key</span> auto_increment,</span><br><span class="line">    字段名 数据类型 <span class="keyword">unique</span> <span class="keyword">key</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    字段名 数据类型 <span class="keyword">unique</span> <span class="keyword">key</span>,</span><br><span class="line">    字段名 数据类型 <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">default</span> 默认值,</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 自增从n开始，也可以自定义步长</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名称(</span><br><span class="line">    字段名 数据类型 <span class="keyword">default</span> 默认值 ,</span><br><span class="line">    字段名 数据类型 <span class="keyword">unique</span> <span class="keyword">key</span> auto_increment,</span><br><span class="line">    字段名 数据类型 <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">default</span> 默认值,</span><br><span class="line">    primary <span class="keyword">key</span>(字段名)</span><br><span class="line">) auto_increment = n;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名称 <span class="keyword">modify</span> 字段名 数据类型 auto_increment;</span><br><span class="line"><span class="comment">-- 给这个字段增加自增约束</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名称 <span class="keyword">modify</span> 字段名 数据类型 auto_increment</span><br><span class="line"><span class="comment">-- 去掉auto_increment相当于删除</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名称 <span class="keyword">modify</span> 字段名 数据类型;</span><br></pre></td></tr></table></figure><p>在MySQL 8.0之前，自增主键AUTO_INCREMENT的值如果大于max(primary key)+1，在MySQL重启后，会重置AUTO_INCREMENT=max(primary key)+1，这种现象在某些情况下会导致业务主键冲突或者其他难以发现的问题。<br>MySQL 8. 0 将自增主键的计数器持久化到重做日志中。每次计数器发生改变，都会将其写入重做日志中。如果数据库重启，InnoDB会根据重做日志中的信息来初始化计数器的内存值</p><h2 id="6、FOREIGN-KEY-约束-不推荐">6、FOREIGN KEY 约束(不推荐)</h2><h3 id="6-1-作用和特点">6.1 作用和特点</h3><p>限定某个表的某个字段的引用完整性</p><ul><li>主表（父表）：被引用的表，被参考的表</li><li>从表（子表）：引用别人的表，参考别人的表</li></ul><p>例如：员工表的员工所在部门这个字段的值要参考部门表：部门表是主表，员工表是从表。例如：学生表、课程表、选课表：选课表的学生和课程要分别参考学生表和课程表，学生表和课程表是主表，选课表是从表。</p><ul><li>从表的外键列，必须引用/参考主表的主键或唯一约束的列为什么？因为被依赖/被参考的值必须是唯一的</li><li>在创建外键约束时，如果不给外键约束命名，** 默认名不是列名，而是自动产生一个外键名** （例如student_ibfk_1;），也可以指定外键约束名。</li><li>创建(CREATE)表时就指定外键约束的话，先创建主表，再创建从表</li><li>删表时，先删从表（或先删除外键约束），再删除主表</li><li>当主表的记录被从表参照时，主表的记录将不允许删除，如果要删除数据，需要先删除从表中依赖该记录的数据，然后才可以删除主表的数据</li><li>在“从表”中指定外键约束，并且一个表可以建立多个外键约束</li><li>从表的外键列与主表被参照的列名字可以不相同，但是数据类型必须一样，逻辑意义一致。如果类型不一样，创建子表时，就会出现错误“ERROR 1005 (HY000): Can’t create table’database.tablename’(errno: 150)”。例如：都是表示部门编号，都是int类型。</li><li><strong>当创建外键约束时，系统默认会在所在的列上建立对应的普通索引</strong> 。但是索引名是外键的约束名。（根据外键查询效率很高）</li><li>删除外键约束后，必须手动删除对应的索引</li></ul><h3 id="6-2-简单演示">6.2 简单演示</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 建表时</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 主表名称(</span><br><span class="line">    字段 <span class="number">1</span> 数据类型 primary <span class="keyword">key</span>,</span><br><span class="line">    字段 <span class="number">2</span> 数据类型</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 从表名称(</span><br><span class="line">    字段 <span class="number">1</span> 数据类型 primary <span class="keyword">key</span>,</span><br><span class="line">    字段 <span class="number">2</span> 数据类型,</span><br><span class="line">    [<span class="keyword">CONSTRAINT</span> &lt;外键约束名称&gt;] <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span>(从表的某个字段) <span class="keyword">references</span> 主表名(被参考字段)</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- (从表的某个字段)的数据类型必须与主表名(被参考字段)的数据类型一致，逻辑意义也一样</span></span><br><span class="line"><span class="comment">-- (从表的某个字段)的字段名可以与主表名(被参考字段)的字段名一样，也可以不一样</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- FOREIGN KEY: 在表级指定子表中的列</span></span><br><span class="line"><span class="comment">-- REFERENCES: 标示在父表中的列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 建表后</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 从表名 <span class="keyword">ADD</span> [<span class="keyword">CONSTRAINT</span> 约束名] <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (从表的字段) <span class="keyword">REFERENCES</span> 主表名(被引用字段) [<span class="keyword">on</span> <span class="keyword">update</span> xx][<span class="keyword">on</span> <span class="keyword">delete</span> xx];</span><br></pre></td></tr></table></figure><ul><li>添加了外键约束后，主表的修改和删除数据受约束</li><li>添加了外键约束后，从表的添加和修改数据受约束</li><li>在从表上建立外键，要求主表必须存在</li><li>删除主表时，要求从表从表先删除，或将从表中外键引用该主表的关系先删除</li></ul><h3 id="6-3-约束等级">6.3 约束等级</h3><ul><li>Cascade方式：在父表上update/delete记录时，同步update/delete掉子表的匹配记录</li><li>Set null方式：在父表上update/delete记录时，将子表上匹配记录的列设为null，但是要注意子表的外键列不能为not null</li><li>No action方式：如果子表中有匹配的记录，则不允许对父表对应候选键进行update/delete操作</li><li>Restrict方式：同no action， 都是立即检查外键约束</li><li>Set default方式（在可视化工具SQLyog中可能显示空白）：父表有变更时，子表将外键列设置成一个默认的值，但Innodb不能识别</li></ul><p>对于外键约束，最好是采用: ON UPDATE CASCADE ON DELETE RESTRICT 的方式。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 举例</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> dept(</span><br><span class="line">    did <span class="built_in">int</span> primary <span class="keyword">key</span>, <span class="comment">#部门编号</span></span><br><span class="line">    dname <span class="built_in">varchar</span>( <span class="number">50</span> ) <span class="comment">#部门名称</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> emp(</span><br><span class="line">    eid <span class="built_in">int</span> primary <span class="keyword">key</span>,  <span class="comment">#员工编号</span></span><br><span class="line">    ename <span class="built_in">varchar</span>( <span class="number">5</span> ), <span class="comment">#员工姓名</span></span><br><span class="line">    deptid <span class="built_in">int</span>, <span class="comment">#员工所在的部门</span></span><br><span class="line">    <span class="keyword">foreign</span> <span class="keyword">key</span> (deptid) <span class="keyword">references</span> dept(did)  <span class="keyword">on</span> <span class="keyword">update</span> <span class="keyword">cascade</span> <span class="keyword">on</span> <span class="keyword">delete</span> <span class="keyword">set</span> <span class="literal">null</span></span><br><span class="line">    <span class="comment">-- 把修改操作设置为级联修改等级，把删除操作设置为set null等级</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="6-4-删除外键约束">6.4 删除外键约束</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 第一步先查看约束名和删除外键约束</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> information_schema.table_constraints <span class="keyword">WHERE</span> table_name = <span class="string">'表名称'</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 从表名 <span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> 外键约束名;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 第二步查看索引名和删除索引。（注意，只能手动删除）</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">INDEX</span> <span class="keyword">FROM</span> 表名称;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 从表名 <span class="keyword">DROP</span> <span class="keyword">INDEX</span> 索引名;</span><br></pre></td></tr></table></figure><h3 id="6-5-开发场景">6.5 开发场景</h3><p><strong>问题 1 ：如果两个表之间有关系（一对一、一对多），比如：员工表和部门表（一对多），它们之间是否一定要建外键约束？</strong><br>答：不是的<br><strong>问题 2 ：建和不建外键约束有什么区别？</strong><br>答：建外键约束，你的操作（创建表、删除表、添加、修改、删除）会受到限制，从语法层面受到限制。例如：在员工表中不可能添加一个员工信息，它的部门的值在部门表中找不到。<br>不建外键约束，你的操作（创建表、删除表、添加、修改、删除）不受限制，要保证数据的引用完整性，只能依靠程序员的自觉，或者是在Java程序中进行限定。例如：在员工表中，可以添加一个员工的信息，它的部门指定为一个完全不存在的部门。<br><strong>问题 3 ：那么建和不建外键约束和查询有没有关系？</strong><br>答：没有</p><blockquote><p>在 MySQL 里，外键约束是有成本的，需要消耗系统资源。对于大并发的 SQL 操作，有可能会不适合。比如大型网站的中央数据库，可能会因为外键约束的系统开销而变得非常慢。所以， MySQL 允许你不使用系统自带的外键约束，在应用层面完成检查数据一致性的逻辑。也就是说，即使你不用外键约束，也要想办法通过应用层面的附加逻辑，来实现外键约束的功能，确保数据的一致性。</p></blockquote><p><strong>阿里开发规范</strong><br>【强制】不得使用外键与级联，一切外键概念必须在应用层解决。<br>说明：（概念解释）学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，即为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。</p><h2 id="7、CHECK-约束">7、CHECK 约束</h2><p>CHECK，检查某个字段的值是否符号xx要求，一般指的是值的范围，MySQL5.7 可以使用check约束，但check约束对数据验证没有任何作用。添加数据时，没有任何错误或警告，但是<strong>MySQL 8.0中可以使用check约束了</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> employee(</span><br><span class="line">    eid <span class="built_in">int</span> primary <span class="keyword">key</span>,</span><br><span class="line">    ename <span class="built_in">varchar</span>( <span class="number">5</span> ),</span><br><span class="line">    gender <span class="built_in">char</span> <span class="keyword">check</span> (<span class="string">'男'</span> <span class="keyword">or</span> <span class="string">'女'</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- age tinyint check(age &gt; 20 ) 或 sex char( 2 ) check(sex in('男','女'))</span></span><br></pre></td></tr></table></figure><h2 id="8、DEFAULT约束">8、DEFAULT约束</h2><p>给某个字段/某列指定默认值，一旦设置默认值，在插入数据时，如果此字段没有显式赋值，则赋值为默认值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 建表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名称(</span><br><span class="line">    字段名 数据类型 primary <span class="keyword">key</span>,</span><br><span class="line">    字段名 数据类型 <span class="keyword">unique</span> <span class="keyword">key</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    字段名 数据类型 <span class="keyword">unique</span> <span class="keyword">key</span>,</span><br><span class="line">    字段名 数据类型 <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">default</span> 默认值,</span><br><span class="line">);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名称(</span><br><span class="line">    字段名 数据类型 <span class="keyword">default</span> 默认值 ,</span><br><span class="line">    字段名 数据类型 <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">default</span> 默认值,</span><br><span class="line">    字段名 数据类型 <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">default</span> 默认值,</span><br><span class="line">    primary <span class="keyword">key</span>(字段名),</span><br><span class="line">    <span class="keyword">unique</span> <span class="keyword">key</span>(字段名)</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 说明：默认值约束一般不在唯一键和主键列上加</span></span><br><span class="line">desc employee;</span><br><span class="line"><span class="comment">-- 后期添加</span></span><br><span class="line"><span class="comment">-- 如果这个字段原来有非空约束，你还保留非空约束，那么在加默认值约束时，还得保留非空约束，否则非空约束就被删除了</span></span><br><span class="line"><span class="comment">-- 同理，在给某个字段加非空约束也一样，如果这个字段原来有默认值约束，你想保留，也要在modify语句中保留默认值约束，否则就删除了</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名称 <span class="keyword">modify</span> 字段名 数据类型 <span class="keyword">default</span> 默认值 <span class="keyword">not</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名称 <span class="keyword">modify</span> 字段名 数据类型 <span class="keyword">default</span> 默认值;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除默认值约束</span></span><br><span class="line"><span class="comment">-- 删除默认值约束，也不保留非空约束</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名称 <span class="keyword">modify</span> 字段名 数据类型 ;</span><br><span class="line"><span class="comment">-- 删除默认值约束，保留非空约束</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名称 <span class="keyword">modify</span> 字段名 数据类型 <span class="keyword">not</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h1>七、视图</h1><h2 id="1、常见的数据库对象">1、常见的数据库对象</h2><table><thead><tr><th><strong>对象</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>表(TABLE)</td><td>表是存储数据的逻辑单元，以行和列的形式存在，列就是字段，行就是记录</td></tr><tr><td>数据字典</td><td>就是系统表，存放数据库相关信息的表。系统表的数据通常由数据库系统维护，程序员通常不应该修改，只可查看</td></tr><tr><td>约束(CONSTRAINT)</td><td>执行数据校验的规则，用于保证数据完整性的规则</td></tr><tr><td>视图(VIEW)</td><td>一个或者多个数据表里的数据的逻辑显示，视图并不存储数据</td></tr><tr><td>索引(INDEX)</td><td>用于提高查询性能，相当于书的目录</td></tr><tr><td>存储过程(PROCEDURE)</td><td>用于完成一次完整的业务处理，没有返回值，但可通过传出参数将多个值传给调用环境</td></tr><tr><td>存储函数(FUNCTION)</td><td>用于完成一次特定的计算，具有一个返回值</td></tr><tr><td>触发器(TRIGGER)</td><td>相当于一个事件监听器，当数据库发生特定事件后，触发器被触发，完成相应的处理</td></tr></tbody></table><h2 id="2、视图概述">2、视图概述</h2><ul><li>视图是一种虚拟表，本身是不具有数据的，占用很少的内存空间，它是 SQL 中的一个重要概念。</li><li><strong>视图建立在已有表的基础上</strong> , 视图赖以建立的这些表称为 <strong>基表</strong></li><li>视图的创建和删除只影响视图本身，不影响对应的基表。但是当对视图中的数据进行增加、删除和修改操作时，数据表中的数据会相应地发生变化，反之亦然。</li><li>向视图提供数据内容的语句为 SELECT 语句, 可以将视图理解为 <strong>存储起来的 SELECT 语句</strong><ul><li>在数据库中，视图不会保存数据，数据真正保存在数据表中。当对视图中的数据进行增加、删除和修改操作时，数据表中的数据会相应地发生变化；反之亦然。</li></ul></li><li>视图，是向用户提供基表数据的另一种表现形式。通常情况下，小型项目的数据库可以不使用视图，但是在大型项目中，以及数据表比较复杂的情况下，视图的价值就凸显出来了，它可以帮助我们把经常查询的结果集放到虚拟表中，提升使用效率。理解和使用起来都非常方便。</li></ul><h2 id="3、创建视图">3、创建视图</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 在 CREATE VIEW 语句中嵌入子查询</span></span><br><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">OR</span> <span class="keyword">REPLACE</span>]</span><br><span class="line">[ALGORITHM = &#123;UNDEFINED | <span class="keyword">MERGE</span> | TEMPTABLE&#125;]</span><br><span class="line"><span class="keyword">VIEW</span> 视图名称 [(字段列表)]</span><br><span class="line"><span class="keyword">AS</span> 查询语句</span><br><span class="line">[<span class="keyword">WITH</span> [<span class="keyword">CASCADED</span>|<span class="keyword">LOCAL</span>] <span class="keyword">CHECK</span> <span class="keyword">OPTION</span>]</span><br><span class="line"><span class="comment">-- 精简版</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> 视图名称 <span class="keyword">AS</span> 查询语句</span><br><span class="line"><span class="comment">-- 举例</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> empvu</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> employee_id, last_name, salary</span><br><span class="line"><span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> department_id = <span class="number">80</span> ;</span><br><span class="line"><span class="comment">-- 查询视图</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> salvu80;</span><br><span class="line"><span class="comment">-- 实际上就是我们在 SQL 查询语句的基础上封装了视图 VIEW，这样就会基于 SQL 语句的结果集形成一张虚拟表</span></span><br><span class="line"><span class="comment">-- 在创建视图时，没有在视图名后面指定字段列表，则视图中字段列表默认和SELECT语句中的字段列表一致。如果SELECT语句中给字段取了别名，那么视图中的字段名和别名相同</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建多表联合视图</span></span><br><span class="line"><span class="comment">-- 举例</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> dept_sum_vu</span><br><span class="line">(<span class="keyword">name</span>, minsal, maxsal, avgsal)</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> d.department_name, <span class="keyword">MIN</span>(e.salary), <span class="keyword">MAX</span>(e.salary),<span class="keyword">AVG</span>(e.salary)</span><br><span class="line"><span class="keyword">FROM</span> employees e, departments d</span><br><span class="line"><span class="keyword">WHERE</span> e.department_id = d.department_id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> d.department_name;</span><br><span class="line"><span class="comment">-- 利用视图对数据进行格式化</span></span><br><span class="line"><span class="comment">-- 我们经常需要输出某个格式的内容，比如我们想输出员工姓名和对应的部门名，对应格式为emp_name(department_name)，就可以使用视图来完成数据格式化的操作</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> emp_depart</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CONCAT</span>(last_name,<span class="string">'('</span>,department_name,<span class="string">')'</span>) <span class="keyword">AS</span> emp_dept</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">WHERE</span> e.department_id = d.department_id</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 基于视图创建视图</span></span><br><span class="line"><span class="comment">-- 当我们创建好一张视图之后，还可以在它的基础上继续创建视图</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> emp_dept_ysalary</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> emp_dept.ename,dname,year_salary</span><br><span class="line"><span class="keyword">FROM</span> emp_dept <span class="keyword">INNER</span> <span class="keyword">JOIN</span> emp_year_salary</span><br><span class="line"><span class="keyword">ON</span> emp_dept.ename = emp_year_salary.ename;</span><br></pre></td></tr></table></figure><h2 id="4、查看视图">4、查看视图</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看数据库的表对象、视图对象</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">TABLES</span>;</span><br><span class="line"><span class="comment">-- 查看视图的结构</span></span><br><span class="line">DESC/<span class="keyword">DESCRIBE</span> 视图名称;</span><br><span class="line"><span class="comment">-- 查看视图的属性信息</span></span><br><span class="line"><span class="comment">-- 查看视图信息（显示数据表的存储引擎、版本、数据行数和数据大小等）</span></span><br><span class="line"><span class="comment">-- 执行结果显示，注释Comment为VIEW，说明该表为视图，其他的信息为NULL，说明这是一个虚表</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">TABLE</span> <span class="keyword">STATUS</span> <span class="keyword">LIKE</span> <span class="string">'视图名称'</span>\G</span><br><span class="line"><span class="comment">-- 查看视图的详细定义信息</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">VIEW</span> 视图名称;</span><br></pre></td></tr></table></figure><h2 id="5、更新视图的数据">5、更新视图的数据</h2><h3 id="5-1-一般情况">5.1 一般情况</h3><p>MySQL支持使用INSERT、UPDATE和DELETE语句对视图中的数据进行插入、更新和删除操作。当视图中的数据发生变化时，数据表中的数据也会发生变化，反之亦然。</p><h3 id="5-2-不可更新的视图">5.2 不可更新的视图</h3><p>要使视图可更新，视图中的行和底层基本表中的行之间必须存在一对一的关系。另外当视图定义出现如下情况时，视图不支持更新操作：</p><ul><li>在定义视图的时候指定了“ALGORITHM = TEMPTABLE”，视图将不支持INSERT和DELETE操作；</li><li>视图中不包含基表中所有被定义为非空又未指定默认值的列，视图将不支持INSERT操作；</li><li>在定义视图的SELECT语句中使用了JOIN联合查询，视图将不支持INSERT和DELETE操作；</li><li>在定义视图的SELECT语句后的字段列表中使用了数学表达式或子查询，视图将不支持INSERT，也不支持UPDATE使用了数学表达式、子查询的字段值；</li><li>在定义视图的SELECT语句后的字段列表中使用DISTINCT、聚合函数、GROUP BY、HAVING、UNION等，视图将不支持INSERT、UPDATE、DELETE；</li><li>在定义视图的SELECT语句中包含了子查询，而子查询中引用了FROM后面的表，视图将不支持INSERT、UPDATE、DELETE；</li><li>视图定义基于一个不可更新视图；</li><li>常量视图</li></ul><p>虽然可以更新视图数据，但总的来说，视图作为虚拟表，主要用于方便查询，不建议更新视图的数据。 <strong>对视图数据的更改，都是通过对实际数据表里数据的操作来完成的</strong></p><h2 id="6、修改、删除视图">6、修改、删除视图</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 修改视图</span></span><br><span class="line"><span class="comment">-- 使用CREATE OR REPLACE VIEW 子句 修改视图</span></span><br><span class="line"><span class="comment">-- 注意CREATE VIEW 子句中各列的别名应和子查询中各列相对应</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">VIEW</span> empvu</span><br><span class="line">(id_number, <span class="keyword">name</span>, sal, department_id)</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> employee_id, first_name || <span class="string">' '</span> || last_name, salary, department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id = <span class="number">80</span> ;</span><br><span class="line"><span class="comment">-- 方式2</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">VIEW</span> 视图名称</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line">查询语句</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除视图</span></span><br><span class="line"><span class="comment">-- 删除视图只是删除视图的定义，并不会删除基表的数据</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> 视图名称;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> 视图名称<span class="number">1</span>,视图名称<span class="number">2</span>,视图名称<span class="number">3</span>,...;</span><br><span class="line"><span class="comment">-- 基于视图a、b创建了新的视图c，如果将视图a或者视图b删除，会导致视图c的查询失败。这样的视图c需要手动删除或修改，否则影响使用</span></span><br></pre></td></tr></table></figure><h2 id="7、总结">7、总结</h2><h3 id="7-1-优点">7.1 优点</h3><ul><li><strong>操作简单</strong>。将经常使用的查询操作定义为视图，可以使开发人员不需要关心视图对应的数据表的结构、表与表之间的关联关系，也不需要关心数据表之间的业务逻辑和查询条件，而只需要简单地操作视图即可，极大简化了开发人员对数据库的操作。</li><li><strong>减少数据冗余</strong>。视图跟实际数据表不一样，它存储的是查询语句。所以，在使用的时候，我们要通过定义视图的查询语句来获取结果集。而视图本身不存储数据，不占用数据存储的资源，减少了数据冗余。</li><li><strong>数据安全</strong>。MySQL将用户对数据的访问限制在某些数据的结果集上，而这些数据的结果集可以使用视图来实现。用户不必直接查询或操作数据表。这也可以理解为视图具有隔离性。视图相当于在用户和实际的数据表之间加了一层虚拟表。同时，MySQL可以根据权限将用户对数据的访问限制在某些视图上， <strong>用户不需要查询数据表，可以直接通过视图获取数据表中的信息</strong> 。这在一定程度上保障了数据表中数据的安全性。</li><li><strong>适应灵活多变的需求</strong>。当业务系统的需求发生变化后，如果需要改动数据表的结构，则工作量相对较大，可以使用视图来减少改动的工作量。这种方式在实际工作中使用得比较多。</li><li>**能够分解复杂的查询逻辑。**数据库中如果存在复杂的查询逻辑，则可以将问题进行分解，创建多个视图获取数据，再将创建的多个视图结合起来，完成复杂的查询逻辑。</li></ul><h3 id="7-2-缺点">7.2 缺点</h3><p>如果我们在实际数据表的基础上创建了视图，那么， <strong>如果实际数据表的结构变更了，我们就需要及时对相关的视图进行相应的维护</strong> 。特别是嵌套的视图（就是在视图的基础上创建视图），维护会变得比较复杂，可读性不好，容易变成系统的潜在隐患。因为创建视图的 SQL 查询可能会对字段重命名，也可能包含复杂的逻辑，这些都会增加维护的成本。<br>实际项目中，如果视图过多，会导致数据库维护成本的问题。所以，在创建视图的时候，你要结合实际项目需求，综合考虑视图的优点和不足，这样才能正确使用视图，使系统整体达到最优。</p><h1>八、存储过程与函数</h1><h2 id="1、存储过程概述">1、存储过程概述</h2><h3 id="1-1-介绍">1.1 介绍</h3><p><strong>含义</strong> ：存储过程的英文是 Stored Procedure。它的思想很简单，就是一组经过预先编译的 SQL 语句的封装。执行过程：存储过程预先存储在 MySQL 服务器上，需要执行的时候，客户端只需要向服务器端发出调用存储过程的命令，服务器端就可以把预先存储好的这一系列 SQL 语句全部执行。<br><strong>好处</strong> ：</p><ol><li>简化操作，提高了sql语句的重用性，减少了开发程序员的压力</li><li>减少操作过程中的失误，提高效率</li><li>减少网络传输量（客户端不需要把所有的 SQL 语句通过网络发给服务器）</li><li>减少了 SQL 语句暴露在网上的风险，也提高了数据查询的安全性</li></ol><p><strong>和视图、函数的对比</strong> ：<br>它和视图有着同样的优点，清晰、安全，还可以减少网络传输量。不过它和视图不同，视图是虚拟表，通常不对底层数据表直接操作，而存储过程是程序化的 SQL，可以直接操作底层数据表，相比于面向集合的操作方式，能够实现一些更复杂的数据处理。一旦存储过程被创建出来，使用它就像使用函数一样简单，我们直接通过调用存储过程名即可。相较于函数，存储过程是没有返回值的。</p><h3 id="1-2-分类">1.2 分类</h3><p>存储过程的参数类型可以是IN、OUT和INOUT。根据这点分类如下：</p><ol><li>没有参数（无参数无返回）</li><li>仅仅带 IN 类型（有参数无返回）</li><li>仅仅带 OUT 类型（无参数有返回）</li><li>既带 IN 又带 OUT（有参数有返回）</li><li>带 INOUT（有参数有返回）</li></ol><p>注意：IN、OUT、INOUT 都可以在一个存储过程中带多个。</p><h2 id="2、创建存储过程">2、创建存储过程</h2><h3 id="2-1-语法分析">2.1 语法分析</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> 存储过程名(<span class="keyword">IN</span>|<span class="keyword">OUT</span>|INOUT 参数名 参数类型,...)</span><br><span class="line">[characteristics ...]</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">存储过程体</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ol><li>参数前面的符号的意思</li></ol><ul><li>IN：当前参数为输入参数，也就是表示入参；存储过程只是读取这个参数的值。如果没有定义参数种类，默认就是 IN，表示输入参数。</li><li>OUT：当前参数为输出参数，也就是表示出参；执行完成之后，调用这个存储过程的客户端或者应用程序就可以读取这个参数返回的值了。</li><li>INOUT：当前参数既可以为输入参数，也可以为输出参数。</li></ul><ol start="2"><li>形参类型可以是 MySQL数据库中的任意类型。</li><li>characteristics 表示创建存储过程时指定的对存储过程的约束条件</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LANGUAGE SQL</span><br><span class="line">| [NOT] DETERMINISTIC</span><br><span class="line">| &#123; CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA &#125;</span><br><span class="line">| SQL SECURITY &#123; DEFINER | INVOKER &#125;</span><br><span class="line">| <span class="keyword">COMMENT</span> <span class="string">'string'</span></span><br></pre></td></tr></table></figure><ol start="4"><li>存储过程体中可以有多条 SQL 语句，如果仅仅一条SQL 语句，则可以省略 BEGIN 和 END<br>编写存储过程并不是一件简单的事情，可能存储过程中需要复杂的 SQL 语句。</li><li>需要设置新的结束标记，因为MySQL默认的语句结束符号为分号‘;’。为了避免与存储过程中SQL语句结束符相冲突，需要使用DELIMITER改变存储过程的结束符。</li></ol><h3 id="2-2-举例">2.2 举例</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 举例1</span></span><br><span class="line">DELIMITER $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> select_all_data()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emps;</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 举例2，创建存储过程show_max_salary()，用来查看“emps”表的最高薪资值</span></span><br><span class="line">DELIMITER //</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> show_max_salary()</span><br><span class="line"><span class="keyword">LANGUAGE</span> <span class="keyword">SQL</span></span><br><span class="line"><span class="keyword">NOT</span> <span class="keyword">DETERMINISTIC</span></span><br><span class="line">CONTAINS <span class="keyword">SQL</span></span><br><span class="line"><span class="keyword">SQL</span> <span class="keyword">SECURITY</span> DEFINER</span><br><span class="line"><span class="keyword">COMMENT</span> <span class="string">'查看最高薪资'</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MAX</span>(salary) <span class="keyword">FROM</span> emps;</span><br><span class="line"><span class="keyword">END</span> //</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">--  查看“emps”表的最低薪资值。并将最低薪资通过OUT参数“ms”输出</span></span><br><span class="line">DELIMITER //</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> show_min_salary(<span class="keyword">OUT</span> ms <span class="keyword">DOUBLE</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MIN</span>(salary) <span class="keyword">INTO</span> ms <span class="keyword">FROM</span> emps;</span><br><span class="line"><span class="keyword">END</span> //</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看“emps”表的某个员工的薪资，并用IN参数empname输入员工姓名</span></span><br><span class="line">DELIMITER //</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> show_someone_salary(<span class="keyword">IN</span> empname <span class="built_in">VARCHAR</span>( <span class="number">20</span> ))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">SELECT</span> salary <span class="keyword">FROM</span> emps <span class="keyword">WHERE</span> ename = empname;</span><br><span class="line"><span class="keyword">END</span> //</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><h2 id="3、调用存储过程">3、调用存储过程</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 存储过程有多种调用方法。存储过程必须使用CALL语句调用，并且存储过程和数据库相关，如果要执行其他数据库中的存储过程，需要指定数据库名称</span></span><br><span class="line"><span class="keyword">CALL</span> 存储过程名(实参列表)</span><br><span class="line"><span class="comment">-- 调用in模式</span></span><br><span class="line"><span class="keyword">CALL</span> sp1(<span class="string">'值'</span>);</span><br><span class="line"><span class="comment">-- 调用out模式的参数</span></span><br><span class="line"><span class="keyword">SET</span> @<span class="keyword">name</span>;</span><br><span class="line"><span class="keyword">CALL</span> sp1(@<span class="keyword">name</span>);</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="keyword">name</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 调用inout模式的参数</span></span><br><span class="line"><span class="keyword">SET</span> @<span class="keyword">name</span>=值;</span><br><span class="line"><span class="keyword">CALL</span> sp1(@<span class="keyword">name</span>);</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="keyword">name</span>;</span><br></pre></td></tr></table></figure><h2 id="4、存储函数的使用">4、存储函数的使用</h2><h3 id="4-1-语法分析">4.1 语法分析</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> 函数名(参数名 参数类型,...)</span><br><span class="line"><span class="keyword">RETURNS</span> 返回值类型</span><br><span class="line">[characteristics ...]</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">函数体 <span class="comment">#函数体中肯定有 RETURN 语句</span></span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><ul><li>参数列表：指定参数为IN、OUT或INOUT只对PROCEDURE是合法的，FUNCTION中总是默认为IN参数。</li><li>RETURNS type 语句表示函数返回数据的类型；<br>RETURNS子句只能对FUNCTION做指定，对函数而言这是强制的。它用来指定函数的返回类型，而且函数体必须包含一个RETURN value语句。</li><li>characteristic 创建函数时指定的对函数的约束。取值与创建存储过程时相同，这里不再赘述。</li><li>函数体也可以用BEGIN…END来表示SQL代码的开始和结束。如果函数体只有一条语句，也可以省略BEGIN…END。</li></ul><h3 id="4-2-调用存储函数">4.2 调用存储函数</h3><p>在MySQL中，存储函数的使用方法与MySQL内部函数的使用方法是一样的。换言之，用户自己定义的存储函数与MySQL内部函数是一个性质的。区别在于，存储函数是用户自己定义的，而内部函数是MySQL的开发者定义的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 函数名(实参列表)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 举例</span></span><br><span class="line">DELIMITER //</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> email_by_id(emp_id <span class="built_in">INT</span>)</span><br><span class="line"><span class="keyword">RETURNS</span> <span class="built_in">VARCHAR</span>( <span class="number">25</span> )</span><br><span class="line"><span class="keyword">DETERMINISTIC</span></span><br><span class="line">CONTAINS <span class="keyword">SQL</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">RETURN</span> (<span class="keyword">SELECT</span> email <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> employee_id = emp_id);</span><br><span class="line"><span class="keyword">END</span> //</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br><span class="line"><span class="comment">-- 调用</span></span><br><span class="line"><span class="keyword">SET</span> @emp_id = <span class="number">102</span> ;</span><br><span class="line"><span class="keyword">SELECT</span> email_by_id( <span class="number">102</span> );</span><br></pre></td></tr></table></figure><p><strong>注意：</strong><br>若在创建存储函数中报错“you might want to use the less safe log_bin_trust_function_creators variable”，有两种处理方法：</p><ul><li>方式 1 ：加上必要的函数特性“[NOT] DETERMINISTIC”和“{CONTAINS SQL | NO SQL | READS SQL DATA |MODIFIES SQL DATA}”</li><li>方式 2 ：<code>SET GLOBAL log_bin_trust_function_creators = 1 ;</code></li></ul><h3 id="4-3-对比存储函数和存储过程">4.3 对比存储函数和存储过程</h3><table><thead><tr><th>**<strong>关键字</strong></th><th><strong>调用语法</strong></th><th><strong>返回值</strong></th><th><strong>应用场景</strong></th><th></th></tr></thead><tbody><tr><td>存储过程</td><td>PROCEDURE</td><td>CALL 存储过程()</td><td>理解为有 0 个或多个</td><td>一般用于更新</td></tr><tr><td>存储函数</td><td>FUNCTION</td><td>SELECT 函数()</td><td>只能是一个</td><td>一般用于查询结果为一个值并返回时</td></tr></tbody></table><h2 id="5、存储过程和函数的查看、修改、删除">5、存储过程和函数的查看、修改、删除</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看存储过程和函数的创建信息</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> &#123;<span class="keyword">PROCEDURE</span> | <span class="keyword">FUNCTION</span>&#125; 存储过程名或函数名</span><br><span class="line"><span class="comment">-- 举例</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> test_db.CountProc \G</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用SHOW STATUS语句查看存储过程和函数的状态信息</span></span><br><span class="line"><span class="keyword">SHOW</span> &#123;<span class="keyword">PROCEDURE</span> | <span class="keyword">FUNCTION</span>&#125; <span class="keyword">STATUS</span> [<span class="keyword">LIKE</span> <span class="string">'pattern'</span>]</span><br><span class="line"><span class="comment">-- 举例</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">PROCEDURE</span> <span class="keyword">STATUS</span> <span class="keyword">LIKE</span> <span class="string">'SELECT%'</span> \G</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 从information_schema.Routines表中查看存储过程和函数的信息</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> information_schema.Routines</span><br><span class="line"><span class="keyword">WHERE</span> ROUTINE_NAME=<span class="string">'存储过程或函数的名'</span>[<span class="keyword">AND</span> ROUTINE_TYPE=&#123;<span class="string">'PROCEDURE|FUNCTION'</span>&#125;];</span><br><span class="line"><span class="comment">-- 举例：从Routines表中查询名称为CountProc的存储函数的信息</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> information_schema.Routines</span><br><span class="line"><span class="keyword">WHERE</span> ROUTINE_NAME=<span class="string">'count_by_id'</span> <span class="keyword">AND</span> ROUTINE_TYPE = <span class="string">'FUNCTION'</span> \G</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改存储过程或函数，不影响存储过程或函数功能，只是修改相关特性</span></span><br><span class="line"><span class="keyword">ALTER</span> &#123;<span class="keyword">PROCEDURE</span> | <span class="keyword">FUNCTION</span>&#125; 存储过程或函数的名 [characteristic ...]</span><br><span class="line"><span class="comment">-- 其中，characteristic指定存储过程或函数的特性，其取值信息与创建存储过程、函数时的取值信息略有不同</span></span><br><span class="line">&#123; CONTAINS <span class="keyword">SQL</span> | <span class="keyword">NO</span> <span class="keyword">SQL</span> | <span class="keyword">READS</span> <span class="keyword">SQL</span> <span class="keyword">DATA</span> | MODIFIES <span class="keyword">SQL</span> <span class="keyword">DATA</span> &#125;</span><br><span class="line">| <span class="keyword">SQL</span> <span class="keyword">SECURITY</span> &#123; DEFINER | INVOKER &#125;</span><br><span class="line">| <span class="keyword">COMMENT</span> <span class="string">'string'</span></span><br><span class="line"><span class="comment">-- 举例</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">FUNCTION</span> CountProc</span><br><span class="line"><span class="keyword">READS</span> <span class="keyword">SQL</span> <span class="keyword">DATA</span></span><br><span class="line"><span class="keyword">COMMENT</span> <span class="string">'FIND NAME'</span> ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除</span></span><br><span class="line"><span class="keyword">DROP</span> &#123;<span class="keyword">PROCEDURE</span> | <span class="keyword">FUNCTION</span>&#125; [<span class="keyword">IF</span> <span class="keyword">EXISTS</span>] 存储过程或函数的名</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> CountProc;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">FUNCTION</span> CountProc;</span><br></pre></td></tr></table></figure><h2 id="6、总结">6、总结</h2><h3 id="6-1-优点">6.1 优点</h3><ol><li>**存储过程可以一次编译多次使用。**存储过程只在创建时进行编译，之后的使用都不需要重新编译，这就提升了 SQL 的执行效率。</li><li><strong>可以减少开发工作量。</strong> 将代码封装成模块，实际上是编程的核心思想之一，这样可以把复杂的问题拆解成不同的模块，然后模块之间可以重复使用，在减少开发工作量的同时，还能保证代码的结构清晰。</li><li><strong>存储过程的安全性强。</strong> 我们在设定存储过程的时候可以设置对用户的使用权限，这样就和视图一样具有较强的安全性。</li><li><strong>可以减少网络传输量。</strong> 因为代码封装到存储过程中，每次使用只需要调用存储过程即可，这样就减少了网络传输量。</li><li><strong>良好的封装性。</strong> 在进行相对复杂的数据库操作时，原本需要使用一条一条的 SQL 语句，可能要连接多次数据库才能完成的操作，现在变成了一次存储过程，只需要连接一次即可。</li></ol><h3 id="6-2-缺点">6.2 缺点</h3><blockquote><p><strong>阿里开发规范</strong><br>【强制】禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。</p></blockquote><ol><li><strong>可移植性差。</strong> 存储过程不能跨数据库移植，比如在 MySQL、Oracle 和 SQL Server 里编写的存储过程，在换成其他数据库时都需要重新编写。</li><li><strong>调试困难。</strong> 只有少数 DBMS 支持存储过程的调试。对于复杂的存储过程来说，开发和维护都不容易。虽然也有一些第三方工具可以对存储过程进行调试，但要收费。</li><li><strong>存储过程的版本管理很困难。</strong> 比如数据表索引发生变化了，可能会导致存储过程失效。我们在开发软件的时候往往需要进行版本管理，但是存储过程本身没有版本控制，版本迭代更新的时候很麻烦。</li><li><strong>它不适合高并发的场景。</strong> 高并发的场景需要减少数据库的压力，有时数据库会采用分库分表的方式，而且对可扩展性要求很高，在这种情况下，存储过程会变得难以维护，增加数据库的压力，显然就不适用了。</li></ol><h1>九、变量、流程控制、游标与触发器</h1><h2 id="1、变量">1、变量</h2><h3 id="1-1-系统变量">1.1 系统变量</h3><blockquote><p>MySQL文档的系统变量：<a href="https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html</a></p></blockquote><p>变量由系统定义，不是用户定义，属于服务器层面。启动MySQL服务，生成MySQL服务实例期间，MySQL将为MySQL服务器内存中的系统变量赋值，这些系统变量定义了当前MySQL服务实例的属性、特征。这些系统变量的值要么是编译MySQL时参数的默认值，要么是配置文件（例如my.ini等）中的参数值。<br>系统变量分为全局系统变量（需要添加global 关键字）以及会话系统变量（需要添加 session 关键字），有时也把全局系统变量简称为全局变量，有时也把会话系统变量称为local变量。 <strong>如果不写，默认会话级别。</strong> 静态变量（在 MySQL 服务实例运行期间它们的值不能使用 set 动态修改）属于特殊的全局系统变量。<br>每一个MySQL客户机成功连接MySQL服务器后，都会产生与之对应的会话。会话期间，MySQL服务实例会在MySQL服务器内存中生成与该会话对应的会话系统变量，这些会话系统变量的初始值是全局系统变量值的复制。如下图<br><img src="https://img-blog.csdnimg.cn/img_convert/d599a5a143d3bc07ce27059fb8302042.png" alt="image.png"></p><ul><li>全局系统变量针对于所有会话（连接）有效，但不能跨重启</li><li>会话系统变量仅针对于当前会话（连接）有效。会话期间，当前会话对某个会话系统变量值的修改，不会影响其他会话同一个会话系统变量的值。</li><li>会话 1 对某个全局系统变量值的修改会导致会话 2 中同一个全局系统变量值的修改。</li></ul><p>在MySQL中有些系统变量只能是全局的，例如 max_connections 用于限制服务器的最大连接数；有些系统变量作用域既可以是全局又可以是会话，例如 character_set_client 用于设置客户端的字符集；有些系统变量的作用域只能是当前会话，例如 pseudo_thread_id 用于标记当前会话的 MySQL 连接 ID。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看系统变量</span></span><br><span class="line"><span class="comment">-- 查看所有全局变量</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> <span class="keyword">VARIABLES</span>;</span><br><span class="line"><span class="comment">-- 查看所有会话变量</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">SESSION</span> <span class="keyword">VARIABLES</span>;</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看满足条件的部分系统变量。</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">'%标识符%'</span>;</span><br><span class="line"><span class="comment">-- 查看满足条件的部分会话变量</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">SESSION</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">'%标识符%'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看指定系统变量</span></span><br><span class="line"><span class="comment">-- 作为 MySQL 编码规范，MySQL 中的系统变量以两个“@”开头，其中“@@global”仅用于标记全局系统变量，“@@session”仅用于标记会话系统变量。</span></span><br><span class="line"><span class="comment">-- “@@”首先标记会话系统变量，如果会话系统变量不存在，则标记全局系统变量</span></span><br><span class="line"><span class="comment">-- 查看指定的系统变量的值</span></span><br><span class="line"><span class="keyword">SELECT</span> @@global.变量名;</span><br><span class="line"><span class="comment">-- 查看指定的会话变量的值</span></span><br><span class="line"><span class="keyword">SELECT</span> @@session.变量名;</span><br><span class="line"><span class="keyword">SELECT</span> @@变量名;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改系统变量的值</span></span><br><span class="line"><span class="comment">-- 方式一修改MySQL配置文件，继而修改MySQL系统变量的值（该方法需要重启MySQL服务）</span></span><br><span class="line"><span class="comment">-- 方式二在MySQL服务运行期间，使用“set”命令重新设置系统变量的值</span></span><br><span class="line"><span class="comment">-- 为某个系统变量赋值</span></span><br><span class="line"><span class="keyword">SET</span> @@global.变量名=变量值;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> 变量名=变量值;</span><br><span class="line"><span class="comment">-- 为某个会话变量赋值</span></span><br><span class="line"><span class="keyword">SET</span> @@session.变量名=变量值;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">SESSION</span> 变量名=变量值;</span><br></pre></td></tr></table></figure><h3 id="1-2-用户变量">1.2 用户变量</h3><p>用户变量是用户自己定义的，作为 MySQL 编码规范，MySQL 中的用户变量以一个“@”开头。根据作用范围不同，又分为会话用户变量和局部变量。</p><ul><li>会话用户变量：作用域和会话变量一样，只对当前连接会话有效。</li><li>局部变量：只在 BEGIN 和 END 语句块中有效。局部变量只能在存储过程和函数中使用。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 会话用户变量</span></span><br><span class="line"><span class="comment">-- 变量定义</span></span><br><span class="line"><span class="comment">-- 方式 1 ：“=”或“:=”</span></span><br><span class="line"><span class="keyword">SET</span> @用户变量 = 值;</span><br><span class="line"><span class="keyword">SET</span> @用户变量 := 值;</span><br><span class="line"><span class="comment">-- 方式 2 ：“:=” 或 INTO关键字</span></span><br><span class="line"><span class="keyword">SELECT</span> @用户变量 := 表达式 [<span class="keyword">FROM</span> 等子句];</span><br><span class="line"><span class="keyword">SELECT</span> 表达式 <span class="keyword">INTO</span> @用户变量 [<span class="keyword">FROM</span> 等子句];</span><br><span class="line"><span class="comment">-- 查询</span></span><br><span class="line"><span class="keyword">SELECT</span> @用户变量</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 局部变量</span></span><br><span class="line"><span class="comment">-- 如果没有DEFAULT子句，初始值为NULL</span></span><br><span class="line"><span class="keyword">DECLARE</span> 变量名 类型 [<span class="keyword">default</span> 值];  </span><br><span class="line"><span class="comment">-- 赋值，一般用于赋简单的值</span></span><br><span class="line"><span class="keyword">SET</span> 变量名=值;</span><br><span class="line"><span class="keyword">SET</span> 变量名:=值;</span><br><span class="line"><span class="comment">-- 一般用于赋表中的字段值</span></span><br><span class="line"><span class="keyword">SELECT</span> 字段名或表达式 <span class="keyword">INTO</span> 变量名 <span class="keyword">FROM</span> 表;</span><br><span class="line"><span class="comment">-- 使用变量</span></span><br><span class="line"><span class="keyword">SELECT</span> 局部变量名;</span><br></pre></td></tr></table></figure><h3 id="1-3-MySQL-8-0-的新特性—全局变量的持久化">1.3 MySQL 8. 0 的新特性—全局变量的持久化</h3><p>使用SET GLOBAL语句设置的变量值只会临时生效。数据库重启后，服务器又会从MySQL配置文件中读取变量的默认值。 MySQL 8.0版本新增了SET PERSIST命令。例如，设置服务器的最大连接数为 1000 ：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> PERSIST <span class="keyword">global</span> max_connections = <span class="number">1000</span> ;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%max_connections%'</span>;</span><br></pre></td></tr></table></figure><p>MySQL会将该命令的配置保存到数据目录下的mysqld-auto.cnf文件中，下次启动时会读取该文件，用其中的配置来覆盖默认的配置文件。</p><h2 id="2、定义条件与处理程序">2、定义条件与处理程序</h2><p>定义条件是事先定义程序执行过程中可能遇到的问题，处理程序定义了在遇到问题时应当采取的处理方式，并且保证存储过程或函数在遇到警告或错误时能继续执行。这样可以增强存储程序处理问题的能力，避免程序异常停止运行。说明：定义条件和处理程序在存储过程、存储函数中都是支持的。</p><h3 id="2-1-定义条件">2.1 定义条件</h3><p>定义条件就是给MySQL中的错误码命名，这有助于存储的程序代码更清晰。它将一个错误名字和指定的错误条件关联起来。这个名字可以随后被用在定义处理程序的DECLARE HANDLER语句中。定义条件使用DECLARE语句，语法格式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> 错误名称 CONDITION <span class="keyword">FOR</span> 错误码（或错误条件）</span><br></pre></td></tr></table></figure><ul><li>MySQL_error_code和sqlstate_value都可以表示MySQL的错误。<ul><li>MySQL_error_code是数值类型错误代码。</li><li>sqlstate_value是长度为 5 的字符串类型错误代码。</li></ul></li><li>例如，在ERROR 1418 (HY000)中,1418 是MySQL_error_code，’HY000’是sqlstate_value。</li><li>例如，在ERROR 1142 (42000)中,1142 是MySQL_error_code，’42000’是sqlstate_value。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 举例 定义”ERROR 1148(42000)”错误，名称为command_not_allowed</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用MySQL_error_code</span></span><br><span class="line"><span class="keyword">DECLARE</span> command_not_allowed CONDITION <span class="keyword">FOR</span> <span class="number">1148</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用sqlstate_value</span></span><br><span class="line"><span class="keyword">DECLARE</span> command_not_allowed CONDITION <span class="keyword">FOR</span> <span class="keyword">SQLSTATE</span> <span class="string">'42000'</span>;</span><br></pre></td></tr></table></figure><h3 id="2-2-定义处理程序">2.2 定义处理程序</h3><p>可以为SQL执行过程中发生的某种类型的错误定义特殊的处理程序。定义处理程序时，使用DECLARE语句的语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> 处理方式 <span class="keyword">HANDLER</span> <span class="keyword">FOR</span> 错误类型 处理语句</span><br></pre></td></tr></table></figure><ul><li><strong>处理方式</strong> ：处理方式有 3 个取值：CONTINUE、EXIT、UNDO。<ul><li>CONTINUE：表示遇到错误不处理，继续执行。</li><li>EXIT：表示遇到错误马上退出。</li><li>UNDO：表示遇到错误后撤回之前的操作。MySQL中暂时不支持这样的操作。</li></ul></li><li><strong>错误类型</strong> （即条件）可以有如下取值：<ul><li>SQLSTATE ‘字符串错误码’：表示长度为 5 的sqlstate_value类型的错误代码；</li><li>MySQL_error_code：匹配数值类型错误代码；</li><li>错误名称：表示DECLARE … CONDITION定义的错误条件名称。</li><li>SQLWARNING：匹配所有以 01 开头的SQLSTATE错误代码；</li><li>NOT FOUND：匹配所有以 02 开头的SQLSTATE错误代码；</li><li>SQLEXCEPTION：匹配所有没有被SQLWARNING或NOT FOUND捕获的SQLSTATE错误代码；</li></ul></li><li><strong>处理语句</strong> ：如果出现上述条件之一，则采用对应的处理方式，并执行指定的处理语句。语句可以是像“SET 变量 = 值”这样的简单语句，也可以是使用BEGIN … END编写的复合语句。</li></ul><p>定义处理程序的几种方式，代码如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 方法 1 ：捕获sqlstate_value</span></span><br><span class="line"><span class="keyword">DECLARE</span> CONTINUE <span class="keyword">HANDLER</span> <span class="keyword">FOR</span> <span class="keyword">SQLSTATE</span> <span class="string">'42S02'</span> <span class="keyword">SET</span> @info=<span class="string">'NO_SUCH_TABLE'</span>;</span><br><span class="line"><span class="comment">-- 方法 2 ：捕获mysql_error_value</span></span><br><span class="line"><span class="keyword">DECLARE</span> CONTINUE <span class="keyword">HANDLER</span> <span class="keyword">FOR</span> <span class="number">1146</span> <span class="keyword">SET</span> @info = <span class="string">'NO_SUCH_TABLE'</span>;</span><br><span class="line"><span class="comment">-- 方法 3 ：先定义条件，再调用</span></span><br><span class="line"><span class="keyword">DECLARE</span> no_such_table CONDITION <span class="keyword">FOR</span> <span class="number">1146</span> ;</span><br><span class="line"><span class="keyword">DECLARE</span> CONTINUE <span class="keyword">HANDLER</span> <span class="keyword">FOR</span> NO_SUCH_TABLE <span class="keyword">SET</span> @info = <span class="string">'NO_SUCH_TABLE'</span>;</span><br><span class="line"><span class="comment">-- 方法 4 ：使用SQLWARNING</span></span><br><span class="line"><span class="keyword">DECLARE</span> <span class="keyword">EXIT</span> <span class="keyword">HANDLER</span> <span class="keyword">FOR</span> SQLWARNING <span class="keyword">SET</span> @info = <span class="string">'ERROR'</span>;</span><br><span class="line"><span class="comment">-- 方法 5 ：使用NOT FOUND</span></span><br><span class="line"><span class="keyword">DECLARE</span> <span class="keyword">EXIT</span> <span class="keyword">HANDLER</span> <span class="keyword">FOR</span> <span class="keyword">NOT</span> <span class="keyword">FOUND</span> <span class="keyword">SET</span> @info = <span class="string">'NO_SUCH_TABLE'</span>;</span><br><span class="line"><span class="comment">-- 方法 6 ：使用SQLEXCEPTION</span></span><br><span class="line"><span class="keyword">DECLARE</span> <span class="keyword">EXIT</span> <span class="keyword">HANDLER</span> <span class="keyword">FOR</span> SQLEXCEPTION <span class="keyword">SET</span> @info = <span class="string">'ERROR'</span>;</span><br></pre></td></tr></table></figure><h3 id="2-3-案例解决">2.3 案例解决</h3><p>在存储过程中，定义处理程序，捕获sqlstate_value值，当遇到MySQL_error_code值为 1048 时，执行CONTINUE操作，并且将@proc_value的值设置为-1</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> InsertDataWithCondition()</span><br><span class="line">    <span class="keyword">BEGIN</span></span><br><span class="line">        <span class="keyword">DECLARE</span> duplicate_entry CONDITION <span class="keyword">FOR</span> <span class="keyword">SQLSTATE</span> <span class="string">'23000'</span> ;</span><br><span class="line">        <span class="keyword">DECLARE</span> <span class="keyword">EXIT</span> <span class="keyword">HANDLER</span> <span class="keyword">FOR</span> duplicate_entry <span class="keyword">SET</span> @proc_value = - <span class="number">1</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">SET</span> @x = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">INSERT</span> <span class="keyword">INTO</span> departments(department_name) <span class="keyword">VALUES</span>(<span class="string">'测试'</span>);</span><br><span class="line">        <span class="keyword">SET</span> @x = <span class="number">2</span> ;</span><br><span class="line">        <span class="keyword">INSERT</span> <span class="keyword">INTO</span> departments(department_name) <span class="keyword">VALUES</span>(<span class="string">'测试'</span>);</span><br><span class="line">        <span class="keyword">SET</span> @x = <span class="number">3</span> ;</span><br><span class="line">    <span class="keyword">END</span> //</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><h2 id="3、流程控制">3、流程控制</h2><p>解决复杂问题不可能通过一个 SQL 语句完成，我们需要执行多个 SQL 操作。流程控制语句的作用就是控制存储过程中 SQL 语句的执行顺序，是我们完成复杂操作必不可少的一部分。只要是执行的程序，流程就分为三大类：</p><ul><li>顺序结构：程序从上往下依次执行</li><li>分支结构：程序按条件进行选择执行，从两条或多条路径中选择一条执行</li><li>循环结构：程序满足一定条件下，重复执行一组语句</li></ul><p>针对于MySQL 的流程控制语句主要有 3 类。注意：只能用于存储程序。</p><ul><li>条件判断语句：IF 语句和 CASE 语句</li><li>循环语句：LOOP、WHILE 和 REPEAT 语句</li><li>跳转语句：ITERATE 和 LEAVE 语句</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 分支结构之 IF</span></span><br><span class="line">IF 表达式 1 THEN 操作 1</span><br><span class="line">[ELSEIF 表达式 2 THEN 操作2]......</span><br><span class="line">[ELSE 操作N]</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">IF</span></span><br><span class="line"><span class="comment">-- 分支结构之 CASE</span></span><br><span class="line"><span class="keyword">CASE</span></span><br><span class="line"><span class="keyword">WHEN</span> 条件 <span class="number">1</span> <span class="keyword">THEN</span> 结果 <span class="number">1</span> 或语句<span class="number">1</span>(如果是语句，需要加分号)</span><br><span class="line"><span class="keyword">WHEN</span> 条件 <span class="number">2</span> <span class="keyword">THEN</span> 结果 <span class="number">2</span> 或语句<span class="number">2</span>(如果是语句，需要加分号)</span><br><span class="line">...</span><br><span class="line"><span class="keyword">ELSE</span> 结果n或语句n(如果是语句，需要加分号)</span><br><span class="line"><span class="keyword">END</span> [<span class="keyword">case</span>]（如果是放在<span class="keyword">begin</span> <span class="keyword">end</span>中需要加上<span class="keyword">case</span>，如果放在<span class="keyword">select</span>后面不需要）</span><br><span class="line"><span class="comment">-- 循环结构之LOOP</span></span><br><span class="line">[loop_label:] <span class="keyword">LOOP</span></span><br><span class="line">循环执行的语句</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">LOOP</span> [loop_label]</span><br><span class="line"><span class="comment">-- 循环结构之WHILE</span></span><br><span class="line">[while_label:] <span class="keyword">WHILE</span> 循环条件 <span class="keyword">DO</span></span><br><span class="line">循环体</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">WHILE</span> [while_label];</span><br><span class="line"><span class="comment">-- 循环结构之REPEAT</span></span><br><span class="line">[repeat_label:] REPEAT</span><br><span class="line">　　　　循环体的语句</span><br><span class="line">UNTIL 结束循环的条件表达式</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">REPEAT</span> [repeat_label]</span><br><span class="line"><span class="comment">-- 跳转语句之LEAVE语句,可以把 LEAVE 理解为 break</span></span><br><span class="line">LEAVE 标记名</span><br><span class="line"><span class="comment">-- 跳转语句之ITERATE语句,可以把 ITERATE 理解为 continue</span></span><br><span class="line"><span class="keyword">ITERATE</span> label</span><br></pre></td></tr></table></figure><h2 id="4、游标">4、游标</h2><h3 id="4-1-什么是游标（或光标）">4.1 什么是游标（或光标）</h3><p>虽然我们也可以通过筛选条件 WHERE 和 HAVING，或者是限定返回记录的关键字 LIMIT 返回一条记录，但是，却无法在结果集中像指针一样，向前定位一条记录、向后定位一条记录，或者是随意定位到某一条记录，并对记录的数据进行处理。这个时候，就可以用到游标。游标，提供了一种灵活的操作方式，让我们能够对结果集中的每一条记录进行定位，并对指向的记录中的数据进行操作的数据结构。 <strong>游标让 SQL 这种面向集合的语言有了面向过程开发的能力。</strong><br>在 SQL 中，游标是一种临时的数据库对象，可以指向存储在数据库表中的数据行指针。这里游标充当了指针的作用，我们可以通过操作游标来对数据行进行操作。MySQL中游标可以在存储过程和函数中使用。</p><h3 id="4-2-游标的使用">4.2 游标的使用</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1、声明游标</span></span><br><span class="line"><span class="keyword">DECLARE</span> cursor_name <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> select_statement;</span><br><span class="line"><span class="comment">-- 这个语法适用于 MySQL，SQL Server，DB2 和 MariaDB。如果是用 Oracle 或者 PostgreSQL，需要写成</span></span><br><span class="line"><span class="keyword">DECLARE</span> cursor_name <span class="keyword">CURSOR</span> <span class="keyword">IS</span> select_statement;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 要使用 SELECT 语句来获取数据结果集，而此时还没有开始遍历数据，这里 select_statement 代表的是SELECT 语句，返回一个用于创建游标的结果集。</span></span><br><span class="line"><span class="comment">-- 举例</span></span><br><span class="line"><span class="keyword">DECLARE</span> cur_emp <span class="keyword">CURSOR</span> <span class="keyword">FOR</span></span><br><span class="line"><span class="keyword">SELECT</span> employee_id,salary <span class="keyword">FROM</span> employees;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2、打开游标的语法</span></span><br><span class="line">OPEN cursor_name</span><br><span class="line"><span class="comment">-- 当我们定义好游标之后，如果想要使用游标，必须先打开游标。</span></span><br><span class="line"><span class="comment">-- 打开游标的时候 SELECT 语句的查询结果集就会送到游标工作区，为后面游标的逐条读取结果集中的记录做准备</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3、使用游标（从游标中取得数据）</span></span><br><span class="line">FETCH cursor_name INTO var_name [, var_name] ...</span><br><span class="line"><span class="comment">-- 使用 cursor_name 这个游标来读取当前行，并且将数据保存到 var_name 这个变量中，游标指针指到下一行</span></span><br><span class="line"><span class="comment">-- 如果游标读取的数据行有多个列名，则在 INTO 关键字后面赋值给多个变量名即可</span></span><br><span class="line"><span class="comment">-- 游标的查询结果集中的字段数，必须跟 INTO 后面的变量数一致 ，否则，在存储过程执行的时候，MySQL 会提示错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 4、关闭游标</span></span><br><span class="line">CLOSE cursor_name</span><br><span class="line"><span class="comment">-- 如果不及时关闭， 游标会一直保持到存储过程结束 ，影响系统运行的效率</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 举例</span></span><br><span class="line">DELIMITER //</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> get_count_by_limit_total_salary(<span class="keyword">IN</span> limit_total_salary <span class="keyword">DOUBLE</span>,<span class="keyword">OUT</span> total_count <span class="built_in">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> sum_salary <span class="keyword">DOUBLE</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> ;  <span class="comment">-- 记录累加的总工资</span></span><br><span class="line">    <span class="keyword">DECLARE</span> cursor_salary <span class="keyword">DOUBLE</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> ; <span class="comment">-- 记录某一个工资值</span></span><br><span class="line">    <span class="keyword">DECLARE</span> emp_count <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> ; <span class="comment">-- 记录循环个数</span></span><br><span class="line">    <span class="comment">-- 定义游标</span></span><br><span class="line">    <span class="keyword">DECLARE</span> emp_cursor <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> <span class="keyword">SELECT</span> salary <span class="keyword">FROM</span> employees <span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span>;</span><br><span class="line">    <span class="comment">-- 打开游标</span></span><br><span class="line">    OPEN emp_cursor;</span><br><span class="line"></span><br><span class="line">    REPEAT</span><br><span class="line">        <span class="comment">-- 使用游标（从游标中获取数据）</span></span><br><span class="line">        FETCH emp_cursor INTO cursor_salary;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">SET</span> sum_salary = sum_salary + cursor_salary;</span><br><span class="line">        <span class="keyword">SET</span> emp_count = emp_count + <span class="number">1</span> ;</span><br><span class="line"></span><br><span class="line">        UNTIL sum_salary &gt;= limit_total_salary</span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">REPEAT</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">SET</span> total_count = emp_count;</span><br><span class="line">    <span class="comment">-- 关闭游标</span></span><br><span class="line">    CLOSE emp_cursor;</span><br><span class="line"><span class="keyword">END</span> //</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><h3 id="4-3-小结">4.3 小结</h3><p>游标是 MySQL 的一个重要的功能，为逐条读取结果集中的数据，提供了完美的解决方案。跟在应用层面实现相同的功能相比，游标可以在存储程序中使用，效率高，程序也更加简洁。但同时也会带来一些性能问题，比如在使用游标的过程中，会对数据行进行加锁，这样在业务并发量大的时候，不仅会影响业务之间的效率，还会消耗系统资源，造成内存不足，这是因为游标是在内存中进行的处理。<br>建议：养成用完之后就关闭的习惯，这样才能提高系统的整体效率。</p><h2 id="5、触发器">5、触发器</h2><h3 id="5-1-触发器概述">5.1 触发器概述</h3><p>MySQL从5.0.2版本开始支持触发器。MySQL的触发器和存储过程一样，都是嵌入到MySQL服务器的一段程序。触发器是由事件来触发某个操作，这些事件包括INSERT、UPDATE、DELETE事件。所谓事件就是指用户的动作或者触发某项行为。如果定义了触发程序，当数据库执行这些语句时候，就相当于事件发生了，就会自动激发触发器执行相应的操作。当对数据表中的数据执行插入、更新和删除操作，需要自动执行一些数据库逻辑时，可以使用触发器来实现。</p><h3 id="5-2-触发器应用场景">5.2 触发器应用场景</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建触发器的语法结构</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> 触发器名称</span><br><span class="line">&#123;<span class="keyword">BEFORE</span>|<span class="keyword">AFTER</span>&#125; &#123;<span class="keyword">INSERT</span>|<span class="keyword">UPDATE</span>|<span class="keyword">DELETE</span>&#125; <span class="keyword">ON</span> 表名</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span></span><br><span class="line">触发器执行的语句块;</span><br><span class="line"><span class="comment">-- 表名：表示触发器监控的对象。</span></span><br><span class="line"><span class="comment">-- BEFORE|AFTER：表示触发的时间。BEFORE 表示在事件之前触发；AFTER 表示在事件之后触发。</span></span><br><span class="line"><span class="comment">-- INSERT|UPDATE|DELETE：表示触发的事件。</span></span><br><span class="line"><span class="comment">-- INSERT 表示插入记录时触发；</span></span><br><span class="line"><span class="comment">-- UPDATE 表示更新记录时触发；</span></span><br><span class="line"><span class="comment">-- DELETE 表示删除记录时触发。</span></span><br><span class="line"><span class="comment">-- 触发器执行的语句块：可以是单条SQL语句，也可以是由BEGIN…END结构组成的复合语句块。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 举例1</span></span><br><span class="line"><span class="comment">-- 向test_trigger数据表插入数据之前，向test_trigger_log数据表中插入before_insert的日志信息</span></span><br><span class="line">DELIMITER //</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> before_insert</span><br><span class="line"><span class="keyword">BEFORE</span> <span class="keyword">INSERT</span> <span class="keyword">ON</span> test_trigger</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_trigger_log (t_log)</span><br><span class="line">    <span class="keyword">VALUES</span>(<span class="string">'before_insert'</span>);</span><br><span class="line"><span class="keyword">END</span> //</span><br><span class="line">DELIMITER ;</span><br><span class="line"><span class="comment">-- 举例2</span></span><br><span class="line"><span class="comment">-- 在INSERT之前检查将要添加的新员工薪资是否大于他领导的薪资，如果大于领导薪资，则报sqlstate_value为’HY000’的错误，从而使得添加失败</span></span><br><span class="line">DELIMITER //</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> salary_check_trigger</span><br><span class="line"><span class="keyword">BEFORE</span> <span class="keyword">INSERT</span> <span class="keyword">ON</span> employees <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> mgrsalary <span class="keyword">DOUBLE</span>;</span><br><span class="line">    <span class="keyword">SELECT</span> salary <span class="keyword">INTO</span> mgrsalary <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> employee_id = NEW.manager_id;</span><br><span class="line"></span><br><span class="line">    IF NEW.salary &gt; mgrsalary THEN</span><br><span class="line">    SIGNAL SQLSTATE 'HY000' <span class="keyword">SET</span> MESSAGE_TEXT = <span class="string">'薪资高于领导薪资错误'</span>;</span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"><span class="keyword">END</span> //</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看、删除触发器</span></span><br><span class="line"><span class="comment">-- 查看当前数据库的所有触发器的定义</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">TRIGGERS</span>\G</span><br><span class="line"><span class="comment">-- 查看当前数据库中某个触发器的定义</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> 触发器名</span><br><span class="line"><span class="comment">-- 从系统库information_schema的TRIGGERS表中查询“salary_check_trigger”触发器的信息</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> information_schema.TRIGGERS;</span><br><span class="line"><span class="comment">-- 触发器也是数据库对象，删除触发器也用DROP语句</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> 触发器名称;</span><br></pre></td></tr></table></figure><h3 id="5-3-触发器的优缺点">5.3 触发器的优缺点</h3><p><strong>优点：</strong></p><ul><li>触发器可以确保数据的完整性</li><li>触发器可以帮助我们记录操作日志</li><li>触发器还可以用在操作数据前，对数据进行合法性检查</li></ul><p><strong>缺点：</strong></p><ul><li>触发器最大的一个问题就是可读性差</li><li>相关数据的变更，可能会导致触发器出错</li></ul><p><strong>注意点：</strong><br>注意，如果在子表中定义了外键约束，并且外键指定了ON UPDATE/DELETE CASCADE/SET NULL子句，此时修改父表被引用的键值或删除父表被引用的记录行时，也会引起子表的修改和删除操作，此时基于子表的UPDATE和DELETE语句定义的触发器并不会被激活。</p><h1>十、MySQL8其他新特性</h1><h2 id="1、MySQL-8-0-新增特性">1、MySQL 8. 0 新增特性</h2><h3 id="1-1-MySQL-8-0-新增特性">1.1 MySQL 8. 0 新增特性</h3><ol><li><strong>更简便的NoSQL支持</strong> NoSQL泛指非关系型数据库和数据存储。随着互联网平台的规模飞速发展，传统的关系型数据库已经越来越不能满足需求。从5.6版本开始，MySQL就开始支持简单的NoSQL存储功能。MySQL 8对这一功能做了优化，以更灵活的方式实现NoSQL功能，不再依赖模式（schema）。</li><li><strong>更好的索引</strong> 在查询中，正确地使用索引可以提高查询的效率。MySQL 8中新增了隐藏索引和降序索引。隐藏索引可以用来测试去掉索引对查询性能的影响。在查询中混合存在多列索引时，使用降序索引可以提高查询的性能。</li><li><strong>更完善的JSON支持</strong> MySQL从5.7开始支持原生JSON数据的存储，MySQL 8对这一功能做了优化，增加了聚合函数JSON_ARRAYAGG()和JSON_OBJECTAGG()，将参数聚合为JSON数组或对象，新增了行内操作符 -&gt;&gt;，是列路径运算符 -&gt;的增强，对JSON排序做了提升，并优化了JSON的更新操作。</li><li><strong>安全和账户管理</strong> MySQL 8中新增了caching_sha2_password 授权插件、角色、密码历史记录和FIPS模式支持，这些特性提高了数据库的安全性和性能，使数据库管理员能够更灵活地进行账户管理工作。</li><li><strong>InnoDB的变化</strong> InnoDB是MySQL默认的存储引擎，是事务型数据库的首选引擎，支持事务安全表（ACID），支持行锁定和外键。在MySQL 8 版本中，InnoDB在自增、索引、加密、死锁、共享锁等方面做了大量的改进和优化，并且支持原子数据定义语言（DDL），提高了数据安全性，对事务提供更好的支持。</li><li><strong>数据字典</strong> 在之前的MySQL版本中，字典数据都存储在元数据文件和非事务表中。从MySQL 8开始新增了事务数据字典，在这个字典里存储着数据库对象信息，这些数据字典存储在内部事务表中。</li><li><strong>原子数据定义语句</strong> MySQL 8开始支持原子数据定义语句（Automic DDL），即原子DDL。目前，只有InnoDB存储引擎支持原子DDL。原子数据定义语句（DDL）将与DDL操作相关的数据字典更新、存储引擎操作、二进制日志写入结合到一个单独的原子事务中，这使得即使服务器崩溃，事务也会提交或回滚。使用支持原子操作的存储引擎所创建的表，在执行DROP TABLE、CREATE TABLE、ALTER TABLE、RENAME TABLE、TRUNCATE TABLE、CREATE TABLESPACE、DROP TABLESPACE等操作时，都支持原子操作，即事务要么完全操作成功，要么失败后回滚，不再进行部分提交。 对于从MySQL 5.7复制到MySQL 8版本中的语句，可以添加IF EXISTS或IF NOT EXISTS语句来避免发生错误。</li><li><strong>资源管理</strong> MySQL 8开始支持创建和管理资源组，允许将服务器内运行的线程分配给特定的分组，以便线程根据组内可用资源执行。组属性能够控制组内资源，启用或限制组内资源消耗。数据库管理员能够根据不同的工作负载适当地更改这些属性。 目前，CPU时间是可控资源，由“虚拟CPU”这个概念来表示，此术语包含CPU的核心数，超线程，硬件线程等等。服务器在启动时确定可用的虚拟CPU数量。拥有对应权限的数据库管理员可以将这些CPU与资源组关联，并为资源组分配线程。 资源组组件为MySQL中的资源组管理提供了SQL接口。资源组的属性用于定义资源组。MySQL中存在两个默认组，系统组和用户组，默认的组不能被删除，其属性也不能被更改。对于用户自定义的组，资源组创建时可初始化所有的属性，除去名字和类型，其他属性都可在创建之后进行更改。 在一些平台下，或进行了某些MySQL的配置时，资源管理的功能将受到限制，甚至不可用。例如，如果安装了线程池插件，或者使用的是macOS系统，资源管理将处于不可用状态。在FreeBSD和Solaris系统中，资源线程优先级将失效。在Linux系统中，只有配置了CAP_SYS_NICE属性，资源管理优先级才能发挥作用。</li><li><strong>字符集支持</strong> MySQL 8中默认的字符集由latin1更改为utf8mb4，并首次增加了日语所特定使用的集合，utf8mb4_ja_0900_as_cs。</li><li><strong>优化器增强</strong> MySQL优化器开始支持隐藏索引和降序索引。隐藏索引不会被优化器使用，验证索引的必要性时不需要删除索引，先将索引隐藏，如果优化器性能无影响就可以真正地删除索引。降序索引允许优化器对多个列进行排序，并且允许排序顺序不一致。</li><li><strong>公用表表达式</strong> 公用表表达式（Common Table Expressions）简称为CTE，MySQL现在支持递归和非递归两种形式的CTE。CTE通过在SELECT语句或其他特定语句前使用WITH语句对临时结果集进行命名。基础语法如下：<code>WITH cte_name (col_name1,col_name2 ...) AS (Subquery) SELECT * FROM cte_name;</code>Subquery代表子查询，子查询前使用WITH语句将结果集命名为cte_name，在后续的查询中即可使用cte_name进行查询。</li><li><strong>窗口函数</strong> MySQL 8开始支持窗口函数。在之前的版本中已存在的大部分聚合函数在MySQL 8中也可以作为窗口函数来使用。<br><img src="https://img-blog.csdnimg.cn/img_convert/31ecccd8f5f5188a676f07309078b5ea.png" alt="image.png"></li><li><strong>正则表达式支持</strong> MySQL在8.0.4以后的版本中采用支持Unicode的国际化组件库实现正则表达式操作，这种方式不仅能提供完全的Unicode支持，而且是多字节安全编码。MySQL增加了REGEXP_LIKE()、EGEXP_INSTR()、REGEXP_REPLACE()和 REGEXP_SUBSTR()等函数来提升性能。另外，regexp_stack_limit和regexp_time_limit 系统变量能够通过匹配引擎来控制资源消耗。</li><li><strong>内部临时表</strong> TempTable存储引擎取代MEMORY存储引擎成为内部临时表的默认存储引擎。TempTable存储引擎为VARCHAR和VARBINARY列提供高效存储。internal_tmp_mem_storage_engine会话变量定义了内部临时表的存储引擎，可选的值有两个，TempTable和MEMORY，其中TempTable为默认的存储引擎。temptable_max_ram系统配置项定义了TempTable存储引擎可使用的最大内存数量。</li><li><strong>日志记录</strong> 在MySQL 8中错误日志子系统由一系列MySQL组件构成。这些组件的构成由系统变量log_error_services来配置，能够实现日志事件的过滤和写入。</li><li><strong>备份锁</strong> 新的备份锁允许在线备份期间执行数据操作语句，同时阻止可能造成快照不一致的操作。新备份锁由 LOCK INSTANCE FOR BACKUP 和 UNLOCK INSTANCE 语法提供支持，执行这些操作需要备份管理员特权。</li><li><strong>增强的MySQL复制</strong> MySQL 8复制支持对JSON文档进行部分更新的二进制日志记录，该记录使用紧凑的二进制格式，从而节省记录完整JSON文档的空间。当使用基于语句的日志记录时，这种紧凑的日志记录会自动完成，并且可以通过将新的binlog_row_value_options系统变量值设置为PARTIAL_JSON来启用。</li></ol><h3 id="1-2-MySQL-8-0-移除的旧特性">1.2 MySQL 8. 0 移除的旧特性</h3><p>在MySQL 5.7版本上开发的应用程序如果使用了MySQL8.0 移除的特性，语句可能会失败，或者产生不同的执行结果。为了避免这些问题，对于使用了移除特性的应用，应当尽力修正避免使用这些特性，并尽可能使用替代方法。</p><ol><li><strong>查询缓存</strong> 查询缓存已被移除，删除的项有：<br>(1) 语句： FLUSH QUERY CACHE和RESET QUERY CACHE。<br>(2) 系统变量： query_cache_limit、query_cache_min_res_unit、query_cache_size、query_cache_type、query_cache_wlock_invalidate。<br>(3) 状态变量： Qcache_free_blocks、Qcache_free_memory、Qcache_hits、Qcache_inserts、Qcache_lowmem_prunes、Qcache_not_cached、Qcache_queries_in_cache、Qcache_total_blocks。<br>(4) 线程状态： checking privileges on cached query、checking query cache for query、invalidating query cache entries、sending cached result to client、storing result in query cache、waiting for query cache lock。</li><li><strong>加密相关</strong> 删除的加密相关的内容有：ENCODE()、DECODE()、ENCRYPT()、DES_ENCRYPT()和DES_DECRYPT()函数，配置项des-key-file，系统变量have_crypt，FLUSH语句的DES_KEY_FILE选项，HAVE_CRYPT CMake选项。 对于移除的ENCRYPT()函数，考虑使用SHA2()替代，对于其他移除的函数，使用AES_ENCRYPT()和AES_DECRYPT()替代。</li><li><strong>空间函数相关</strong> 在MySQL 5.7版本中，多个空间函数已被标记为过时。这些过时函数在MySQL 8中都已被移除，只保留了对应的ST_和MBR函数。</li><li><strong>\N和NULL</strong> 在SQL语句中，解析器不再将\N视为NULL，所以在SQL语句中应使用NULL代替\N。这项变化不会影响使用LOAD DATA INFILE或者SELECT…INTO OUTFILE操作文件的导入和导出。在这类操作中，NULL仍等同于\N。</li><li><strong>mysql_install_db</strong> 在MySQL分布中，已移除了mysql_install_db程序，数据字典初始化需要调用带着–initialize或者–initialize-insecure选项的mysqld来代替实现。另外，–bootstrap和INSTALL_SCRIPTDIR CMake也已被删除。</li><li><strong>通用分区处理程序</strong> 通用分区处理程序已从MySQL服务中被移除。为了实现给定表分区，表所使用的存储引擎需要自有的分区处理程序。 提供本地分区支持的MySQL存储引擎有两个，即InnoDB和NDB，而在MySQL 8中只支持InnoDB。</li><li><strong>系统和状态变量信息</strong> 在INFORMATION_SCHEMA数据库中，对系统和状态变量信息不再进行维护。GLOBAL_VARIABLES、SESSION_VARIABLES、GLOBAL_STATUS、SESSION_STATUS表都已被删除。另外，系统变量show_compatibility_56也已被删除。被删除的状态变量有Slave_heartbeat_period、Slave_last_heartbeat,Slave_received_heartbeats、Slave_retried_transactions、Slave_running。以上被删除的内容都可使用性能模式中对应的内容进行替代。</li><li><strong>mysql_plugin工具</strong> mysql_plugin工具用来配置MySQL服务器插件，现已被删除，可使用–plugin-load或–plugin-load-add选项在服务器启动时加载插件或者在运行时使用INSTALL PLUGIN语句加载插件来替代该工具。</li></ol><h2 id="2、新特性-1-：窗口函数">2、新特性 1 ：窗口函数</h2><h3 id="2-1-使用窗口函数前后对比">2.1 使用窗口函数前后对比</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 假设我现在有这样一个数据表，它显示了某购物网站在每个城市每个区的销售额</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> sales(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span> AUTO_INCREMENT,</span><br><span class="line">    city <span class="built_in">VARCHAR</span>( <span class="number">15</span> ),</span><br><span class="line">    county <span class="built_in">VARCHAR</span>( <span class="number">15</span> ),</span><br><span class="line">    sales_value <span class="built_in">DECIMAL</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> sales(city,county,sales_value)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">'北京'</span>,<span class="string">'海淀'</span>,<span class="number">10.00</span>),</span><br><span class="line">(<span class="string">'北京'</span>,<span class="string">'朝阳'</span>,<span class="number">20.00</span>),</span><br><span class="line">(<span class="string">'上海'</span>,<span class="string">'黄埔'</span>,<span class="number">30.00</span>),</span><br><span class="line">(<span class="string">'上海'</span>,<span class="string">'长宁'</span>,<span class="number">10.00</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--  现在计算这个网站在每个城市的销售总额、在全国的销售总额、每个区的销售额占所在城市销售额中的比率，以及占总销售额中的比率</span></span><br><span class="line"><span class="comment">-- 传统方式实现</span></span><br><span class="line"><span class="comment">-- 第一步，计算总销售金额，并存入临时表 a：</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TEMPORARY</span> <span class="keyword">TABLE</span> a <span class="comment">-- 创建临时表</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SUM</span>(sales_value) <span class="keyword">AS</span> sales_value <span class="comment">-- 计算总计金额</span></span><br><span class="line"><span class="keyword">FROM</span> sales;</span><br><span class="line"><span class="comment">-- 第二步，计算每个城市的销售总额并存入临时表 b</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TEMPORARY</span> <span class="keyword">TABLE</span> b  <span class="comment">-- 创建临时表</span></span><br><span class="line"><span class="keyword">SELECT</span> city,<span class="keyword">SUM</span>(sales_value) <span class="keyword">AS</span> sales_value  <span class="comment">-- 计算城市销售合计</span></span><br><span class="line"><span class="keyword">FROM</span> sales</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> city;</span><br><span class="line"><span class="comment">-- 第三步，计算各区的销售占所在城市的总计金额的比例，和占全部销售总计金额的比例</span></span><br><span class="line"><span class="keyword">SELECT</span> s.city <span class="keyword">AS</span> 城市,s.county <span class="keyword">AS</span> 区,s.sales_value <span class="keyword">AS</span> 区销售额,</span><br><span class="line">b.sales_value <span class="keyword">AS</span> 市销售额,s.sales_value/b.sales_value <span class="keyword">AS</span> 市比率,</span><br><span class="line">a.sales_value <span class="keyword">AS</span> 总销售额,s.sales_value/a.sales_value <span class="keyword">AS</span> 总比率</span><br><span class="line"><span class="keyword">FROM</span> sales s</span><br><span class="line"><span class="keyword">JOIN</span> b <span class="keyword">ON</span> (s.city=b.city) <span class="comment">-- 连接市统计结果临时表</span></span><br><span class="line"><span class="keyword">JOIN</span> a <span class="comment">-- 连接总计金额临时表</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> s.city,s.county;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用窗口函数</span></span><br><span class="line"><span class="keyword">SELECT</span> city <span class="keyword">AS</span> 城市,county <span class="keyword">AS</span> 区,sales_value <span class="keyword">AS</span> 区销售额,</span><br><span class="line"><span class="keyword">SUM</span>(sales_value) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> city) <span class="keyword">AS</span> 市销售额,  <span class="comment">-- 计算市销售额</span></span><br><span class="line">sales_value/<span class="keyword">SUM</span>(sales_value) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> city) <span class="keyword">AS</span> 市比率,</span><br><span class="line"><span class="keyword">SUM</span>(sales_value) <span class="keyword">OVER</span>() <span class="keyword">AS</span> 总销售额, <span class="comment">-- 计算总销售额</span></span><br><span class="line">sales_value/<span class="keyword">SUM</span>(sales_value) <span class="keyword">OVER</span>() <span class="keyword">AS</span> 总比率</span><br><span class="line"><span class="keyword">FROM</span> sales</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> city,county;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在这种需要用到分组统计的结果对每一条记录进行计算的场景下，使用窗口函数更好</span></span><br></pre></td></tr></table></figure><h3 id="2-2-窗口函数分类">2.2 窗口函数分类</h3><blockquote><p>官方文档：<a href="https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html#function_row-number" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html#function_row-number</a></p></blockquote><p>MySQL从 8. 0 版本开始支持窗口函数。窗口函数的作用类似于在查询中对数据进行分组，不同的是，分组操作会把分组的结果聚合成一条记录，而窗口函数是将结果置于每一条数据记录中。窗口函数可以分为静态窗口函数和动态窗口函数。</p><ul><li>静态窗口函数的窗口大小是固定的，不会因为记录的不同而不同；</li><li>动态窗口函数的窗口大小会随着记录的不同而变化。</li></ul><p>窗口函数总体上可以分为序号函数、分布函数、前后函数、首尾函数和其他函数，如下表：<br><img src="https://img-blog.csdnimg.cn/img_convert/febbb64915b3f6da7baa70ec51c0245c.png" alt="image.png"></p><h3 id="2-3-语法格式">2.3 语法格式</h3><ul><li>OVER 关键字指定函数窗口的范围。<ul><li>如果省略后面括号中的内容，则窗口会包含满足WHERE条件的所有记录，窗口函数会基于所有满足WHERE条件的记录进行计算。</li><li>如果OVER关键字后面的括号不为空，则可以使用如下语法设置窗口。</li></ul></li><li>窗口名：为窗口设置一个别名，用来标识窗口。</li><li>PARTITION BY子句：指定窗口函数按照哪些字段进行分组。分组后，窗口函数可以在每个分组中分别执行。</li><li>ORDER BY子句：指定窗口函数按照哪些字段进行排序。执行排序操作使窗口函数按照排序后的数据记录的顺序进行编号。</li><li>FRAME子句：为分区中的某个子集定义规则，可以用来作为滑动窗口使用</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 窗口函数的语法结构</span></span><br><span class="line">函数 OVER（[PARTITION BY 字段名 ORDER BY 字段名 ASC|DESC]）</span><br><span class="line"><span class="comment">-- 或者</span></span><br><span class="line">函数 OVER 窗口名 ... WINDOW 窗口名 AS （[PARTITION BY 字段名 ORDER BY 字段名 ASC|DESC]）</span><br></pre></td></tr></table></figure><h3 id="2-4-举例讲解">2.4 举例讲解</h3><p>首先创建表和插入数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> goods(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span> AUTO_INCREMENT,</span><br><span class="line">    category_id <span class="built_in">INT</span>,</span><br><span class="line">    <span class="keyword">category</span> <span class="built_in">VARCHAR</span>( <span class="number">15</span> ),</span><br><span class="line">    <span class="keyword">NAME</span> <span class="built_in">VARCHAR</span>( <span class="number">30</span> ),</span><br><span class="line">    price <span class="built_in">DECIMAL</span>( <span class="number">10</span> , <span class="number">2</span> ),</span><br><span class="line">    stock <span class="built_in">INT</span>,</span><br><span class="line">    upper_time DATETIME</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> goods(category_id,<span class="keyword">category</span>,<span class="keyword">NAME</span>,price,stock,upper_time)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">( <span class="number">1</span> , <span class="string">'女装/女士精品'</span>, <span class="string">'T恤'</span>, <span class="number">39.90</span>, <span class="number">1000</span> , <span class="string">'2020-11-10 00:00:00'</span>),</span><br><span class="line">( <span class="number">1</span> , <span class="string">'女装/女士精品'</span>, <span class="string">'连衣裙'</span>, <span class="number">79.90</span>, <span class="number">2500</span> , <span class="string">'2020-11-10 00:00:00'</span>),</span><br><span class="line">( <span class="number">1</span> , <span class="string">'女装/女士精品'</span>, <span class="string">'卫衣'</span>, <span class="number">89.90</span>, <span class="number">1500</span> , <span class="string">'2020-11-10 00:00:00'</span>),</span><br><span class="line">( <span class="number">1</span> , <span class="string">'女装/女士精品'</span>, <span class="string">'牛仔裤'</span>, <span class="number">89.90</span>, <span class="number">3500</span> , <span class="string">'2020-11-10 00:00:00'</span>),</span><br><span class="line">( <span class="number">1</span> , <span class="string">'女装/女士精品'</span>, <span class="string">'百褶裙'</span>, <span class="number">29.90</span>, <span class="number">500</span> , <span class="string">'2020-11-10 00:00:00'</span>),</span><br><span class="line">( <span class="number">1</span> , <span class="string">'女装/女士精品'</span>, <span class="string">'呢绒外套'</span>, <span class="number">399.90</span>, <span class="number">1200</span> , <span class="string">'2020-11-10 00:00:00'</span>),</span><br><span class="line">( <span class="number">2</span> , <span class="string">'户外运动'</span>, <span class="string">'自行车'</span>, <span class="number">399.90</span>, <span class="number">1000</span> , <span class="string">'2020-11-10 00:00:00'</span>),</span><br><span class="line">( <span class="number">2</span> , <span class="string">'户外运动'</span>, <span class="string">'山地自行车'</span>, <span class="number">1399.90</span>, <span class="number">2500</span> , <span class="string">'2020-11-10 00:00:00'</span>),</span><br><span class="line">( <span class="number">2</span> , <span class="string">'户外运动'</span>, <span class="string">'登山杖'</span>, <span class="number">59.90</span>, <span class="number">1500</span> , <span class="string">'2020-11-10 00:00:00'</span>),</span><br><span class="line">( <span class="number">2</span> , <span class="string">'户外运动'</span>, <span class="string">'骑行装备'</span>, <span class="number">399.90</span>, <span class="number">3500</span> , <span class="string">'2020-11-10 00:00:00'</span>),</span><br><span class="line">( <span class="number">2</span> , <span class="string">'户外运动'</span>, <span class="string">'运动外套'</span>, <span class="number">799.90</span>, <span class="number">500</span> , <span class="string">'2020-11-10 00:00:00'</span>),</span><br><span class="line">( <span class="number">2</span> , <span class="string">'户外运动'</span>, <span class="string">'滑板'</span>, <span class="number">499.90</span>, <span class="number">1200</span> , <span class="string">'2020-11-10 00:00:00'</span>);</span><br></pre></td></tr></table></figure><p>不同函数讲解</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- ====================序号函数==========================</span></span><br><span class="line"><span class="comment">-- ROW_NUMBER()函数</span></span><br><span class="line"><span class="comment">-- ROW_NUMBER()函数能够对数据中的序号进行顺序显示</span></span><br><span class="line"><span class="comment">-- 举例：查询 goods 数据表中每个商品分类下价格降序排列的各个商品信息</span></span><br><span class="line"><span class="keyword">SELECT</span> ROW_NUMBER() <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> category_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> price <span class="keyword">DESC</span>) <span class="keyword">AS</span> row_num,</span><br><span class="line"><span class="keyword">id</span>, category_id, <span class="keyword">category</span>, <span class="keyword">NAME</span>, price, stock</span><br><span class="line"><span class="keyword">FROM</span> goods;</span><br><span class="line"><span class="comment">-- 举例：查询 goods 数据表中每个商品分类下价格最高的 3 种商品信息</span></span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line"><span class="keyword">SELECT</span> ROW_NUMBER() <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> category_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> price <span class="keyword">DESC</span>) <span class="keyword">AS</span> row_num,</span><br><span class="line"><span class="keyword">id</span>, category_id, <span class="keyword">category</span>, <span class="keyword">NAME</span>, price, stock</span><br><span class="line"><span class="keyword">FROM</span> goods) t</span><br><span class="line"><span class="keyword">WHERE</span> row_num &lt;= <span class="number">3</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- RANK()函数</span></span><br><span class="line"><span class="comment">-- 使用RANK()函数能够对序号进行并列排序，并且会跳过重复的序号，比如序号为 1 、 1 、 3 。</span></span><br><span class="line"><span class="comment">-- 举例：使用RANK()函数获取 goods 数据表中各类别的价格从高到低排序的各商品信息。</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">RANK</span>() <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> category_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> price <span class="keyword">DESC</span>) <span class="keyword">AS</span> row_num,</span><br><span class="line"><span class="keyword">id</span>, category_id, <span class="keyword">category</span>, <span class="keyword">NAME</span>, price, stock</span><br><span class="line"><span class="keyword">FROM</span> goods;</span><br><span class="line"><span class="comment">-- 举例：使用RANK()函数获取 goods 数据表中类别为“女装/女士精品”的价格最高的 4 款商品信息</span></span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span>(</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">RANK</span>() <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> category_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> price <span class="keyword">DESC</span>) <span class="keyword">AS</span> row_num,</span><br><span class="line"><span class="keyword">id</span>, category_id, <span class="keyword">category</span>, <span class="keyword">NAME</span>, price, stock</span><br><span class="line"><span class="keyword">FROM</span> goods) t</span><br><span class="line"><span class="keyword">WHERE</span> category_id = <span class="number">1</span> <span class="keyword">AND</span> row_num &lt;= <span class="number">4</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- DENSE_RANK()函数</span></span><br><span class="line"><span class="comment">-- DENSE_RANK()函数对序号进行并列排序，并且不会跳过重复的序号，比如序号为1 、1 、2。</span></span><br><span class="line"><span class="comment">-- 举例：使用DENSE_RANK()函数获取 goods 数据表中各类别的价格从高到低排序的各商品信息。</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DENSE_RANK</span>() <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> category_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> price <span class="keyword">DESC</span>) <span class="keyword">AS</span> row_num,</span><br><span class="line"><span class="keyword">id</span>, category_id, <span class="keyword">category</span>, <span class="keyword">NAME</span>, price, stock</span><br><span class="line"><span class="keyword">FROM</span> goods;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- ============================分布函数===========================</span></span><br><span class="line"><span class="comment">-- PERCENT_RANK()函数</span></span><br><span class="line"><span class="comment">-- PERCENT_RANK()函数是等级值百分比函数。按照如下方式进行计算。其中，rank的值为使用RANK()函数产生的序号，rows的值为当前窗口的总记录数。</span></span><br><span class="line"><span class="comment">-- (rank - 1 ) / (rows - 1 )</span></span><br><span class="line"><span class="comment">-- 举例：计算 goods 数据表中名称为“女装/女士精品”的类别下的商品的PERCENT_RANK值。</span></span><br><span class="line"><span class="comment">-- 写法一：</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> category_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> price <span class="keyword">DESC</span>) <span class="keyword">AS</span> r,</span><br><span class="line"><span class="keyword">PERCENT_RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> category_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> price <span class="keyword">DESC</span>) <span class="keyword">AS</span> pr,</span><br><span class="line"><span class="keyword">id</span>, category_id, <span class="keyword">category</span>, <span class="keyword">NAME</span>, price, stock</span><br><span class="line"><span class="keyword">FROM</span> goods</span><br><span class="line"><span class="keyword">WHERE</span> category_id = <span class="number">1</span> ;</span><br><span class="line"><span class="comment">-- 写法二：</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">RANK</span>() <span class="keyword">OVER</span> w <span class="keyword">AS</span> r,</span><br><span class="line"><span class="keyword">PERCENT_RANK</span>() <span class="keyword">OVER</span> w <span class="keyword">AS</span> pr,</span><br><span class="line"><span class="keyword">id</span>, category_id, <span class="keyword">category</span>, <span class="keyword">NAME</span>, price, stock</span><br><span class="line"><span class="keyword">FROM</span> goods</span><br><span class="line"><span class="keyword">WHERE</span> category_id = <span class="number">1</span> <span class="keyword">WINDOW</span> w <span class="keyword">AS</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> category_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> price <span class="keyword">DESC</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- CUME_DIST()函数</span></span><br><span class="line"><span class="comment">-- CUME_DIST()函数主要用于查询小于或等于某个值的比例</span></span><br><span class="line"><span class="comment">-- 举例：查询goods数据表中小于或等于当前价格的比例</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CUME_DIST</span>() <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> category_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> price <span class="keyword">ASC</span>) <span class="keyword">AS</span> cd,</span><br><span class="line"><span class="keyword">id</span>, <span class="keyword">category</span>, <span class="keyword">NAME</span>, price</span><br><span class="line"><span class="keyword">FROM</span> goods;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ============================前后函数======================================</span></span><br><span class="line"><span class="comment">-- LAG(expr,n)函数</span></span><br><span class="line"><span class="comment">-- LAG(expr,n)函数返回当前行的前n行的expr的值。</span></span><br><span class="line"><span class="comment">-- 举例：查询goods数据表中前一个商品价格与当前商品价格的差值</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, <span class="keyword">category</span>, <span class="keyword">NAME</span>, price, pre_price, price - pre_price <span class="keyword">AS</span> diff_price</span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, <span class="keyword">category</span>, <span class="keyword">NAME</span>, price,LAG(price, <span class="number">1</span>) <span class="keyword">OVER</span> w <span class="keyword">AS</span> pre_price</span><br><span class="line"><span class="keyword">FROM</span> goods</span><br><span class="line"><span class="keyword">WINDOW</span> w <span class="keyword">AS</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> category_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> price)) t;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- LEAD(expr,n)函数</span></span><br><span class="line"><span class="comment">-- LEAD(expr,n)函数返回当前行的后n行的expr的值</span></span><br><span class="line"><span class="comment">-- 举例：查询goods数据表中后一个商品价格与当前商品价格的差值</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, <span class="keyword">category</span>, <span class="keyword">NAME</span>, behind_price, price,behind_price - price <span class="keyword">AS</span> diff_price</span><br><span class="line"><span class="keyword">FROM</span>(</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, <span class="keyword">category</span>, <span class="keyword">NAME</span>, price,<span class="keyword">LEAD</span>(price, <span class="number">1</span> ) <span class="keyword">OVER</span> w <span class="keyword">AS</span> behind_price</span><br><span class="line"><span class="keyword">FROM</span> goods <span class="keyword">WINDOW</span> w <span class="keyword">AS</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> category_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> price)) t;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- ==================================首尾函数==================================</span></span><br><span class="line"><span class="comment">-- FIRST_VALUE(expr)函数</span></span><br><span class="line"><span class="comment">-- FIRST_VALUE(expr)函数返回第一个expr的值</span></span><br><span class="line"><span class="comment">-- 举例：按照价格排序，查询第 1 个商品的价格信息</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, <span class="keyword">category</span>, <span class="keyword">NAME</span>, price, stock,<span class="keyword">FIRST_VALUE</span>(price) <span class="keyword">OVER</span> w <span class="keyword">AS</span> first_price</span><br><span class="line"><span class="keyword">FROM</span> goods <span class="keyword">WINDOW</span> w <span class="keyword">AS</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> category_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> price);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- LAST_VALUE(expr)函数</span></span><br><span class="line"><span class="comment">-- LAST_VALUE(expr)函数返回最后一个expr的值</span></span><br><span class="line"><span class="comment">-- 举例：按照价格排序，查询最后一个商品的价格信息</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, <span class="keyword">category</span>, <span class="keyword">NAME</span>, price, stock,<span class="keyword">LAST_VALUE</span>(price) <span class="keyword">OVER</span> w <span class="keyword">AS</span> last_price</span><br><span class="line"><span class="keyword">FROM</span> goods <span class="keyword">WINDOW</span> w <span class="keyword">AS</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> category_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> price);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">--=================================其他函数========================</span></span><br><span class="line"><span class="comment">-- NTH_VALUE(expr,n)函数</span></span><br><span class="line"><span class="comment">-- NTH_VALUE(expr,n)函数返回第n个expr的值</span></span><br><span class="line"><span class="comment">-- 举例：查询goods数据表中排名第 2 和第 3 的价格信息</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, <span class="keyword">category</span>, <span class="keyword">NAME</span>, price,<span class="keyword">NTH_VALUE</span>(price, <span class="number">2</span> ) <span class="keyword">OVER</span> w <span class="keyword">AS</span> second_price,</span><br><span class="line"><span class="keyword">NTH_VALUE</span>(price, <span class="number">3</span> ) <span class="keyword">OVER</span> w <span class="keyword">AS</span> third_price</span><br><span class="line"><span class="keyword">FROM</span> goods <span class="keyword">WINDOW</span> w <span class="keyword">AS</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> category_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> price);</span><br><span class="line"><span class="comment">-- NTILE(n)函数</span></span><br><span class="line"><span class="comment">-- NTILE(n)函数将分区中的有序数据分为n个桶，记录桶编号</span></span><br><span class="line"><span class="comment">-- 举例：将goods表中的商品按照价格分为 3 组</span></span><br><span class="line"><span class="keyword">SELECT</span> NTILE( <span class="number">3</span> ) <span class="keyword">OVER</span> w <span class="keyword">AS</span> nt,<span class="keyword">id</span>, <span class="keyword">category</span>, <span class="keyword">NAME</span>, price</span><br><span class="line"><span class="keyword">FROM</span> goods <span class="keyword">WINDOW</span> w <span class="keyword">AS</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> category_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> price);</span><br></pre></td></tr></table></figure><p>窗口函数的特点是可以分组，而且可以在分组内排序。另外，窗口函数不会因为分组而减少原表中的行数，这对我们在原表数据的基础上进行统计和排序非常有用</p><h2 id="3、新特性-2-：公用表表达式">3、新特性 2 ：公用表表达式</h2><p>公用表表达式（或通用表表达式）简称为CTE（Common Table Expressions）。CTE是一个命名的临时结果集，作用范围是当前语句。CTE可以理解成一个可以复用的子查询，当然跟子查询还是有点区别的，CTE可以引用其他CTE，但子查询不能引用其他子查询。所以，可以考虑代替子查询。依据语法结构和执行方式的不同，公用表表达式分为普通公用表表达式和递归公用表表达式 2 种</p><h3 id="3-1-普通公用表表达式">3.1 普通公用表表达式</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 普通公用表表达式的语法结构</span></span><br><span class="line"><span class="keyword">WITH</span> CTE名称</span><br><span class="line"><span class="keyword">AS</span> （子查询）</span><br><span class="line"><span class="keyword">SELECT</span>|<span class="keyword">DELETE</span>|<span class="keyword">UPDATE</span> 语句;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询员工所在的部门的详细信息</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> departments</span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="keyword">IN</span> (</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> department_id</span><br><span class="line"><span class="keyword">FROM</span> employees);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 这个查询也可以用普通公用表表达式的方式完成：</span></span><br><span class="line"><span class="keyword">WITH</span> emp_dept_id</span><br><span class="line"><span class="keyword">AS</span> (<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> department_id <span class="keyword">FROM</span> employees)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> departments d <span class="keyword">JOIN</span> emp_dept_id e</span><br><span class="line"><span class="keyword">ON</span> d.department_id = e.department_id;</span><br></pre></td></tr></table></figure><h3 id="3-2-递归公用表表达式">3.2 递归公用表表达式</h3><p>递归公用表表达式也是一种公用表表达式，只不过，除了普通公用表表达式的特点以外，它还有自己的特点，就是 <strong>可以调用自己</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WITH</span> <span class="keyword">RECURSIVE</span></span><br><span class="line">CTE名称 <span class="keyword">AS</span> （子查询）</span><br><span class="line"><span class="keyword">SELECT</span>|<span class="keyword">DELETE</span>|<span class="keyword">UPDATE</span> 语句;</span><br></pre></td></tr></table></figure><p>递归公用表表达式由 2 部分组成，分别是种子查询和递归查询，中间通过关键字 UNION [ALL]进行连接。这里的 <strong>种子查询，意思就是获得递归的初始值</strong> 。这个查询只会运行一次，以创建初始数据集，之后递归查询会一直执行，直到没有任何新的查询数据产生，递归返回。<br><strong>案例：</strong> 针对于我们常用的employees表，包含employee_id，last_name和manager_id三个字段。如果a是b的管理者，那么，我们可以把b叫做a的下属，如果同时b又是c的管理者，那么c就是b的下属，是a的下下属。<br>下面我们尝试用查询语句列出所有具有下下属身份的人员信息。如果用我们之前学过的知识来解决，会比较复杂，至少要进行 4 次查询才能搞定：</p><ul><li>第一步，先找出初代管理者，就是不以任何别人为管理者的人，把结果存入临时表；</li><li>第二步，找出所有以初代管理者为管理者的人，得到一个下属集，把结果存入临时表；</li><li>第三步，找出所有以下属为管理者的人，得到一个下下属集，把结果存入临时表。</li><li>第四步，找出所有以下下属为管理者的人，得到一个结果集。</li></ul><p>如果第四步的结果集为空，则计算结束，第三步的结果集就是我们需要的下下属集了，否则就必须继续进行第四步，一直到结果集为空为止。比如上面的这个数据表，就需要到第五步，才能得到空结果集。而且，最后还要进行第六步：把第三步和第四步的结果集合并，这样才能最终获得我们需要的结果集。<br>如果用递归公用表表达式，就非常简单了。我介绍下具体的思路。</p><ul><li>用递归公用表表达式中的种子查询，找出初代管理者。字段 n 表示代次，初始值为 1 ，表示是第一代管理者。</li><li>用递归公用表表达式中的递归查询，查出以这个递归公用表表达式中的人为管理者的人，并且代次的值加 1 。直到没有人以这个递归公用表表达式中的人为管理者了，递归返回。</li><li>在最后的查询中，选出所有代次大于等于 3 的人，他们肯定是第三代及以上代次的下属了，也就是下下属了。这样就得到了我们需要的结果集。</li></ul><p>这里看似也是 3 步，实际上是一个查询的 3 个部分，只需要执行一次就可以了。而且也不需要用临时表保存中间结果，比刚刚的方法简单多了。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WITH</span> <span class="keyword">RECURSIVE</span> cte</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,manager_id, <span class="number">1</span> <span class="keyword">AS</span> n <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> employee_id = <span class="number">100</span> <span class="comment">-- 种子查询，找到第一代领导</span></span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> a.employee_id,a.last_name,a.manager_id,n+ <span class="number">1</span> <span class="keyword">FROM</span> employees <span class="keyword">AS</span> a <span class="keyword">JOIN</span> cte</span><br><span class="line"><span class="keyword">ON</span> (a.manager_id = cte.employee_id) <span class="comment">-- 递归查询，找出以递归公用表表达式的人为领导的人)</span></span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name <span class="keyword">FROM</span> cte <span class="keyword">WHERE</span> n &gt;= <span class="number">3</span> ;</span><br></pre></td></tr></table></figure><p>总之，递归公用表表达式对于查询一个有共同的根节点的树形结构数据，非常有用。它可以不受层级的限制，轻松查出所有节点的数据。如果用其他的查询方式，就比较复杂了。<br>公用表表达式的作用是可以替代子查询，而且可以被多次引用。递归公用表表达式对查询有一个共同根节点的树形结构数据非常高效，可以轻松搞定其他查询方式难以处理的查询。</p><h1>十一、数据库的设计规范</h1><h2 id="1、概述">1、概述</h2><h3 id="1-1-问题描述">1.1 问题描述</h3><ul><li>用户都需要什么数据?需要在数据表中保存哪些数据?</li><li>如何保证数据表中数据的正确性，当插入、删除、更新的时候该进行怎样的约束检查?。如何降低数据表的数据冗余度，保证数据表不会因为用户量的增长而迅速扩张?</li><li>如何让负责数据库维护的人员更方便地使用数据库?</li><li>使用数据库的应用场景也各不相同，可以说针对不同的情况，设计出来的数据表可能千差万别</li></ul><h3 id="1-2-好的数据库设计原则">1.2 好的数据库设计原则</h3><ul><li>节省数据的存储空间</li><li>能够保证数据的完整性</li><li>方便进行数据库应用系统的开发</li></ul><p>总之，开始设置数据库的时候，我们就需要重视数据表的设计。为了建立冗余较小、结构合理的数据库，设计数据库时必须遵循一定的规则。</p><h2 id="2、范式">2、范式</h2><h3 id="2-1-范式简介">2.1 范式简介</h3><p>在关系型数据库中，关于数据表设计的基本原则、规则就称为范式。可以理解为，一张数据表的设计结 构需要满足的某种设计标准的 级别 。要想设计一个结构合理的关系型数据库，必须满足一定的范式。<br>目前关系型数据库有六种常见范式，按照范式级别，从低到高分别是：<strong>第一范式（1NF）、第二范式 （2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）</strong>。数据库的范式设计越高阶，夯余度就越低，同时高阶的范式一定符合低阶范式的要求，满足最低要求的范式是第一范式（1NF）。在第一范式的基础上进一步满足更多规范的要求称为第二范式（2NF），其余范式以此类推。<br>一般来说，<strong>在关系型数据库设计中，最高也就遵循到BCNF, 普遍还是3NF</strong>。但也不绝对，有时候为了提高某些查询性能，我们还需要破坏范式规则，也就是<strong>反规范化</strong></p><h3 id="2-2-键和相关属性的概念">2.2 键和相关属性的概念</h3><p>范式的定义会使用到主键和候选键，数据库中的键（Key)由一个或者多个属性组成。数据表中常用的几种键和属性的定义:</p><ul><li><strong>超键</strong>：能唯—标识元组的属性集叫做超键。</li><li><strong>候选键</strong>：如果超键不包括多余的属性，那么这个超键就是候选键</li><li><strong>主键</strong>：用户可以从候选键中选择一个作为主键。</li><li><strong>外键</strong>︰如果数据表R1中的某属性集不是R1的主键，而是另一个数据表R2的主键，那么这个属性集就是数据表R1的外键。</li><li><strong>主属性</strong>：包含在任一候选键中的属性称为主属性</li><li><strong>非主属性</strong>：与主属性相对，指的是不包含在任何一个候选键中的属性。</li></ul><p>通常，我们也将候选键称之为“<strong>码</strong>”，把主键也称为“<strong>主码</strong>”。因为键可能是由多个属性组成的，针对单个属性，我们还可以用主属性和非主属性来进行区分。<br><strong>举例</strong><br><code>球员表(player)</code> ：球员编号 | 姓名 | 身份证号 | 年龄 | 球队编号<br><code>球队表(team)</code>：球队编号 | 主教练 | 球队所在地</p><ul><li>超键 ：对于球员表来说，超键就是包括球员编号或者身份证号的任意组合，比如（球员编号） （球员编号，姓名）（身份证号，年龄）等。</li><li>候选键 ：就是最小的超键，对于球员表来说，候选键就是（球员编号）或者（身份证号）。</li><li>主键 ：我们自己选定，也就是从候选键中选择一个，比如（球员编号）。</li><li>外键 ：球员表中的球队编号。</li><li>主属性 、 非主属性 ：在球员表中，主属性是（球员编号）（身份证号），其他的属性（姓名） （年龄）（球队编号）都是非主属性。</li></ul><h3 id="2-3-第一范式-1st-NF">2.3 第一范式(1st NF)</h3><p>第一范式主要确保数据库中每个字段的值必须具有<strong>原子性</strong>，也就是说数据表中每个字段的值为<strong>不可再次拆分</strong>的最小数据单元。我们在设计某个字段的时候，对于字段X来说，不能把字段X拆分成字段X-1和字段X-2。事实上，任何的DBMS都会满足第一范式的要求，不会将字段进行拆分。</p><h3 id="2-4-第二范式-2nd-NF">2.4 第二范式(2nd NF)</h3><p>第二范式要求，在满足第一范式的基础上，还要<strong>满足数据库里的每一条数据记录，都是可唯一标识的。而且所有非主键字段，都必须完全依赖主键，不能只依赖主键的一部分</strong>。如果知道主键的所有属性的值，就可以检索到任何元组（行）的任何属性的任何值。（要求中的主键，其实可以扩展替换为候选键）</p><blockquote><p>第二范式（2NF）要求实体的属性完全依赖主关键字。如果存在不完全依赖，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与元实体之间是一对多的关系</p></blockquote><h3 id="2-5-第三范式-3rd-NF">2.5 第三范式(3rd NF)</h3><p>第三范式是在第二范式的基础上，确保数据表中的每一个非主键字段都和主键字段直接相关，也就是说，<strong>要求数据表中的所有非主键字段不能依赖于其他非主键字段</strong>。（即，不能存在非主属性A依赖于非主属性B，非主属性B依赖于主键C的情况，即存在“A-&gt;B-&gt;C&quot;的决定关系）通俗地讲，该规则的意思是所有非主键属性之间不能由依赖关系，必须相互独立。<br>这里的主键可以扩展为候选键。</p><h3 id="2-6-小结">2.6 小结</h3><p>关于数据表的设计，有三个范式要遵循。</p><ul><li>第一范式（1NF)，确保每列保持<code>原子性</code>。数据库的每一列都是不可分割的原子数据项，不可再分的最小数据单元，而不能是集合、数组、记录等非原子数据项。</li><li>第二范式(2NF)，确保每列都和主键<code>完全依赖</code>。尤其在复合主键的情况下，非主键部分不应该依赖于部分主键。</li><li>第三范式(3NF）确保每列都和主键列<code>直接相关</code>，而不是间接相关</li></ul><p><strong>范式的优点</strong>：数据的标准化有助于消除数据库中的<code>数据冗余</code>，第三范式(3NF）通常被认为在性能、扩展性和数据完整性方面达到了最好的平衡。<br><strong>范式的缺点</strong>：范式的使用，可能<code>降低查询的效率</code>。因为范式等级越高，设计出来的数据表就越多、越精细，数据的冗余度就越低，进行数据查询的时候就可能需要<code>关联多张表</code>，这不但代价昂贵，也可能使一些<code>索引策略无效</code>。<br>范式只是提出了设计的标准，实际上设计数据表时，未必一定要符合这些标准。开发中，我们会出现为了性能和读取效率违反范式化的原则，通过<strong>增加少量的冗余</strong>或重复的数据来提高数据库的<strong>读性能</strong>，减少关联查询，join 表的次数，实现<strong>空间换取时间</strong>的目的。因此在实际的设计过程中要理论结合实际，灵活运用。</p><h2 id="3、反范式化">3、反范式化</h2><h3 id="3-1-概述">3.1 概述</h3><p>有的时候不能简单按照规范要求设计数据表，因为有的数据看似冗余，其实对业务来说十分重要。这个时候，我们就要遵循<strong>业务优先</strong>的原则，首先满足业务需求，再尽量减少冗余。<br>如果数据库中的数据量比较大，系统的UV和PV访问频次比较高，则完全按照MysQL的三大范式设计数据表，读数据时会产生大量的关联查询，在一定程度上会影响数据库的读性能。如果我们想对查询效率进行优化，<strong>反范式优化</strong>也是一种优化思路。此时，可以通过在数据表中增<strong>加冗余字段</strong>来提高数据库的读性能。<br><strong>规范化 vs 性能</strong></p><ul><li>为满足某种商业目标 , 数据库性能比规范化数据库更重要</li><li>在数据规范化的同时 , 要综合考虑数据库的性能</li><li>通过在给定的表中添加额外的字段，以大量减少需要从中搜索信息所需的时间</li><li>通过在给定的表中插入计算列，以方便查询</li></ul><h3 id="3-2-反范式的新问题">3.2 反范式的新问题</h3><ul><li>存储 空间变大了</li><li>一个表中字段做了修改，另一个表中冗余的字段也需要做同步修改，否则 数据不一致</li><li>若采用存储过程来支持数据的更新、删除等额外操作，如果更新频繁，会非常 消耗系统资源</li><li>在 数据量小 的情况下，反范式不能体现性能的优势，可能还会让数据库的设计更加复杂</li></ul><h3 id="3-3-反范式的适用场景">3.3 反范式的适用场景</h3><p>当冗余信息有价值或者能 大幅度提高查询效率 的时候，我们才会采取反范式的优化</p><ul><li>增加冗余字段一定要符合如下两个条件。只要满足这两个条件，才可以考虑增加夯余字段。<ul><li>这个冗余字段不需要经常进行修改</li><li>这个冗余字段查询的时候不可或缺</li></ul></li></ul><p>在现实生活中，我们经常需要一些冗余信息，比如订单中的收货人信息，包括姓名、电话和地址等。每 次发生的 <code>订单收货信息</code> 都属于 <code>历史快照</code> ，需要进行保存，但用户可以随时修改自己的信息，这时保存这 些冗余信息是非常有必要的。反范式优化也常用在 <code>数据仓库</code> 的设计中，因为数据仓库通常<code>存储历史数据</code> ，对增删改的实时性要求不 强，对历史数据的分析需求强。这时适当允许数据的冗余度，更方便进行数据分析。简单总结下数据仓库和数据库在使用上的区别：</p><ul><li>数据库设计的目的在于<code>捕捉数据</code>，而数据仓库设计的目的在于<code>分析数据</code></li><li>数据库对数据的<code>增删改实时性</code>要求强，需要存储在线的用户数据，而数据仓库存储的一般是<code>历史数据</code></li><li>数据库设计需要<code>尽量避免冗余</code>，但为了提高查询效率也允许一定的<code>冗余度</code>，而数据仓库在设计上更偏向采用反范式设计</li></ul><h2 id="4-BCNF-巴斯范式">4. BCNF(巴斯范式)</h2><p>人们在3NF的基础上进行了改进，提出了巴斯范式（BCNF），页脚巴斯 - 科德范式（Boyce - Codd Normal Form）。BCNF被认为没有新的设计规范加入，只是对第三范式中设计规范要求更强，使得数据库冗余度更小。所以，称为是修正的第三范式，或扩充的第三范式，BCNF不被称为第四范式。<br>若一个关系达到了第三范式，并且它只有一个候选键，或者它的每个候选键都是单属性，则该关系自然达到BC范式。一般来说，一个数据库设符合3NF或者BCNF就可以了。</p><h2 id="5、其他范式">5、其他范式</h2><h3 id="5-1-第四范式">5.1 第四范式</h3><p>多值依赖的概念：</p><ul><li><code>多值依赖</code>即属性之间的一对多关系，记为K—&gt;—&gt;A。</li><li><code>函数依赖</code>事实上是单值依赖，所以不能表达属性值之间的一对多关系。</li><li><code>平凡的多值依赖</code>：全集U=K+A，一个K可以对应于多个A，即K—&gt;—&gt;A。此时整个表就是一组一对多关系。</li><li><code>非平凡的多值依赖</code>：全集U=K+A+B，一个K可以对应于多个A，也可以对应于多个B，A与B相互独立，即K—&gt;—&gt;A，K—&gt;—&gt;B。整个表有多组一对多关系，且有：&quot;一&quot;部分是相同的属性集合，“多”部分是相互独立的属性集合。</li></ul><p>第四范式即在满足巴斯 - 科德范式（BCNF）的基础上，消除非平凡且非函数依赖的多值依赖（即把同一表的多对多关系删除）</p><h3 id="5-2-第五范式、域键范式">5.2 第五范式、域键范式</h3><p>除了第四范式外，我们还有更高级的第五范式（又称完美范式）和域键范式（DKNF）。在满足第四范式（4NF）的基础上，消除不是由候选键所蕴含的连接依赖。<strong>如果关系模式R中的每一个连 接依赖均由R的候选键所隐含</strong>，则称此关系模式符合第五范式。<br>函数依赖是多值依赖的一种特殊的情况，而多值依赖实际上是连接依赖的一种特殊情况。但连接依赖不 像函数依赖和多值依赖可以由 语义直接导出 ，而是在 关系连接运算 时才反映出来。存在连接依赖的关系 模式仍可能遇到数据冗余及插入、修改、删除异常等问题。第五范式处理的是 无损连接问题 ，这个范式基本 没有实际意义 ，因为无损连接很少出现，而且难以察觉。而域键范式试图定义一个 终极范式 ，该范式考虑所有的依赖和约束类型，但是实用价值也是最小的，只存在理论研究中。</p><h2 id="6、实战案例">6、实战案例</h2><blockquote><p>在实际工作场景中，这种由于数据表结构设计不合理，而导致的数据重复的现象并不少见。往往是系统虽然能够运行，承载能力却很差，稍微有点流量，就会出现内存不足、CPU使用率飙升的情况，甚至会导致整个项目失败</p></blockquote><p><img src="https://img-blog.csdnimg.cn/img_convert/b295b3fbba5a99de8140ad7306c2d304.png" alt="image-20220707134636225.png"><br>这个表中的字段很多，表里的数据量也很惊人。大量重复导致表变得庞大，效率极低。如何改?</p><h3 id="6-1-迭代1次：考虑1NF">6.1 迭代1次：考虑1NF</h3><p>第一范式要求：<strong>所有的字段都是基本数据类型，不可进行拆分</strong>。这里需要确认，所有的列中，每个字段只包含一种数据。这张表里，我们把“property&quot;这一字段，拆分成”specification (规格)&quot; 和 “unit (单位)”</p><h3 id="6-2-迭代2次：考虑2NF">6.2 迭代2次：考虑2NF</h3><p>第二范式要求，在满足第一范式的基础上，<strong>还要满足数据表里的每一条数据记录，都是可唯一标识的。而且所有字段，都必须完全依赖主键，不能只依赖主键的一部分</strong><br>第1步，就是要确定这个表的主键。通过观察发现，字段“listnumber（单号）&quot;+“barcode（条码）“可以唯一标识每一条记录，可以作为主键。第2步，确定好了主键以后，判断哪些字段完全依赖主键，哪些字段只依赖于主键的一部分。把只依赖于主键一部分的字段拆出去，形成新的数据表。此外，字段&quot;supplierid(供应商编号)”“suppliername(供应商名称)”“stock(仓库)“只依赖于&quot;listnumber(单号)”，不完全依赖于主键，所以，我们可以把&quot;supplierid”“suppliername”“stock&quot;这3个字段拆出去，再加上它们依赖的字段&quot;listnumber(单号)”，就形成了一个新的表&quot;进货单头表&quot;。剩下的字段，会组成新的表，我们叫它&quot;进货单明细表&quot;<br><strong>进货单头表</strong><br><img src="https://img-blog.csdnimg.cn/img_convert/6df13399892021e4356cbeb90bde5bf4.png" alt="image-20220707164128704.png"><br><strong>进货单明细表</strong><br><img src="https://img-blog.csdnimg.cn/img_convert/0ad2ed0fe81a00466c9dc6be5d9014b6.png" alt="image-20220707164146216.png"><br><strong>商品信息表</strong><br><img src="https://img-blog.csdnimg.cn/img_convert/a7ee60fe4a914663364860fe5a666bf7.png" alt="image-20220707164227845.png"></p><h3 id="6-3-迭代3次：考虑3NF">6.3 迭代3次：考虑3NF</h3><p>我们的进货单头表，还有数据冗余的可能。因为&quot;suppliername&quot;依赖&quot;supplierid&quot;，那么就可以按照第三范式的原则进行拆分了。我们就进一步拆分进货单头表，把它拆解成供货商表和进货单头表<br><img src="https://img-blog.csdnimg.cn/img_convert/c46386971764c730cbde6c83f5e6ef00.png" alt="image-20220707165011050.png"></p><h3 id="6-4-反范式化：业务优先的原则">6.4 反范式化：业务优先的原则</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/04f7676f8410b838f2836a88ff0d6d3d.png" alt="image-20220707165459547.png"><br>因此，最后我们可以把进货单表拆分成下面的4个表<br>供货商表：<br><img src="https://img-blog.csdnimg.cn/img_convert/bacbd89c7e752a5fa6f259e987585359.png" alt="image-20220707165011050.png"><br>进货单头表：<br><img src="https://img-blog.csdnimg.cn/img_convert/6205a9942a6b48fee3aa3250726be0f7.png" alt="image-20220707165038108.png"><br>进货单明细表：<br><img src="https://img-blog.csdnimg.cn/img_convert/8d11617dc90baae0e966042bd3262b16.png" alt="image-20220707164146216.png"><br>商品信息表：<br><img src="https://img-blog.csdnimg.cn/img_convert/f15e6d0f01d9a92098f0fd4b3a80f6bb.png" alt="image-20220707164227845.png"></p><h2 id="7、ER模型">7、ER模型</h2><blockquote><p>在开发基于数据库的信息系统的设计阶段，通常使用ER模型来描述信息需求和信息特性，帮助我们理清业务逻辑，从而设计出优秀的数据库。</p></blockquote><h3 id="7-1-ER模型包括哪些要素？">7.1 ER模型包括哪些要素？</h3><p><strong>ER 模型中有三个要素，分别是实体、属性和关系。</strong><br>实体 ，可以看做是数据对象，往往对应于现实生活中的真实存在的个体。在 ER 模型中，用 矩形 来表 示。实体分为两类，分别是 强实体 和 弱实体 。强实体是指不依赖于其他实体的实体；弱实体是指对另 一个实体有很强的依赖关系的实体。<br>属性 ，则是指实体的特性。比如超市的地址、联系电话、员工数等。在 ER 模型中用 椭圆形 来表示。<br>关系 ，则是指实体之间的联系。比如超市把商品卖给顾客，就是一种超市与顾客之间的联系。在 ER 模 型中用 菱形 来表示。<br>注意：实体和属性不容易区分。这里提供一个原则：我们要从系统整体的角度出发去看，<strong>可以独立存在的是实体，不可再分的是属性</strong>。也就是说，属性不能包含其他属性。</p><h3 id="7-2-关系的类型">7.2 关系的类型</h3><p>在 ER 模型的 3 个要素中，关系又可以分为 3 种类型，分别是 一对一、一对多、多对多。<br>一对一 ：指实体之间的关系是一一对应的，比如个人与身份证信息之间的关系就是一对一的关系。一个人只能有一个身份证信息，一个身份证信息也只属于一个人。<br>一对多 ：指一边的实体通过关系，可以对应多个另外一边的实体。相反，另外一边的实体通过这个关系，则只能对应唯一的一边的实体。比如说，我们新建一个班级表，而每个班级都有多个学生，每个学 生则对应一个班级，班级对学生就是一对多的关系。<br>多对多 ：指关系两边的实体都可以通过关系对应多个对方的实体。比如在进货模块中，供货商与超市之 间的关系就是多对多的关系，一个供货商可以给多个超市供货，一个超市也可以从多个供货商那里采购 商品。再比如一个选课表，有许多科目，每个科目有很多学生选，而每个学生又可以选择多个科目，这 就是多对多的关系</p><h3 id="7-3-ER模型举例与转化">7.3 ER模型举例与转化</h3><p>通过绘制 ER 模型，我们已经理清了业务逻辑，转换的原则：</p><ul><li>一个 实体 通常转换成一个 数据表 ；</li><li>一个 多对多的关系 ，通常也转换成一个 数据表 ；</li><li>一个 1 对 1 ，或者 1 对多 的关系，往往通过表的 外键 来表达，而不是设计一个新的数据表；</li><li>属性 转换成表的 字段</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/4b73e485aa75a42bb22f0c7526e94cc7.png" alt="image-20220707171022246.png"></p><h3 id="7-4-总结">7.4 总结</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/84af8a87a2e3f490c37c678002118df4.png" alt="image-20220707172918017.png"></p><h2 id="8、设计原则与建议">8、设计原则与建议</h2><h3 id="8-1-数据表的设计原则">8.1 数据表的设计原则</h3><blockquote><p>综合以上内容，总结出数据表设计的一般原则：“三少一多”</p></blockquote><ul><li><strong>数据表的个数越少越好</strong></li></ul><p>RDBMS的核心在于对实体和联系的定义，也就是E-R图（Entity Relationship Diagram)，数据表越少，证明实体和联系设计得越简洁，既方便理解又方便操作</p><ul><li><strong>数据表中的字段个数越少越好</strong></li></ul><p>字段个数越多，数据冗余的可能性越大。设置字段个数少的前提是各个字段相互独立，而不是某个字段的取值可以由其他字段计算出来。当然字段个数少是相对的，我们通常会在数据冗余和检索效率中进行平衡。</p><ul><li><strong>数据表中联合主键的字段个数越少越好</strong></li></ul><p>设置主键是为了确定唯一性，当一个字段无法确定唯一性的时候，就需要采用联合主键的方式(也就是用多个字段来定义一个主键)。联合主键中的字段越多，占用的索引空间越大，不仅会加大理解难度，还会增加运行时间和索引空间，因此联合主键的字段个数越少越好。</p><ul><li><strong>使用主键和外键越多越好</strong></li></ul><p>数据库的设计实际上就是定义各种表，以及各种字段之间的关系。这些关系越多，证明这些实体之间的冗余度越低，利用度越高。这样做的好处在于不仅保证了数据表之间的独立性，还能提升相互之间的关联使用率。</p><h3 id="8-2-数据库对象编写建议">8.2 数据库对象编写建议</h3><p><strong>1、关于库</strong></p><ol><li>【强制】库的名称必须控制在32个字符以内，只能使用英文字母、数字和下划线，建议以英文字 母开头。</li><li>【强制】库名中英文 一律小写 ，不同单词采用 下划线 分割。须见名知意。</li><li>【强制】库的名称格式：业务系统名称_子系统名。</li><li>【强制】库名禁止使用关键字（如type,order等）。</li><li>【强制】创建数据库时必须 显式指定字符集 ，并且字符集只能是utf8或者utf8mb4。 创建数据库SQL举例：CREATE DATABASE crm_fund DEFAULT CHARACTER SET ‘utf8’ ;</li><li>【建议】对于程序连接数据库账号，遵循 权限最小原则 使用数据库账号只能在一个DB下使用，不准跨库。程序使用的账号 原则上不准有drop权限 。</li><li>【建议】临时库以 tmp_ 为前缀，并以日期为后缀； 备份库以 bak_ 为前缀，并以日期为后缀</li></ol><p><strong>2、关于表、列</strong></p><ol><li>【强制】表和列的名称必须控制在32个字符以内，表名只能使用英文字母、数字和下划线，建议 以 英文字母开头 。</li><li>【强制】 表名、列名一律小写 ，不同单词采用下划线分割。须见名知意。</li><li>【强制】表名要求有模块名强相关，同一模块的表名尽量使用 统一前缀 。比如：crm_fund_item</li><li>【强制】创建表时必须 显式指定字符集 为utf8或utf8mb4。</li><li>【强制】表名、列名禁止使用关键字（如type,order等）。</li><li>【强制】创建表时必须 显式指定表存储引擎 类型。如无特殊需求，一律为InnoDB。</li><li>【强制】建表必须有comment。</li><li>【强制】字段命名应尽可能使用表达实际含义的英文单词或 缩写 。如：公司 ID，不要使用 corporation_id, 而用corp_id 即可。</li><li>【强制】布尔值类型的字段命名为 is_描述 。如member表上表示是否为enabled的会员的字段命 名为 is_enabled。</li><li>【强制】禁止在数据库中存储图片、文件等大的二进制数据 通常文件很大，短时间内造成数据量快速增长，数据库进行数据库读取时，通常会进行大量的随 机IO操作，文件很大时，IO操作很耗时。通常存储于文件服务器，数据库只存储文件地址信息。</li><li>【建议】建表时关于主键： 表必须有主键<br>(1)强制要求主键为id，类型为int或bigint，且为 auto_increment 建议使用unsigned无符号型。<br>(2)标识表里每一行主体的字段不要设为主键，建议 设为其他字段如user_id，order_id等，并建立unique key索引。因为如果设为主键且主键值为随机 插入，则会导致innodb内部页分裂和大量随机I/O，性能下降。</li><li>【建议】核心表（如用户表）必须有行数据的 创建时间字段 （create_time）和 最后更新时间字段 （update_time），便于查问题。</li><li>【建议】表中所有字段尽量都是 NOT NULL 属性，业务可以根据需要定义 DEFAULT值 。 因为使用 NULL值会存在每一行都会占用额外存储空间、数据迁移容易出错、聚合函数计算结果偏差等问 题。</li><li>【建议】所有存储相同数据的 列名和列类型必须一致 （一般作为关联列，如果查询时关联列类型 不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低）。</li><li>【建议】中间表（或临时表）用于保留中间结果集，名称以 tmp_ 开头。 备份表用于备份或抓取源表快照，名称以 bak_ 开头。中间表和备份表定期清理。 1</li><li>【示范】一个较为规范的建表语句</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> user_info (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">int</span> <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'自增主键'</span>,</span><br><span class="line"><span class="string">`user_id`</span> <span class="built_in">bigint</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户id'</span>,</span><br><span class="line"><span class="string">`username`</span> <span class="built_in">varchar</span>(<span class="number">45</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'真实姓名'</span>,</span><br><span class="line"><span class="string">`email`</span> <span class="built_in">varchar</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户邮箱'</span>,</span><br><span class="line"><span class="string">`nickname`</span> <span class="built_in">varchar</span>(<span class="number">45</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'昵称'</span>,</span><br><span class="line"><span class="string">`birthday`</span> <span class="built_in">date</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'生日'</span>,</span><br><span class="line"><span class="string">`sex`</span> <span class="built_in">tinyint</span>(<span class="number">4</span>) <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'性别'</span>,</span><br><span class="line"><span class="string">`short_introduce`</span> <span class="built_in">varchar</span>(<span class="number">150</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'一句话介绍自己，最多50个汉字'</span>,</span><br><span class="line"><span class="string">`user_resume`</span> <span class="built_in">varchar</span>(<span class="number">300</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户提交的简历存放地址'</span>,</span><br><span class="line"><span class="string">`user_register_ip`</span> <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户注册时的源ip'</span>,</span><br><span class="line"><span class="string">`create_time`</span> <span class="built_in">timestamp</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'创建时间'</span>,</span><br><span class="line"><span class="string">`update_time`</span> <span class="built_in">timestamp</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span></span><br><span class="line"><span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'修改时间'</span>,</span><br><span class="line"><span class="string">`user_review_status`</span> <span class="built_in">tinyint</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户资料审核状态，1为通过，2为审核中，3为未</span></span><br><span class="line"><span class="string">通过，4为还未提交审核'</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line"><span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`uniq_user_id`</span> (<span class="string">`user_id`</span>),</span><br><span class="line"><span class="keyword">KEY</span> <span class="string">`idx_username`</span>(<span class="string">`username`</span>),</span><br><span class="line"><span class="keyword">KEY</span> <span class="string">`idx_create_time_status`</span>(<span class="string">`create_time`</span>,<span class="string">`user_review_status`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'网站用户基本信息</span></span><br></pre></td></tr></table></figure><ol start="17"><li>【建议】创建表时，可以使用可视化工具。这样可以确保表、字段相关的约定都能设置上。实际上，我们通常很少自己写 DDL 语句，可以使用一些可视化工具来创建和操作数据库和数据表。可视化工具除了方便，还能直接帮我们将数据库的结构定义转化成 SQL 语言，方便数据库和数据表结构的导出和导入。</li></ol><p><strong>3、关于索引</strong></p><ol><li>【强制】InnoDB表必须主键为id int/bigint auto_increment，且主键值 禁止被更新 。</li><li>【强制】InnoDB和MyISAM存储引擎表，索引类型必须为 BTREE 。</li><li>【建议】主键的名称以 pk_ 开头，唯一键以 uni_ 或 uk_ 开头，普通索引以 idx_ 开头，一律使用小写格式，以字段的名称或缩写作为后缀。</li><li>【建议】多单词组成的columnname，取前几个单词首字母，加末单词组成column_name。如: sample 表 member_id 上的索引：idx_sample_mid。</li><li>【建议】单个表上的索引个数 不能超过6个 。</li><li>【建议】在建立索引时，多考虑建立 联合索引 ，并把区分度最高的字段放在最前面。</li><li>【建议】在多表 JOIN 的SQL里，保证被驱动表的连接列上有索引，这样JOIN 执行效率最高。</li><li>【建议】建表或加索引时，保证表里互相不存在 冗余索引 。 比如：如果表里已经存在key(a,b)， 则key(a)为冗余索引，需要删除。</li></ol><p><strong>4、SQL编写</strong></p><ol><li>【强制】程序端SELECT语句必须指定具体字段名称，禁止写成 *。</li><li>【建议】程序端insert语句指定具体字段名称，不要写成INSERT INTO t1 VALUES(…)。</li><li>【建议】除静态表或小表（100行以内），DML语句必须有WHERE条件，且使用索引查找。</li><li>【建议】INSERT INTO…VALUES(XX),(XX),(XX)… 这里XX的值不要超过5000个。 值过多虽然上线很 快，但会引起主从同步延迟。</li><li>【建议】SELECT语句不要使用UNION，推荐使用UNION ALL，并且UNION子句个数限制在5个以 内。</li><li>【建议】线上环境，多表 JOIN 不要超过5个表。</li><li>【建议】减少使用ORDER BY，和业务沟通能不排序就不排序，或将排序放到程序端去做。ORDER BY、GROUP BY、DISTINCT 这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的。</li><li>【建议】包含了ORDER BY、GROUP BY、DISTINCT 这些查询的语句，WHERE 条件过滤出来的结果 集请保持在1000行以内，否则SQL会很慢。</li><li>【建议】对单表的多次alter操作必须合并为一次 对于超过100W行的大表进行alter table，必须经过DBA审核，并在业务低峰期执行，多个alter需整 合在一起。 因为alter table会产生 表锁 ，期间阻塞对于该表的所有写入，对于业务可能会产生极 大影响。</li><li>【建议】批量操作数据时，需要控制事务处理间隔时间，进行必要的sleep。</li><li>【建议】事务里包含SQL不超过5个。 因为过长的事务会导致锁数据较久，MySQL内部缓存、连接消耗过多等问题。</li><li>【建议】事务里更新语句尽量基于主键或UNIQUE KEY，如UPDATE… WHERE id=XX; 否则会产生间隙锁，内部扩大锁定范围，导致系统性能下降，产生死锁。</li></ol><h3 id="8-3-PowerDesigner的使用">8.3 PowerDesigner的使用</h3><p>PowerDesigner是一款开发人员常用的数据库建模工具，用户利用该软件可以方便地制作 数据流程图 、 概念数据模型 、 物理数据模型 ，它几乎包括了数据库模型设计的全过程，是Sybase公司为企业建模和设 计提供的一套完整的集成化企业级建模解决方案。</p><hr><p>参考：<br><a href="https://www.bilibili.com/video/BV1iq4y1u7vj" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1iq4y1u7vj</a><br><a href="https://new-wangz.github.io/categories/" target="_blank" rel="noopener">https://new-wangz.github.io/categories/</a></p><ol start="13"><li>【建议】表中所有字段尽量都是 NOT NULL 属性，业务可以根据需要定义 DEFAULT值 。 因为使用 NULL值会存在每一行都会占用额外存储空间、数据迁移容易出错、聚合函数计算结果偏差等问 题。</li><li>【建议】所有存储相同数据的 列名和列类型必须一致 （一般作为关联列，如果查询时关联列类型 不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低）。</li><li>【建议】中间表（或临时表）用于保留中间结果集，名称以 tmp_ 开头。 备份表用于备份或抓取源表快照，名称以 bak_ 开头。中间表和备份表定期清理。 1</li><li>【示范】一个较为规范的建表语句</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> user_info (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">int</span> <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'自增主键'</span>,</span><br><span class="line"><span class="string">`user_id`</span> <span class="built_in">bigint</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户id'</span>,</span><br><span class="line"><span class="string">`username`</span> <span class="built_in">varchar</span>(<span class="number">45</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'真实姓名'</span>,</span><br><span class="line"><span class="string">`email`</span> <span class="built_in">varchar</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户邮箱'</span>,</span><br><span class="line"><span class="string">`nickname`</span> <span class="built_in">varchar</span>(<span class="number">45</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'昵称'</span>,</span><br><span class="line"><span class="string">`birthday`</span> <span class="built_in">date</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'生日'</span>,</span><br><span class="line"><span class="string">`sex`</span> <span class="built_in">tinyint</span>(<span class="number">4</span>) <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'性别'</span>,</span><br><span class="line"><span class="string">`short_introduce`</span> <span class="built_in">varchar</span>(<span class="number">150</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'一句话介绍自己，最多50个汉字'</span>,</span><br><span class="line"><span class="string">`user_resume`</span> <span class="built_in">varchar</span>(<span class="number">300</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户提交的简历存放地址'</span>,</span><br><span class="line"><span class="string">`user_register_ip`</span> <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户注册时的源ip'</span>,</span><br><span class="line"><span class="string">`create_time`</span> <span class="built_in">timestamp</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'创建时间'</span>,</span><br><span class="line"><span class="string">`update_time`</span> <span class="built_in">timestamp</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span></span><br><span class="line"><span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'修改时间'</span>,</span><br><span class="line"><span class="string">`user_review_status`</span> <span class="built_in">tinyint</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户资料审核状态，1为通过，2为审核中，3为未</span></span><br><span class="line"><span class="string">通过，4为还未提交审核'</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line"><span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`uniq_user_id`</span> (<span class="string">`user_id`</span>),</span><br><span class="line"><span class="keyword">KEY</span> <span class="string">`idx_username`</span>(<span class="string">`username`</span>),</span><br><span class="line"><span class="keyword">KEY</span> <span class="string">`idx_create_time_status`</span>(<span class="string">`create_time`</span>,<span class="string">`user_review_status`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'网站用户基本信息</span></span><br></pre></td></tr></table></figure><ol start="17"><li>【建议】创建表时，可以使用可视化工具。这样可以确保表、字段相关的约定都能设置上。实际上，我们通常很少自己写 DDL 语句，可以使用一些可视化工具来创建和操作数据库和数据表。可视化工具除了方便，还能直接帮我们将数据库的结构定义转化成 SQL 语言，方便数据库和数据表结构的导出和导入。</li></ol><p><strong>3、关于索引</strong></p><ol><li>【强制】InnoDB表必须主键为id int/bigint auto_increment，且主键值 禁止被更新 。</li><li>【强制】InnoDB和MyISAM存储引擎表，索引类型必须为 BTREE 。</li><li>【建议】主键的名称以 pk_ 开头，唯一键以 uni_ 或 uk_ 开头，普通索引以 idx_ 开头，一律使用小写格式，以字段的名称或缩写作为后缀。</li><li>【建议】多单词组成的columnname，取前几个单词首字母，加末单词组成column_name。如: sample 表 member_id 上的索引：idx_sample_mid。</li><li>【建议】单个表上的索引个数 不能超过6个 。</li><li>【建议】在建立索引时，多考虑建立 联合索引 ，并把区分度最高的字段放在最前面。</li><li>【建议】在多表 JOIN 的SQL里，保证被驱动表的连接列上有索引，这样JOIN 执行效率最高。</li><li>【建议】建表或加索引时，保证表里互相不存在 冗余索引 。 比如：如果表里已经存在key(a,b)， 则key(a)为冗余索引，需要删除。</li></ol><p><strong>4、SQL编写</strong></p><ol><li>【强制】程序端SELECT语句必须指定具体字段名称，禁止写成 *。</li><li>【建议】程序端insert语句指定具体字段名称，不要写成INSERT INTO t1 VALUES(…)。</li><li>【建议】除静态表或小表（100行以内），DML语句必须有WHERE条件，且使用索引查找。</li><li>【建议】INSERT INTO…VALUES(XX),(XX),(XX)… 这里XX的值不要超过5000个。 值过多虽然上线很 快，但会引起主从同步延迟。</li><li>【建议】SELECT语句不要使用UNION，推荐使用UNION ALL，并且UNION子句个数限制在5个以 内。</li><li>【建议】线上环境，多表 JOIN 不要超过5个表。</li><li>【建议】减少使用ORDER BY，和业务沟通能不排序就不排序，或将排序放到程序端去做。ORDER BY、GROUP BY、DISTINCT 这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的。</li><li>【建议】包含了ORDER BY、GROUP BY、DISTINCT 这些查询的语句，WHERE 条件过滤出来的结果 集请保持在1000行以内，否则SQL会很慢。</li><li>【建议】对单表的多次alter操作必须合并为一次 对于超过100W行的大表进行alter table，必须经过DBA审核，并在业务低峰期执行，多个alter需整 合在一起。 因为alter table会产生 表锁 ，期间阻塞对于该表的所有写入，对于业务可能会产生极 大影响。</li><li>【建议】批量操作数据时，需要控制事务处理间隔时间，进行必要的sleep。</li><li>【建议】事务里包含SQL不超过5个。 因为过长的事务会导致锁数据较久，MySQL内部缓存、连接消耗过多等问题。</li><li>【建议】事务里更新语句尽量基于主键或UNIQUE KEY，如UPDATE… WHERE id=XX; 否则会产生间隙锁，内部扩大锁定范围，导致系统性能下降，产生死锁。</li></ol><h3 id="8-3-PowerDesigner的使用-v2">8.3 PowerDesigner的使用</h3><p>PowerDesigner是一款开发人员常用的数据库建模工具，用户利用该软件可以方便地制作 数据流程图 、 概念数据模型 、 物理数据模型 ，它几乎包括了数据库模型设计的全过程，是Sybase公司为企业建模和设 计提供的一套完整的集成化企业级建模解决方案。</p><hr><p>参考：<br><a href="https://www.bilibili.com/video/BV1iq4y1u7vj" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1iq4y1u7vj</a><br><a href="https://new-wangz.github.io/categories/" target="_blank" rel="noopener">https://new-wangz.github.io/categories/</a></p>]]></content>
    
    
    <summary type="html">&lt;h1&gt;一、MySQL概述&lt;/h1&gt;
&lt;h2 id=&quot;1、数据库概述&quot;&gt;1、数据库概述&lt;/h2&gt;
&lt;h3 id=&quot;1-1-数据库作用&quot;&gt;1.1 数据库作用&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;持久化（persistence）：把数据保存到可掉电式存储设备中以供之后使用&lt;/li&gt;
&lt;li&gt;持久化的主要作用是将内存中的数据存储在关系型数据库中，当然也可以存储在磁盘文件、XML数据文件中&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1-2-数据库的相关概念&quot;&gt;1.2 数据库的相关概念&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;DB&lt;/strong&gt;：数据库（Database）即存储数据的“仓库”，其本质是一个文件系统。它保存了一系列有组织的数据&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DBMS&lt;/strong&gt;：数据库管理系统（Database Management System）是一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库，对数据库进行统一管理和 控制。用户通过数据库管理系统访问数据库中表内的数据。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SQL&lt;/strong&gt;：结构化查询语言（Structured Query Language），专门用来与数据库通信的语言&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;目前互联网上常见的数据库管理软件有 Oracle、MySQL、MS SQL Server、DB2、PostgreSQL、Access、SyBase、Informix这几种（查看数据库最新排名：&lt;a href=&quot;https://db-engines.com/en/ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://db-engines.com/en/ranking&lt;/a&gt;）&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://www.shawn22.xyz/categories/Java/"/>
    
    
    <category term="SQL" scheme="https://www.shawn22.xyz/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL8.0高级篇(下)-事务与日志和备份</title>
    <link href="https://www.shawn22.xyz/posts/b2281a88.html"/>
    <id>https://www.shawn22.xyz/posts/b2281a88.html</id>
    <published>2023-03-05T16:17:23.000Z</published>
    <updated>2023-03-05T16:34:26.137Z</updated>
    
    <content type="html"><![CDATA[<h1>一、事务基础知识</h1><h2 id="1、数据库事务概述">1、数据库事务概述</h2><h3 id="1-1-基本概念">1.1 基本概念</h3><blockquote><p>SHOW ENGINES`命令来查看当前 MySQL 支持的存储引擎都有哪些，以及这些存储引擎是否支持事务</p></blockquote><p>**事务：**一组逻辑操作单元，使数据从一种状态变换到另一种状态。<br>**事务处理的原则：**保证所有事务都作为 一个工作单元 来执行，即使出现了故障，都不能改变这种执行方 式。当在一个事务中执行多个操作时，要么所有的事务都被提交( commit )，那么这些修改就 永久 地保 存下来；要么数据库管理系统将 放弃 所作的所有 修改 ，整个事务回滚( rollback )到最初状态。</p><a id="more"></a><h3 id="1-2-事物的ACID特性">1.2 事物的ACID特性</h3><ul><li><strong>原子性（atomicity）</strong></li></ul><p>原子性是指事务是一个不可分割的工作单位，要么全部提交，要么全部失败回滚。即要么转账成功，要么转账失败，是不存在中间的状态。如果无法保证原子性会怎么样？就会出现数据不一致的情形，A账户减去100元，而B账户增加100元操作失败，系统将无故丢失100元。</p><ul><li><strong>一致性（consistency）</strong></li></ul><p>根据定义，一致性是指事务执行前后，数据从一个 <code>合法性状态</code> 变换到另外一个 <code>合法性状态</code> 。这种状态是 <code>语义上</code> 的而不是语法上的，跟具体的业务有关。那什么是合法的数据状态呢？满足 <code>预定的约束</code> 的状态就叫做合法的状态。通俗一点，这状态是由你自己来定义的（比如满足现实世界中的约束）。满足这个状态，数据就是一致的，不满足这个状态，数据就 是不一致的！如果事务中的某个操作失败了，系统就会自动撤销当前正在执行的事务，返回到事务操作 之前的状态。<br>**举例1：**A账户有200元，转账300元出去，此时A账户余额为-100元。你自然就发现此时数据是不一致的，为什么呢？因为你定义了一个状态，余额这列必须&gt;=0。<br>**举例2：**A账户有200元，转账50元给B账户，A账户的钱扣了，但是B账户因为各种意外，余额并没有增加。你也知道此时的数据是不一致的，为什么呢？因为你定义了一个状态，要求A+B的总余额必须不变。<br>**举例3：**在数据表中我们将<code>姓名</code>字段设置为<code>唯一性约束</code>，这时当事务进行提交或者事务发生回滚的时候，如果数据表的姓名不唯一，就破坏了事物的一致性要求。</p><ul><li><strong>隔离型（isolation）</strong></li></ul><p>事务的隔离性是指一个事务的执行<code>不能被其他事务干扰</code>，即一个事务内部的操作及使用的数据对<code>并发</code>的其他事务是隔离的，并发执行的各个事务之间不能相互干扰。</p><ul><li><strong>持久性（durability）</strong></li></ul><p>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是 永久性的 ，接下来的其他操作和数据库 故障不应该对其有任何影响。持久性是通过 事务日志 来保证的。日志包括了 重做日志 和 回滚日志 。当我们通过事务对数据进行修改 的时候，首先会将数据库的变化信息记录到重做日志中，然后再对数据库中对应的行进行修改。这样做 的好处是，即使数据库系统崩溃，数据库重启后也能找到没有更新到数据库系统中的重做日志，重新执 行，从而使事务具有持久性。</p><h3 id="1-3-事务的状态">1.3 事务的状态</h3><ul><li><strong>活动的（active）</strong><br>事务对应的数据库操作正在执行过程中时，我们就说该事务处在 <code>活动的</code> 状态。</li><li><strong>部分提交的（partially committed）</strong><br>当事务中的最后一个操作执行完成，但由于操作都在内存中执行，所造成的影响并 <code>没有刷新到磁盘</code> 时，我们就说该事务处在 <code>部分提交的</code> 状态。</li><li><strong>失败的（failed）</strong><br>当事务处在 <code>活动的</code> 或者 部分提交的 状态时，可能遇到了某些错误（数据库自身的错误、操作系统 错误或者直接断电等）而无法继续执行，或者人为的停止当前事务的执行，我们就说该事务处在 失 败的 状态。</li><li><strong>中止的（aborted）</strong><br>如果事务执行了一部分而变为 <code>失败的</code> 状态，那么就需要把已经修改的事务中的操作还原到事务执 行前的状态。换句话说，就是要撤销失败事务对当前数据库造成的影响。我们把这个撤销的过程称之为 <code>回滚</code> 。当 <code>回滚</code> 操作执行完毕时，也就是数据库恢复到了执行事务之前的状态，我们就说该事 务处在了 <code>中止的</code> 状态。</li><li><strong>提交的（committed）</strong></li></ul><p>当一个处在 部分提交的 状态的事务将修改过的数据都 同步到磁盘 上之后，我们就可以说该事务处在了 提交的 状态。<br><img src="https://img-blog.csdnimg.cn/img_convert/34555bfc2fdfe71af5fe51d38f84b4be.png" alt="image-20220708171857847.png"></p><h2 id="2、如何使用事务">2、如何使用事务</h2><blockquote><p>使用事务有两种方式，分别为 显式事务 和 隐式事务</p></blockquote><h3 id="2-1-显式事务">2.1 显式事务</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 步骤1：START TRANSACTION 或者 BEGIN ，作用是显式开启一个事务</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="comment">-- START TRANSACTION`语句相较于BEGIN特别之处在于，后边能跟随几个 修饰符</span></span><br><span class="line"><span class="comment">-- READ ONLY：标识当前事务是一个 只读事务，也就是属于该事务的数据库操作只能读取数据，而不能修改数据</span></span><br><span class="line"><span class="comment">-- READ WRITE ：标识当前事务是一个 读写事务 ，也就是属于该事务的数据库操作既可以读取数据， 也可以修改数据</span></span><br><span class="line"><span class="comment">-- WITH CONSISTENT SNAPSHOT ：启动一致性读。</span></span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span> <span class="keyword">READ</span> <span class="keyword">ONLY</span>; <span class="comment">-- 开启一个只读事务</span></span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span> <span class="keyword">READ</span> <span class="keyword">ONLY</span>, <span class="keyword">WITH</span> <span class="keyword">CONSISTENT</span> <span class="keyword">SNAPSHOT</span> <span class="comment">-- 开启只读事务和一致性读</span></span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span> <span class="keyword">READ</span> WRITE, <span class="keyword">WITH</span> <span class="keyword">CONSISTENT</span> <span class="keyword">SNAPSHOT</span> <span class="comment">-- 开启读写事务和一致性读</span></span><br></pre></td></tr></table></figure><ul><li><code>READ ONLY</code>和<code>READ WRITE</code>是用来设置所谓的事物<code>访问模式</code>的，就是以只读还是读写的方式来访问数据库中的数据，一个事务的访问模式不能同时即设置为<code>只读</code>的也设置为<code>读写</code>的，所以不能同时把<code>READ ONLY</code>和<code>READ WRITE</code>放到<code>START TRANSACTION</code>语句后边。</li><li>如果我们不显式指定事务的访问模式，那么该事务的访问模式就是<code>读写</code>模式</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 步骤2:一系列事务中的操作（主要是DML，不含DDL）</span></span><br><span class="line"><span class="comment">-- 步骤3：提交事务 或 中止事务（即回滚事务）</span></span><br><span class="line"><span class="comment">-- 提交事务。当提交事务后，对数据库的修改是永久性的</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="comment">-- 将事务回滚到某个保存点</span></span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> [<span class="keyword">SAVEPOINT</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 其中关于SAVEPOINT相关操作有</span></span><br><span class="line"><span class="comment">-- 在事务中创建保存点，方便后续针对保存点进行回滚。一个事务中可以存在多个保存点。</span></span><br><span class="line"><span class="keyword">SAVEPOINT</span> 保存点名称;</span><br><span class="line"><span class="comment">-- 删除某个保存点</span></span><br><span class="line"><span class="keyword">RELEASE</span> <span class="keyword">SAVEPOINT</span> 保存点名称;</span><br></pre></td></tr></table></figure><h3 id="2-2-隐式事务">2.2 隐式事务</h3><p>MySQL中有一个系统变量 autocommit ：<code>SHOW VARIABLES LIKE 'autocommit';</code>当然，如果我们想关闭这种 <code>自动提交</code> 的功能，可以使用下边两种方法之一：</p><ul><li>显式的的使用 <code>START TRANSACTION</code> 或者 <code>BEGIN</code> 语句开启一个事务。这样在本次事务提交或者回滚前会暂时关闭掉自动提交的功能。</li><li>把系统变量 <code>autocommit</code> 的值设置为 <code>OFF</code> ，就像这样：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> autocommit = <span class="keyword">OFF</span>;</span><br><span class="line"><span class="keyword">SET</span> autocommit = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h3 id="2-3-隐式提交数据的情况">2.3 隐式提交数据的情况</h3><ul><li>数据定义语言（Data definition language，缩写为：DDL）。数据库对象，指的就是<code>数据库、表、视图、存储过程</code>等结构。当我们<code>CREATE、ALTER、DROP</code>等语句去修改数据库对象时，就会隐式的提交前边语句所属于的事物。</li><li>隐式使用或修改mysql数据库中的表。当我们使用<code>ALTER USER</code>、<code>CREATE USER</code>、<code>DROP USER</code>、<code>GRANT</code>、<code>RENAME USER</code>、<code>REVOKE</code>、<code>SET PASSWORD</code>等语句时也会隐式的提交前边语句所属于的事务。</li><li>事务控制或关于锁定的语句<ul><li>当我们在一个事务还没提交或者回滚时就又使用 START TRANSACTION 或者 BEGIN 语句开启了另一个事务时，会隐式的提交上一个事务。</li><li>当前的 autocommit 系统变量的值为 OFF ，我们手动把它调为 ON 时，也会 隐式的提交前边语句所属的事务。</li><li>使用 LOCK TABLES 、 UNLOCK TABLES 等关于锁定的语句也会 隐式的提交 前边语句所属的事务。</li></ul></li><li>加载数据的语句。使用<code>LOAD DATA</code>语句来批量往数据库中导入数据时，也会<code>隐式的提交</code>前边语句所属的事务。</li><li>关于MySQL复制的一些语句。使用<code>START SLAVE、STOP SLAVE、RESET SLAVE、CHANGE MASTER TO</code>等语句会隐式的提交前边语句所属的事务</li><li>其他的一些语句。使用<code>ANALYZE TABLE、CACHE INDEX、CAECK TABLE、FLUSH、LOAD INDEX INTO CACHE、OPTIMIZE TABLE、REPAIR TABLE、RESET</code>等语句也会隐式的提交前边语句所属的事务。</li></ul><h3 id="2-4-使用举例">2.4 使用举例</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">account</span> <span class="keyword">SET</span> balance = balance - <span class="number">100</span> <span class="keyword">WHERE</span> <span class="keyword">NAME</span> = <span class="string">'张三'</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">account</span> <span class="keyword">SET</span> balance = balance - <span class="number">100</span> <span class="keyword">WHERE</span> <span class="keyword">NAME</span> = <span class="string">'张三'</span>;</span><br><span class="line"><span class="keyword">SAVEPOINT</span> s1; <span class="comment"># 设置保存点</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">account</span> <span class="keyword">SET</span> balance = balance + <span class="number">1</span> <span class="keyword">WHERE</span> <span class="keyword">NAME</span> = <span class="string">'张三'</span>;</span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> s1; <span class="comment"># 回滚到保存点</span></span><br></pre></td></tr></table></figure><h2 id="3、事务隔离级别">3、事务隔离级别</h2><p>MySQL是一个 客户端／服务器 架构的软件，对于同一个服务器来说，可以有若干个客户端与之连接，每 个客户端与服务器连接上之后，就可以称为一个会话（ Session ）。每个客户端都可以在自己的会话中 向服务器发出请求语句，一个请求语句可能是某个事务的一部分，也就是对于服务器来说可能同时处理多个事务。事务有 隔离性 的特性，理论上在某个事务 对某个数据进行访问 时，其他事务应该进行排队 ，当该事务提交之后，其他事务才可以继续访问这个数据。但是这样对 性能影响太大 ，我们既想保持事务的隔离性，又想让服务器在处理访问同一数据的多个事务时 性能尽量高些 ，那就看二者如何权衡取 舍了</p><h3 id="3-1-数据准备">3.1 数据准备</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student (</span><br><span class="line">    studentno <span class="built_in">INT</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    <span class="keyword">class</span> <span class="built_in">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (studentno)</span><br><span class="line">) <span class="keyword">Engine</span>=<span class="keyword">InnoDB</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student <span class="keyword">VALUES</span>(<span class="number">1</span>, <span class="string">'小谷'</span>, <span class="string">'1班'</span>);</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student;</span><br></pre></td></tr></table></figure><h3 id="3-2-数据并发问题">3.2 数据并发问题</h3><p><strong>1、脏写</strong>，对于两个事务 Session A、Session B，如果事务Session A 修改了 另一个 未提交 事务Session B 修改过 的数据，那就意味着发生了 脏写<br><img src="https://img-blog.csdnimg.cn/img_convert/f663ec1653db90809f64f11da2b38b2c.png" alt="image-20220708214453902.png"><br>**2、脏读，**对于两个事务 Session A、Session B，Session A 读取 了已经被 Session B 更新 但还 没有被提交 的字段。 之后若 Session B 回滚 ，Session A 读取的内容就是 临时且无效 的<br><img src="https://img-blog.csdnimg.cn/img_convert/e46ed4599c8f90c15ac94532e8d5a891.png" alt="image-20220708215109480.png"><br>**3、不可重复读（ Non-Repeatable Read ），**对于两个事务Session A、Session B，Session A 读取了一个字段，然后 Session B 更新了该字段。 之后 Session A 再次读取 同一个字段， 值就不同 了。<br><img src="https://img-blog.csdnimg.cn/img_convert/c0f60c85d36da0618fe35f33da22ff30.png" alt="image-20220708215626435.png"><br>4、**幻读（ Phantom ），**对于两个事务Session A、Session B, Session A 从一个表中 读取 了一个字段, 然后 Session B 在该表中 插 入 了一些新的行。 之后, 如果 Session A 再次读取 同一个表, 就会多出几行。<br><img src="https://img-blog.csdnimg.cn/img_convert/83644f913a0e55cf9a0af10006188ac4.png" alt="image-20220708220102342.png"></p><h3 id="3-3-SQL中的四种隔离级别">3.3 SQL中的四种隔离级别</h3><p>上面介绍了几种并发事务执行过程中可能遇到的一些问题，这些问题有轻重缓急之分，我们给这些问题 按照严重性来排一下序：<strong>脏写 &gt; 脏读 &gt; 不可重复读 &gt; 幻读</strong><br>SQL标准 中设立了4个 隔离级别</p><ul><li><code>READ UNCOMMITTED</code> ：读未提交，在该隔离级别，所有事务都可以看到其他未提交事务的执行结 果。不能避免脏读、不可重复读、幻读。</li><li><code>READ COMMITTED</code> ：读已提交，它满足了隔离的简单定义：一个事务只能看见已经提交事务所做 的改变。这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。可以避免脏读，但不可 重复读、幻读问题仍然存在。</li><li><code>REPEATABLE READ</code> ：可重复读，事务A在读到一条数据之后，此时事务B对该数据进行了修改并提 交，那么事务A再读该数据，读到的还是原来的内容。可以避免脏读、不可重复读，但幻读问题仍 然存在。这是MySQL的默认隔离级别。</li><li><code>SERIALIZABLE</code> ：可串行化，确保事务可以从一个表中读取相同的行。在这个事务持续期间，禁止 其他事务对该表执行插入、更新和删除操作。所有的并发问题都可以避免，但性能十分低下。能避 免脏读、不可重复读和幻读。</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/db67608a5a25d8512b384c3cff08c2f3.png" alt="image-20220708220917267.png"><br>脏写怎么没涉及到？因为脏写这个问题太严重了，不论是哪种隔离级别，都不允许脏写的情况发生。不同的隔离级别有不同的现象，并有不同的锁和并发机制，隔离级别越高，数据库的并发性能就越差，4 种事务隔离级别与并发性能的关系如下：<br><img src="https://img-blog.csdnimg.cn/img_convert/c86ac2a4b73613d7f33e823a31e0a185.png" alt="image-20220708220957108.png"></p><h3 id="3-4-MySQL支持的四种隔离级别">3.4 MySQL支持的四种隔离级别</h3><p>不同的数据库厂商对sQL标准中规定的四种隔离级别支持不一样。比如，<code>Oracle</code>就只支持 <strong>READ COMMITTED（默认隔离级别）和SERIALIZABLE隔离级别</strong>。MySQL虽然支持4种隔离级别，但与SQL标准中所规定的各级隔离级别允许发生的问题却有些出入，<strong>MySQL在REPEATABLE READ隔离级别下，是可以禁止幻读问题的发生的</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看隔离级别，MySQL 5.7.20的版本之前</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">'tx_isolation'</span>;</span><br><span class="line"><span class="comment">--  MySQL 5.7.20版本之后，引入transaction_isolation来替换tx_isolation</span></span><br><span class="line"><span class="comment">-- 查看隔离级别，MySQL 5.7.20的版本及之后</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">'transaction_isolation'</span>;</span><br><span class="line"><span class="comment">-- 或者不同MySQL版本中都可以使用的：</span></span><br><span class="line"><span class="keyword">SELECT</span> @@transaction_isolation;</span><br></pre></td></tr></table></figure><p>对于事物隔离级别的设置</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> [<span class="keyword">GLOBAL</span>|<span class="keyword">SESSION</span>] <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> 隔离级别;</span><br><span class="line"><span class="comment">-- 其中，隔离级别格式：</span></span><br><span class="line"><span class="comment">-- READ UNCOMMITTED/READ COMMITTED/REPEATABLE READ/SERIALIZABLE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 或者</span></span><br><span class="line"><span class="keyword">SET</span> [<span class="keyword">GLOBAL</span>|<span class="keyword">SESSION</span>] TRANSACTION_ISOLATION = <span class="string">'隔离级别'</span></span><br><span class="line"><span class="comment">-- READ-UNCOMMITTED/READ-COMMITTED/REPEATABLE-READ/SERIALIZABLE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用 GLOBAL 关键字（在全局范围影响）</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> <span class="keyword">SERIALIZABLE</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> TRANSACTION_ISOLATION = <span class="string">'SERIALIZABLE'</span>;</span><br><span class="line"><span class="comment">-- 当前已经存在的会话无效</span></span><br><span class="line"><span class="comment">-- 只对执行完该语句之后产生的会话起作用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用 SESSION 关键字（在会话范围影响）</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">SESSION</span> <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> <span class="keyword">SERIALIZABLE</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">SESSION</span> TRANSACTION_ISOLATION = <span class="string">'SERIALIZABLE'</span>;</span><br><span class="line"><span class="comment">-- 对当前会话的所有后续的事务有效</span></span><br><span class="line"><span class="comment">-- 如果在事务之间执行，则对后续的事务有效</span></span><br><span class="line"><span class="comment">-- 该语句可以在已经开启的事务中间执行，但不会影响当前正在执行的事务</span></span><br></pre></td></tr></table></figure><p>如果在服务器启动时想改变事务的默认隔离级别，可以修改启动参数transaction_isolation的值。比如，在启动服务器时指定了transaction_isolation=SERIALIZABLE，那么事务的默认隔离界别就从原来的REPEATABLE-READ变成了SERIALIZABLE</p><h2 id="4、事务的常见分类">4、事务的常见分类</h2><ul><li>扁平事务（Flat Transactions）</li><li>带有保存点的扁平事务（Flat Transactions with Savepoints）</li><li>链事务（Chained Transactions）</li><li>嵌套事务（Nested Transactions）</li><li>分布式事务（Distributed Transactions）</li></ul><h1>二、MySQL事务日志</h1><h2 id="1、概述">1、概述</h2><p>事务有4种特性：原子性、一致性、隔离性和持久性。那么事务的四种特性到底是基于什么机制实现呢？</p><ul><li>事务的隔离性由 <code>锁机制</code> 实现。</li><li>而事务的原子性、一致性和持久性由事务的 redo 日志和undo 日志来保证。<ul><li>REDO LOG 称为 <code>重做日志</code>，提供再写入操作，恢复提交事务修改的页操作，用来保证事务的持久性。</li><li>UNDO LOG 称为 <code>回滚日志</code> ，回滚行记录到某个特定版本，用来保证事务的原子性、一致性。</li></ul></li></ul><p>有的DBA或许会认为 UNDO 是 REDO 的逆过程，其实不然。REDO 和 UNDO都可以视为是一种 <code>恢复操作</code>，但是：</p><ul><li>redo log: 是存储引擎层 (innodb) 生成的日志，记录的是<code>&quot;物理级别&quot;</code>上的页修改操作，比如页号xxx，偏移量yyy写入了’zzz’数据。主要为了保证数据的可靠性。</li><li>undo log: 是存储引擎层 (innodb) 生成的日志，记录的是 <code>逻辑操作</code> 日志，比如对某一行数据进行了INSERT语句操作，那么undo log就记录一条与之相反的DELETE操作。主要用于 <code>事务的回滚</code> (undo log 记录的是每个修改操作的 <code>逆操作</code>) 和 <code>一致性非锁定读</code> (undo log 回滚行记录到某种特定的版本——MVCC，即多版本并发控制)。</li></ul><h2 id="2、redo日志">2、redo日志</h2><blockquote><p>InnoDB存储引擎是以页为单位来管理存储空间的。在真正访问页面之前，需要把在磁盘上的页缓存到内存中的Buffer Pool之后才可以访问。所有的变更都必须先更新缓冲池中的数据，然后缓冲池中的脏页会以一定的频率被刷入磁盘 (checkPoint机制)，通过缓冲池来优化CPU和磁盘之间的鸿沟，这样就可以保证整体的性能不会下降太快</p></blockquote><h3 id="2-1-为什么需要REDO日志">2.1 为什么需要REDO日志</h3><p>一方面，缓冲池可以帮助我们消除CPU和磁盘之间的鸿沟，checkpoint机制可以保证数据的最终落盘，然 而由于checkpoint <code>并不是每次变更的时候就触发</code> 的，而是master线程隔一段时间去处理的。所以最坏的情 况就是事务提交后，刚写完缓冲池，数据库宕机了，那么这段数据就是丢失的，无法恢复。另一方面，事务包含 <code>持久性</code> 的特性，就是说对于一个已经提交的事务，在事务提交后即使系统发生了崩溃，这个事务对数据库中所做的更改也不能丢失。<br>那么如何保证这个持久性呢？ <code>一个简单的做法</code> ：在事务提交完成之前把该事务所修改的所有页面都刷新 到磁盘，但是这个简单粗暴的做法有些问题:</p><ul><li><strong>修改量与刷新磁盘工作量严重不成比例</strong><br>有时候我们仅仅修改了某个页面中的一个字节，但是我们知道在InnoDB中是以页为单位来进行磁盘IO的，也就是说我们在该事务提交时不得不将一个完整的页面从内存中刷新到磁盘，我们又知道一个默认页面时16KB大小，只修改一个字节就要刷新16KB的数据到磁盘上显然是小题大做了。</li><li><strong>随机IO刷新较慢</strong><br>一个事务可能包含很多语句，即使是一条语句也可能修改许多页面，假如该事务修改的这些页面可能并不相邻，这就意味着在将某个事务修改的Buffer Pool中的页面<code>刷新到磁盘</code>时，需要进行很多的<code>随机IO</code>，随机IO比顺序IO要慢，尤其对于传统的机械硬盘来说。</li></ul><p><code>另一个解决的思路</code> ：我们只是想让已经提交了的事务对数据库中数据所做的修改永久生效，即使后来系 统崩溃，在重启后也能把这种修改恢复出来。所以我们其实没有必要在每次事务提交时就把该事务在内 存中修改过的全部页面刷新到磁盘，只需要把 修改 了哪些东西 记录一下 就好。比如，某个事务将系统 表空间中 第10号 页面中偏移量为 100 处的那个字节的值 1 改成 2 。我们只需要记录一下：将第0号表 空间的10号页面的偏移量为100处的值更新为 2。<br>InnoDB引擎的事务采用了WAL技术 (<code>Write-Ahead Logging</code>)，这种技术的思想就是先写日志，再写磁盘，只有日志写入成功，才算事务提交成功，这里的日志就是redo log。当发生宕机且数据未刷到磁盘的时候，可以通过redo log来恢复，保证ACID中的D，这就是redo log的作用。</p><h3 id="2-2-REDO日志的好处、特点">2.2 REDO日志的好处、特点</h3><p><strong>好处</strong></p><ul><li>redo日志降低了刷盘频率</li><li>redo日志占用的空间非常小</li></ul><p>存储表空间ID、页号、偏移量以及需要更新的值，所需的存储空间是很小的，刷盘快。<br><strong>特点</strong></p><ul><li><strong>redo日志是顺序写入磁盘的</strong><br>在执行事务的过程中，每执行一条语句，就可能产生若干条redo日志，这些日志是按照<code>产生的顺序写入磁盘的</code>，也就是使用顺序ID，效率比随机IO快。</li><li><strong>事务执行过程中，redo log不断记录</strong><br>redo log跟bin log的区别，redo log是<code>存储引擎层</code>产生的，而bin log是<code>数据库层</code>产生的。假设一个事务，对表做10万行的记录插入，在这个过程中，一直不断的往redo log顺序记录，而bin log不会记录，直到这个事务提交，才会一次写入到bin log文件中。</li></ul><h3 id="2-3-redo的组成">2.3 redo的组成</h3><p>Redo log可以简单分为以下两个部分：</p><ul><li><code>重做日志的缓冲 (redo log buffer)</code> ，保存在内存中，是易失的。在服务器启动时就会向操作系统申请了一大片称之为 redo log buffer 的 <code>连续内存</code> 空间，翻译成中文就是redo日志缓冲区。这片内存空间被划分为若干个连续的<code>redo log block</code>。一个redo log block占用<code>512字节</code>大小。</li></ul><p>**参数设置：innodb_log_buffer_size，**redo log buffer 大小默认 16M ，最大值是4096M，最小值为1M</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%innodb_log_buffer_size%'</span>;</span><br></pre></td></tr></table></figure><ul><li>重做日志文件 (redo log file)，保存在硬盘中，是持久的。例如ib_logfile0和ib_logfile1即为REDO日志</li></ul><h3 id="2-4-redo的整体流程">2.4 redo的整体流程</h3><p>以一个更新事务为例，redo log 流转过程，如下图所示：<br><img src="https://img-blog.csdnimg.cn/img_convert/33603fdb317fa44fe2f00c6f7fdce74f.png" alt="image-20220710204810264.png"><br>第1步：先将原始数据从磁盘中读入内存中来，修改数据的内存拷贝<br>第2步：生成一条重做日志并写入redo log buffer，记录的是数据被修改后的值<br>第3步：当事务commit时，将redo log buffer中的内容刷新到 redo log file，对 redo log file采用追加写的方式<br>第4步：定期将内存中修改的数据刷新到磁盘中</p><blockquote><p>Write-Ahead Log(预先日志持久化)：在持久化一个数据页之前，先将内存中相应的日志页持久化</p></blockquote><h3 id="2-5-redo-log的刷盘策略">2.5 redo log的刷盘策略</h3><p>redo log的写入并不是直接写入磁盘的，InnoDB引擎会在写redo log的时候先写redo log buffer，之后以一 定的频率刷入到真正的redo log file 中。这里的一定频率怎么看待呢？这就是我们要说的刷盘策略。<br><img src="https://img-blog.csdnimg.cn/img_convert/651defef8ee660bc13d5b52581860d3c.png" alt="image-20220710205015302.png"><br>注意，redo log buffer刷盘到redo log file的过程并不是真正的刷到磁盘中去，只是刷入到 <code>文件系统缓存 （page cache）</code>中去（这是现代操作系统为了提高文件写入效率做的一个优化），真正的写入会交给系统自己来决定（比如page cache足够大了）。那么对于InnoDB来说就存在一个问题，如果交给系统来同 步，同样如果系统宕机，那么数据也丢失了（虽然整个系统宕机的概率还是比较小的）。<br>针对这种情况，InnoDB给出 <code>innodb_flush_log_at_trx_commit</code> 参数，该参数控制 commit提交事务 时，如何将 redo log buffer 中的日志刷新到 redo log file 中。它支持三种策略：</p><ul><li><code>设置为0</code> ：表示每次事务提交时不进行刷盘操作。（系统默认master thread每隔1s进行一次重做日 志的同步） 第1步：先将原始数据从磁盘中读入内存中来，修改数据的内存拷贝 第2步：生成一条重做日志并写入redo log buffer，记录的是数据被修改后的值 第3步：当事务commit时，将redo log buffer中的内容刷新到 redo log file，对 redo log file采用追加 写的方式 第4步：定期将内存中修改的数据刷新到磁盘中</li><li><code>设置为1</code> ：表示每次事务提交时都将进行同步，刷盘操作（ 默认值 ）</li><li><code>设置为2</code> ：表示每次事务提交时都只把 redo log buffer 内容写入 page cache，不进行同步。由os自 己决定什么时候同步到磁盘文件。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看自己的刷盘策略</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'innodb_flush_log_at_trx_commit'</span> ;</span><br></pre></td></tr></table></figure><p>另外，InnoDB存储引擎有一个后台线程，每隔1秒，就会把redo log buffer中的内容写到文件系统缓存(page cache)，然后调用刷盘操作<br><img src="https://img-blog.csdnimg.cn/img_convert/46e7642946d13c47be46271e3720d9ac.png" alt="image-20220710210339724.png"><br>也就是说，一个没有提交事务的redo log记录，也可能会刷盘。因为在事务执行过程 redo log 记录是会写入 redo log buffer中，这些redo log 记录会被后台线程刷盘。<br><img src="https://img-blog.csdnimg.cn/img_convert/a115b8a99f045e3d97422868f5a8f1fb.png" alt="image-20220710210532805.png"><br>除了后台线程每秒1次的轮询操作，还有一种情况，当redo log buffer占用的空间即将达到innodb_log_buffer_size（这个参数默认是16M）的一半的时候，后台线程会主动刷盘</p><h3 id="1-6-不同刷盘策略演示">1.6 不同刷盘策略演示</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 比较innodb_flush_log_at_trx_commit对事务的影响</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_load(</span><br><span class="line">a <span class="built_in">INT</span>,</span><br><span class="line">b <span class="built_in">CHAR</span>(<span class="number">80</span>)</span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">INNODB</span>;</span><br><span class="line"></span><br><span class="line">DELIMITER//</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> p_load(<span class="keyword">COUNT</span> <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> s <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> c <span class="built_in">CHAR</span>(<span class="number">80</span>) <span class="keyword">DEFAULT</span> <span class="keyword">REPEAT</span>(<span class="string">'a'</span>,<span class="number">80</span>);</span><br><span class="line">WHILE s&lt;=COUNT DO</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_load <span class="keyword">SELECT</span> <span class="literal">NULL</span>, c;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="keyword">SET</span> s=s+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">WHILE</span>;</span><br><span class="line"><span class="keyword">END</span> //</span><br><span class="line">DELIMITER;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 向表中插入3w条记录，并执行3万次的fsync操作。</span></span><br><span class="line"><span class="keyword">CALL</span> p_load(<span class="number">30000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改参数innodb_flush_log_at_trx_commit，进行分别测试</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> innodb_flush_log_at_trx_commit = <span class="number">0</span>;</span><br><span class="line"><span class="comment">-- 0最快2其次1最慢</span></span><br></pre></td></tr></table></figure><h3 id="1-7-写入redo-log-buffer-过程">1.7 写入redo log buffer 过程</h3><p><strong>1、补充概念：Mini-Transaction</strong><br>MySQL把对底层页面中的一次原子访问过程称之为一个Mini-Transaction，简称mtr，比如，向某个索引对应的B+树中插入一条记录的过程就是一个Mini-Transaction。一个所谓的mtr可以包含一组redo日志，在进行崩溃恢复时这一组redo日志可以作为一个不可分割的整体。<br>一个事务可以包含若干条语句，每一条语句其实是由若干个 mtr 组成，每一个 mtr 又可以包含若干条 redo日志，画个图表示它们的关系就是这样：<br><img src="https://img-blog.csdnimg.cn/img_convert/8ee4d298405cac83a435e6256b1a2e5c.png" alt="image-20220710220653131.png"><br><strong>2、 redo 日志写入log buffer</strong><br>向<code>log buffer</code>中写入redo日志的过程是顺序的，也就是先往前边的block中写，当该block的空闲空间用完之后再往下一个block中写。当我们想往<code>log buffer</code>中写入redo日志时，第一个遇到的问题就是应该写在哪个<code>block</code>的哪个偏移量处，所以<code>InnoDB</code>的设计者特意提供了一个称之为<code>buf_free</code>的全局变量，该变量指明后续写入的redo日志应该写入到<code>log buffer</code>中的哪个位置，如图所示:<br><img src="https://img-blog.csdnimg.cn/img_convert/fb17ed844060ff3f503a0c6a18b4e1f7.png" alt="image-20220710220919271.png"><br>一个mtr执行过程中可能产生若干条redo日志，<strong>这些redo日志是一个不可分割的组</strong>，所以其实并不是每生成一条redo日志，就将其插入到log buffer中，而是每个mtr运行过程中产生的日志先暂时存到一个地方，当该mtr结束的时候，将过程中产生的一组redo日志再全部复制到log buffer中。我们现在假设有两个名为<strong>T1、T2</strong>的事务，每个事务都包含2个mtr，我们给这几个mtr命名一下:</p><ul><li>事务T1的两个mtr分别称为mtr_T1_1和mtr_T1_2</li><li>事务T2的两个mtr分别称为mtr_T2_1和mtr_T2_2</li></ul><p>每个mtr都会产生一组redo日志，不同的事务可能是 并发 执行的，所以 T1 、 T2 之间的 mtr 可能是 交替执行 的。没当一个mtr执行完成时，伴随该mtr生成的一组redo日志就需要被复制到log buffer中，也就是说不同事务的mtr可能是交替写入log buffer的，我们画个示意图（为了美观，我们把一个mtr中产生的所有redo日志当做一个整体来画）<br><img src="https://img-blog.csdnimg.cn/img_convert/7b6bd715d14a897899f5c72e5c2849bc.png" alt="image-20220710221620291.png"><br><strong>3、redo log block的结构</strong><br>一个redo log block是由<code>日志头、日志体、日志尾</code>组成。日志头占用12字节，日志尾占用8字节，所以一个block真正能存储的数据是512-12-8=492字节。</p><blockquote><p>这个和磁盘的扇区有关，机械磁盘默认的扇区就是512字节，如果你要写入的数据大于512字节，那么要写入的扇区肯定不止一个，这时就要涉及到盘片的转动，找到下一个扇区，假设现在需要写入两个扇区A和B，如果扇区A写入成功，而扇区B写入失败，那么就会出现非原子性的写入，而如果每次只写入和扇区的大小一样的512字节，那么每次的写入都是原子性的。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/img_convert/d3e17db3f01b7a2863e5d3095b9cba81.png" alt="image-20220711144608223.png"></p><h3 id="1-8-redo-log-file">1.8 redo log file</h3><p><strong>1、相关参数设置</strong></p><ul><li><code>innodb_log_group_home_dir</code> ：指定 redo log 文件组所在的路径，默认值为 <code>./</code> ，表示在数据库 的数据目录下。MySQL的默认数据目录（ <code>var/lib/mysql</code>）下默认有两个名为 <code>ib_logfile0</code> 和 <code>ib_logfile1</code> 的文件，log buffer中的日志默认情况下就是刷新到这两个磁盘文件中。此redo日志 文件位置还可以修改。</li><li><code>innodb_log_files_in_group</code>：指明redo log file的个数，命名方式如：ib_logfile0，iblogfile1… iblogfilen。默认2个，最大100个。 <code>show variables like 'innodb_log_files_in_group';</code></li><li><code>innodb_flush_log_at_trx_commit</code>：控制 redo log 刷新到磁盘的策略，默认为1。</li><li><code>innodb_log_file_size</code>：单个 redo log 文件设置大小，默认值为 <code>48M</code> 。最大值为512G，注意最大值 指的是整个 redo log 系列文件之和，即（innodb_log_files_in_group * innodb_log_file_size ）不能大 于最大值512G</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'innodb_log_file_size'</span>;</span><br><span class="line"><span class="comment">-- 根据业务修改其大小，以便容纳较大的事务。编辑my.cnf文件并重启数据库生效</span></span><br><span class="line">vim /etc/my.cnf</span><br><span class="line">innodb_log_file_size=200M</span><br><span class="line"><span class="comment">-- 在数据库实例更新比较频繁的情况下，可以适当加大 redo log 数组和大小。</span></span><br><span class="line"><span class="comment">-- 但也不推荐 redo log 设置过大，在MySQL崩溃时会重新执行REDO日志中的记录。</span></span><br></pre></td></tr></table></figure><p><strong>2、日志文件组</strong><br>从上边的描述中可以看到，磁盘上的redo日志文件不只一个，而是以一个<strong>日志文件组</strong>的形式出现的。这些文件以**ib_logfile[数字]（数字可以是0、1、2…)**的形式进行命名，每个的redo日志文件大小都是一样的。在将redo日志写入日志文件组时，是从ib_logfile0开始写，如果<code>ib_logfile0</code>写满了，就接着<code>ib_logfile1</code>写。同理，<code>ib_logfile1</code>写满了就去写<code>ib_logfile2</code>，依此类推。如果写到最后一个文件该咋办?那就重新转到<code>ib_logfile0</code>继续写<br>总共的redo日志文件大小其实就是： innodb_log_file_size × innodb_log_files_in_group 。采用循环使用的方式向redo日志文件组里写数据的话，会导致后写入的redo日志覆盖掉前边写的redo日志？当然！所以InnoDB的设计者提出了checkpoint的概念。<br><strong>3、checkpoint</strong><br>在整个日志文件组中还有两个重要的属性，分别是 <strong>write pos、checkpoint</strong></p><ul><li><code>write pos</code>是当前记录的位置，一边写一边后移</li><li><code>checkpoint</code>是当前要擦除的位置，也是往后推移</li></ul><p>每次刷盘 redo log 记录到日志文件组中，write pos 位置就会后移更新。每次MySQL加载日志文件组恢复数据时，会清空加载过的 redo log 记录，并把check point后移更新。write pos 和 checkpoint 之间的还空着的部分可以用来写入新的 redo log 记录。<br><img src="https://img-blog.csdnimg.cn/img_convert/4cc3fa152f83257debcdc22fe1f3b431.png" alt="image-20220711152626161.png"><br>如果 write pos 追上 checkpoint ，表示日志文件组满了，这时候不能再写入新的 redo log记录，MySQL 得 停下来，清空一些记录，把 checkpoint 推进一下<br><img src="https://img-blog.csdnimg.cn/img_convert/ee6cc809c5c99f1ac3847b60039edfa1.png" alt="image-20220711152802294.png"></p><h3 id="1-9-redo-log-小结">1.9 redo log 小结</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/362c2141eee1aa61a9212b7882667d06.png" alt="image-20220711152930911.png"></p><h2 id="3、Undo日志">3、Undo日志</h2><blockquote><p>redo log是事务持久性的保证，undo log是事务原子性的保证。在事务中 更新数据 的 前置操作 其实是要先写入一个 undo log</p></blockquote><h3 id="3-1-Undo日志概述">3.1 Undo日志概述</h3><p>事务需要保证 <code>原子性</code>，也就是事务中的操作要么全部完成，要么什么也不做。但有时候事务执行到一半会出现一些情况，比如：</p><ul><li>情况一：事务执行过程中可能遇到各种错误，比如<code>服务器本身的错误</code> ， <code>操作系统错误</code> ，甚至是突然 <code>断电</code> 导致的错误。</li><li>情况二：程序员可以在事务执行过程中手动输入 <code>ROLLBACK</code> 语句结束当前事务的执行。</li></ul><p>以上情况出现，我们需要把数据改回原先的样子，这个过程称之为 <code>回滚</code> ，这样就可以造成一个假象：这 个事务看起来什么都没做，所以符合 <code>原子性</code> 要求。<br>每当我们要对一条记录做改动时(<strong>这里的改动可以指INSERT、DELETE、UPDATE</strong>)，都需要&quot;“留一手”—-把回滚时所需的东西记下来。比如:</p><ul><li><strong>插入一条记录时</strong>，至少要把这条记录的主键值记下来，之后回滚的时候只需要把这个主键值对应的<strong>记录删掉</strong>就好了。(对于每个INSERT,InnoDB存储引擎会完成一个DELETE)</li><li><strong>删除了一条记录</strong>，至少要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录<strong>插入</strong>到表中就好了。(对于每个DELETE,lnnoDB存储引擎会执行一个INSERT)</li><li><strong>修改了一条记录</strong>，至少要把修改这条记录前的旧值都记录下来，这样之后回滚时再把这条记录<strong>更新为旧值</strong>就好了。(对于每个UPDATE，InnoDB存储引擎会执行一个相反的UPDATE，将修改前的行放回去)</li></ul><p>MySQL把这些为了回滚而记录的这些内容称之为<strong>撤销日志或者回滚日志</strong>(即undo log)。注意，由于查询操作( SELECT）并不会修改任何用户记录，所以在查询操作执行时，并<strong>不需要记录相应的undo日志</strong>。此外，undo log <strong>会产生redo log</strong>，也就是undo log的产生会伴随着redo log的产生，这是因为undo log也需要持久性的保护</p><h3 id="3-2-Undo日志的作用">3.2 Undo日志的作用</h3><p><strong>作用1：回滚数据</strong><br>用户对undo日志可能有误解:undo用于将数据库物理地恢复到执行语句或事务之前的样子。但事实并非如此。undo是逻辑日志，因此只是将数据库逻辑地恢复到原来的样子。所有修改都被逻辑地取消了，但是数据结构和页本身在回滚之后可能大不相同。这是因为在多用户并发系统中，可能会有数十、数百甚至数千个并发事务。数据库的主要任务就是协调对数据记录的并发访问。比如，一个事务在修改当前一个页中某几条记录，同时还有别的事务在对同一个页中另几条记录进行修改。因此，不能将一个页回滚到事务开始的样子，因为这样会影响其他事务正在进行的工作。<br><strong>作用2：MVCC</strong><br>undo的另一个作用是MVCC，即在InnoDB存储引擎中MVCC的实现是通过undo来完成。当用户读取一行记录时，若该记录以及被其他事务占用，当前事务可以通过undo读取之前的行版本信息，以此实现非锁定读取。</p><h3 id="3-3-undo的存储结构">3.3 undo的存储结构</h3><p><strong>1、回滚段与undo页</strong><br>InnoDB对undo log的管理采用段的方式，也就是 <code>回滚段（rollback segment）</code> 。每个回滚段记录了 <code>1024</code> 个 <code>undo log segment</code> ，而在每个undo log segment段中进行 <code>undo页</code> 的申请</p><ul><li>在<code>InnoDB1.1版本之前</code> （不包括1.1版本），只有一个rollback segment，因此支持同时在线的事务限制为 <code>1024</code> 。虽然对绝大多数的应用来说都已经够用。</li><li>从1.1版本开始InnoDB支持最大 <code>128个rollback segment</code> ，故其支持同时在线的事务限制提高到 了 <code>128*1024</code></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'innodb_undo%'</span>;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'innodb_undo_logs'</span>;</span><br></pre></td></tr></table></figure><p>虽然InnoDB1.1版本支持了128个rollback segment，但是这些rollback segment都存储于共享表空间ibdata中。从InnoDB1.2版本开始，可通过参数对rollback segment做进一步的设置。这些参数包括:</p><ul><li><code>innodb_undo_directory</code>:设置rollback segment文件所在的路径。这意味着rollback segment可以存放在共享表空间以外的位置，即可以设置为独立表空间。该参数的默认值为“./&quot;，表示当前InnoDB存储引擎的目录</li><li><code>innodb_undo_logs</code> :设置rollback segment的个数，默认值为128。在InnoDB1.2版本中，该参数用来替换之前版本的参数innodb_rollback_segments</li><li><code>innodb_undo_tablespaces</code> :设置构成rollback segment文件的数量，这样rolback segment可以较为平均地分布在多个文件中。设置该参数后，会在路径innodb_undo_directory看到undo为前缀的文件，该文件就代表rollback segment文件</li></ul><p><strong>undo log相关参数一般很少改动，针对uno页的重用</strong><br>当我们开启一个事务需要写undo log的时候，就得先去undo log segment中去找到一个空闲的位置，当有空位的时候，就去申请undo页，在这个申请到的undo页中进行undo log的写入。我们<strong>知道mysql默认一页的大小是16k</strong>。为每一个事务分配一个页，是非常浪费的（除非你的事务非常长)，假设你的应用的TPS(每秒处理的事务数目)为1000，那么1s就需要1000个页，大概需要16M的存储，1分钟大概需要1G的存储。如果照这样下去除非MySQL清理的非常勤快，否则随着时间的推移，磁盘空间会增长的非常快，而且很多空间都是浪费的。<br>于是undo页就被设计的可以<strong>重用</strong>了，当事务提交时，并不会立刻删除undo页。因为重用，所以这个undo页可能混杂着其他事务的undo log。undo log在commit后，会被放到一个<strong>链表</strong>中，然后判断undo页的使用空间是否小于<strong>3/4</strong>，如果小于3/4的话，则表示当前的undo页可以被重用，那么它就不会被回收，其他事务的undo log可以记录在当前undo页的后面。由于undo log是<strong>离散的</strong>，所以清理对应的磁盘空间时，效率不高。<br><strong>2、回滚段与事务</strong></p><ul><li>每个事务只会使用一个回滚段，一个回滚段在同一时刻可能会服务于多个事务。</li><li>当一个事务开始的时候，会制定一个回滚段，在事务进行的过程中，当数据被修改时，原始的数 据会被复制到回滚段</li><li>在回滚段中，事务会不断填充盘区，直到事务结束或所有的空间被用完。如果当前的盘区不够 用，事务会在段中请求扩展下一个盘区，如果所有已分配的盘区都被用完，事务会覆盖最初的盘 区或者在回滚段允许的情况下扩展新的盘区来使用。</li><li>回滚段存在于undo表空间中，在数据库中可以存在多个undo表空间，但同一时刻只能使用一个 undo表空间。 undo log的数量，最少为2，undo log的truncate操作有purge协调线程发起。在truncate某个undo log表空间的过程中，保证有一个可用的undo log可用</li><li>当事务提交时，InnoDB存储引擎会做以下两件事情：将undo log放入列表中，以供之后的purge操作；判断undo log所在的页是否可以重用，若可以分配给下个事务使用</li></ul><p><strong>3、回滚段中的数据分类</strong></p><ul><li><code>未提交的回滚数据(uncommitted undo information)</code>：该数据所关联的事务并未提交，用于实现读一致性，所以该数据不能被其他事务的数据覆盖。</li><li><code>已经提交但未过期的回滚数据(committed undo information)</code>：该数据关联的事务已经提交，但是仍受到undo retention参数的保持时间的影响。</li><li><code>事务已经提交并过期的数据(expired undo information)</code>：事务已经提交，而且数据保存时间已经超过 undo retention参数指定的时间，属于已经过期的数据。当回滚段满了之后，就优先覆盖“事务已经提交并过期的数据&quot;。</li></ul><p>事务提交后不能马上删除undo log及undo log所在的页。这是因为可能还有其他事务需要通过undo log来得到行记录之前的版本。故事务提交时将undo log放入一个链表中，是否可以最终删除undo log以undo log所在页由purge线程来判断</p><h3 id="3-4-undo的类型">3.4 undo的类型</h3><p>在InnoDB存储引擎中，undo log分为：</p><ul><li><code>insert undo log</code>。insert undo log是指insert操作中产生的undo log。因为insert操作的记录，只对事务本身可见，对其他事务不可见（这是事务隔离性的要求），故该undo log可以在事务提交后直接删除。不需要进行purge操作。</li><li><code>update undo log</code>。update undo log记录的是对delete和update操作产生的undo log。该undo log可能需要提供MVCC机制，因此不能在事务提交时就进行删除。<strong>提交时放入undo log链表</strong>，等待purge线程进行最后的删除。</li></ul><h3 id="3-5-undo-log的生命周期">3.5 undo log的生命周期</h3><p><strong>1、简要生成过程</strong><br>以下是undo+redo事务的简化过程，假设有两个数值，分别为A=1和B=2，然后将A修改为3，B修改为4</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line">记录A=1到undo log;</span><br><span class="line"><span class="keyword">update</span> A = <span class="number">3</span>;</span><br><span class="line">记录A=3 到redo log:</span><br><span class="line">记录B=2到undo log:</span><br><span class="line"><span class="keyword">update</span> B = <span class="number">4</span>;</span><br><span class="line">记录B =4到redo log;</span><br><span class="line">将redo log刷新到磁盘</span><br><span class="line"><span class="keyword">commit</span></span><br></pre></td></tr></table></figure><ul><li>在1-8步骤的任意一步系统宕机，事务未提交，该事务就不会对磁盘上的数据做任何影响</li><li>如果在8-9之间宕机，恢复之后可以选择回滚，也可以选择继续完成事务提交，因为此时redo log已经持久化</li><li>若在9之后系统宕机，内存映射中变更的数据还来不及刷回磁盘，那么系统恢复之后，可以根据redo log把数据刷回磁盘。</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/8159a2da49a514f5100186599ec87ddf.png" alt="image-20220711162642305.png"><br><strong>2、详细生成过程</strong><br><img src="https://img-blog.csdnimg.cn/img_convert/ab30f97d6272556124dd8488d7445b4c.png" alt="image-20220711162919157.png"><br>对应更新的操作会产生update undo log，并且会分更新主键和不更新主键的，对于不更新主键的，这时会把老的记录写入新的undo log，让回滚指针指向新的undo log，它的undo no是1，并且新的undo log会指向老的undo log（undo no=0）<br><img src="https://img-blog.csdnimg.cn/img_convert/9d033f40f8f2b15773dfeea7956d53db.png" alt="image-20220711164138414.png"><br>对于更新主键的操作，会先把原来的数据deletemark标识打开，这时并没有真正的删除数据，真正的删除会交给清理线程去判断，然后在后面插入一条新的数据，新的数据也会产生undo log，并且undo log的序号会递增<br><img src="https://img-blog.csdnimg.cn/img_convert/23038c6563ea1b105f626802c3295dc4.png" alt="image-20220711164421494.png"><br>可以发现每次对数据的变更都会产生一个undo log，当一条记录被变更多次时，那么就会产生多条undo log，undo log记录的是变更前的日志，并且每个undo log的序号是递增的，那么当要回滚的时候，按照序号依次向前推，就可以找到我们的原始数据了<br><strong>3、undo log是如何回滚的</strong><br>以上面的例子来说，假设执行rollback，那么对应的流程应该是这样：</p><ul><li>通过undo no=3的日志把id=2的数据删除</li><li>通过undo no=2的日志把id=1的数据的deletemark还原成0</li><li>通过undo no=1的日志把id=1的数据的name还原成Tom通过undo no=0的日志把id=1的数据删除</li></ul><p><strong>4、undo log的删除</strong></p><ul><li>针对于insert undo log。因为insert操作的记录，只对事务本身可见，对其他事务不可见。故该undo log可以在事务提交后直接删除，不需要进行purge操作。</li><li>针对于update undo log。该undo log可能需要提供MVCC机制，因此不能在事务提交时就进行删除。提交时放入undo log链表，等待purge线程进行最后的删除。</li></ul><h3 id="3-6-小结">3.6 小结</h3><ul><li>undo log是逻辑日志，对事务回滚时，只是将数据库逻辑地恢复到原来的样子</li><li>redo log是物理日志，记录的是数据页的物理变化，undo log不是redo log的逆过程</li></ul><h1>三、锁</h1><h2 id="1、概述-v2">1、概述</h2><p><strong>锁</strong>是计算机协调多个进程或线程<strong>并发访问某一资源</strong>的机制。在程序开发中会存在多线程同步的问题，当多个线程并发访问某个数据的时候，尤其是针对一些敏感的数据（比如订单、金额等)，我们就需要保证这个数据在任何时刻<strong>最多只有一个线程</strong>在访问，保证数据的<strong>完整性</strong>和<strong>一致性</strong>。在开发过程中加锁是为了保证数据的一致性，这个思想在数据库领域中同样很重要。<br>在数据库中，除传统的计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供许多用户共享的 资源。为保证数据的一致性，需要对 并发操作进行控制 ，因此产生了 锁 。同时 锁机制 也为实现MySQL 的各个隔离级别提供了保证。 锁冲突 也是影响数据库 并发访问性能 的一个重要因素。所以锁对数据库而言显得尤其重要，也更加复杂。</p><h2 id="2、MySQL并发事务访问相同记录">2、MySQL并发事务访问相同记录</h2><h3 id="2-1-读-读情况">2.1 读-读情况</h3><p>读-读情况，即并发事务相继读取相同的记录。读取操作本身不会对记录有任何影响，并不会引起什么问题，所以允许这种情况的发生</p><h3 id="2-2-写-写情况">2.2 写-写情况</h3><p>写-写 情况，即并发事务相继对相同的记录做出改动，在这种情况下会发生 脏写 的问题，任何一种隔离级别都不允许这种问题的发生。所以在多个未提交事务相继对一条记录做改动时，需要让它们 排队执行 ，这个排队的过程其实是通过 锁 来实现的。这个所谓的锁其实是一个内存中的结构 ，在事务执行前本来是没有锁的，也就是说一开始是没有 锁结构 和记录进 行关联的，当一个事务想对这条记录做改动时，首先会看看内存中有没有与这条记录关联的 锁结构 ，当没有的时候 就会在内存中生成一个 锁结构 与之关联。比如，事务T1 要对这条记录做改动，就需要生成一个 锁结构 与之关联<br><img src="https://img-blog.csdnimg.cn/img_convert/f297073de2c39b94711af16f4e0b95aa.png" alt="image-20220711192633239.png"></p><p>在<code>锁结构</code>里有很多信息，为了简化理解，只把两个比较重要的属性拿了出来</p><ul><li><code>trx信息</code>：代表这个锁结构是哪个事务生成的。</li><li><code>is_waiting</code>：代表当前事务是否在等待</li></ul><p>在事务<code>T1</code>改动了这条记录后，就生成了一个<code>锁结构</code>与该记录关联，因为之前没有别的事务为这条记录加锁，所以<code>is_waiting</code>属性就是<code>false</code>，我们把这个场景就称值为<code>获取锁成功</code>，或者<code>加锁成功</code>，然后就可以继续执行操作了。在事务<code>T1</code>提交之前，另一个事务<code>T2</code>也想对该记录做改动，那么先看看有没有<code>锁结构</code>与这条记录关联，发现有一个<code>锁结构</code>与之关联后，然后也生成了一个锁结构与这条记录关联，不过锁结构的<code>is_waiting</code>属性值为<code>true</code>，表示当前事务需要等待，我们把这个场景就称之为<code>获取锁失败</code>，或者<code>加锁失败</code><br><img src="https://img-blog.csdnimg.cn/img_convert/d0bc50389caf2e0a2f40fb18438bc990.png" alt="image-20220711193732567.png"><br>在事务T1提交之后，就会把该事务生成的锁结构释放掉，然后看看还有没有别的事务在等待获取锁，发现了事务T2还在等待获取锁，所以把事务T2对应的锁结构的is_waiting属性设置为false，然后把该事务对应的线程唤醒，让它继续执行，此时事务T2就算获取到锁了<br><strong>小结</strong></p><ul><li>不加锁，意思就是不需要在内存中生成对应的 <code>锁结构</code> ，可以直接执行操作。</li><li>获取锁成功，或者加锁成功，意思就是在内存中生成了对应的 <code>锁结构</code> ，而且锁结构的 <code>is_waiting</code> 属性为 <code>false</code> ，也就是事务 可以继续执行操作。</li><li>获取锁失败，或者加锁失败，或者没有获取到锁，意思就是在内存中生成了对应的 <code>锁结构</code> ，不过锁结构的 <code>is_waiting</code> 属性为 <code>true</code> ，也就是事务 需要等待，不可以继续执行操作。</li></ul><h3 id="2-3-读-写或写-读情况">2.3 读-写或写-读情况</h3><p>读-写 或 写-读，即一个事务进行读取操作，另一个进行改动操作。这种情况下可能发生 脏读 、 不可重 复读 、 幻读 的问题。各个数据库厂商对 SQL标准 的支持都可能不一样。比如MySQL在 REPEATABLE READ 隔离级别上就已经解决了 幻读 问题</p><h3 id="2-4-并发问题的解决方案">2.4 并发问题的解决方案</h3><p><strong>方案一：读操作利用多版本并发控制（ MVCC ，下章讲解），写操作进行 加锁</strong><br>所谓的<code>MVCC</code>，就是生成一个<code>ReadView</code>，通过ReadView找到符合条件的记录版本（历史版本由<code>undo日志</code>构建)。查询语句只能读到在生成ReadView之前<code>已提交事务所做的更改</code>，在生成ReadView之前未提交的事务或者之后才开启的事务所做的更改是看不到的。而写操作肯定针对的是<code>最新版本的记录</code>，读记录的历史版本和改动记录的最新版本本身并不冲突，也就是采用MVCC时，<code>读-写</code>操作并不冲突。<br>普通的SELECT语句在READ COMMITTED和REPEATABLE READ隔离级别下会使用到MVCC读取记录。</p><ul><li>在 <code>READ COMMITTED</code> 隔离级别下，一个事务在执行过程中每次执行SELECT操作时都会生成一 个ReadView，ReadView的存在本身就保证了<code>事务不可以读取到未提交的事务所做的更改</code> ，也就是避免了脏读现象；</li><li>在 <code>REPEATABLE READ</code> 隔离级别下，一个事务在执行过程中只有 <code>第一次执行SELECT操作</code> 才会生成一个ReadView，之后的SELECT操作都 <code>复用</code> 这个ReadView，这样也就避免了不可重复读和幻读的问题。</li></ul><p><strong>方案二：读、写操作都采用 加锁 的方式</strong><br>如果我们的一些业务场景不允许读取记录的旧版本，而是每次都必须去<strong>读取记录的最新版本</strong>。比如，在银行存款的事务中，你需要先把账户的余额读出来，然后将其加上本次存款的数额，最后再写到数据库中。在将账户余额读取出来后，就不想让别的事务再访问该余额，直到本次存款事务执行完成，其他事务才可以访问账户的余额。这样在读取记录的时候就需要对其进行<strong>加锁</strong>操作，这样也就意味着<strong>读操作和写操作也像写-写操作那样排队执行</strong>。<br><strong>脏读</strong>的产生是因为当前事务读取了另一个未提交事务写的一条记录，如果另一个事务在写记录的时候就给这条记录加锁，那么当前事务就无法继续读取该记录了，所以也就不会有脏读问题的产生了。<br><strong>不可重复读</strong>的产生是因为当前事务先读取一条记录，另外一个事务对该记录做了改动之后并提交之后，当前事务再次读取时会获得不同的值，如果在当前事务读取记录时就给该记录加锁，那么另一个事务就无法修改该记录，自然也不会发生不可重复读了。<br><strong>幻读</strong>问题的产生是因为当前事务读取了一个范围的记录，然后另外的事务向该范围内插入了新记录，当前事务再次读取该范围的记录时发现了新插入的新记录。采用加锁的方式解决幻读问题就有一些麻烦，因为当前事务在第一次读取记录时幻影记录并不存在，所以读取的时候加锁就有点尴尬（因为你并不知道给谁加锁)。<br><strong>小结对比发现</strong></p><ul><li>采用 <code>MVCC</code> 方式的话， 读-写 操作彼此并不冲突， 性能更高 。</li><li>采用 <code>加锁</code> 方式的话， 读-写 操作彼此需要 <code>排队执行</code> ，影响性能。</li></ul><p>一般情况下我们当然愿意采用 <code>MVCC</code> 来解决 <code>读-写</code> 操作并发执行的问题，但是业务在某些特殊情况下，要求必须采用 <code>加锁</code>的方式执行。下面就讲解下MySQL中不同类别的锁。</p><h2 id="3、锁的不同角度分类">3、锁的不同角度分类</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/45b82f67617450175521419008bd7349.png" alt="image-20220711203519162.png"></p><h3 id="3-1-从数据操作的类型划分：读锁、写锁">3.1 从数据操作的类型划分：读锁、写锁</h3><p>对于数据库中并发事务的<code>读-读</code>情况并不会引起什么问题。对于<code>写-写、读-写或写-读</code>这些情况可能会引起一些问题，需要使用<code>MVCC</code>或者<code>加锁</code>的方式来解决它们。在使用加锁的方式解决问题时，由于既要允许读-读情况不受影响，又要使<code>写-写、读-写或写-读</code>情况中的操作相互阻塞，所以MySQL实现一个由两种类型的锁组成的锁系统来解决。这两种类型的锁通常被称为<strong>共享锁(Shared Lock，SLock)和排他锁（Exclusive Lock，XLock)，也叫读锁(readlock)和写锁(write lock)</strong>。</p><ul><li><code>读锁</code> ：也称为 <code>共享锁</code> 、英文用 S 表示。针对同一份数据，多个事务的读操作可以同时进行而不会互相影响，相互不阻塞的。</li><li><code>写锁</code> ：也称为 <code>排他锁</code> 、英文用 X 表示。当前写操作没有完成前，它会阻断其他写锁和读锁。这样 就能确保在给定的时间里，只有一个事务能执行写入，并防止其他用户读取正在写入的同一资源</li></ul><p><strong>需要注意的是对于 InnoDB 引擎来说，读锁和写锁可以加在表上，也可以加在行上</strong><br><strong>1、锁定读</strong><br><img src="https://img-blog.csdnimg.cn/img_convert/540da7c2bef2b48c6b0a794be878a043.png" alt="image-20220711212931912.png"><br><img src="https://img-blog.csdnimg.cn/img_convert/85ca2b14b42df08ec50fde07b8ee4899.png" alt="image-20220711213741630.png"><br><strong>2、写操作</strong><br><img src="https://img-blog.csdnimg.cn/img_convert/8982ff5f8999b7be69f7a9bc74855222.png" alt="image-20220711214412163.png"></p><h3 id="3-2-从数据操作的粒度划分：表级锁、页级锁、行锁">3.2 从数据操作的粒度划分：表级锁、页级锁、行锁</h3><p>为了尽可能提高数据库的并发度，每次锁定的数据范围越小越好,理论上每次只锁定当前操作的数据的方案会得到最大的并发度，但是管理锁是很耗资源的事情（涉及获取、检查、释放锁等动作)。因此数据库系统需要在<strong>高并发响应</strong>和<strong>系统性能</strong>两方面进行平衡，这样就产生了“<strong>锁粒度(Lock granularity)</strong>”的概念。<br>对一条记录加锁影响的也只是这条记录而已，我们就说这个锁的粒度比较细;其实一个事务也可以在表级别进行加锁，自然就被称之为<strong>表级锁</strong>或者表锁，对一个表加锁影响整个表中的记录，我们就说这个锁的粒度比较粗。锁的粒度主要分为<strong>表级锁、页级锁和行锁</strong>。</p><h4 id="1、表锁（Table-Lock）">1、表锁（Table Lock）</h4><blockquote><p>该锁会锁定整张表，它是MySQL中最基本的锁策略，并不依赖于存储引擎〈不管你是MysQL的什么存储引擎，对于表锁的策略都是一样的)，并且表锁是开销最小的策略（因为粒度比较大)。由于表级锁一次会将整个表锁定，所以可以很好的避免死锁问题。当然，锁的粒度大所带来最大的负面影响就是出现锁资源争用的概率也会最高，导致并发率大打折扣。</p></blockquote><p>①<strong>表级别的S锁、X锁</strong><br>在对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，InnoDB存储引擎是不会为这个表添加表级别的 <code>S锁</code> 或者 <code>X锁</code> 的。在对某个表执行一些诸如 <code>ALTER TABLE 、 DROP TABLE</code> 这类的 DDL 语句时，其 他事务对这个表并发执行诸如SELECT、INSERT、DELETE、UPDATE的语句会发生阻塞。同理，某个事务中对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，在其他会话中对这个表执行 <code>DDL</code> 语句也会 发生阻塞。这个过程其实是通过在 server层使用一种称之为 <code>元数据锁</code> （英文名： Metadata Locks ， 简称 MDL ）结构来实现的。<br>一般情况下，不会使用InnoDB存储引擎提供的表级别的 <code>S锁</code> 和 <code>X锁</code> 。只会在一些特殊情况下，比方说 <code>崩溃恢复</code> 过程中用到。比如，在系统变量 <code>autocommit=0，innodb_table_locks = 1</code> 时， 手动 获取 InnoDB存储引擎提供的表t 的 <code>S锁</code> 或者 <code>X锁</code> 可以这么写：</p><ul><li><code>LOCK TABLES t READ</code> ：InnoDB存储引擎会对表 t 加表级别的 <code>S锁</code>。</li><li><code>LOCK TABLES t WRITE</code> ：InnoDB存储引擎会对表 t 加表级别的 <code>X锁</code> 。</li></ul><p>不过尽量避免在使用InnoDB存储引擎的表上使用 <code>LOCK TABLES</code> 这样的手动锁表语句，它们并不会提供 什么额外的保护，只是会降低并发能力而已。InnoDB的厉害之处还是实现了更细粒度的 <code>行锁</code> ，关于 InnoDB表级别的 <code>S锁</code> 和<code>X锁</code> 大家了解一下就可以了。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 下面我们讲解MyISAM引擎下的表锁</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mylock(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> PRIMARY <span class="keyword">KEY</span> auto_increment,</span><br><span class="line"><span class="keyword">NAME</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">)<span class="keyword">ENGINE</span> myisam;</span><br><span class="line"><span class="comment">-- 插入一条数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mylock(<span class="keyword">NAME</span>) <span class="keyword">VALUES</span>(<span class="string">'a'</span>);</span><br><span class="line"><span class="comment">-- 查询表中所有数据</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> mylock;</span><br><span class="line"><span class="comment">-- 查看表上加过的锁</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">OPEN</span> <span class="keyword">TABLES</span>; <span class="comment">-- 主要关注In_use字段的值</span></span><br><span class="line"><span class="comment">-- 或者</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">OPEN</span> <span class="keyword">TABLES</span> <span class="keyword">where</span> In_use &gt; <span class="number">0</span>;</span><br><span class="line"><span class="comment">-- 手动增加表锁命令</span></span><br><span class="line"><span class="keyword">LOCK</span> <span class="keyword">TABLES</span> t <span class="keyword">READ</span>; <span class="comment">-- 存储引擎会对表t加表级别的共享锁。共享锁也叫读锁或S锁（Share的缩写）</span></span><br><span class="line"><span class="keyword">LOCK</span> <span class="keyword">TABLES</span> t WRITE; <span class="comment">-- 存储引擎会对表t加表级别的排他锁。排他锁也叫独占锁、写锁或X锁（exclusive的缩写）</span></span><br><span class="line"><span class="comment">-- 释放表锁</span></span><br><span class="line"><span class="keyword">UNLOCK</span> <span class="keyword">TABLES</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- MyISAM在执行查询语句（SELECT）前，会给涉及的所有表加读锁，在执行增删改操作前，会给涉及的表加写锁。InnoDB存储引擎是不会为这个表添加表级别的读锁和写锁的。</span></span><br><span class="line"><span class="comment">-- MySQL的表级锁有两种模式：（以MyISAM表进行操作的演示）</span></span><br><span class="line"><span class="comment">-- 表共享读锁（Table Read Lock）</span></span><br><span class="line"><span class="comment">-- 表独占写锁（Table Write Lock）</span></span><br></pre></td></tr></table></figure><p>② <strong>意向锁 （intention lock）</strong><br>InnoDB 支持 <code>多粒度锁（multiple granularity locking）</code> ，它允许 <code>行级锁</code> 与 <code>表级锁</code> 共存，而<code>意向锁</code>就是其中的一种 <code>表锁</code></p><ol><li>意向锁的存在是为了协调行锁和表锁的关系，支持多粒度（表锁和行锁）的锁并存。</li><li>意向锁是一种<code>不与行级锁冲突表级锁</code>，这一点非常重要。</li><li>表明“某个事务正在某些行持有了锁或该事务准备去持有锁”</li></ol><p>意向锁分为两种：</p><ul><li><strong>意向共享锁</strong>（intention shared lock, IS）：事务有意向对表中的某些行加<strong>共享锁</strong>（S锁），<code>SELECT column FROM table ... LOCK IN SHARE MODE;</code></li><li><strong>意向排他锁</strong>（intention exclusive lock, IX）：事务有意向对表中的某些行加<strong>排他锁</strong>（X锁），<code>SELECT column FROM table ... FOR UPDATE;</code></li></ul><p><strong>意向锁要解决的问题：</strong><br>在数据表的场景中，<strong>如果我们给某一行数据加上了排它锁，数据库会自动给更大一级的空间，比如数据页或数据表加上意向锁，告诉其他人这个数据页或数据表已经有人上过排它锁了</strong>，这样当其他人想要获取数据表排它锁的时候，只需要了解是否有人已经获取了这个数据表的意向排他锁即可。</p><ul><li>如果事务想要获得数据表中某些记录的共享锁，就需要在数据表上<strong>添加意向共享锁</strong></li><li>如果事务想要获得数据表中某些记录的排他锁，就需要在数据表上<strong>添加意向排他锁</strong></li></ul><p>这时，意向锁会告诉其他事务已经有人锁定了表中的某些记录。<br><strong>意向锁的并发性：</strong><br>意向锁不会与行级的共享 / 排他锁互斥！正因为如此，意向锁并不会影响到多个事务对不同数据行加排他锁时的并发性。（不然我们直接用普通的表锁就行了）<br><strong>总结：</strong></p><ol><li>InnoDB 支持 <code>多粒度锁</code> ，特定场景下，行级锁可以与表级锁共存。</li><li>意向锁之间互不排斥，但除了 IS 与 S 兼容外， <code>意向锁会与 共享锁 / 排他锁 互斥</code> 。</li><li>IX，IS是表级锁，不会和行级的X，S锁发生冲突。只会和表级的X，S发生冲突。</li><li>意向锁在保证并发性的前提下，实现了 <code>行锁和表锁共存</code> 且 <code>满足事务隔离性</code> 的要求</li></ol><p><strong>③ 自增锁（AUTO-INC锁）</strong><br><strong>1. “Simple inserts” （简单插入）</strong><br>可以 预先确定要插入的行数 （当语句被初始处理时）的语句。包括没有嵌套子查询的单行和多行INSERT…VALUES()和 REPLACE 语句。比如我们上面举的例子就属于该类插入，已经确定要插入的行 数。<br><strong>2. “Bulk inserts” （批量插入）</strong><br>事先不知道要插入的行数 （和所需自动递增值的数量）的语句。比如 INSERT … SELECT ， REPLACE … SELECT 和 LOAD DATA 语句，但不包括纯INSERT。 InnoDB在每处理一行，为AUTO_INCREMENT列<br><strong>3. “Mixed-mode inserts” （混合模式插入）</strong><br>这些是“Simple inserts”语句但是指定部分新行的自动递增值。例如 INSERT INTO teacher (id,name) VALUES (1,‘a’), (NULL,‘b’), (5,‘c’), (NULL,‘d’); 只是指定了部分id的值。另一种类型的“混合模式插入”是 INSERT … ON DUPLICATE KEY UPDATE 。<br>MySQL中采用了自增锁的方式来实现，<strong>AUTO-INC锁是当向使用含有AUTO_INCREMENT列的表中插入数据时需要获取的一种特殊的表级锁</strong>，在执行插入语句时就在表级别加一个AUTO-INC锁，然后为每条待插入记录的AUTo_INCREMENT修饰的列分配递增的值，在该语句执行结束后，再把AUTO-INC锁释放掉。<strong>一个事务在持有AUTO-INC锁的过程中，其他事务的插入语句都要被阻塞</strong>，可以保证一个语句中分配的递增值是连续的。也正因为此，其并发性显然并不高，<strong>当我们向一个有AUTO_INCREMENT关键字的主键插入值的时候，每条语句都要对这个表锁进行竞争</strong>，这样的并发潜力其实是很低下的，所以innodb通过<code>innodb_autoinc_lock_mode</code>的不同取值来提供不同的锁定机制，来显著提高SQL语句的可伸缩性和性能。innodb_autoinc_lock_mode有三种取值，分别对应与不同锁定模式：<br><strong>（1）innodb_autoinc_lock_mode = 0(“传统”锁定模式)</strong><br>在此锁定模式下，所有类型的insert语句都会获得一个特殊的表级AUTO-INC锁，用于插入具有 AUTO_INCREMENT列的表。这种模式其实就如我们上面的例子，即每当执行insert的时候，都会得到一个 表级锁(AUTO-INC锁)，使得语句中生成的auto_increment为顺序，且在binlog中重放的时候，可以保证 master与slave中数据的auto_increment是相同的。因为是表级锁，当在同一时间多个事务中执行insert的 时候，对于AUTO-INC锁的争夺会 限制并发 能力。<br><strong>（2）innodb_autoinc_lock_mode = 1(&quot;连续&quot;锁定模式)</strong><br>在 MySQL 8.0 之前，连续锁定模式是 默认 的。在这个模式下，“bulk inserts”仍然使用AUTO-INC表级锁，并保持到语句结束。这适用于所有INSERT … SELECT，REPLACE … SELECT和LOAD DATA语句。同一时刻只有一个语句可以持有AUTO-INC锁。<br>对于“Simple inserts”（要插入的行数事先已知），则通过在 mutex（轻量锁） 的控制下获得所需数量的自动递增值来避免表级AUTO-INC锁， 它只在分配过程的持续时间内保持，而不是直到语句完成。不使用表级AUTO-INC锁，除非AUTO-INC锁由另一个事务保持。如果另一个事务保持AUTO-INC锁，则“Simple inserts”等待AUTO-INC锁，如同它是一个“bulk inserts”。<br><strong>（3）innodb_autoinc_lock_mode = 2(“交错”锁定模式)</strong><br>从 MySQL 8.0 开始，交错锁模式是 默认 设置。在此锁定模式下，自动递增值 保证 在所有并发执行的所有类型的insert语句中是 唯一 且 单调递增 的。但是，由于多个语句可以同时生成数字（即，跨语句交叉编号），<strong>为任何给定语句插入的行生成的值可能不是连续的。</strong><br>如果执行的语句是“simple inserts&quot;，其中要插入的行数已提前知道，除了&quot;Mixed-mode inserts&quot;之外，为单个语句生成的数字不会有间隙。然后，当执行&quot;bulk inserts&quot;时，在由任何给定语句分配的自动递增值中可能存在间隙。<br><strong>④ 元数据锁（MDL锁）</strong><br>MySQL5.5引入了meta data lock，简称MDL锁，属于表锁范畴。MDL 的作用是，保证读写的正确性。比 如，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个 表结构做变更 ，增加了一 列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。因此，<strong>当对一个表做增删改查操作的时候，加 MDL读锁；当要对表做结构变更操作的时候，加 MDL 写锁</strong>。<br>读锁之间不互斥，因此你可以有多个线程同时对一张表增删查改。读写锁之间、写锁之间都是互斥的，用来保证变更表结构操作的安全性，解决了DML和DDL操作之间的一致性问题。不需要显式使用，在访问一个表的时候会被自动加上。</p><h4 id="2、InnoDB中的行锁">2、InnoDB中的行锁</h4><p>行锁（Row Lock）也称为记录锁，顾名思义，就是锁住某一行（某条记录 row）。需要注意的是，MySQL服务器层并没有实现行锁机制，<strong>行级锁只在存储引擎层实现</strong>。<br>**优点：**锁定力度小，发生锁冲突概率低，可以实现的并发度高。<br>**缺点：**对于锁的开销比较大，加锁会比较慢，容易出现死锁情况。<br>InnoDB与MyISAM的最大不同有两点：一是支持事物（TRANSACTION）；二是采用了行级锁。<br><strong>① 记录锁（Record Locks）</strong><br>记录锁也就是仅仅把一条记录锁，官方的类型名称为：LOCK_REC_NOT_GAP。记录锁是有S锁和X锁之分的，称之为 <code>S型记录锁</code> 和 <code>X型记录锁</code> 。</p><ul><li>当一个事务获取了一条记录的S型记录锁后，其他事务也可以继续获取该记录的S型记录锁，但不可以继续获取X型记录锁；</li><li>当一个事务获取了一条记录的X型记录锁后，其他事务既不可以继续获取该记录的S型记录锁，也不可以继续获取X型记录锁。</li></ul><p><strong>② 间隙锁（Gap Locks）</strong><br>MySQL 在 REPEATABLE READ 隔离级别下是可以解决幻读问题的，解决方案有两种，可以使用 MVCC 方 案解决，也可以采用 加锁方案解决。但是在使用加锁方案解决时有个大问题，就是事务在第一次执行读取操作时，那些幻影记录尚不存在，我们无法给这些 幻影记录 加上 记录锁 。InnoDB提出了一种称之为 Gap Locks 的锁，官方的类型名称为：LOCK_GAP ，我们可以简称为 gap锁<br>**gap锁的提出仅仅是为了防止插入幻影记录而提出的。**虽然有共享gap锁和独占gap锁这样的说法，但是它们起到的作用是相同的。而且如果对一条记录加了gap锁（不论是共享gap锁还是独占gap锁），并不会限制其他事务对这条记录加记录锁或者继续加gap锁。<br><strong>③ 临键锁（Next-Key Locks）</strong><br>有时候我们既想 锁住某条记录 ，又想 阻止 其他事务在该记录前边的 间隙插入新记录 ，所以InnoDB就提 出了一种称之为 Next-Key Locks 的锁，官方的类型名称为： LOCK_ORDINARY ，我们也可以简称为 next-key锁 。Next-Key Locks是在存储引擎 innodb 、事务级别在 可重复读 的情况下使用的数据库锁， innodb默认的锁就是Next-Key locks。<br>next-key锁的本质就是一个记录锁和一个gap锁的合体，它既能保护该条记录，又能阻止别的事务将新记录插入被保护记录前边的间隙<br><strong>④ 插入意向锁</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">id</span> &lt;=<span class="number">8</span> <span class="keyword">and</span> <span class="keyword">id</span> &gt; <span class="number">3</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure><p>我们说一个事务在<strong>插入</strong>一条记录时需要判断一下插入位置是不是被别的事务加了<strong>gap锁</strong>( next-key锁也包含gap锁），如果有的话，插入操作需要等待，直到拥有gap锁的那个事务提交。但是<strong>InnoDB规定事务在等待的时候也需要在内存中生成一个锁结构</strong>，表明有事务想在某个间隙中插入新记录，但是现在在等待。InnoDB就把这种类型的锁命名为<code>Insert Intention Locks</code>，官方的类型名称为:<code>LOCK_INSERT_INTENTION</code>，我们称为插入意向锁。插入意向锁是一种Gap锁，不是意向锁，在insert操作时产生。<br>插入意向锁是在插入一条记录行前，由 <code>INSERT 操作产生的一种间隙锁</code>。该锁用以表示插入意向，当多个事务在同一区间(gap)插入位置不同的多条数据时，事务之间不需要互相等待。假设存在两条值分别为4和7的记录，两个不同的事务分别试图插入值为5和6的两条记录，每个事务在获取插入行上独占的(排他）锁前，都会获取(4，7)之间的间隙锁，但是因为数据行之间并不冲突，所以两个事务之间并不会产生冲突(阻塞等待)。总结来说，插入意向锁的特性可以分成两部分:</p><ul><li>插入意向锁是一种<strong>特殊的间隙锁</strong>—间隙锁可以锁定开区间内的部分记录。</li><li>插入意向锁之间<strong>互不排斥</strong>，所以即使多个事务在同一区间插入多条记录，只要记录本身（(主键、唯一索引）不冲突，那么事务之间就不会出现冲突等待。</li></ul><p>注意，虽然插入意向锁中含有意向锁三个字，但是它并不属于意向锁而属于间隙锁，因为意向锁是表锁而插入意向锁是<strong>行锁</strong>。</p><h4 id="3、页锁">3、页锁</h4><p>页锁就是在 页的粒度 上进行锁定，锁定的数据资源比行锁要多，因为一个页中可以有多个行记录。当我 们使用页锁的时候，会出现数据浪费的现象，但这样的浪费最多也就是一个页上的数据行。<strong>页锁的开销介于表锁和行锁之间，会出现死锁。锁定粒度介于表锁和行锁之间，并发度一般。</strong><br>每个层级的锁数量是有限制的，因为锁会占用内存空间， 锁空间的大小是有限的 。当某个层级的锁数量 超过了这个层级的阈值时，就会进行 锁升级 。锁升级就是用更大粒度的锁替代多个更小粒度的锁，比如 InnoDB 中行锁升级为表锁，这样做的好处是占用的锁空间降低了，但同时数据的并发度也下降了。</p><h3 id="3-3-从对待锁的态度划分-乐观锁、悲观锁">3.3  从对待锁的态度划分:乐观锁、悲观锁</h3><h4 id="1、悲观锁（Pessimistic-Locking）">1、悲观锁（Pessimistic Locking）</h4><blockquote><p>悲观锁是一种思想，顾名思义，就是很悲观，对数据被其他事务的修改持保守态度，会通过数据库自身的锁机制来实现，从而保证数据操作的排它性。</p></blockquote><p>悲观锁总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会 阻塞 直到它拿到锁（<strong>共享资源每次只给一个线程使用，其它线程阻塞， 用完后再把资源转让给其它线程</strong>）。比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁，当其他线程想要访问数据时，都需要阻塞挂起。Java中 synchronized 和 ReentrantLock 等独占锁就是悲观锁思想的实现。<br><code>select .... for update</code>是MySQL中悲观锁。此时在items表中，id为1001的那条数据就被我们锁定了，其他的要执行<code>select quantity from items where id = 1001 for update;</code>语句的事务必须等本次事务提交之后才能执行。这样我们可以保证当前的数据不会被其它事务修改。注意，当执行select quantity from items where id = 1001 for update;语句之后，如果在其他事务中执行selectquantity from items where id = 1001;语句，并不会受第一个事务的影响，仍然可以正常查询出数据。<strong>注意: select … for update语句执行过程中所有扫描的行都会被锁上，因此在MySQL中用悲观锁必须确定使用了索引，而不是全表扫描，否则将会把整个表锁住。</strong><br>悲观锁不适用的场景较多，它存在一些不足，因为悲观锁大多数情况下依靠数据库的锁机制来实现，以保证程序的并发访问性，同时这样对数据库性能开销影响也很大，特别是<code>长事务</code>而言，这样的<code>开销往往无法承受</code>，这时就需要乐观锁。</p><h4 id="2、乐观锁（Optimistic-Locking）">2、乐观锁（Optimistic Locking）</h4><blockquote><p>乐观锁认为对同一数据的并发操作不会总发生，属于小概率事件，不用每次都对数据上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，也就是<strong>不采用数据库自身的锁机制，而是通过程序来实现</strong>。在程序上，我们可以采用 版本号机制 或者 CAS机制 实现。<strong>乐观锁适用于多读的应用类型， 这样可以提高吞吐量</strong>。在Java中java.util.concurrent.atomic 包下的原子变量类就是使用了乐观锁的一种实现方式：CAS实现的</p></blockquote><p><strong>乐观锁的版本号机制</strong><br>在表中设计一个 版本字段 version ，第一次读的时候，会获取 version 字段的取值。然后对数据进行更新或删除操作时，会执行 UPDATE … SET version=version+1 WHERE version=version 。此时 如果已经有事务对这条数据进行了更改，修改就不会成功。这种方式类似我们熟悉的SVN、CVS版本管理系统，当我们修改了代码进行提交时，首先会检查当前版本号与服务器上的版本号是否一致，如果一致就可以直接提交，如果不一致就需要更新服务器上的最新代码，然后再进行提交。<br><strong>乐观锁的时间戳机制</strong><br>时间戳和版本号机制一样，也是在更新提交的时候，将当前数据的时间戳和更新之前取得的时间戳进行 比较，如果两者一致则更新成功，否则就是版本冲突。你能看到乐观锁就是程序员自己控制数据并发操作的权限，基本是通过给数据行增加一个戳（版本号或 者时间戳），从而证明当前拿到的数据是否最新。</p><h4 id="3、两种锁的适用场景">3、两种锁的适用场景</h4><ul><li><code>乐观锁</code> 适合 <code>读操作多</code> 的场景，相对来说写的操作比较少。它的优点在于 <code>程序实现</code> ， <code>不存在死锁</code> 问题，不过适用场景也会相对乐观，因为它阻止不了除了程序以外的数据库操作。</li><li><code>悲观锁</code> 适合 <code>写操作多</code> 的场景，因为写的操作具有 <code>排它性</code> 。采用悲观锁的方式，可以在数据库层 面阻止其他事务对该数据的操作权限，防止 <code>读 - 写</code> 和 <code>写 - 写</code> 的冲突。</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/0dec8a6081b73189478fde102642a922.png" alt="image-20220713211417909.png"></p><h3 id="3-4-按加锁的方式划分：显式锁、隐式锁">3.4 按加锁的方式划分：显式锁、隐式锁</h3><h4 id="1、隐式锁">1、隐式锁</h4><p>一个事务在执行<code>INSERT</code>操作时，如果即将插入的<code>间隙</code>已经被其他事务加了<code>gap锁</code>，那么本次INSERT操作会阻塞，并且当前事务会在该间隙上加一个<code>插入意向锁</code>，否则一般情况下<code>INSERT</code>操作是不加锁的。那如果一个事务首先插入了一条记录（此时并没有在内存生产与该记录关联的锁结构)，然后另一个事务:</p><ul><li>立即使用<code>SELECT ... LOCK IN SHARE MODE</code>语句读取这条记录，也就是要获取这条记录的<code>S锁</code>，或者使用<code>SELECT ... FOR UPDATE</code>语句读取这条记录，也就是要获取这条记录的<code>X锁</code>，怎么办?如果允许这种情况的发生，那么可能产生脏读问题。</li><li>立即修改这条记录，也就是要获取这条记录的X锁，怎么办?如果允许这种情况的发生，那么可能产生脏写问题。</li></ul><p>这时候我们前边提过的<code>事务id</code>又要起作用了。我们把聚簇索引和二级索引中的记录分开看一下:</p><ul><li><strong>情景一</strong>：对于聚簇索引记录来说，有一个 <code>trx_id</code> 隐藏列，该隐藏列记录着最后改动该记录的 <code>事务 id</code> 。那么如果在当前事务中新插入一条聚簇索引记录后，该记录的<code>trx_id</code>隐藏列代表的的就是 当前事务的 事务id ，如果其他事务此时想对该记录添加 S锁 或者 X锁 时，首先会看一下该记录的 <code>trx_id</code> 隐藏列代表的事务是否是当前的活跃事务，如果是的话，那么就帮助当前事务创建一个 <code>X 锁</code> （也就是为当前事务创建一个锁结构， is_waiting 属性是 false ），然后自己进入等待状态 （也就是为自己也创建一个锁结构， is_waiting 属性是 true ）。</li><li><strong>情景二</strong>：对于二级索引记录来说，本身并没有 <code>trx_id</code> 隐藏列，但是在二级索引页面的 Page Header 部分有一个 <code>PAGE_MAX_TRX_ID</code> 属性，该属性代表对该页面做改动的最大的 <code>事务id</code> ，如 果 <code>PAGE_MAX_TRX_ID</code> 属性值小于当前最小的活跃 事务id ，那么说明对该页面做修改的事务都已 经提交了，否则就需要在页面中定位到对应的二级索引记录，然后回表找到它对应的聚簇索引记 录，然后再重复 情景一 的做法。</li></ul><p>即:一个事务对新插入的记录可以不显式的加锁（生成一个锁结构)，但是由于事务id的存在，相当于加了一个隐式锁。别的事务在对这条记录加s锁或者x锁时，由于隐式锁的存在，会先帮助当前事务生成一个锁结构，然后自己再生成一个锁结构后进入等待状态。隐式锁是一种延迟加锁的机制，从而来减少加锁的数量。<strong>隐式锁在实际内存对象中并不含有这个锁信息。只有当产生锁等待时,隐式锁转化为显式锁</strong>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> performance_schema.data_lock_waits\G;</span><br></pre></td></tr></table></figure><p>隐式锁的逻辑过程如下：</p><ul><li>InnoDB的每条记录中都一个隐含的trx_id字段，这个字段存在于聚簇索引的B+Tree中</li><li>在操作一条记录前，首先根据记录中的trx_id检查该事务是否是活动的事务(未提交或回滚)。如果是活动的事务，首先将 隐式锁 转换为 显式锁 (就是为该事务添加一个锁)</li><li>检查是否有锁冲突，如果有冲突，创建锁，并设置为waiting状态。如果没有冲突不加锁，跳到E</li><li>等待加锁成功，被唤醒，或者超时</li><li>写数据，并将自己的trx_id写入trx_id字段</li></ul><h4 id="2、显式锁">2、显式锁</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 通过特定的语句进行加锁，我们一般称之为显示加锁</span></span><br><span class="line"><span class="comment">-- 显示加共享锁</span></span><br><span class="line"><span class="keyword">select</span> .... <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span></span><br><span class="line"><span class="comment">-- 显示加排它锁</span></span><br><span class="line"><span class="keyword">select</span> .... <span class="keyword">for</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure><h3 id="3-5-其它锁之：全局锁">3.5 其它锁之：全局锁</h3><p>全局锁就是对 整个数据库实例 加锁。当你需要让整个库处于 只读状态 的时候，可以使用这个命令，之后 其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结 构等）和更新类事务的提交语句。全局锁的典型使用 场景 是：做 全库逻辑备份</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Flush</span> <span class="keyword">tables</span> <span class="keyword">with</span> <span class="keyword">read</span> <span class="keyword">lock</span></span><br></pre></td></tr></table></figure><h3 id="3-6-其它锁之：死锁">3.6 其它锁之：死锁</h3><blockquote><p>两个事务都持有对方需要的锁，并且在等待对方释放，并且双方都不会释放自己的锁</p></blockquote><h4 id="1、产生死锁的必要条件">1、产生死锁的必要条件</h4><ul><li>两个或者两个以上事务</li><li>每个事务都已经持有锁并且申请新的锁</li><li>锁资源同时只能被同一个事务持有或者不兼容</li><li>事务之间因为持有锁和申请锁导致彼此循环等待</li></ul><h4 id="2、如何处理死锁">2、如何处理死锁</h4><ul><li>等待，直到超时（innodb_lock_wait_timeout=50s)</li><li>使用死锁检测处理死锁程序</li></ul><p>方式1检测死锁太过被动，innodb还提供了wait-for graph算法来主动进行死锁检测，每当加锁请求无法立即满足需要并进入等待时，wait-for graph算法都会被触发。这是一种较为主动的死锁检测机制，要求数据库保存锁的信息链表和事物等待链表两部分信息。一旦检测到回路、有死锁，这时候InnoDB存储引擎会选择回滚undo量最小的事务，让其他事务继续执行（innodb_deadlock_detect=on表示开启这个逻辑）<br>缺点：每个新的被阻塞的线程，都要判断是不是由于自己的加入导致了死锁，这个操作时间复杂度是O(n)。如果100个并发线程同时更新同一行，意味着要检测100*100=1万次，1万个线程就会有1千万次检测。<br><strong>如何解决？</strong></p><ul><li>方式1：关闭死锁检测，但意味着可能会出现大量的超时，会导致业务有损。</li><li>方式2：控制并发访问的数量。比如在中间件中实现对于相同行的更新，在进入引擎之前排队，这样在InnoDB内部就不会有大量的死锁检测工作。</li></ul><p><strong>进一步的思路：</strong><br>可以考虑通过将一行改成逻辑上的多行来减少<code>锁冲突</code>。比如，连锁超市账户总额的记录，可以考虑放到多条记录上。账户总额等于这多个记录的值的总和。</p><h4 id="3、如何避免死锁">3、如何避免死锁</h4><ul><li>合理设计索引，使业务SQL尽可能通过索引定位更少的行，减少锁竞争</li><li>调整业务逻辑SQL执行顺序，避免update/delete长时间持有锁的SQL在事务前面</li><li>避免大事务，尽量将大事务拆成多个小事务来处理，小事务缩短锁定资源的时间，发生锁冲突的几率也更小。</li><li>在并发比较高的系统中，不要显式加锁，特别是是在事务里显式加锁。如select …for update语句，如果是在事务里运行了start transaction或设置了autocommit等于0，那么就会锁定所查找到的记录</li><li>降低隔离级别。如果业务允许，将隔离级别调低也是较好的选择，比如将隔离级别从RR调整为RC，可以避免掉很多因为gap锁造成的死锁</li></ul><h2 id="4、锁的内部结构">4、锁的内部结构</h2><h3 id="4-1-概述">4.1 概述</h3><p>我们前边说对一条记录加锁的本质就是在内存中创建一个锁结构与之关联，那么是不是一个事务对多条记录加锁，就要创建多个锁结构呢，比如<code>SELECT * FROM user LOCK IN SHARE MODE;</code><br>理论上创建多个<code>锁结构</code>没问题，但是如果一个事务要获取10000条记录的锁，生成10000个锁结构也太崩溃了！所以决定在对不同记录加锁时，如果符合下边这些条件的记录会放在一个<code>锁结构</code>中。</p><ul><li>在同一个事务中进行加锁操作</li><li>被加锁的记录在同一个页面中</li><li>加锁的类型是一样的</li><li>等待状态是一样的</li></ul><p><code>InnoDB</code> 存储引擎中的 <code>锁结构</code> 如下：<br><img src="https://img-blog.csdnimg.cn/img_convert/e3935a656e6e72bf9ada8f18772be3cb.png" alt="image-20220714132306208.png"></p><h3 id="4-2-结构解析">4.2 结构解析</h3><p><strong>1、锁所在的事务信息</strong><br>不论是 <code>表锁</code> 还是 <code>行锁</code> ，都是在事务执行过程中生成的，哪个事务生成了这个锁结构 ，这里就记录这个 事务的信息。此 <code>锁所在的事务信息</code> 在内存结构中只是一个指针，通过指针可以找到内存中关于该事务的更多信息，比方说事务id等。<br><strong>2、索引信息</strong><br>对于 <code>行锁</code> 来说，需要记录一下加锁的记录是属于哪个索引的。这里也是一个指针。<br><strong>3、表锁／行锁信息</strong><br><code>表锁结构</code> 和 <code>行锁结构</code> 在这个位置的内容是不同的：</p><ul><li>表锁：<br>记载着是对哪个表加的锁，还有其他的一些信息。</li><li>行锁，记载了三个重要的信息：<ul><li><code>Space ID</code> ：记录所在表空间</li><li><code>Page Number</code> ：记录所在页号</li><li><code>n_bits</code>：对于行锁来说，一条记录就对应着一个比特位，一个页面中包含很多记录，用不同 的比特位来区分到底是哪一条记录加了锁。为此在行锁结构的末尾放置了一堆比特位，这个<code>n_bis</code>属性代表使用了多少比特位。n_bits的值一般都比页面中记录条数多一些。主要是为了之后在页面中插入了新记录后 也不至于重新分配锁结构</li></ul></li></ul><p><strong>4、type_mode</strong><br>这是一个32位的数，被分成了 <code>lock_mode</code> 、 <code>lock_type</code> 和 <code>rec_lock_type</code> 三个部分，如图所示：<br><img src="https://img-blog.csdnimg.cn/img_convert/3e3dc8d663119bda7d4b7f7d5c70c2ee.png" alt="image-20220714133319666.png"></p><ul><li>锁的模式（ <code>lock_mode</code> ），占用低4位，可选的值如下：<ul><li><code>LOCK_IS</code> （十进制的 0 ）：表示共享意向锁，也就是 <code>IS锁</code></li><li><code>LOCK_IX</code> （十进制的 1 ）：表示独占意向锁，也就是 <code>IX锁</code></li><li><code>LOCK_S</code> （十进制的 2 ）：表示共享锁，也就是 <code>S锁</code></li><li><code>LOCK_X</code> （十进制的 3 ）：表示独占锁，也就是 <code>X锁</code></li><li><code>LOCK_AUTO_INC</code> （十进制的 4 ）：表示 <code>AUTO-INC锁</code></li></ul></li></ul><p>在InnoDB存储引擎中，LOCK_IS，LOCK_IX，LOCK_AUTO_INC都算是表级锁的模式，LOCK_S和 LOCK_X既可以算是表级锁的模式，也可以是行级锁的模式。</p><ul><li>锁的类型（ <code>lock_type</code> ），占用第5～8位，不过现阶段只有第5位和第6位被使用：<ul><li><code>LOCK_TABLE</code> （十进制的 16 ），也就是当第5个比特位置为1时，表示表级锁</li><li><code>LOCK_REC</code>（十进制的 32 ），也就是当第6个比特位置为1时，表示行级锁</li></ul></li><li>行锁的具体类型（ <code>rec_lock_type</code> ），使用其余的位来表示。只有在 <code>lock_type</code> 的值为 <code>LOCK_REC</code> 时，也就是只有在该锁为行级锁时，才会被细分为更多的类型：<ul><li><code>LOCK_ORDINARY</code> （十进制的 0 ）：表示 <code>next-key锁</code></li><li><code>LOCK_GAP</code> （十进制的 512 ）：也就是当第10个比特位置为1时，表示 <code>gap锁</code></li><li><code>LOCK_REC_NOT_GAP</code> （十进制的 1024 ）：也就是当第11个比特位置为1时，表示正经 <code>记录锁</code></li><li><code>LOCK_INSERT_INTENTION</code> （十进制的 2048 ）：也就是当第12个比特位置为1时，表示插入意向锁。其他的类型：还有一些不常用的类型我们就不多说了</li></ul></li><li><code>is_waiting</code> 属性呢？基于内存空间的节省，所以把 <code>is_waiting</code> 属性放到了 <code>type_mode</code> 这个32 位的数字中：<ul><li><code>LOCK_WAIT</code> （十进制的 256 ） ：当第9个比特位置为 1 时，表示 <code>is_waiting</code> 为 <code>true</code> ，也 就是当前事务尚未获取到锁，处在等待状态；当这个比特位为 0 时，表示 <code>is_waiting</code> 为 <code>false</code> ，也就是当前事务获取锁成功。</li></ul></li></ul><p><strong>5、其他信息</strong><br>为了更好的管理系统运行过程中生成的各种锁结构而设计了各种哈希表和链表。<br>**6、一堆比特位 **<br>如果是 行锁结构 的话，在该结构末尾还放置了一堆比特位，比特位的数量是由上边提到的 n_bits 属性 表示的。InnoDB数据页中的每条记录在 记录头信息 中都包含一个 heap_no 属性，伪记录 Infimum 的 heap_no 值为 0 ， Supremum 的 heap_no 值为 1 ，之后每插入一条记录， heap_no 值就增1。 锁结 构 最后的一堆比特位就对应着一个页面中的记录，一个比特位映射一个 heap_no ，即一个比特位映射 到页内的一条记录</p><h2 id="5、锁监控">5、锁监控</h2><h3 id="5-1-监控">5.1 监控</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 关于MySQL锁的监控，我们一般可以通过检查 InnoDB_row_lock 等状态变量来分析系统上的行锁的争夺情况</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'innodb_row_lock%'</span>;</span><br></pre></td></tr></table></figure><ul><li>Innodb_row_lock_current_waits：当前正在等待锁定的数量；</li><li><code>Innodb_row_lock_time</code> ：从系统启动到现在锁定总时间长度；（等待总时长）</li><li><code>Innodb_row_lock_time_avg</code> ：每次等待所花平均时间；（等待平均时长）</li><li>Innodb_row_lock_time_max：从系统启动到现在等待最常的一次所花的时间；</li><li><code>Innodb_row_lock_waits</code> ：系统启动后到现在总共等待的次数；（等待总次数）</li></ul><h3 id="5-2-其他监控方法">5.2 其他监控方法</h3><p>MySQL把事务和锁的信息记录在了 information_schema 库中，涉及到的三张表分别是 INNODB_TRX 、 INNODB_LOCKS 和 INNODB_LOCK_WAITS 。MySQL5.7及之前 ，可以通过information_schema.INNODB_LOCKS查看事务的锁情况，但只能看到阻塞事 务的锁；如果事务并未被阻塞，则在该表中看不到该事务的锁情况。<br>MySQL8.0删除了information_schema.INNODB_LOCKS，添加了 performance_schema.data_locks ，可以通过performance_schema.data_locks查看事务的锁情况，和MySQL5.7及之前不同，performance_schema.data_locks不但可以看到阻塞该事务的锁，还可以看到该事务所持有的锁。同时，information_schema.INNODB_LOCK_WAITS也被 performance_schema.data_lock_waits 所代 替。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询正在被锁阻塞的sql语句</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> information_schema.INNODB_TRX\G;</span><br><span class="line"><span class="comment">--查询锁等待情况 </span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> performance_schema.data_lock_waits\G;</span><br><span class="line"><span class="comment">-- 查询锁的情况</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">from</span> performance_schema.data_locks\G;</span><br></pre></td></tr></table></figure><h2 id="6、举例与实战">6、举例与实战</h2><h3 id="6-1-间隙锁加锁规则（共11个案例）">6.1 间隙锁加锁规则（共11个案例）</h3><p>间隙锁是在可重复读隔离级别下才会生效的： <code>next-key lock</code> 实际上是由间隙锁加行锁实现的，如果切换 到读提交隔离级别 (read-committed) 的话，就好理解了，过程中去掉间隙锁的部分，也就是只剩下行锁 的部分。而在读提交隔离级别下间隙锁就没有了，为了解决可能出现的数据和日志不一致问题，需要把 binlog 格式设置为 row 。也就是说，许多公司的配置为：读提交隔离级别加 binlog_format=row。业务不 需要可重复读的保证，这样考虑到读提交下操作数据的锁范围更小（没有间隙锁），这个选择是合理的。<br>**next-key lock的加锁规则，**总结的加锁规则里面，包含了两个&quot;原则&quot;、两个&quot;优化&quot;和一个&quot;bug&quot;</p><ul><li>原则 1 ：加锁的基本单位是 next-key lock 。 next-key lock 是前开后闭区间</li><li>原则 2 ：查找过程中访问到的对象才会加锁。任何辅助索引上的锁，或者非索引列上的锁，最终 都要回溯到主键上，在主键上也要加一把锁</li><li>优化 1 ：索引上的等值查询，给唯一索引加锁的时候， next-key lock 退化为行锁。也就是说如果 InnoDB扫描的是一个主键、或是一个唯一索引的话，那InnoDB只会采用行锁方式来加锁</li><li>优化 2 ：索引上（不一定是唯一索引）的等值查询，向右遍历时且最后一个值不满足等值条件的 时候， next-keylock 退化为间隙锁。</li><li>一个 bug ：唯一索引上的范围查询会访问到不满足条件的第一个值为止</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 首先准备数据</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`test`</span> (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`col1`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`col2`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line"><span class="keyword">KEY</span> <span class="string">`c`</span> (<span class="string">`col1`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span> <span class="keyword">values</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>),</span><br><span class="line">(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>),(<span class="number">15</span>,<span class="number">15</span>,<span class="number">15</span>),(<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>),(<span class="number">25</span>,<span class="number">25</span>,<span class="number">25</span>);</span><br></pre></td></tr></table></figure><h3 id="6-2-11个案例详解">6.2 11个案例详解</h3><p><strong>案例一：唯一索引等值查询间隙锁</strong><br>由于表 test 中没有 id=7 的记录，根据原则 1 ，加锁单位是 next-key lock ， session A 加锁范围就是 (5,10] ； 同时根据优化 2 ，这是一个等值查询 (id=7) ，而 id=10 不满足查询条件， next-key lock 退化成间隙锁，因此最终加锁的范围是 (5,10)</p><table><thead><tr><th>sessionA</th><th>sessionB</th><th>sessionc</th></tr></thead><tbody><tr><td>begin;</td><td></td><td></td></tr><tr><td>update test set col2 = col2+1where id=7;</td><td></td><td></td></tr><tr><td></td><td>insert into test values(8,8,8)(blocked)</td><td></td></tr><tr><td></td><td></td><td>update test set col2 =col2+1 whereid=10;</td></tr><tr><td>(Query OK)</td><td></td><td></td></tr></tbody></table><p><strong>案例二：非唯一索引等值查询锁</strong><br>这里 session A 要给索引 col1 上 col1=5 的这一行加上读锁。</p><ol><li>根据原则 1 ，加锁单位是 next-key lock ，左开右闭，5是闭上的，因此会给 (0,5] 加上 next-key lock 。</li><li>要注意 c 是普通索引，因此仅访问 c=5 这一条记录是不能马上停下来的（可能有col1=5的其他记 录），需要向右遍历，查到c=10 才放弃。根据原则 2 ，访问到的都要加锁，因此要给 (5,10] 加 next-key lock 。</li><li>但是同时这个符合优化 2 ：等值判断，向右遍历，最后一个值不满足 col1=5 这个等值条件，因此退化成间隙锁 (5,10) 。</li><li>根据原则 2 ， 只有访问到的对象才会加锁，这个查询使用覆盖索引，并不需要访问主键索引，所以主键索引上没有加任何锁，这就是为什么 session B 的 update 语句可以执行完成。</li></ol><p>但 session C 要插入一个 (7,7,7) 的记录，就会被 session A 的间隙锁 (5,10) 锁住 这个例子说明，锁是加在索引上的。执行 for update 时，系统会认为你接下来要更新数据，因此会顺便给主键索引上满足条件的行加上行锁。如果你要用 lock in share mode来给行加读锁避免数据被更新的话，就必须得绕过覆盖索引的优化，因为覆盖索引不会访问主键索引，不会给主键索引上加锁</p><table><thead><tr><th>sessionA</th><th>sessionB</th><th>sessionc</th></tr></thead><tbody><tr><td>begin;</td><td></td><td></td></tr><tr><td>select id from test where col1 = 5 lock inshare mode;</td><td></td><td></td></tr><tr><td></td><td>update test col2 =col2+1 where id=5;</td><td></td></tr><tr><td>(Query OK)</td><td></td><td></td></tr><tr><td></td><td></td><td>insert into test values(7,7,7)(blocked)</td></tr></tbody></table><p><strong>案例三：主键索引范围查询锁</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 上面两个例子是等值查询的，这个例子是关于范围查询的，也就是说下面的语句</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">10</span> <span class="keyword">for</span> <span class="keyword">update</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tets <span class="keyword">where</span> <span class="keyword">id</span>&gt;=<span class="number">10</span> <span class="keyword">and</span> <span class="keyword">id</span>&lt;<span class="number">11</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="comment">-- 这两条查语句肯定是等价的，但是它们的加锁规则不太一样</span></span><br></pre></td></tr></table></figure><ul><li>开始执行的时候，要找到第一个 id=10 的行，因此本该是 next-key lock(5,10] 。 根据优化 1 ，主键 id 上的等值条件，退化成行锁，只加了 id=10 这一行的行锁。</li><li>它是范围查询， 范围查找就往后继续找，找到 id=15 这一行停下来，不满足条件，因此需要加 next-key lock(10,15] 。</li></ul><p>session A 这时候锁的范围就是主键索引上，行锁 id=10 和 next-key lock(10,15] 。<strong>首次 session A 定位查找 id=10 的行的时候，是当做等值查询来判断的，而向右扫描到 id=15 的时候，用的是范围查询判断。</strong></p><table><thead><tr><th>sessionA</th><th>sessionB</th><th>sessionc</th></tr></thead><tbody><tr><td>begin;</td><td></td><td></td></tr><tr><td>sclcct * from test where id&gt;= 10 and id&lt;11 for update;</td><td></td><td></td></tr><tr><td></td><td>insert into test values(8,8,8)(Query OK)</td><td></td></tr><tr><td>insert into test values(13,13,13);(blocked)</td><td></td><td></td></tr><tr><td></td><td></td><td>update test set clo2=col2+1where id=15;</td></tr><tr><td>(blocked)</td><td></td><td></td></tr></tbody></table><p><strong>案例四：非唯一索引范围查询锁</strong><br>与案例三不同的是，案例四中查询语句的 where 部分用的是字段 c ，它是普通索引。这两条查语句肯定是等价的，但是它们的加锁规则不太一样。<br>此最终 sesion A 加的锁是，索引 c 上的 (5,10] 和 (10,15] 这两个 next-keylock 。这里需要扫描到 col1=15 才停止扫描，是合理的，因为 InnoDB 要扫到 col1=15 ，才知道不需要继续往后找了。</p><table><thead><tr><th>sessionA</th><th>sessionB</th><th>sessionc</th></tr></thead><tbody><tr><td>begin;</td><td></td><td></td></tr><tr><td>select *from test where col1&gt;= 10 andcol1&lt;11 for update;</td><td></td><td></td></tr><tr><td></td><td>insert into test values(8,8,8)(blocked)</td><td></td></tr><tr><td></td><td></td><td>update test set clo2=col2+1where id=15;</td></tr><tr><td>(blocked)</td><td></td><td></td></tr></tbody></table><p><strong>案例五：唯一索引范围查询锁 bug</strong><br>session A 是一个范围查询，按照原则 1 的话，应该是索引 id 上只加 (10,15] 这个 next-key lock ，并且因 为 id 是唯一键，所以循环判断到 id=15 这一行就应该停止了。<br>但是实现上， InnoDB 会往前扫描到第一个不满足条件的行为止，也就是 id=20 。而且由于这是个范围扫描，因此索引 id 上的 (15,20] 这个 next-key lock 也会被锁上。照理说，这里锁住 id=20 这一行的行为，其实是没有必要的。因为扫描到 id=15 ，就可以确定不用往后再找了。</p><table><thead><tr><th>sessionA</th><th>sessionB</th><th>sessionc</th></tr></thead><tbody><tr><td>begin;</td><td></td><td></td></tr><tr><td>select * from test where id&gt; 10 and id&lt;=15 for update;</td><td></td><td></td></tr><tr><td></td><td>update test set clo2=col2+1where id=20;</td><td></td></tr><tr><td>(blocked)</td><td></td><td></td></tr><tr><td></td><td></td><td>insert into test values(16,16,16);(blocked)</td></tr></tbody></table><p><strong>案例六：非唯一索引上存在&quot;等值&quot;的例子</strong><br>这里，我给表 t 插入一条新记录：insert into t values(30,10,30);也就是说，现在表里面有两个col1=10的行，<strong>但是它们的主键值 id 是不同的（分别是 10 和 30 ），因此这两个col1=10 的记录之间，也是有间隙的。</strong></p><table><thead><tr><th>sessionA</th><th>sessionB</th><th>sessionc</th></tr></thead><tbody><tr><td>begin;</td><td></td><td></td></tr><tr><td>delete from test where col1=10;</td><td></td><td></td></tr><tr><td></td><td>insert into test values(12,12,12);(blocked)</td><td></td></tr><tr><td></td><td></td><td>update test set col2=col2+1 where col1=15;</td></tr><tr><td>(blocked)</td><td></td><td></td></tr></tbody></table><p>这次我们用 delete 语句来验证。注意， delete 语句加锁的逻辑，其实跟 select … for update 是类似的， 也就是我在文章开始总结的两个原则 、两个优化和一个bug。这时， session A 在遍历的时候，先访问第一个 col1=10 的记录。同样地，根据原则 1 ，这里加的是 (col1=5,id=5) 到 (col1=10,id=10) 这个 next-key lock 。<br>由于c是普通索引，所以继续向右查找，直到碰到 (col1=15,id=15) 这一行循环才结束。根据优化 2 ，这是 一个等值查询，向右查找到了不满足条件的行，所以会退化成 (col1=10,id=10) 到 (col1=15,id=15) 的间隙锁。<br><img src="https://img-blog.csdnimg.cn/img_convert/d8bd4d904b98ba9c0074e50bd5833576.png" alt="image-20220714134945012.png"><br>这个 delete 语句在索引 col1 上的加锁范围，就是上面图中蓝色区域覆盖的部分。这个蓝色区域左右两边都 是虚线，表示开区间，即 (col1=5,id=5) 和 (col1=15,id=15) 这两行上都没有锁<br><strong>案例七： limit 语句加锁</strong></p><table><thead><tr><th>sessionA</th><th>sessionB</th></tr></thead><tbody><tr><td>begin;</td><td></td></tr><tr><td>delete from test where col1=10 limit 2;</td><td></td></tr></tbody></table><p>|<br>|<br>| insert into test values(12,12,12);<br>(Query OK) |</p><p>session A 的 delete 语句加了 limit 2 。你知道表 t 里 col1=10 的记录其实只有两条，因此加不加 limit 2 ，删除的效果都是一样的。但是加锁效果却不一样。这是因为，案例七里的 delete 语句明确加了 limit 2 的限制，因此在遍历到 (col1=10, id=30) 这一行之后， 满足条件的语句已经有两条，循环就结束了。因此，索引 col1 上的加锁范围就变成了从（ col1=5,id=5) 到（ col1=10,id=30) 这个前开后闭区间<br><strong>案例八：一个死锁的例子</strong></p><ul><li>session A 启动事务后执行查询语句加 lock in share mode ，在索引 col1 上加了 next-keylock(5,10] 和 间隙锁 (10,15) （索引向右遍历退化为间隙锁）；</li><li>session B 的 update 语句也要在索引 c 上加 next-key lock(5,10] ，进入锁等待； 实际上分成了两步， 先是加 (5,10) 的间隙锁，加锁成功；然后加 col1=10 的行锁，因为sessionA上已经给这行加上了读 锁，此时申请死锁时会被阻塞</li><li>然后 session A 要再插入 (8,8,8) 这一行，被 session B 的间隙锁锁住。由于出现了死锁， InnoDB 让 session B 回滚</li></ul><table><thead><tr><th>sessionA</th><th>sessionB</th></tr></thead><tbody><tr><td>begin;</td><td></td></tr><tr><td>select id from test where col1=10 lock in share mode;</td><td></td></tr></tbody></table><p>|<br>|<br>| update test set col2=col2+1 where col1=10;(blocked) |<br>| insert into test values(8,8,8); |  |<br>|  | ERROR 1213(40001):Deadlock found when trying togetlock;try restarting transaction |</p><p><strong>案例九：order by索引排序的间隙锁1</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> <span class="keyword">id</span>&gt;<span class="number">9</span> <span class="keyword">and</span> <span class="keyword">id</span>&lt;<span class="number">12</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span> <span class="keyword">desc</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure><ul><li>首先这个查询语句的语义是 order by id desc ，要拿到满足条件的所有行，优化器必须先找到 “ 第 一个 id&lt;12 的值 ”</li><li>这个过程是通过索引树的搜索过程得到的，在引擎内部，其实是要找到 id=12 的这个值，只是最终 没找到，但找到了 (10,15) 这个间隙。（ id=15 不满足条件，所以 next-key lock 退化为了间隙锁 (10, 15) ）</li><li>然后向左遍历，在遍历过程中，就不是等值查询了，会扫描到 id=5 这一行，又因为区间是左开右 闭的，所以会加一个next-key lock (0,5] 。 也就是说，在执行过程中，通过树搜索的方式定位记录 的时候，用的是 “ 等值查询 ” 的方法。</li></ul><p><strong>案例十：order by索引排序的间隙锁2</strong></p><ul><li>由于是 order by col1 desc ，第一个要定位的是索引 col1 上 “ 最右边的 ”col1=20 的行。这是一个非唯一索引的等值查询：左开右闭区间，首先加上 next-key lock (15,20] 。 向右遍历，col1=25不满足条件，退化为间隙锁 所以会 加上间隙锁(20,25) 和 next-key lock (15,20]</li><li>在索引 col1 上向左遍历，要扫描到 col1=10 才停下来。同时又因为左开右闭区间，所以 next-key lock 会加到 (5,10] ，这正是阻塞session B 的 insert 语句的原因。</li><li>在扫描过程中， col1=20 、 col1=15 、 col1=10 这三行都存在值，由于是 select * ，所以会在主键 id 上加三个行锁。 因此， session A 的 select 语句锁的范围就是：<ul><li>索引 col1 上 (5, 25) ；</li><li>主键索引上 id=15 、 20 两个行锁。</li></ul></li></ul><table><thead><tr><th>sessionA</th><th>sessionB</th></tr></thead><tbody><tr><td>begin;</td><td></td></tr><tr><td>select * from test where col1&gt;=15 and col1&lt;=20 order by col1 desc lock in share mode;</td><td></td></tr></tbody></table><p>|<br>|<br>| insert into testvalues(6,6,6);<br>(blocked) |</p><p><strong>案例十一：update修改数据的例子-先插入后删除</strong></p><table><thead><tr><th>sessionA</th><th>sessionB</th></tr></thead><tbody><tr><td>begin;</td><td></td></tr><tr><td>select col1 from test where col1&gt;5 lock in share mode;</td><td></td></tr></tbody></table><p>|<br>|<br>| update test set col1=1 where col1=5(Query OK)<br>update test set col1=5 where col1=1;(blocked) |</p><p>注意：根据 col1&gt;5 查到的第一个记录是 col1=10 ，因此不会加 (0,5] 这个 next-key lock 。session A 的加锁范围是索引 col1 上的 (5,10] 、 (10,15] 、 (15,20] 、 (20,25] 和(25,supremum] 。之后 session B 的第一个 update 语句，要把 col1=5 改成 col1=1 ，你可以理解为两步：</p><ul><li>插入 (col1=1, id=5) 这个记录；</li><li>删除 (col1=5, id=5) 这个记录</li></ul><p>通过这个操作， session A 的加锁范围变成了图所示的样子:<br><img src="https://img-blog.csdnimg.cn/img_convert/2f2f89540a9c669f584da1573c3757ab.png" alt="image-20220714135333089.png"><br>接下来 session B 要执行 update t set col1 = 5 where col1 = 1 这个语句了，一样地可以拆成两步：</p><ul><li>插入 (col1=5, id=5) 这个记录；</li><li>删除 (col1=1, id=5) 这个记录。 第一步试图在已经加了间隙锁的 (1,10) 中插入数据，所以就被堵住了</li></ul><h1>四、多版本并发控制</h1><h2 id="1、什么是MVCC">1、什么是MVCC</h2><p>MVCC （Multiversion Concurrency Control），多版本并发控制。顾名思义，MVCC 是通过数据行的多个版本管理来实现数据库的 并发控制。这项技术使得在InnoDB的事务隔离级别下执行 一致性读 操作有了保证。换言之，就是为了查询一些正在被另一个事务更新的行，并且可以看到它们被更新之前的值，这样 在做查询的时候就不用等待另一个事务释放锁。<br>MVCC没有正式的标准，在不同的DBMS中MVCC的实现方式可能是不同的，也不是普遍使用的（大家可以参考相关的DBMS文档）。这里讲解InnoDB中MVCC的实现机制（MySQL其他的存储引擎并不支持它）。</p><h2 id="2、快照读与当前读">2、快照读与当前读</h2><blockquote><p>MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理 读-写冲突 ，做到 即使有读写冲突时，也能做到 不加锁 ， 非阻塞并发读 ，而这个读指的就是 快照读 , 而非 当前读 。当前 读实际上是一种加锁的操作，是悲观锁的实现。而MVCC本质是采用乐观锁思想的一种方式</p></blockquote><h3 id="2-1-快照读">2.1 快照读</h3><p>快照读又叫一致性读，读取的是快照数据。<strong>不加锁的简单的 SELECT 都属于快照读</strong>，即不加锁的非阻塞 读</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> player <span class="keyword">WHERE</span> ...</span><br></pre></td></tr></table></figure><p>之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于MVCC，它在很多情况下， 避免了加锁操作，降低了开销。既然是基于多版本，那么快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本。 快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读。</p><h3 id="2-2-当前读">2.2 当前读</h3><p>当前读读取的是记录的最新版本（最新数据，而不是历史版本的数据），读取时还要保证其他并发事务 不能修改当前记录，会对读取的记录进行加锁。加锁的 SELECT，或者对数据进行增删改都会进行当前 读。比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>; <span class="comment">-- 共享锁</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>; <span class="comment">-- 排他锁</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student <span class="keyword">values</span> ... <span class="comment">-- 排他锁</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> ... <span class="comment">-- 排他锁</span></span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> ... <span class="comment">-- 排他锁</span></span><br></pre></td></tr></table></figure><h2 id="3、前瞻回顾">3、前瞻回顾</h2><h3 id="3-1-再谈隔离级别">3.1 再谈隔离级别</h3><p>我们知道事务有 4 个隔离级别，可能存在三种并发问题<br><img src="https://img-blog.csdnimg.cn/img_convert/d02ed7d161e8a04492f2b1b38ead9fe8.png" alt="image-20220714140441064.png"><br>在MySQL中，默认的隔离级别是可重复读，可以解决脏读和不可重复读的问题，如果仅从定义的角度来看，它并不能解决幻读问题。如果我们想要解决幻读问题，就需要采用串行化的方式，也就是将隔离级别提升到最高，但这样一来就会大幅降低数据库的事务并发能力。MVCC可以不采用锁机制，而是<strong>通过乐观锁的方式来解决不可重复读和幻读问题</strong>!它可以在大多数情况下替代行级锁，降低系统的开销。<br><img src="https://img-blog.csdnimg.cn/img_convert/6ea921d34e52caef91440f86991c8fc3.png" alt="image-20220714140541555.png"></p><h3 id="3-2-隐藏字段、Undo-Log版本链">3.2 隐藏字段、Undo Log版本链</h3><p>回顾一下undo日志的版本链，对于使用 InnoDB 存储引擎的表来说，它的聚簇索引记录中都包含两个必要的隐藏列</p><ul><li><code>trx_id</code> ：每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的 <code>事务id</code> 赋值给 <code>trx_id</code> 隐藏列。</li><li><code>roll_pointer</code> ：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到 <code>undo日志</code> 中，然 后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</li></ul><blockquote><p>insert undo只在事务回滚时起作用，当事务提交后，该类型的undo日志就没用了，它占用的Undo Log Segment也会被系统回收（也就是该undo日志占用的Undo页面链表要么被重用，要么被释放）。</p></blockquote><p>每次对记录进行改动，都会记录一条undo日志，每条undo日志也都有一个 roll_pointer 属性 （ INSERT 操作对应的undo日志没有该属性，因为该记录并没有更早的版本），可以将这些 undo日志 都连起来，串成一个链表：<br><img src="https://img-blog.csdnimg.cn/img_convert/ff38f02640923a585fb989901f5c933d.png" alt="image-20220714141012874.png"><br>对该记录每次更新后，都会将旧值放到一条 undo日志 中，就算是该记录的一个旧版本，随着更新次数 的增多，所有的版本都会被 roll_pointer 属性连接成一个链表，我们把这个链表称之为 版本链 ，版 本链的头节点就是当前记录最新的值。每个版本中还包含生成该版本时对应的事务id。</p><h2 id="4、MVCC实现原理之ReadView">4、MVCC实现原理之ReadView</h2><blockquote><p>MVCC 的实现依赖于：隐藏字段、Undo Log、Read View</p></blockquote><h3 id="4-1-什么是ReadView">4.1 什么是ReadView</h3><p>在MVCC机制中，多个事务对同一个行记录进行更新会产生多个历史快照，这些历史快照保存在Undo Log里。如果一个事务想要查询这个行记录，需要读取哪个版本的行记录呢?这时就需要用到ReadView了，它帮我们解决了行的可见性问题。<br>ReadView就是事务在使用MVCC机制进行快照读操作时产生的读视图。当事务启动时，会生成数据库系统当前的一个快照，InnoDB为每个事务构造了一个数组，用来记录并维护系统<strong>当前活跃事务</strong>的ID（&quot;活跃&quot;指的就是，启动了但还没提交)。</p><h3 id="4-2-设计思路">4.2 设计思路</h3><p>使用 <code>READ UNCOMMITTED</code> 隔离级别的事务，由于可以读到未提交事务修改过的记录，所以直接读取记录的最新版本就好了。使用 <code>SERIALIZABLE</code> 隔离级别的事务，InnoDB规定使用加锁的方式来访问记录。<br>使用 <code>READ COMMITTED</code> 和 <code>REPEATABLE READ</code> 隔离级别的事务，都必须保证读到 <code>已经提交了的</code> 事务修改过的记录。假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的，核心问题就是<strong>需要判断一下版本链中的哪个版本是当前事务可见的</strong>，这是ReadView要解决的主要问题。<br>这个ReadView中主要包含4个比较重要的内容，分别如下：</p><ul><li><code>creator_trx_id</code> ，创建这个 Read View 的事务 ID。 说明：只有在对表中的记录做改动时（执行INSERT、DELETE、UPDATE这些语句时）才会为 事务分配事务id，否则在一个只读事务中的事务id值都默认为0</li><li><code>trx_ids</code> ，表示在生成ReadView时当前系统中活跃的读写事务的 <code>事务id列表</code></li><li><code>up_limit_id</code> ，活跃的事务中最小的事务 ID</li><li><code>low_limit_id</code> ，表示生成ReadView时系统中应该分配给下一个事务的 id 值。low_limit_id 是系 统最大的事务id值，这里要注意是系统中的事务id，需要区别于正在活跃的事务ID</li></ul><blockquote><p>注意：low_limit_id并不是trx_ids中的最大值，事务id是递增分配的。比如，现在有id为1， 2，3这三个事务，之后id为3的事务提交了。那么一个新的读事务在生成ReadView时， trx_ids就包括1和2，up_limit_id的值就是1，low_limit_id的值就是4。</p></blockquote><h3 id="4-3-ReadView的规则">4.3 ReadView的规则</h3><p>有了这个ReadView，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见</p><ul><li>如果被访问版本的trx_id属性值与ReadView中的 creator_trx_id 值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问</li><li>如果被访问版本的trx_id属性值小于ReadView中的 up_limit_id 值，表明生成该版本的事务在当前事务生成ReadView前已经提交，所以该版本可以被当前事务访问</li><li>如果被访问版本的trx_id属性值大于或等于ReadView中的 low_limit_id 值，表明生成该版本的事务在当前事务生成ReadView后才开启，所以该版本不可以被当前事务访问</li><li>如果被访问版本的trx_id属性值在ReadView的 up_limit_id 和 low_limit_id 之间，那就需要判断一下trx_id属性值是不是在 trx_ids 列表中<ul><li>如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问</li><li>如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问</li></ul></li></ul><h3 id="4-4-MVCC整体操作流程">4.4 MVCC整体操作流程</h3><p>当查询一条记录的时候，系统如何通过MVCC找到它：</p><ul><li>首先获取事务自己的版本号，也就是事务 ID；</li><li>获取 ReadView；</li><li>查询得到的数据，然后与 ReadView 中的事务版本号进行比较；</li><li>如果不符合 ReadView 规则，就需要从 Undo Log 中获取历史快照；</li><li>最后返回符合规则的数据。</li></ul><p>如果某个版本的数据对当前事务不可见的话，那就顺着版本链找到下一个版本的数据，继续按照上边的步骤判断可见性，依此类推，直到版本链中的最后一个版本。如果最后一个版本也不可见的话，那么就意味着该条记录对该事务完全不可见，查询结果就不包含该记录。</p><blockquote><p>InnoDB中，MVCC是通过Undo Log + Read View进行数据读取，Undo Log保存了历史快照，而Read View规则帮我们判断当前版本的数据是否可见。</p></blockquote><p>在隔离级别为读已提交（Read Committed）时，一个事务中的每一次 SELECT 查询都会重新获取一次 Read View。注意，此时同样的查询语句都会重新获取一次 Read View，这时如果 Read View 不同，就可能产生不可重复读或者幻读的情况<br><img src="https://img-blog.csdnimg.cn/img_convert/10dea13c9c7a012a1c819e89ad69c993.png" alt="image-20220715130843147.png"><br>当隔离级别为可重复读的时候，就避免了不可重复读，这是因为一个事务只在第一次 SELECT 的时候会获取一次 Read View，而后面所有的 SELECT 都会复用这个 Read View</p><h2 id="5、举例说明">5、举例说明</h2><p>假设现在student表中只有一条由事务id为8的事务插入的一条记录:<code>SELECT * FROM student;</code>MVCC只能在<strong>READ COMMITTED和REPEATABLE READ两个隔离级别下工作</strong>。接下来看一下READ COMMNITTED和REPEATABLE READ所谓的生成ReadView的时机不同到底不同在哪里。</p><h3 id="5-1-READ-COMMITTED隔离级别下">5.1 READ COMMITTED隔离级别下</h3><blockquote><p>READ COMMITTED ：每次读取数据前都生成一个ReadView</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 现在有两个 事务id 分别为 10、 20的事务在执行</span></span><br><span class="line"><span class="comment">-- Transaction 10</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> <span class="keyword">name</span>=<span class="string">"李四"</span> <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> <span class="keyword">name</span>=<span class="string">"王五"</span> <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">1</span>;</span><br><span class="line"><span class="comment">-- Transaction 20</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="comment">-- 更新了一些别的表的记录</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">-- 事务执行过程中，只有在第一次真正修改记录时（比如使用INSERT、DELETE、UPDATE语句），才会被分配一个单独的事务id，这个事务id是递增的。</span></span><br><span class="line"><span class="comment">-- 所以我们才在事务2中更新一些别的表的记录，目的是让它分配事务id。</span></span><br></pre></td></tr></table></figure><p>此刻，表student 中 id 为 1 的记录得到的版本链表如下所示：<br><img src="https://img-blog.csdnimg.cn/img_convert/51ddf7615a4ce1b5a96d3e23f16ed3ae.png" alt="image-20220715133640655.png"><br>假设现在有一个使用 READ COMMITTED 隔离级别的事务开始执行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用READ COMMITTED隔离级别的事务</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- SELECT1：Transaction 10、20未提交</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>; <span class="comment">-- 得到的列name的值为'张三'</span></span><br></pre></td></tr></table></figure><p>这个<code>SELECT1</code>的执行过程如下:</p><ul><li>步骤1:在执行<code>SELECT</code>语句时会先生成一个<code>ReadView</code> ，ReadView的<code>trx_ids</code>列表的内容就是<code>[10，20]</code>，<code>up_limit_id为10</code>，<code>low_limit_id为21</code>, <code>creator_trx_id为0</code></li><li>步骤2:从版本链中挑选可见的记录，从图中看出，最新版本的列<code>name</code>的内容是<code>'王五'</code>，该版本的<code>trx_id</code>值为10，在<code>trx_ids</code>列表内，所以不符合可见性要求，根据<code>roll_pointer</code>跳到下一个版本。</li><li>步骤3:下一个版本的列<code>name</code>的内容是’李四’，该版本的<code>trx_id</code>值也为10，也在<code>trx_ids</code>列表内，所以也不符合要求，继续跳到下一个版本</li><li>步骤4∶下一个版本的列<code>name</code>的内容是’张三’，该版本的<code>trx_id</code>值为8，小于<code>ReadView</code> 中的<code>up_limit_id</code>值10，所以这个版本是符合要求的，最后返回给用户的版本就是这条列name为’张三’的记录</li></ul><p>之后，我们把 事务id 为 10 的事务提交一下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Transaction 10</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> <span class="keyword">name</span>=<span class="string">"李四"</span> <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> <span class="keyword">name</span>=<span class="string">"王五"</span> <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 然后再到 事务id为 20的事务中更新一下表 student中 id为 1的记录</span></span><br><span class="line"><span class="comment">-- Transaction 20</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="comment">-- 更新了一些别的表的记录</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> <span class="keyword">name</span>=<span class="string">"钱七"</span> <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> <span class="keyword">name</span>=<span class="string">"宋八"</span> <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>此刻，表student中 id 为 1 的记录的版本链就长这样：<br><img src="https://img-blog.csdnimg.cn/img_convert/af176d0643ae45de76816bef235f0162.png" alt="image-20220715134839081.png"><br>然后再到刚才使用 READ COMMITTED 隔离级别的事务中继续查找这个 id 为 1 的记录，如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用READ COMMITTED隔离级别的事务</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- SELECT1：Transaction 10、20均未提交</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>; <span class="comment">-- 得到的列name的值为'张三'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- SELECT2：Transaction 10提交，Transaction 20未提交</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>; <span class="comment">-- 得到的列name的值为'王五'</span></span><br></pre></td></tr></table></figure><p>这个<code>SELECT2</code>的执行过程如下:</p><ul><li>步骤1:<strong>在执行SELECT 语句时会又会单独生成一个ReadView</strong>，该ReadView的<code>trx_ids</code>列表的内容就是[20]，<code>up_limit_id为20</code>，<code>low_limit_id</code>为21, <code>creator_trx_id</code>为0。|</li><li>步骤2:从版本链中挑选可见的记录，从图中看出，最新版本的列name的内容是’宋八’，该版本的<code>trx_id</code>值为20，在trx_ids列表内，所以不符合可见性要求，根据<code>roll_pointer</code>跳到下一个版本。</li><li>步骤3:下一个版本的列name的内容是’钱七’，该版本的trx_id值为20，也在trx_ids列表内，所以也不符合要求，继续跳到下一个版本。</li><li>步骤4:∶下一个版本的列name的内容是’王五’，该版本的trx_id值为10，小于ReadView 中的up_limit_id值20，所以这个版本是符合要求的，最后返回给用户的版本就是这条列name为’王五’的记录。</li></ul><p>以此类推，如果之后事务id为20的记录也提交了，再次在使用READ COMMITTED隔离级别的事务中查询表student中id值为1的记录时，得到的结果就是’宋八’了，具体流程我们就不分析了。<br><strong>强调:使用READ COMMITTED隔离级别的事务在每次查询开始时都会生成一个独立的ReadView</strong></p><h3 id="5-2-REPEATABLE-READ隔离级别下">5.2 REPEATABLE READ隔离级别下</h3><blockquote><p>使用 REPEATABLE READ 隔离级别的事务来说，只会在第一次执行查询语句时生成一个 ReadView ，之后的查询就不会重复生成了</p></blockquote><p>比如，系统里有两个 事务id 分别为 10 、 20 的事务在执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Transaction 10</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> <span class="keyword">name</span>=<span class="string">"李四"</span> <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> <span class="keyword">name</span>=<span class="string">"王五"</span> <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">1</span>;</span><br><span class="line"><span class="comment">-- Transaction 20</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="comment">-- 更新了一些别的表的记录</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 假设现在有一个使用 `REPEATABLE READ` 隔离级别的事务开始执行：</span></span><br><span class="line"><span class="comment">-- 使用REPEATABLE READ隔离级别的事务</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="comment">-- SELECT1：Transaction 10、20未提交</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>; <span class="comment">-- 得到的列name的值为'张三'</span></span><br></pre></td></tr></table></figure><p>这个SELECT1的执行过程如下:</p><ul><li>步骤1:在执行SELECT语句时会先生成一个ReadView ，ReadView的trx_ids列表的内容就是[10，20]，up_limit_id为10，low_limit_id为21, creator_trx_id为0</li><li>步骤2:从版本链中挑选可见的记录，从图中看出，最新版本的列name的内容是’王五’，该版本的trx_id值为10，在trx_ids列表内，所以不符合可见性要求，根据roll_pointer跳到下一个版本。</li><li>步骤3:下一个版本的列name的内容是’李四’，该版本的trx_id值也为10，也在trx_ids列表内，所以也不符合要求，继续跳到下一个版本</li><li>步骤4∶下一个版本的列name的内容是’张三’，该版本的trx_id值为8，小于ReadView 中的up_limit_id值10，所以这个版本是符合要求的，最后返回给用户的版本就是这条列name为’张三’的记录</li></ul><p>之后，我们把 事务id 为 10 的事务提交一下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Transaction 10</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> <span class="keyword">name</span>=<span class="string">"李四"</span> <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> <span class="keyword">name</span>=<span class="string">"王五"</span> <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="comment">-- 然后再到 `事务id` 为 `20` 的事务中更新一下表 `student` 中 `id` 为 `1` 的记录</span></span><br><span class="line"><span class="comment">-- Transaction 20</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="comment">-- 更新了一些别的表的记录</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> <span class="keyword">name</span>=<span class="string">"钱七"</span> <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> <span class="keyword">name</span>=<span class="string">"宋八"</span> <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 然后再到刚才使用 `REPEATABLE READ` 隔离级别的事务中继续查找这个 `id` 为 `1` 的记录</span></span><br><span class="line"><span class="comment">-- 使用REPEATABLE READ隔离级别的事务</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="comment">-- SELECT1：Transaction 10、20均未提交</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>; <span class="comment">-- 得到的列name的值为'张三'</span></span><br><span class="line"><span class="comment">-- SELECT2：Transaction 10提交，Transaction 20未提交</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>; <span class="comment">-- 得到的列name的值仍为'张三'</span></span><br></pre></td></tr></table></figure><p><code>SELECT2</code>的执行过程如下:</p><ul><li>步骤1∶因为当前事务的隔离级别为<strong>REPEATABLE READ</strong>，而之前在执行SELECT1时已经生成过ReadView了，所以<strong>此时直接复用之前的ReadView</strong>，之前的ReadView的<code>trx_ids</code>列表的内容就是[10，20]，up_limit_id为10, low_limit_id为21, creator_trx_id为0</li><li>步骤2:然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列name的内容是’宋八’，该版本的<code>trx_id</code>值为20，在trx_ids列表内，所以不符合可见性要求，根据<code>roll_pointer</code>跳到下一个版本。</li><li>步骤3:下一个版本的列name的内容是’钱七’，该版本的trx_id值为20，也在trx_ids列表内，所以也不符合要求，继续跳到下一个版本。</li><li>步骤4∶下一个版本的列name的内容是’王五，该版本的trx_id值为10，而trx_ids列表中是包含值为10的事务id的，所以该版本也不符合要求，同理下一个列name的内容是’李四’的版本也不符合要求。继续跳到下一个版本。</li><li>步骤5:下一个版本的列name的内容是’张三’，该版本的trx_id值为80，小于ReadView 中的up_limit_id值10，所以这个版本是符合要求的，最后返回给用户的版本就是这条列c为‘张三’的记录。</li></ul><p>这次SELECT查询得到的结果是重复的，记录的列c值都是张三，这就是可重复读的含义。如果我们之后再把事务id为20的记录提交了，然后再到刚才使用REPEATABLE READ隔离级别的事务中继续查找这个id为1的记录，得到的结果还是张三，具体执行过程大家可以自己分析一下。</p><h3 id="5-3-如何解决幻读">5.3 如何解决幻读</h3><p>接下来说明InnoDB 是如何解决幻读的。假设现在表 student 中只有一条数据，数据内容中，主键 id=1，隐藏的 trx_id=10，它的 undo log 如下图所示。<br><img src="https://img-blog.csdnimg.cn/img_convert/e72ab7ee3373257f5cd129b3146a1a5a.png" alt="image-20220715141002035.png"><br>假设现在有事务 A 和事务 B 并发执行，事务 A 的事务 id 为 20 ， 事务 B 的事务 id 为 30 。<br>步骤1：事务 A 开始第一次查询数据，查询的 SQL 语句如下：<code>select * from student where id &gt;= 1;</code>在开始查询之前，MySQL 会为事务 A 产生一个 ReadView，此时 ReadView 的内容如下： trx_ids= [20,30] ， up_limit_id=20 ， low_limit_id=31 ， creator_trx_id=20 。<br>由于此时表 student 中只有一条数据，且符合 where id&gt;=1 条件，因此会查询出来。然后根据 ReadView 机制，发现该行数据的trx_id=10，小于事务 A 的 ReadView 里 up_limit_id，这表示这条数据是事务 A 开启之前，其他事务就已经提交了的数据，因此事务 A 可以读取到。结论：事务 A 的第一次查询，能读取到一条数据，id=1。<br>步骤2：接着事务 B(trx_id=30)，往表 student 中新插入两条数据，并提交事务。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">'李四'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">'王五'</span>);</span><br></pre></td></tr></table></figure><p>步骤3：接着事务 A 开启第二次查询，根据可重复读隔离级别的规则，此时事务 A 并不会再重新生成 ReadView。此时表 student 中的 3 条数据都满足 where id&gt;=1 的条件，因此会先查出来。然后根据 ReadView 机制，判断每条数据是不是都可以被事务 A 看到。</p><ul><li>首先 id=1 的这条数据，前面已经说过了，可以被事务 A 看到</li><li>然后是 id=2 的数据，它的 trx_id=30，此时事务 A 发现，这个值处于 up_limit_id 和 low_limit_id 之 间，因此还需要再判断 30 是否处于 trx_ids 数组内。由于事务 A 的 trx_ids=[20,30]，因此在数组内，这表 示 id=2 的这条数据是与事务 A 在同一时刻启动的其他事务提交的，所以这条数据不能让事务 A 看到</li><li>同理，id=3 的这条数据，trx_id 也为 30，因此也不能被事务 A 看见。</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/90e754c0c81071aa8229ab51822777f6.png" alt="image-20220715141243993.png"><br>结论：最终事务 A 的第二次查询，只能查询出 id=1 的这条数据。这和事务 A 的第一次查询的结果是一样 的，因此没有出现幻读现象，所以说在 MySQL 的可重复读隔离级别下，不存在幻读问题。</p><h2 id="6、总结">6、总结</h2><p>这里介绍了 MVCC 在 <code>READ COMMITTD</code> 、 <code>REPEATABLE READ</code> 这两种隔离级别的事务在执行快照读操作时 访问记录的版本链的过程。这样使不同事务的 <code>读-写</code> 、 <code>写-读</code> 操作并发执行，从而提升系统性能。核心点在于 ReadView 的原理， <code>READ COMMITTD</code> 、 <code>REPEATABLE READ</code> 这两个隔离级别的一个很大不同 就是生成ReadView的时机不同：</p><ul><li><code>READ COMMITTD</code> 在每一次进行普通SELECT操作前都会生成一个ReadView</li><li><code>REPEATABLE READ</code> 只在第一次进行普通SELECT操作前生成一个ReadView，之后的查询操作都重复 使用这个ReadView就好了</li></ul><blockquote><p>说明:我们之前说执行DELETE语句或者更新主键的UPDATE语句并不会立即把对应的记录完全从页面中删除,而是执行一个所谓的delete mark操作，相当于只是对记录打上了一个删除标志位，这主要就是为MVCC服务的。</p></blockquote><p>通过MVCC我们可以解决:</p><ul><li><strong>读写之间阻塞的问题</strong>。通过MVcC 可以让读写互相不阻塞，即读不阻塞写，写不阻塞读，这样就可以提升事务并发处理能力</li><li><strong>降低了死锁的概率</strong>。这是因为MVCC 采雨了乐观锁的方式，读取数据时并不需要加锁，对于写操作，也只锁定必要的行</li><li><strong>解决快照读的问题</strong>。当我们查询数据库在某个时间点的快照时，只能看到这个时间点之前事务提交更新的结果，而不能看到这个时间点之后事务提交的更新结果</li></ul><h1>五、其他数据库日志</h1><blockquote><p>官网：<a href="https://dev.mysql.com/doc/refman/8.0/en/server-logs.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/8.0/en/server-logs.html</a></p></blockquote><h2 id="1、MySQL支持的日志">1、MySQL支持的日志</h2><h3 id="1-1-日志类型">1.1 日志类型</h3><p>MySQL有不同类型的日志文件，用来存储不同类型的日志，分为 <code>二进制日志</code> 、 <code>错误日志</code> 、 <code>通用查询日志</code> 和 <code>慢查询日志</code> ，这也是常用的4种。MySQL 8又新增两种支持的日志： 中继日志 和 数据定义语句日志 。使 用这些日志文件，可以查看MySQL内部发生的事情。这6类日志分别为：</p><ul><li><strong>慢查询日志</strong>：记录所有执行时间超过long_query_time的所有查询，方便我们对查询进行优化。</li><li><strong>通用查询日志</strong>：记录所有连接的起始时间和终止时间，以及连接发送给数据库服务器的所有指令， 对我们复原操作的实际场景、发现问题，甚至是对数据库操作的审计都有很大的帮助。</li><li><strong>错误日志</strong>：记录MySQL服务的启动、运行或停止MySQL服务时出现的问题，方便我们了解服务器的 状态，从而对服务器进行维护。</li><li><strong>二进制日志</strong>：记录所有更改数据的语句，可以用于主从服务器之间的数据同步，以及服务器遇到故 障时数据的无损失恢复。</li><li><strong>中继日志</strong>：用于主从服务器架构中，从服务器用来存放主服务器二进制日志内容的一个中间文件。 从服务器通过读取中继日志的内容，来同步主服务器上的操作。</li><li><strong>数据定义语句日志</strong>：记录数据定义语句执行的元数据操作。</li></ul><p>除二进制日志外，其他日志都是 <code>文本文件</code> 。默认情况下，所有日志创建于 <code>MySQL数据目录</code> 中。</p><h3 id="1-2-日志的弊端">1.2 日志的弊端</h3><ul><li>日志功能会 <code>降低MySQL数据库的性能</code> 。例如，在查询非常频繁的MySQL数据库系统中，如果开启了通用查询日志和慢查询日志，MySQL数据库会花费很多时间记录日志。</li><li>日志会 <code>占用大量的磁盘空间</code> 。对于用户量非常大，操作非常频繁的数据库，日志文件需要的存储空间设置比数据库文件需要的存储空间还要大</li></ul><h2 id="2、通用查询日志-general-query-log">2、通用查询日志(general query log)</h2><blockquote><p>慢查询日志(slow query log)前面章节《性能分析工具的使用》已经详细讲述</p></blockquote><p>通用查询日志用来 记录用户的所有操作 ，包括启动和关闭MySQL服务、所有用户的连接开始时间和截止 时间、发给 MySQL 数据库服务器的所有 SQL 指令等。当我们的数据发生异常时，<strong>查看通用查询日志， 还原操作时的具体场景</strong>，可以帮助我们准确定位问题。</p><h3 id="2-1-查看当前状态">2.1 查看当前状态</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">'%general%'</span>;</span><br></pre></td></tr></table></figure><p>说明1∶系统变量general_log的值是OFF，即通用查询日志处于关闭状态。在MySQL中，这个参数的默认值是关闭的。因为一旦开启记录通用查询日志，MySQL会记录所有的连接起止和相关的SQL操作，这样会消耗系统资源并且占用磁盘空间。我们可以通过手动修改变量的值，在需要的时候开启日志。<br>说明2:通用查询日志文件的名称是<code>atguigu01.log</code>。存储路径是<code>/var/lib/mysql/</code>，默认也是数据路径。这样我们就知道在哪里可以查看通用查询日志的内容了</p><h3 id="2-2-启动-停止日志">2.2 启动/停止日志</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- ===================永久性方式====================</span></span><br><span class="line"><span class="comment">-- 修改my.cnf或者my.ini配置文件来设置。在[mysqld]组下加入log选项，并重启MySQL服务</span></span><br><span class="line">[mysqld]</span><br><span class="line">general_log=ON</span><br><span class="line">general_log_file=[path[filename]] <span class="comment">#日志文件所在目录路径，filename为日志文件</span></span><br><span class="line"><span class="comment">-- 如果不指定目录和文件名，通用查询日志将默认存储在MySQL数据目录中的hostname.log文件中， hostname表示主机名。</span></span><br><span class="line"><span class="comment">-- 关闭的话直接选off即可</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- ====================临时性方式=================</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> general_log=<span class="keyword">on</span>; <span class="comment">-- 开启通用查询日志</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> general_log_file=<span class="string">'path/filename'</span>; <span class="comment">-- 设置日志文件保存位置</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> general_log=<span class="keyword">off</span>; <span class="comment">-- 关闭通用查询日志</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">'general_log%'</span>;</span><br></pre></td></tr></table></figure><h3 id="2-3-查看日志">2.3 查看日志</h3><p>通用查询日志是以 <code>文本文件</code> 的形式存储在文件系统中的，可以使用 <code>文本编辑器</code> 直接打开日志文件。每台 MySQL服务器的通用查询日志内容是不同的。</p><ul><li>在Windows操作系统中，使用文本文件查看器；</li><li>在Linux系统中，可以使用vi工具或者gedit工具查看；</li><li>在Mac OSX系统中，可以使用文本文件查看器或者vi等工具查看。</li></ul><p>从 <code>SHOW VARIABLES LIKE 'general_log%'</code>; 结果中可以看到通用查询日志的位置。在通用查询日志里面，我们可以清楚地看到，什么时候开启了新的客户端登陆数据库，登录之后做了什么 SQL 操作，针对的是哪个数据表等信息。</p><h3 id="2-4-删除-刷新日志">2.4 删除\刷新日志</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">'general_log%'</span>;</span><br><span class="line"><span class="comment">-- 使用如下命令重新生成查询日志文件，具体命令如下。</span></span><br><span class="line"><span class="comment">-- 刷新MySQL数据目录，发现创建了新的日志文 件。前提一定要开启通用日志。</span></span><br><span class="line"><span class="comment">-- 开启一个新的文件</span></span><br><span class="line">mysqladmin -uroot -p <span class="keyword">flush</span>-<span class="keyword">logs</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 备份旧的通用查询日志</span></span><br><span class="line">cd mysql-<span class="keyword">data</span>-<span class="keyword">directory</span> <span class="comment">-- 输入自己的通用日志文件所在目录</span></span><br><span class="line">mv mysql.general.log mysql.general.log.old <span class="comment">-- 指定旧的文件名 以及 新的文件名</span></span><br><span class="line">mysqladmin -uroot -p <span class="keyword">flush</span>-<span class="keyword">logs</span></span><br></pre></td></tr></table></figure><h2 id="3、错误日志-error-log">3、错误日志(error log)</h2><p>错误日志记录了MysQL服务器启动、停止运行的时间，以及系统启动、运行和停止过程中的诊断信息，<strong>包括错误、警告和提示等</strong>。通过错误日志可以查看系统的运行状态，便于即时发现故障、修复故障。如果MySQL服务出现异常，错误日志是发现问题、解决故障的首选。</p><h3 id="3-1-启动日志">3.1 启动日志</h3><p>在MySQL数据库中，错误日志功能是 <code>默认开启</code> 的。而且，错误日志 <code>无法被禁止</code> 。默认情况下，错误日志存储在MySQL数据库的数据文件夹下，名称默认为 <code>mysqld.log</code> （Linux系统）或 <code>hostname.err</code> （mac系统）。如果需要制定文件名，则需要在my.cnf或者my.ini中做如下配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"><span class="built_in">log</span>-error=[path/[filename]] <span class="comment">#path为日志文件所在的目录路径，filename为日志文件名</span></span><br></pre></td></tr></table></figure><p>修改配置项后，需要重启MySQL服务以生效。</p><h3 id="3-2-查看日志">3.2 查看日志</h3><p>MySQL错误日志是以文本文件形式存储的，可以使用文本编辑器直接查看</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">'log_err%'</span>;</span><br><span class="line"><span class="comment">-- 执行结果中可以看到错误日志文件是mysqld.log，位于MySQL默认的数据目录下</span></span><br></pre></td></tr></table></figure><h3 id="3-3-删除-刷新日志">3.3 删除\刷新日志</h3><p>对于很久以前的错误日志，数据库管理员查看这些错误日志的可能性不大，可以将这些错误日志删除， 以保证MySQL服务器上的 硬盘空间 。MySQL的错误日志是以文本文件的形式存储在文件系统中的，可以 直接删除</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 第一步（方式1）：删除操作</span></span><br><span class="line"><span class="comment">-- 在运行状态下删除错误日志文件后，MySQL并不会自动创建日志文件</span></span><br><span class="line">rm -f /var/lib/mysql/mysqld.log</span><br><span class="line"><span class="comment">-- 第一步（方式2）：重命名文件</span></span><br><span class="line">mv /var/log/mysqld.log /var/log/mysqld.log.old</span><br><span class="line"><span class="comment">-- 第二步：重建日志</span></span><br><span class="line">mysqladmin -uroot -p <span class="keyword">flush</span>-<span class="keyword">logs</span></span><br><span class="line"><span class="comment">-- 可能报错mysqladmin: refresh failed; error: 'Could not open file '/var/log/mysqld.log' for error logging.'</span></span><br><span class="line"><span class="comment">-- 补充 install -omysql -gmysql -m0644 /dev/null /var/log/mysqld.log</span></span><br></pre></td></tr></table></figure><p>**flush-logs **指令操作:</p><ul><li>MySQL 5.5.7以前的版本，flush-logs将错误日志文件重命名为filename.err_old，并创建新的日志文件</li><li>从MySQL 5.5.7开始，flush-logs只是重新打开日志文件，并不做日志备份和创建的操作。</li><li>如果日志文件不存在，MySQL启动或者执行flush-logs时会自动创建新的日志文件。重新创建错误日志，大小为0字节。</li></ul><h2 id="4、二进制日志-bin-log">4、二进制日志(bin log)</h2><h3 id="4-1-概述-v2">4.1 概述</h3><p>binlog可以说是MySQL中比较 <code>重要</code> 的日志了，在日常开发及运维过程中，经常会遇到。binlog即binary log，二进制日志文件，也叫作变更日志（update log）。它记录了数据库所有执行的 <code>DDL</code> 和 <code>DML</code> 等数据库更新事件的语句，但是不包含没有修改任何数据的语句（如数据查询语句select、 show等）。它以<code>事件形式</code>记录并保存在<code>二进制文件</code>中。通过这些信息，我们可以再现数据更新操作的全过程。</p><blockquote><p>如果想要记录所有语句（例如，为了识别有问题的查询），需要使用通用查询日志。</p></blockquote><p>binlog主要应用场景：</p><ul><li>一是用于数据恢复，如果MySQL数据库意外停止，可以通过二进制日志文件来查看用户执行了哪些操作，对数据库服务器文件做了哪些修改，然后根据二进制日志文件中的记录来恢复数据库服务器。</li><li>二是用于数据复制，由于日志的延续性和时效性，master把它的二进制日志传递给slaves来达到master-slave数据一致的目的。</li></ul><p>可以说MySQL数据库的<strong>数据备份、主备、主主、主从</strong>都离不开binlog，需要依靠binlog来同步数据，保证数据一致性。</p><h3 id="4-2-查看默认情况">4.2 查看默认情况</h3><p>查看记录二进制日志是否开启：在MySQL8中默认情况下，二进制文件是开启的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%log_bin%'</span>;</span><br></pre></td></tr></table></figure><ul><li><code>log_bin_basename</code>:是binlog日志的基本文件名，后面会追加标识来表示每一个文件</li><li><code>log_bin_index</code>:是binlog文件的索引文件，这个文件管理了所有的binlog文件的目录</li><li><code>log_bin_trust_function_creators</code> :限制存储过程，前面我们已经讲过了，这是因为二进制日志的一个重要功能是用于主从复制，而存储函数有可能导致主从的数据不一致。所以当开启二进制日志后，需要限制存储函数的创建、修改、调用</li><li><code>log_bin_use_v1_row_events</code> 此只读系统变量已弃用。ON表示使用版本1二进制日志行，OFF表示使用版本2二进制日志行(MySQL 5.6的默认值为2)。</li></ul><h3 id="4-3-日志参数设置">4.3 日志参数设置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 永久性方式</span></span><br><span class="line">[mysqld]</span><br><span class="line"><span class="comment">#启用二进制日志</span></span><br><span class="line"><span class="built_in">log</span>-bin=atguigu-bin</span><br><span class="line">binlog_expire_logs_seconds=600</span><br><span class="line">max_binlog_size=100M</span><br></pre></td></tr></table></figure><ul><li><code>log-bin=mysql-bin</code> 打开日志(主机需要打开)，这个mysql-bin也可以自定义，这里也可以加上路径,如:<code>/home/www/mysql_bin_log/mysql-bin</code></li><li><code>binlog_expire_logs_seconds</code>:此参数控制二进制日志文件保留的时长，单位是<strong>秒</strong>，<strong>默认2592000</strong> 30天（14400 4小时;86400 1天;259200 3天）</li><li><code>max_binlog_size</code>:控制单个二进制日志大小，当前日志文件大小超过此变量时，执行切换动作。此参数<br>的<strong>最大和默认值是1GB</strong>，该设置<strong>并不能严格控制Binlog的大小</strong>，尤其是Binlog比较靠近最大值而又遇到一个比较大事务时，为了保证事务的完整性，可能不做切换日志的动作，只能将该事务的所有SQL都记录进当前日志，直到事务结束。一般情况下可采取默认值。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 重新启动MySQL服务，查询二进制日志的信息</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%log_bin%'</span>;</span><br><span class="line"><span class="comment">-- 设置带文件夹的bin-log日志存放目录</span></span><br><span class="line"><span class="comment">-- 如果想改变日志文件的目录和名称，可以对my.cnf或my.ini中的log_bin参数</span></span><br><span class="line">[mysqld]</span><br><span class="line">log-bin="/var/lib/mysql/binlog/atguigu-bin"</span><br><span class="line"><span class="comment">-- 注意：新建的文件夹需要使用mysql用户，使用下面的命令即可</span></span><br><span class="line">chown -R -v mysql:mysql binlog</span><br><span class="line"><span class="comment">-- 数据库文件最好不要与日志文件放在同一个磁盘上!</span></span><br><span class="line"><span class="comment">-- 这样，当数据库文件所在的磁盘发生故障时，可以使用日志文件恢复数据。</span></span><br></pre></td></tr></table></figure><p>如果不希望通过修改配置文件并重启的方式设置二进制日志的话，还可以使用如下指令，需要注意的是 在mysql8中只有 会话级别 的设置，没有了global级别的设置</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- session级别</span></span><br><span class="line"><span class="comment">-- 为OFF时，临时不记录binlog开关（增量恢复）某个时间点某些语句不记录binlog</span></span><br><span class="line"><span class="keyword">SET</span> sql_log_bin=<span class="number">0</span>;</span><br></pre></td></tr></table></figure><h3 id="4-4-查看日志">4.4 查看日志</h3><p>当MySQL创建二进制日志文件时，先创建一个以“filename”为名称、以“.index”为后缀的文件，再创建一 个以“filename”为名称、以“.000001”为后缀的文件。MySQL服务 重新启动一次 ，以“.000001”为后缀的文件就会增加一个，并且后缀名按1递增。即日志文件的 个数与MySQL服务启动的次数相同；如果日志长度超过了 max_binlog_size 的上限（默认是1GB），就会创建一个新的日志文件。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看当前的二进制日志文件列表及大小</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="built_in">BINARY</span> <span class="keyword">LOGS</span>;</span><br></pre></td></tr></table></figure><p>然后可以查看相关bin log日志</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开始查看binlog</span></span><br><span class="line">mysqlbinlog <span class="string">"/var/lib/mysql/binlog/atguigu-bin.0000002"</span></span><br><span class="line"><span class="comment"># 执行结果可以看到，这是一个简单的日志文件，日志中记录了用户的一些操作，这里并没有出现具体的SQL语句，这是因为binlog关键字后面的内容是经过编码后的二进制日志。</span></span><br><span class="line"><span class="comment"># 这里一个update语句包含如下事件</span></span><br><span class="line"><span class="comment"># Query事件负责开始一个事务(BEGIN)</span></span><br><span class="line"><span class="comment"># Table_map事件负责映射需要的表</span></span><br><span class="line"><span class="comment"># Update_rows事件负责写入数据</span></span><br><span class="line"><span class="comment"># Xid事件负责结束事务</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面命令将行事件以伪SQL的形式表现出来</span></span><br><span class="line">mysqlbinlog -v <span class="string">"/var/lib/mysql/binlog/atguigu-bin.000002"</span></span><br><span class="line"><span class="comment"># 前面的命令同时显示binlog格式的语句，使用如下命令不显示它</span></span><br><span class="line">mysqlbinlog -v --base64-output=DECODE-ROWS <span class="string">"/var/lib/mysql/binlog/atguigu-bin.000002"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ===============其他命令=======================</span></span><br><span class="line"><span class="comment"># 可查看参数帮助</span></span><br><span class="line">mysqlbinlog --no-defaults --<span class="built_in">help</span></span><br><span class="line"><span class="comment"># 查看最后100行</span></span><br><span class="line">mysqlbinlog --no-defaults --base64-output=decode-rows -vv atguigu-bin.000002 |tail -100</span><br><span class="line"><span class="comment"># 根据position查找</span></span><br><span class="line">mysqlbinlog --no-defaults --base64-output=decode-rows -vv atguigu-bin.000002 |grep -A 20 <span class="string">'4939002'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面这种办法读取出binlog日志的全文内容比较多，不容易分辨查看到pos点信息</span></span><br><span class="line">mysql&gt; show binlog events [IN <span class="string">'log_name'</span>] [FROM pos] [LIMIT [offset,] row_count];* `IN <span class="string">'log_name'</span>` ：指定要查询的binlog文件名（不指定就是第一个binlog文件）　 </span><br><span class="line"><span class="comment"># IN 'log_name' ：指定要查询的binlog文件名（不指定就是第一个binlog文件）　 </span></span><br><span class="line"><span class="comment"># FROM pos ：指定从哪个pos起始点开始查起（不指定就是从整个文件首个pos点开始算） </span></span><br><span class="line"><span class="comment"># LIMIT [offset] ：偏移量(不指定就是0) </span></span><br><span class="line"><span class="comment"># row_count :查询总条数（不指定就是所有行）</span></span><br><span class="line">mysql&gt; show binlog events <span class="keyword">in</span> <span class="string">'atguigu-bin.000002'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># flush logs命令的作用就是关闭当前使用的binary log，然后打开一个新的binary log文件，binlog文件的序号递增加1</span></span><br><span class="line">flush logs</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/640cbee8dfb4b17c3d0b5e3de6039916.png" alt="image-20220715165603879.png"><br>上面我们讲了这么多都是基于binlog的默认格式，binlog格式查看：<code>show variables like 'binlog_format';</code></p><ul><li><strong>Statement</strong>。每一条会修改数据的sql都会记录在binlog中。优点：不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。</li><li><strong>Row</strong>。5.1.5版本的MySQL才开始支持row level的复制，它不记录sql语句上下文相关信息，仅保存哪条记录被修改。优点：row level 的日志内容会非常清楚的记录下每一行数据修改的细节。而且不会出现某些特定情况下 的存储过程，或function，以及trigger的调用和触发无法被正确复制的问题。</li><li><strong>Mixed</strong>。从5.1.8版本开始，MySQL提供了Mixed格式，实际上就是Statement与Row的结合。</li></ul><h3 id="4-5-使用日志恢复数据">4.5 使用日志恢复数据</h3><p>如果MySQL服务器启用了二进制日志，在数据库出现意外丢失数据时，可以使用MySQLbinlog工具从指定的时间点开始（例如，最后一次备份）直到现在或另一个指定的时间点的日志中回复数据。mysqlbinlog恢复数据的语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog [option] filename|mysql –uuser -ppass;</span><br></pre></td></tr></table></figure><p>这个命令可以这样理解：使用mysqlbinlog命令来读取filename中的内容，然后使用mysql命令将这些内容恢复到数据库中。</p><ul><li><code>filename</code> ：是日志文件名。</li><li><code>option</code> ：可选项，比较重要的两对option参数是–start-date、–stop-date 和 --start-position、-- stop-position。<ul><li><code>--start-date</code> 和<code>--stop-date</code> ：可以指定恢复数据库的起始时间点和结束时间点。</li><li><code>--start-position</code>和<code>--stop-position</code> ：可以指定恢复数据的开始位置和结束位置。</li></ul></li></ul><blockquote><p>注意：使用mysqlbinlog命令进行恢复操作时，必须是编号小的先恢复，例如atguigu-bin.000001必须在atguigu-bin.000002之前恢复。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 例如按照位置</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">binlog</span> <span class="keyword">events</span> <span class="keyword">in</span> <span class="string">'atguigu-bin.000002'</span>;</span><br><span class="line">/usr/bin/mysqlbinlog <span class="comment">--start-position884 --stop-position=1729 --database=atguigudb3 /var/lib/mysql/atguigu-bin.00005 | /user/bin/mysql -uroot -proot -v atguigu3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 按照时间恢复</span></span><br><span class="line">mysqlbinlog ' /var/lib/mysql/atgligu-bin.000002'</span><br><span class="line"></span><br><span class="line">/usr/bin/mysqlbinlog <span class="comment">--start-datetime="2022-01-85 15:39:22" --stop-datetime="2022-01-35 15:40:1" --database=atguigu14 /var/lib/mysql/binlog/atguigu-bin.000085 | /usr/bin/mysql -uroot -pabc123 -v atguigu14</span></span><br></pre></td></tr></table></figure><h3 id="4-6-删除二进制日志">4.6 删除二进制日志</h3><p>MySQL的二进制文件可以配置自动删除，同时MySQL也提供了安全的手动删除二进制文件的方法。<code> PURGE MASTER LOGS</code> 只删除指定部分的二进制日志文件，<code> RESET MASTER</code> 删除所有的二进制日志文件</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- =========================1. PURGE MASTER LOGS：删除指定日志文件</span></span><br><span class="line"><span class="keyword">PURGE</span> &#123;<span class="keyword">MASTER</span> | <span class="built_in">BINARY</span>&#125; <span class="keyword">LOGS</span> <span class="keyword">TO</span> <span class="string">'指定日志文件名'</span></span><br><span class="line"><span class="keyword">PURGE</span> &#123;<span class="keyword">MASTER</span> | <span class="built_in">BINARY</span>&#125; <span class="keyword">LOGS</span> <span class="keyword">BEFORE</span> <span class="string">'指定日期'</span></span><br><span class="line"><span class="comment">-- 举例</span></span><br><span class="line"><span class="comment">-- 多次重新启动MysQL服务，便于生成多个日志文件。然后用SHOW语句显示二进制日志文件列表</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="built_in">BINARY</span> <span class="keyword">LOGS</span>;</span><br><span class="line"><span class="comment">-- 执行PURGE MASTER LOGS语句删除创建时间比binlog.000005早的所有日志</span></span><br><span class="line"><span class="keyword">PURGE</span> <span class="keyword">MASTER</span> <span class="keyword">LOGS</span> <span class="keyword">To</span> <span class="string">"binlog.000005"</span>;</span><br><span class="line"><span class="comment">-- 执行mysqlbinlog命令查看二进制日志文件binlog.000005的内容</span></span><br><span class="line">mysqlbinlog <span class="comment">--no-defaults "/var/lib/mysql/binlog/atguigu-bin.008005"</span></span><br><span class="line"><span class="comment">-- 使用PURGE MASTER LOGS语句删除2022年1月05日前创建的所有日志文件</span></span><br><span class="line"><span class="keyword">PURGE</span> <span class="keyword">MASTER</span> <span class="keyword">LOGS</span> <span class="keyword">before</span> <span class="string">"20220105"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- =========================2. RESET MASTER: 删除所有二进制日志文件</span></span><br><span class="line"><span class="comment">-- 使用RESET MASTER语句，清空所有的binlog日志。MySQL会重新创建二进制文件，新的日志文件扩展名将重新从000001开始编号。慎用!</span></span><br><span class="line"><span class="keyword">RESET</span> <span class="keyword">MASTER</span>;</span><br></pre></td></tr></table></figure><h3 id="4-7-其它场景">4.7 其它场景</h3><p>二进制日志可以通过数据库的 全量备份 和二进制日志中保存的 增量信息 ，完成数据库的 无损失恢复 。 但是，如果遇到数据量大、数据库和数据表很多（比如分库分表的应用）的场景，用二进制日志进行数据恢复，是很有挑战性的，因为起止位置不容易管理。<br>在这种情况下，一个有效的解决办法是 配置主从数据库服务器 ，甚至是 一主多从 的架构，把二进制日志文件的内容通过中继日志，同步到从数据库服务器中，这样就可以有效避免数据库故障导致的数据异常等问题</p><h2 id="5、深入二进制日志-binlog">5、深入二进制日志(binlog)</h2><h3 id="5-1-写入机制">5.1 写入机制</h3><p>binlog的写入时机也非常简单，事务执行过程中，先把日志写到 binlog cache ，事务提交的时候，再把binlog cache写到binlog文件中。因为一个事务的binlog不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为binlog cache。<br>我们可以通过binlog_cache_size参数控制单个线程 binlog cache 大小，如果存储内容超过了这个参数，就要暂存到磁盘（Swap）。binlog日志刷盘流程如下：<br><img src="https://img-blog.csdnimg.cn/img_convert/b2bf48e7a038655fc6315820d8fd3cc6.png" alt="image-20220715172958729.png"></p><ul><li>上图的write，是指把日志写入到文件系统的page cache，并没有把数据持久化到磁盘，所以速度比较快</li><li>上图的fsync，才是将数据持久化到磁盘的操作</li></ul><p>write和fsync的时机，可以由参数 sync_binlog 控制，默认是 0 。为0的时候，表示每次提交事务都只 write，由系统自行判断什么时候执行fsync。虽然性能得到提升，但是机器宕机，page cache里面的 binglog 会丢失。<br>为了安全起见，<strong>可以设置为 1 ，表示每次提交事务都会执行fsync</strong>，就如同<strong>redo log 刷盘流程</strong>一样。 最后还有一种折中方式，可以设置为N(N&gt;1)，表示每次提交事务都write，但累积N个事务后才fsync。在出现IO瓶颈的场景里，将sync_binlog设置成一个比较大的值，可以提升性能。同样的，如果机器宕机，会丢失最近N个事务的binlog日志。</p><h3 id="5-2-binlog与redolog对比">5.2 binlog与redolog对比</h3><ul><li>redo log 它是 <code>物理日志</code> ，记录内容是“在某个数据页上做了什么修改”，属于 InnoDB 存储引擎层产生的。</li><li>而 binlog 是 <code>逻辑日志</code> ，记录内容是语句的原始逻辑，类似于“给 ID=2 这一行的 c 字段加 1”，属于 MySQL Server 层。</li><li>虽然它们都属于持久化的保证，但是侧重点不同。<ul><li>redo log让InnoDB存储引擎拥有了崩溃恢复能力。</li><li>binlog保证了MySQL集群架构的数据一致性。</li></ul></li></ul><h3 id="5-3-两阶段提交">5.3 两阶段提交</h3><p>在执行更新语句过程，会记录redo log与binlog两块日志，以基本的事务为单位，redo log在事务执行过程中可以不断写入，而binlog只有在提交事务时才写入，所以redo log与binlog的 写入时机 不一样。<br><img src="https://img-blog.csdnimg.cn/img_convert/66c935ab472ee219efd881403750b5e2.png" alt="image-20220715194959405.png"><br><strong>redo log与binlog两份日志之间的逻辑不一致，会出现什么问题？<strong>由于binlog没写完就异常，这时候binlog里面没有对应的修改记录。因此，之后用binlog日志恢复数据时，就会少这一次更新，恢复出来的最终数据不一致。<br>为了解决两份日志之间的逻辑一致问题，InnoDB存储引擎使用</strong>两阶段提交</strong>方案。原理很简单，将redo log的写入拆成了两个步骤prepare和commit，这就是<strong>两阶段提交</strong>。<br><img src="https://img-blog.csdnimg.cn/img_convert/f573942f4672a60773708786600da41f.png" alt="image-20220715195635196.png"><br>使用两阶段提交后，写入binlog时发生异常也不会有影响，因为MySQL根据redo log日志恢复数据时，发现redo log还处于prepare阶段，并且没有对应binlog日志，就会回滚该事务。<br><img src="https://img-blog.csdnimg.cn/img_convert/7ded8812aa4ef3415773e1cb71882c3f.png" alt="image-20220715200321717.png"><br>另一个场景，redo log设置commit阶段发生异常，那会不会回滚事务呢？答案并不会回滚事务，它会执行上图框住的逻辑，虽然redo log是处于prepare阶段，但是能通过事务id找到对应的binlog日志，所以MySQL认为是完整的，就会提交事务恢复数据。</p><h2 id="6、中继日志-relay-log">6、中继日志(relay log)</h2><h3 id="6-1-介绍">6.1 介绍</h3><p><strong>中继日志只在主从服务器架构的从服务器上存在</strong>。从服务器为了与主服务器保持一致，要从主服务器读取二进制日志的内容，并且把读取到的信息写入 本地的日志文件 中，这个从服务器本地的日志文件就叫 中继日志 。然后，从服务器读取中继日志，并根据中继日志的内容对从服务器的数据进行更新，完成主 从服务器的 数据同步 。<br>搭建好主从服务器之后，中继日志默认会保存在从服务器的数据目录下。文件名的格式是：从服务器名 -relay-bin.序号 。中继日志还有一个索引文件：从服务器名 -relaybin.index ，用来定位当前正在使用的中继日志。</p><h3 id="6-2-查看中继日志">6.2 查看中继日志</h3><p>中继日志与二进制日志的格式相同，可以用 mysqlbinlog 工具进行查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SET TIMESTAMP=1618558728/*!*/;</span><br><span class="line">BEGIN</span><br><span class="line">/*!*/;</span><br><span class="line"><span class="comment"># at 950</span></span><br><span class="line"><span class="comment">#210416 15:38:48 server id 1 end_log_pos 832 CRC32 0xcc16d651 Table_map:</span></span><br><span class="line">`atguigu`.`<span class="built_in">test</span>` mapped to number 91</span><br><span class="line"><span class="comment"># at 1000</span></span><br><span class="line"><span class="comment">#210416 15:38:48 server id 1 end_log_pos 872 CRC32 0x07e4047c Delete_rows: table id</span></span><br><span class="line">91 flags: STMT_END_F -- server id 1 是主服务器，意思是主服务器删了一行数据</span><br><span class="line">BINLOG <span class="string">'</span></span><br><span class="line"><span class="string">CD95YBMBAAAAMgAAAEADAAAAAFsAAAAAAAEABGRlbW8ABHRlc3QAAQMAAQEBAFHWFsw=</span></span><br><span class="line"><span class="string">CD95YCABAAAAKAAAAGgDAAAAAFsAAAAAAAEAAgAB/wABAAAAfATkBw==</span></span><br><span class="line"><span class="string">'</span>/*!*/;</span><br><span class="line"><span class="comment"># at 1040</span></span><br></pre></td></tr></table></figure><p>这一段的意思是，主服务器（“server id 1”）对表 atguigu.test 进行了 2 步操作：定位到表 atguigu.test 编号是 91 的记录，日志位置是 832；删除编号是 91 的记录，日志位置是 872</p><h3 id="6-3-恢复的典型错误">6.3 恢复的典型错误</h3><p>如果从服务器宕机，有的时候为了系统恢复，要重装操作系统，这样就可能会导致你的 服务器名称 与之前 不同 。而中继日志里是 包含从服务器名 的。在这种情况下，就可能导致你恢复从服务器的时候，无法 从宕机前的中继日志里读取数据，以为是日志文件损坏了，其实是名称不对了。<br>解决的方法也很简单，把从服务器的名称改回之前的名称。</p><h1>六、主从复制</h1><h2 id="1、主从复制概述">1、主从复制概述</h2><h3 id="1-1-如何提升数据库并发能力">1.1 如何提升数据库并发能力</h3><p>在实际工作中，我们常常将Redis作为缓存与MySQL配合来使用，当有请求的时候，首先会从缓存中进行查找，如果存在就直接取出。如果不存在再访问数据库，这样就提升了读取的效率，也减少了对后端数据库的访问压力。Redis的缓存架构是高并发架构中非常重要的一环。<br>此外，一般应用对数据库而言都是“ 读多写少 ”，也就说对数据库读取数据的压力比较大，有一个思路就是采用数据库集群的方案，做 主从架构 、进行 读写分离 ，这样同样可以提升数据库的并发处理能力。但并不是所有的应用都需要对数据库进行主从架构的设置，毕竟设置架构本身是有成本的。<br>如果我们的目的在于提升数据库高并发访问的效率，那么首先考虑的是如何 优化SQL和索引 ，这种方式 简单有效；其次才是采用 缓存的策略 ，比如使用 Redis将热点数据保存在内存数据库中，提升读取的效率；最后才是对数据库采用 主从架构 ，进行读写分离。<br><strong>按照上面的方式进行优化，使用和维护的成本是由低到高的</strong>。</p><h3 id="1-2-主从复制的作用">1.2 主从复制的作用</h3><p>**第1个作用：读写分离。**我们可以通过主从复制的方式来同步数据，然后通过读写分离提高数据库并发处理能力。其中一个是Master主库，负责写入数据，我们称之为：<strong>写库</strong>。其他都是Slave从库，负责读取数据，我们称之为：<strong>读库</strong>。当主库进行更新的时候，会自动将数据复制到从库中，而我们在客户端读取数据的时候，会从从库进行读取。<br><strong>面对“读多写少”的需求，采用读写分离的方式</strong>，可以实现更高的并发访问。同时，我们还能对从服务器进行负载均衡，让不同的读请求按照策略均匀地分发到不同的从服务器上，让读取更加顺畅。读取顺畅的另一个原因，就是减少了锁表的影响，比如我们让主库负责写，当主库出现写锁的时候，不会影响到从库进行SELECT的读取。<br>**第2个作用就是数据备份。**我们通过主从复制将主库上的数据复制到从库上，相当于一种热备份机制，也就是在主库正常运行的情况下进行的备份，不会影响到服务。<br>**第3个作用是具有高可用性。**数据备份实际上是一种冗余的机制，通过这种冗余的方式可以换取数据库的高可用性，也就是当服务器出现故障或宕机的情况下，可以切换到从服务器上，保证服务的正常运行。</p><blockquote><p>关于高可用性的程度，我们可以用一个指标衡量，即正常可用时间/全年时间。比如要达到全年99.999%的时间都可用，就意味着系统在一年中的不可用时间不得超过365<em>24</em>60* (1-99.999%) =5.256分钟（含系统崩溃的时间、日常维护操作导致的停机时间等)，其他时间都需要保持可用的状态</p></blockquote><h2 id="2、主从复制的原理">2、主从复制的原理</h2><blockquote><p>Slave 会从 Master 读取 binlog 来进行数据同步</p></blockquote><h3 id="2-1-原理剖析">2.1 原理剖析</h3><p>实际上主从同步的原理就是基于 binlog 进行数据同步的。在主从复制过程中，会基于 3 个线程 来操 作，一个主库线程，两个从库线程<br><img src="https://img-blog.csdnimg.cn/img_convert/75294856dc97fce39914dd6a119290fc.png" alt="image-20220715215944767.png"><br>二进制日志转储线程 （Binlog dump thread）是一个主库线程。当从库线程连接的时候， 主库可以将二进 制日志发送给从库，当主库读取事件（Event）的时候，会在 Binlog 上 加锁 ，读取完成之后，再将锁释放掉。从库 I/O 线程 会连接到主库，向主库发送请求更新 Binlog。这时从库的 I/O 线程就可以读取到主库的二进制日志转储线程发送的 Binlog 更新部分，并且拷贝到本地的中继日志 （Relay log）。从库 SQL 线程 会读取从库中的中继日志，并且执行日志中的事件，将从库中的数据与主库保持同步。<br><img src="https://img-blog.csdnimg.cn/img_convert/c825114198bcb149c0d7933200f4b23d.png" alt="image-20220715220037213.png"></p><blockquote><p>注意：不是所有版本的MySQL都默认开启服务器的二进制日志。在进行主从同步的时候，我们需要先检查服务器是否已经开启了二进制日志。除非特殊指定，默认情况下从服务器会执行所有主服务器中保存的事件。也可以通过配置，使从服务器执行特定的事件。</p></blockquote><p><strong>复制三步骤</strong><br>步骤1： Master 将写操作记录到二进制日志（ binlog ）。<br>步骤2： Slave 将 Master 的binary log events拷贝到它的中继日志（ relay log ）；<br>步骤3： Slave 重做中继日志中的事件，将改变应用到自己的数据库中。 MySQL复制是异步的且串行化的，而且重启后从 接入点 开始复制。<br><strong>复制的问题</strong><br>复制的最大问题： 延时</p><h3 id="2-2-复制的基本原则">2.2 复制的基本原则</h3><ul><li>每个 <code>Slave</code> 只有一个 <code>Master</code></li><li>每个 <code>Slave</code> 只能有一个唯一的服务器ID</li><li>每个 <code>Master</code> 可以有多个 <code>Slave</code></li></ul><h2 id="3、一主一从架构搭建">3、一主一从架构搭建</h2><p>台 主机 用于处理所有 写请求 ，一台 从机 负责所有 读请求 ，架构图如下:<br><img src="https://img-blog.csdnimg.cn/img_convert/be028aaa25deb033af097de1f6daf916.png" alt="image-20220715220852836.png"></p><h3 id="3-1-准备工作">3.1 准备工作</h3><ul><li>准备 2台 CentOS 虚拟机</li><li>每台虚拟机上需要安装好MySQL (可以是MySQL8.0 )</li></ul><p>注意：克隆的方式需要修改新克隆出来主机的：① MAC地址 ② hostname ③IP 地址 ④ UUID 。此外，克隆的方式生成的虚拟机（包含MySQL Server），则克隆的虚拟机MySQL Server的UUID相同，必须修改，否则在有些场景会报错。比如： show slave status\G</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改MySQL Server 的UUID方式：</span></span><br><span class="line">vim /var/lib/mysql/auto.cnf</span><br><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure><h3 id="3-2-主机配置文件">3.2 主机配置文件</h3><p>建议mysql版本一致且后台以服务运行，主从所有配置项都配置在 [mysqld] 节点下，且都是小写字母</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># =============必选============</span></span><br><span class="line"><span class="comment">#[必须]主服务器唯一ID</span></span><br><span class="line">server-id=1</span><br><span class="line"><span class="comment">#[必须]启用二进制日志,指名路径。比如：自己本地的路径/log/mysqlbin</span></span><br><span class="line"><span class="built_in">log</span>-bin=atguigu-bin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ===============可选============</span></span><br><span class="line"><span class="comment">#[可选] 0（默认）表示读写（主机），1表示只读（从机）</span></span><br><span class="line"><span class="built_in">read</span>-only=0</span><br><span class="line"><span class="comment">#设置日志文件保留的时长，单位是秒</span></span><br><span class="line">binlog_expire_logs_seconds=6000</span><br><span class="line"><span class="comment">#控制单个二进制日志大小。此参数的最大和默认值是1GB</span></span><br><span class="line">max_binlog_size=200M</span><br><span class="line"><span class="comment">#[可选]设置不要复制的数据库</span></span><br><span class="line">binlog-ignore-db=<span class="built_in">test</span></span><br><span class="line"><span class="comment">#[可选]设置需要复制的数据库,默认全部记录。比如：binlog-do-db=atguigu_master_slave</span></span><br><span class="line">binlog-do-db=需要复制的主数据库名字</span><br><span class="line"><span class="comment">#[可选]设置binlog格式</span></span><br><span class="line">binlog_format=STATEMENT</span><br></pre></td></tr></table></figure><h3 id="3-3-从机配置文件">3.3 从机配置文件</h3><p>要求主从所有配置项都配置在 my.cnf 的 [mysqld] 栏位下，且都是小写字母</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#[必须]从服务器唯一ID</span></span><br><span class="line">server-id=2</span><br><span class="line"><span class="comment">#[可选]启用中继日志</span></span><br><span class="line">relay-log=mysql-relay</span><br><span class="line"><span class="comment"># 重启后台mysql服务，使配置生效</span></span><br></pre></td></tr></table></figure><h3 id="3-4-主机：建立账户并授权">3.4 主机：建立账户并授权</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 在主机MySQL里执行授权主从复制的命令</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">REPLICATION</span> <span class="keyword">SLAVE</span> <span class="keyword">ON</span> *.* <span class="keyword">TO</span> <span class="string">'slave1'</span>@<span class="string">'从机器数据库IP'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'abc123'</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 注意：如果使用的是MySQL8，需要如下的方式建立账户，并授权slave:</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">'slave1'</span>@<span class="string">'%'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'123456'</span>;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">REPLICATION</span> <span class="keyword">SLAVE</span> <span class="keyword">ON</span> *.* <span class="keyword">TO</span> <span class="string">'slave1'</span>@<span class="string">'%'</span>;</span><br><span class="line"><span class="comment">-- 此语句必须执行。否则见下面。</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">'slave1'</span>@<span class="string">'%'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">WITH</span> mysql_native_password <span class="keyword">BY</span> <span class="string">'123456'</span>;</span><br><span class="line"><span class="keyword">flush</span> <span class="keyword">privileges</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 最后查询Master的状态，并记录下File和Position的值</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">master</span> <span class="keyword">status</span>;</span><br><span class="line"><span class="comment">-- 注意：执行完此步骤后**不要再操作主服务器MySQL**，防止主服务器状态值变化。</span></span><br></pre></td></tr></table></figure><h3 id="3-5-从机：配置需要复制的主机">3.5 从机：配置需要复制的主机</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 步骤1：从机上复制主机的命令</span></span><br><span class="line"><span class="keyword">CHANGE</span> <span class="keyword">MASTER</span> <span class="keyword">TO</span></span><br><span class="line">MASTER_HOST=<span class="string">'主机的IP地址'</span>,</span><br><span class="line">MASTER_USER=<span class="string">'主机用户名'</span>,</span><br><span class="line">MASTER_PASSWORD=<span class="string">'主机用户名的密码'</span>,</span><br><span class="line">MASTER_LOG_FILE=<span class="string">'mysql-bin.具体数字'</span>,</span><br><span class="line">MASTER_LOG_POS=具体值;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 举例</span></span><br><span class="line"><span class="keyword">CHANGE</span> <span class="keyword">MASTER</span> <span class="keyword">TO</span> MASTER_HOST=<span class="string">'192.168.1.150'</span>,MASTER_USER=<span class="string">'slave1'</span>,MASTER_PASSWORD=<span class="string">'123456'</span>,MASTER_LOG_FILE=<span class="string">'atguigu-bin.000007'</span>,MASTER_LOG_POS=<span class="number">154</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 步骤2：启动slave同步</span></span><br><span class="line"><span class="keyword">START</span> <span class="keyword">SLAVE</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 如果报错，可以执行如下操作，删除之前的relay_log信息。然后重新执行 CHANGE MASTER TO ...语句即可</span></span><br><span class="line"><span class="keyword">reset</span> <span class="keyword">slave</span>;</span><br><span class="line"><span class="comment">-- 查看同步状态，如果Slave_IO_Running和Slave_SQL_Running都是yes说明成功</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">SLAVE</span> <span class="keyword">STATUS</span>\G;</span><br></pre></td></tr></table></figure><p>如果失败，可以尝试从以下找原因</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">网络不通</span><br><span class="line">账户密码错误</span><br><span class="line">防火墙</span><br><span class="line">mysql配置文件问题</span><br><span class="line">连接服务器时语法</span><br><span class="line">主服务器mysql权限</span><br></pre></td></tr></table></figure><h3 id="3-6-停止主从同步">3.6 停止主从同步</h3><ul><li>停止主从同步命令：stop slave;</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 从库如果停止从服务器复制功能，再使用需要重新配置主从</span></span><br><span class="line"><span class="keyword">stop</span> <span class="keyword">slave</span>;</span><br><span class="line"><span class="comment">-- 主库删除Master中所有的binglog文件，并将日志索引文件清空，重新开始所有新的日志文件(慎用)</span></span><br><span class="line"><span class="keyword">reset</span> <span class="keyword">master</span>;</span><br></pre></td></tr></table></figure><h3 id="3-7-binlog格式详解">3.7 binlog格式详解</h3><p><strong>1、STATEMENT模式 （基于SQL语句的复制(statement-based replication, SBR)）</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binlog_format=STATEMENT</span><br></pre></td></tr></table></figure><p>每一条会修改数据的sql语句会记录到binlog中。<strong>这是默认的binlog格式</strong></p><ul><li>SBR 的优点：<ul><li>历史悠久，技术成熟</li><li>不需要记录每一行的变化，减少了binlog日志量，文件较小</li><li>binlog中包含了所有数据库更改信息，可以据此来审核数据库的安全等情况</li><li>binlog可以用于实时的还原，而不仅仅用于复制</li><li>主从版本可以不一样，从服务器版本可以比主服务器版本高</li></ul></li><li>SBR 的缺点：<ul><li>不是所有的UPDATE语句都能被复制，尤其是包含不确定操作的时候</li></ul></li><li>使用以下函数的语句也无法被复制：L<code>OAD_FILE()、UUID()、USER()、FOUND_ROWS()、SYSDATE()</code> (除非启动时启用了 <code>--sysdate-is-now</code> 选项)<ul><li>INSERT … SELECT 会产生比 RBR 更多的行级锁</li><li>复制需要进行全表扫描(WHERE 语句中没有使用到索引)的 UPDATE 时，需要比 RBR 请求更多的行级锁</li><li>对于有 AUTO_INCREMENT 字段的 InnoDB表而言，INSERT 语句会阻塞其他 INSERT 语句</li><li>对于一些复杂的语句，在从服务器上的耗资源情况会更严重，而 RBR 模式下，只会对那个发 生变化的记录产生影响</li><li>执行复杂语句如果出错的话，会消耗更多资源</li><li>数据表必须几乎和主服务器保持一致才行，否则可能会导致复制出错</li></ul></li></ul><p><strong>2、ROW模式（基于行的复制(row-based replication, RBR)）</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binlog_format=ROW</span><br></pre></td></tr></table></figure><p>5.1.5版本的MySQL才开始支持，不记录每条sql语句的上下文信息，仅记录哪条数据被修改了，修改成什么样了</p><ul><li>RBR 的优点：<ul><li>任何情况都可以被复制，这对复制来说是最 <code>安全可靠</code> 的。（比如：不会出现某些特定情况下 的存储过程、function、trigger的调用和触发无法被正确复制的问题）</li><li>多数情况下，从服务器上的表如果有主键的话，复制就会快了很多</li><li>复制以下几种语句时的行锁更少：INSERT … SELECT、包含 AUTO_INCREMENT 字段的 INSERT、 没有附带条件或者并没有修改很多记录的 UPDATE 或 DELETE 语句</li><li>执行 INSERT，UPDATE，DELETE 语句时锁更少</li><li>从服务器上采用 多线程 来执行复制成为可能</li></ul></li><li>RBR 的缺点：<ul><li>binlog 大了很多</li><li>复杂的回滚时 binlog 中会包含大量的数据</li><li>主服务器上执行 UPDATE 语句时，所有发生变化的记录都会写到 binlog 中，而 SBR 只会写一次，这会导致频繁发生 binlog 的并发写问题</li><li>无法从 binlog 中看到都复制了些什么语句</li></ul></li></ul><p><strong>3、MIXED模式（混合模式复制(mixed-based replication, MBR)）</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binlog_format=MIXED</span><br></pre></td></tr></table></figure><p>从5.1.8版本开始，MySQL提供了Mixed格式，实际上就是Statement与Row的结合。<strong>在Mixed模式下，一般的语句修改使用statment格式保存binlog</strong>。<strong>如一些函数，statement无法完成主从复制的操作，则采用row格式保存binlog</strong>。<br>MySQL会根据执行的每一条具体的sql语句来区分对待记录的日志形式，也就是在Statement和Row之间选择一种。</p><h3 id="3-8-其他">3.8 其他</h3><p><strong>搭建主从复制：双主双从</strong><br>一个主机m1用于处理所有写请求，它的从机s1和另一台主机m2还有它的从机s2负责所有读请求。当m1主机宕机后，m2主机负责写请求，m1、m2互为备机。结构图如下：<br><img src="https://img-blog.csdnimg.cn/img_convert/f5c167014c8b76f754610a56fa586491.png" alt="image-20220718143705843.png"></p><h2 id="4、同步数据一致性问题">4、同步数据一致性问题</h2><h3 id="4-1-问题介绍">4.1 问题介绍</h3><p><strong>主从同步的要求：</strong></p><ul><li>读库和写库的数据一致(最终一致)；</li><li>写数据必须写到写库；</li><li>读数据必须到读库(不一定)；</li></ul><h3 id="4-2-主从延迟问题">4.2 主从延迟问题</h3><blockquote><p>进行主从同步的内容是二进制日志，它是一个文件，在进行 网络传输 的过程中就一定会 存在主从延迟（比如 500ms），这样就可能造成用户在从库上读取的数据不是最新的数据，也就是主从同步中的 数据不一致性问题。</p></blockquote><p>举例：导致主从延迟的时间点主要包括以下三个:主库A执行完成一个事务，写入binlog，我们把这个时刻记为T1；之后传给从库B，我们把从库B接收完这个binlog的时刻记为T2；从库B执行完成这个事务，我们把这个时刻记为T3。在网络正常的时候，日志从主库传给从库所需的时间是很短的，即T2-T1的值是非常小的。即，网络正常情况下，主备延迟的主要来源是备库接收完binlog和执行完这个事务之间的时间差。<br>**主备延迟最直接的表现是，从库消费中继日志（relay log）的速度，比主库生产binlog的速度要慢。**造成原因：</p><ul><li>从库的机器性能比主库要差</li><li>从库的压力大</li><li>大事务的执行</li></ul><p>**举例1：**一次性用delete语句删除太多数据<br>结论：后续再删除数据的时候，要控制每个事务删除的数据量，分成多次删除。<br>**举例2：**一次性用insert…select插入太多数据<br>**举例3：**大表DDL，比如在主库对一张500W的表添加一个字段耗费了10分钟，那么从节点上也会耗费10分钟。</p><h3 id="4-3-如何减少主从延迟">4.3 如何减少主从延迟</h3><ul><li>降低多线程大事务并发的概率，优化业务逻辑</li><li>优化SQL，避免慢SQL， <code>减少批量操作</code> ，建议写脚本以update-sleep这样的形式完成。</li><li><code>提高从库机器的配置</code> ，减少主库写binlog和从库读binlog的效率差。</li><li>尽量采用 <code>短的链路</code> ，也就是主库和从库服务器的距离尽量要短，提升端口带宽，减少binlog传输的网络延时。</li><li>实时性要求的业务读强制走主库，从库只做灾备，备份</li></ul><h3 id="4-4-解决一致性问题方法">4.4 解决一致性问题方法</h3><blockquote><p>如果操作的数据存储在同一个数据库中，那么对数据进行更新的时候，可以对记录加写锁，这样在读取的时候就不会发生数据不一致的情况。但这时从库的作用就是 备份 ，并没有起到 读写分离 ，分担主库 读压力 的作用。<br>读写分离情况下，解决主从同步中数据不一致的问题， 就是解决主从之间 数据复制方式 的问题，如果按照数据一致性 从弱到强 来进行划分，有以下 3 种复制方式。</p></blockquote><h4 id="方法-1：异步复制">方法 1：异步复制</h4><p>异步模式就是客户端提交 COMMIT 之后不需要等从库返回任何结果，而是直接将结果返回给客户端，这样做的好处是不会影响主库写的效率，但可能会存在主库宕机，而Binlog还没有同步到从库的情况，也就是此时的主库和从库数据不一致。这时候从从库中选择一个作为新主，那么新主则可能缺少原来主服务器中已提交的事务。所以，这种复制模式下的数据一致性是最弱的。<br><img src="https://img-blog.csdnimg.cn/img_convert/eadad27f0d8c3cc7570c246c42f86a68.png" alt="image-20220718144410731.png"></p><h4 id="方法-2：半同步复制">方法 2：半同步复制</h4><p>MySQL5.5版本之后开始支持半同步复制的方式。原理是在<strong>客户端提交COMMIT之后不直接将结果返回给客户端，而是等待至少有一个从库接收到了Binlog，并且写入到中继日志中</strong>，再返回给客户端。这样做的好处就是提高了数据的一致性，当然相比于异步复制来说，至少多增加了一个网络连接的延迟，降低了主库写的效率。<br>在MySQL5.7版本中还增加了一个<code>rpl_semi_sync_master_wait_for_slave_count</code>参数，可以对应答的从库数量进行设置，<strong>默认为1，也就是说只要有1个从库进行了响应</strong>，就可以返回给客户端。如果将这个参数调大，可以提升数据一致性的强度，但也会增加主库等待从库响应的时间。<br><img src="https://img-blog.csdnimg.cn/img_convert/e3320fd843b1aca47873907e7d5e4fea.png" alt="image-20220718144958357.png"></p><h4 id="方法-3：组复制">方法 3：组复制</h4><p>异步复制和半同步复制都无法最终保证数据的一致性问题，半同步复制是通过判断从库响应的个数来决定是否返回给客户端，虽然数据一致性相比于异步复制有提升，但仍然无法满足对数据一致性要求高的场景，比如金融领域。MGR 很好地弥补了这两种复制模式的不足。<strong>组复制技术，简称 MGR（MySQL Group Replication）</strong>。是 MySQL 在 5.7.17 版本中推出的一种新的数据复制技术，这种复制技术是基于 Paxos 协议的状态机复制。<br><strong>MGR 是如何工作的</strong><br>首先我们将多个节点共同组成一个复制组，在 执行读写（RW）事务 的时候，需要通过一致性协议层 （Consensus 层）的同意，也就是读写事务想要进行提交，必须要经过组里“大多数人”（对应 Node 节 点）的同意，大多数指的是同意的节点数量需要大于 （N/2+1），这样才可以进行提交，而不是原发起方一个说了算。而针对 只读（RO）事务 则不需要经过组内同意，直接 COMMIT 即可。在一个复制组内有多个节点组成，它们各自维护了自己的数据副本，并且在一致性协议层实现了原子消 息和全局有序消息，从而保证组内数据的一致性。<br><img src="https://img-blog.csdnimg.cn/img_convert/86f91998d0c6d09e8657f5c91d8c7b07.png" alt="image-20220718145235499.png"><br>MGR 将 MySQL 带入了数据强一致性的时代，是一个划时代的创新，其中一个重要的原因就是MGR 是基 于 Paxos 协议的。Paxos 算法是由 2013 年的图灵奖获得者 Leslie Lamport 于 1990 年提出的，有关这个算法的决策机制可以搜一下。事实上，Paxos 算法提出来之后就作为 分布式一致性算法 被广泛应用，比如 Apache 的 ZooKeeper 也是基于 Paxos 实现的。</p><h2 id="5、知识延伸">5、知识延伸</h2><p>在主从架构的配置中，如果想要采取读写分离的策略，我们可以<code>自己编写程序</code> ，也可以通过 <code>第三方的中间件</code> 来实现。</p><ul><li>自己编写程序的好处就在于比较自主，我们可以自己判断哪些查询在从库上来执行，针对实时性要 求高的需求，我们还可以考虑哪些查询可以在主库上执行。同时，程序直接连接数据库，减少了中间件层，相当于减少了性能损耗。</li><li>采用中间件的方法有很明显的优势，<code>功能强大</code> ， <code>使用简单</code> 。但因为在客户端和数据库之间增加了 中间件层会有一些 <code>性能损耗</code> ，同时商业中间件也是有使用成本的。我们也可以考虑采取一些优秀的开源工具。</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/29fdb08150cfc1338d26c53dbe684160.png" alt="image-20220718145428456.png"></p><h1>七、数据库备份与恢复</h1><h2 id="1、概述-v3">1、概述</h2><h3 id="1-1-备份简介">1.1 备份简介</h3><p>在任何数据库环境中，总会有不确定的意外情况发生，比如例外的停电、计算机系统中的各种软硬件故障、人为破坏、管理员误操作等是不可避免的，这些情况可能会导致数据的丢失、服务器瘫痪等严重的后果。存在多个服务器时，会出现主从服务器之间的数据同步问题。<br>为了有效防止数据丢失，并将损失降到最低，应定期对MySQL数据库服务器做备份。如果数据库中的数据丢失或者出现错误，可以使用备份的数据进行恢复。主从服务器之间的数据同步问题可以通过复制功能实现。\</p><h3 id="1-2-物理备份与逻辑备份">1.2 物理备份与逻辑备份</h3><p>**物理备份：**备份数据文件，转储数据库物理文件到某一目录。物理备份恢复速度比较快，但占用空间比较大，MySQL中可以用 xtrabackup 工具来进行物理备份。<br>**逻辑备份：**对数据库对象利用工具进行导出工作，汇总入备份文件内。逻辑备份恢复速度慢，但占用空间小，更灵活。MySQL 中常用的逻辑备份工具为 mysqldump 。逻辑备份就是 备份sql语句 ，在恢复的 时候执行备份的sql语句实现数据库数据的重现。</p><h2 id="2、mysqldump实现逻辑备份">2、mysqldump实现逻辑备份</h2><h3 id="2-1-备份数据库">2.1 备份数据库</h3><p>mysqldump命令执行时，可以将数据库备份成一个<code>文本文件</code>，该文件中实际上包含多个<code>CREATE</code>和<code>INSERT</code>语句，使用这些语句可以重新创建表和插入数据。</p><ul><li>查出需要备份的表的结构，在文本文件中生成一个CREATE语句</li><li>将表中的所有记录转换为一条INSERT语句</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># =====================备份一个数据库=======================</span></span><br><span class="line"><span class="comment"># 基本语法</span></span><br><span class="line">mysqldump –u 用户名称 –h 主机名称 –p密码 待备份的数据库名称[tbname, [tbname...]]&gt; 备份文件名称.sql</span><br><span class="line"><span class="comment"># 备份的文件并非一定要求后缀名为.sql，例如后缀名为.txt的文件也是可以的</span></span><br><span class="line">mysqldump -uroot -p atguigu&gt;atguigu.sql <span class="comment">#备份文件存储在当前目录下</span></span><br><span class="line">mysqldump -uroot -p atguigudb1 &gt; /var/lib/mysql/atguigu.sql</span><br><span class="line"></span><br><span class="line"><span class="comment"># =====================备份全部数据库========================</span></span><br><span class="line"><span class="comment"># 若想用mysqldump备份整个实例，可以使用 --all-databases 或 -A 参数</span></span><br><span class="line">mysqldump -uroot -pxxxxxx --all-databases &gt; all_database.sql</span><br><span class="line">mysqldump -uroot -pxxxxxx -A &gt; all_database.sql</span><br><span class="line"></span><br><span class="line"><span class="comment"># ======================备份部分数据库=========================</span></span><br><span class="line"><span class="comment"># 使用 `--databases` 或 `-B` 参数了，该参数后面跟数据库名称，多个数据库间用空格隔开。如果指定 databases参数，备份文件中会存在创建数据库的语句，如果不指定参数，则不存在</span></span><br><span class="line">mysqldump –u user –h host –p --databases [数据库的名称1 [数据库的名称2...]] &gt; 备份文件名称.sql</span><br><span class="line">mysqldump -uroot -p --databases atguigu atguigu12 &gt;two_database.sql</span><br><span class="line">mysqldump -uroot -p -B atguigu atguigu12 &gt; two_database.sql</span><br></pre></td></tr></table></figure><h3 id="2-2-备份数据表">2.2 备份数据表</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ====================备份部分表=================================</span></span><br><span class="line">mysqldump –u user –h host –p 数据库的名称 [表名1 [表名2...]] &gt; 备份文件名称.sql</span><br><span class="line">mysqldump -uroot -p atguigu book&gt; book.sql</span><br><span class="line"></span><br><span class="line"><span class="comment"># =====================备份单表的部分数据===========================</span></span><br><span class="line"><span class="comment"># 有些时候一张表的数据量很大，我们只需要部分数据。这时就可以使用 --where 选项了</span></span><br><span class="line">mysqldump -uroot -p atguigu student --<span class="built_in">where</span>=<span class="string">"id &lt; 10 "</span> &gt; student_part_id10_low_bak.sql</span><br><span class="line"></span><br><span class="line"><span class="comment"># ========================排除某些表的备份===========================</span></span><br><span class="line"><span class="comment"># 如果我们想备份某个库，但是某些表数据量很大或者与业务关联不大，这个时候可以考虑排除掉这些表，同样的，选项 `--ignore-table` 可以完成这个功能</span></span><br><span class="line">mysqldump -uroot -p atguigu --ignore-table=atguigu.student &gt; no_stu_bak.sql</span><br><span class="line"><span class="comment"># 通过如下指定判定文件中没有student表结构</span></span><br><span class="line">grep <span class="string">"student"</span> no_stu_bak.sql</span><br></pre></td></tr></table></figure><h3 id="2-3-只备份结构或只备份数据">2.3 只备份结构或只备份数据</h3><p>只备份结构的话可以使用 --no-data 简写为 -d 选项；只备份数据可以使用 --no-create-info 简写为 -t选项</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ======================只备份结构===================</span></span><br><span class="line">mysqldump -uroot -p atguigu --no-data &gt; atguigu_no_data_bak.sql</span><br><span class="line"><span class="comment">#使用grep命令，没有找到insert相关语句，表示没有数据备份。</span></span><br><span class="line">grep <span class="string">"INSERT"</span> atguigu_no_data_bak.sql</span><br><span class="line"></span><br><span class="line"><span class="comment"># ======================只备份数据=====================</span></span><br><span class="line">mysqldump -uroot -p atguigu --no-create-info &gt; atguigu_no_create_info_bak.sql</span><br><span class="line"><span class="comment">#使用grep命令，没有找到create相关语句，表示没有数据结构。</span></span><br><span class="line">grep <span class="string">"CREATE"</span> atguigu_no_create_info_bak.sql</span><br></pre></td></tr></table></figure><h3 id="2-4-备份中包含存储过程、函数、事件">2.4 备份中包含存储过程、函数、事件</h3><p>mysqldump备份默认是不包含存储过程，自定义函数及事件的。可以使用 <code>--routines</code> 或 <code>-R</code> 选项来备份存储过程及函数，使用 <code>--events</code> 或 <code>-E</code> 参数来备份事件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前库有哪些存储过程或者函数</span></span><br><span class="line">SELECT SPECIFIC_NAME,ROUTINE_TYPE,ROUTINE_SCHEMA FROM information_schema.Routines WHERE ROUTINE_SCHEMA=<span class="string">"atguigu"</span>;</span><br><span class="line"><span class="comment"># 备份</span></span><br><span class="line">mysqldump -uroot -p -R -E --databases atguigu &gt; fun_atguigu_bak.sql</span><br><span class="line"><span class="comment"># 查询备份文件中是否存在函</span></span><br><span class="line">grep -C 5 <span class="string">"rand_num"</span> fun_atguigu_bak.sql</span><br></pre></td></tr></table></figure><h3 id="2-5-mysqldump常用选项">2.5 mysqldump常用选项</h3><p>行帮助命令 mysqldump --help ，可以获得特定版本的完整选项列表。提示 如果运行mysqldump没有–quick或–opt选项，mysqldump在转储结果前将整个结果集装入内 存。如果转储大数据库可能会出现问题，该选项默认启用，但可以用–skip-opt禁用。如果使用最 新版本的mysqldump程序备份数据，并用于恢复到比较旧版本的MySQL服务器中，则不要使用–opt 或-e选项</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">--add-drop-database <span class="comment"># 在每个CREATE DATABASE语句前添加DROP DATABASE语句。</span></span><br><span class="line">--add-drop-tables <span class="comment"># 在每个CREATE TABLE语句前添加DROP TABLE语句。</span></span><br><span class="line">--add-locking <span class="comment"># 用LOCK TABLES和UNLOCK TABLES语句引用每个表转储。重载转储文件时插入得更快。</span></span><br><span class="line">--all-database, -A <span class="comment"># 转储所有数据库中的所有表。与使用--database选项相同，在命令行中命名所有数据库。</span></span><br><span class="line">--comment[=0|1] <span class="comment"># 如果设置为0，禁止转储文件中的其他信息，例如程序版本、服务器版本和主机。--skip-comments与--comments=0的结果相同。默认值为1，即包括额外信息。</span></span><br><span class="line">--compact <span class="comment"># 产生少量输出。该选项禁用注释并启用--skip-add-drop-tables、--no-set-names、--skip-disable-keys和--skip-add-locking选项。</span></span><br><span class="line">--compatible=name <span class="comment"># 产生与其他数据库系统或旧的MySQL服务器更兼容的输出，值可以为ansi、MySQL323、MySQL40、postgresql、oracle、mssql、db2、maxdb、no_key_options、no_table_options或者no_field_options。</span></span><br><span class="line">--complete_insert, -c <span class="comment"># 使用包括列名的完整的INSERT语句。</span></span><br><span class="line">--debug[=debug_options], -[debug_options] <span class="comment"># 写调试日志。</span></span><br><span class="line">--delete，-D <span class="comment"># 导入文本文件前清空表。</span></span><br><span class="line">--default-character-set=charset <span class="comment"># 使用charsets默认字符集。如果没有指定，就使用utf8。</span></span><br><span class="line">--delete-master-logs <span class="comment"># 在主复制服务器上，完成转储操作后删除二进制日志。该选项自动启用-master-data。</span></span><br><span class="line">--extended-insert，-e <span class="comment"># 使用包括几个VALUES列表的多行INSERT语法。这样使得转储文件更小，重载文件时可以加速插入。</span></span><br><span class="line">--flush-logs，-F <span class="comment"># 开始转储前刷新MySQL服务器日志文件。该选项要求RELOAD权限。</span></span><br><span class="line">--force，-f <span class="comment"># 在表转储过程中，即使出现SQL错误也继续。</span></span><br><span class="line">--lock-all-tables，-x <span class="comment"># 对所有数据库中的所有表加锁。在整体转储过程中通过全局锁定来实现。该选项自动关闭--single-transaction和--lock-tables。</span></span><br><span class="line">--lock-tables，-l <span class="comment"># 开始转储前锁定所有表。用READ LOCAL锁定表以允许并行插入MyISAM表。对于事务表（例如InnoDB和BDB），--single-transaction是一个更好的选项，因为它根本不需要锁定表。</span></span><br><span class="line">--no-create-db，-n <span class="comment"># 该选项禁用CREATE DATABASE /*!32312 IF NOT EXIST*/db_name语句，如果给出--database或--all-database选项，就包含到输出中。</span></span><br><span class="line">--no-create-info，-t <span class="comment"># 只导出数据，而不添加CREATE TABLE语句。</span></span><br><span class="line">--no-data，-d <span class="comment"># 不写表的任何行信息，只转储表的结构。</span></span><br><span class="line">--opt <span class="comment"># 该选项是速记，它可以快速进行转储操作并产生一个能很快装入MySQL服务器的转储文件。该选项默认开启，但可以用--skip-opt禁用。</span></span><br><span class="line">--password[=password]，-p[password] <span class="comment"># 当连接服务器时使用的密码。</span></span><br><span class="line">-port=port_num，-P port_num <span class="comment"># 用于连接的TCP/IP端口号。</span></span><br><span class="line">--protocol=&#123;TCP|SOCKET|PIPE|MEMORY&#125; <span class="comment"># 使用的连接协议。</span></span><br><span class="line">--replace，-r –replace和--ignore <span class="comment"># 控制替换或复制唯一键值已有记录的输入记录的处理。如果指定--replace，新行替换有相同的唯一键值的已有行；如果指定--ignore，复制已有的唯一键值的输入行被跳过。如果不指定这两个选项，当发现一个复制键值时会出现一个错误，并且忽视文本文件的剩余部分。</span></span><br><span class="line">--silent，-s <span class="comment"># 沉默模式。只有出现错误时才输出。</span></span><br><span class="line">--socket=path，-S path <span class="comment"># 当连接localhost时使用的套接字文件（为默认主机）。</span></span><br><span class="line">--user=user_name，-u user_name <span class="comment"># 当连接服务器时MySQL使用的用户名。</span></span><br><span class="line">--verbose，-v <span class="comment"># 冗长模式，打印出程序操作的详细信息。</span></span><br><span class="line">--xml，-X <span class="comment"># 产生XML输出。</span></span><br></pre></td></tr></table></figure><h2 id="3、mysql命令恢复数据">3、mysql命令恢复数据</h2><p>使用mysqldump命令将数据库中的数据备份成一个文本文件。需要恢复时，可以使用mysql命令来恢复备份的数据。mysql命令可以执行备份文件中的CREATE语句和INSERT语句。通过CREATE语句来创建数据库和表。通过INSERT语句来插入备份的数据。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql –u root –p [dbname] &lt; backup.sql</span><br></pre></td></tr></table></figure><p>其中，dbname参数表示数据库名称。该参数是可选参数，可以指定数据库名，也可以不指定。指定数据库名时，表示还原该数据库下的表。<strong>此时需要确保MySQL服务器中已经创建了该名的数据库</strong>。不指定数据库名，表示还原文件中所有的数据库。此时sql文件中包含有CREATE DATABASE语句，不需要MySQL服务器中已存在的这些数据库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===========================单库备份中恢复单库=========================</span></span><br><span class="line"><span class="comment"># 如果备份文件中包含了创建数据库的语句，则恢复的时候不需要指定数据库名称</span></span><br><span class="line">mysql -uroot -p &lt; atguigu.sql</span><br><span class="line"><span class="comment"># 否则需要指定数据库名称</span></span><br><span class="line">mysql -uroot -p atguigu4&lt; atguigu.sql</span><br><span class="line"></span><br><span class="line"><span class="comment"># =========================全量备份恢复=============================</span></span><br><span class="line">mysql -uroot -pxxxxxx &lt; all.sql</span><br><span class="line"><span class="comment"># 说我们只想恢复某一个库，但是我们有的是整个实例的备份，这个时候我们可以从全量备份中分离出单个库的备份</span></span><br><span class="line"><span class="comment">#举例，分离完成后我们再导入atguigu.sql即可恢复单个库</span></span><br><span class="line">sed -n <span class="string">'/^-- Current Database: `atguigu`/,/^-- Current Database: `/p'</span> all_database.sql &gt; atguigu.sql</span><br><span class="line"></span><br><span class="line"><span class="comment"># ========================从单库备份中恢复单表========================</span></span><br><span class="line"><span class="comment"># 解释可以参考https://www.jianshu.com/p/5c56580c326a/</span></span><br><span class="line">cat atguigu.sql | sed -e <span class="string">'/./&#123;H;$!d;&#125;'</span> -e <span class="string">'x;/CREATE TABLE `class`/!d;q'</span> &gt; class_structure.sql</span><br><span class="line">cat atguigu.sql | grep --ignore-case <span class="string">'insert into `class`'</span> &gt; class_data.sql</span><br><span class="line"><span class="comment">#用shell语法分离出创建表的语句及插入数据的语句后 再依次导出即可完成恢复</span></span><br><span class="line"></span><br><span class="line">use atguigu;</span><br><span class="line">mysql&gt; <span class="built_in">source</span> class_structure.sql;</span><br><span class="line">mysql&gt; <span class="built_in">source</span> class_data.sql;</span><br></pre></td></tr></table></figure><h2 id="4、物理备份与恢复">4、物理备份与恢复</h2><h3 id="4-1-物理备份">4.1 物理备份</h3><p>直接将MySQL中的数据库文件复制出来。这种方法最简单，速度也最快。MySQL的数据库目录位置不一 定相同：</p><ul><li>在Windows平台下，MySQL 8.0存放数据库的目录通常默认为 “ C:\ProgramData\MySQL\MySQL Server 8.0\Data ”或者其他用户自定义目录；</li><li>在Linux平台下，数据库目录位置通常为/var/lib/mysql/；</li><li>在MAC OSX平台下，数据库目录位置通常为“/usr/local/mysql/data”</li></ul><p>但为了保证备份的一致性。需要保证：</p><ul><li>方式1：备份前，将服务器停止。</li><li>方式2：备份前，对相关表执行 <code>FLUSH TABLES WITH READ LOCK</code> 操作。这样当复制数据库目录中 的文件时，允许其他客户继续查询表。同时，FLUSH TABLES语句来确保开始备份前将所有激活的索 引页写入硬盘。</li></ul><p>这种方式方便、快速，但不是最好的备份方法，因为实际情况可能 <code>不允许停止MySQL服务器</code> 或者 <code>锁住表</code> ，而且这种方法 对InnoDB存储引擎 的表不适用。对于MyISAM存储引擎的表，这样备份和还原很方便，但是还原时最好是相同版本的MySQL数据库，否则可能会存在文件类型不同的情况。注意，物理备份完毕后，执行 <code>UNLOCK TABLES</code> 来结算其他客户对表的修改行为。</p><blockquote><p>说明： 在MySQL版本号中，第一个数字表示主版本号，主版本号相同的MySQL数据库文件格式相同。</p></blockquote><p>此外，还可以考虑使用相关工具实现备份。比如， <code>MySQLhotcopy</code> 工具。MySQLhotcopy是一个Perl脚本，它使用LOCK TABLES、FLUSH TABLES和cp或scp来快速备份数据库。它是备份数据库或单个表最快的途径，但它只能运行在数据库目录所在的机器上，并且只能备份MyISAM类型的表。多用于mysql5.5之前。</p><h3 id="4-2-物理恢复">4.2 物理恢复</h3><p><strong>步骤：</strong><br>1）演示删除备份的数据库中指定表的数据<br>2）将备份的数据库数据拷贝到数据目录下，并重启MySQL服务器<br>3）查询相关表的数据是否恢复。需要使用下面的<code>chown</code> 操作。<br><strong>要求：</strong></p><ul><li>必须确保备份数据的数据库和待恢复的数据库服务器的主版本号相同。 因为只有MySQL数据库主版本号相同时，才能保证这两个MySQL数据库文件类型是相同的。</li><li>这种方式对 <code>MyISAM类型的表比较有效</code> ，对于InnoDB类型的表则不可用。 因为InnoDB表的表空间不能直接复制。</li><li>在Linux操作系统下，复制到数据库目录后，一定要将数据库的用户和组变成mysql，命令如下：<code>chown -R mysql.mysql /var/lib/mysql/dbname</code>。其中，两个mysql分别表示组和用户；“-R”参数可以改变文件夹下的所有子文件的用户和组；“dbname”参数表示数据库目录</li></ul><blockquote><p>提示 ：Linux操作系统下的权限设置非常严格。通常情况下，MySQL数据库只有root用户和mysql用户 组下的mysql用户才可以访问，因此将数据库目录复制到指定文件夹后，一定要使用chown命令将 文件夹的用户组变为mysql，将用户变为mysql。</p></blockquote><h2 id="5、表的导出与导入">5、表的导出与导入</h2><h3 id="5-1-表的导出">5.1 表的导出</h3><h4 id="1、使用SELECT…INTO-OUTFILE导出文本文件">1、使用SELECT…INTO OUTFILE导出文本文件</h4><p>在MySQL中，可以使用SELECT…INTO OUTFILE语句将表的内容导出成一个文本文件。但是mysql默认对导出的目录有权限限制，也就是说使用命令行进行导出的时候，需要指定目录进行操作。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询secure_file_priv值</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">'%secure%'</span>;</span><br><span class="line"><span class="comment">-- 参数secure_file_priv的可选值和作用分别是:</span></span><br><span class="line"><span class="comment">-- 如果设置为empty，表示不限制文件生成的位置，这是不安全的设置;</span></span><br><span class="line"><span class="comment">-- 如果设置为一个表示路径的字符串，就要求生成的文件只能放在这个指定的目录，或者它的子目录;</span></span><br><span class="line"><span class="comment">-- 如果设置为NULL，就表示禁止在这个MySQL实例上执行select ... into outfile操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- secure_file_priv变量的值为/var/lib/mysql-files/，导出目录设置为该目录</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">account</span> <span class="keyword">INTO</span> <span class="keyword">OUTFILE</span> <span class="string">"/var/lib/mysql-files/account.txt"</span>;</span><br><span class="line"><span class="comment">-- 查看 /var/lib/mysql-files/account.txt文件</span></span><br></pre></td></tr></table></figure><h4 id="2、使用mysqldump命令导出文本文件">2、使用mysqldump命令导出文本文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用mysqldump命令将将atguigu数据库中account表中的记录导出到文本文件</span></span><br><span class="line">mysqldump -uroot -p -T <span class="string">"/var/lib/mysql-files/"</span> atguigu account</span><br><span class="line"><span class="comment"># 使用mysqldump将atguigu数据库中的account表导出到文本文件，使用FIELDS选项，要求字段之 间使用逗号“，”间隔，所有字符类型字段值用双引号括起来</span></span><br><span class="line">mysqldump -uroot -p -T <span class="string">"/var/lib/mysql-files/"</span> atguigu account --fields-terminated-by=<span class="string">','</span> --fields-optionally-enclosed-by=<span class="string">'\"'</span></span><br></pre></td></tr></table></figure><h4 id="3、使用mysql命令导出文本文件">3、使用mysql命令导出文本文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用mysql语句导出atguigu数据中account表中的记录到文本文件</span></span><br><span class="line">mysql -uroot -p --execute=<span class="string">"SELECT * FROM account;"</span> atguigu&gt; <span class="string">"/var/lib/mysql-files/account.txt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将atguigu数据库account表中的记录导出到文本文件，使用--veritcal参数将该条件记录分为多行显示</span></span><br><span class="line">mysql -uroot -p --vertical --execute=<span class="string">"SELECT * FROM account;"</span> atguigu &gt; <span class="string">"/var/lib/mysql-files/account_1.txt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将atguigu数据库account表中的记录导出到xml文件，使用--xml参数</span></span><br><span class="line">mysql -uroot -p --xml --execute=<span class="string">"SELECT * FROM account;"</span> atguigu&gt;<span class="string">"/var/lib/mysqlfiles/account_3.xml"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果要将表数据导出到html文件中，可以使用 `--html` 选项</span></span><br></pre></td></tr></table></figure><h3 id="6-2-表的导入">6.2 表的导入</h3><h4 id="1、使用LOAD-DATA-INFILE方式导入文本文件">1、使用LOAD DATA INFILE方式导入文本文件</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用SELECT...INTO OUTFILE将atguigu数据库中account表的记录导出到文本文件</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> atguigu.account <span class="keyword">INTO</span> <span class="keyword">OUTFILE</span> <span class="string">'/var/lib/mysql-files/account_0.txt'</span>;</span><br><span class="line"><span class="comment">-- 刪除数据</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> atguigu.account;</span><br><span class="line"><span class="comment">-- 从文本文件account.txt中恢复数据</span></span><br><span class="line"><span class="keyword">LOAD</span> <span class="keyword">DATA</span> <span class="keyword">INFILE</span> <span class="string">'/var/lib/mysql-files/account_0.txt'</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> atguigu.account;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 选择数据库atguigu，使用SELECT…INTO OUTFILE将atguigu数据库account表中的记录导出到文本文件，使用FIELDS选项和LINES选项，要求字段之间使用逗号"，"间隔，所有字段值用双引号括起来</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> atguigu.account <span class="keyword">INTO</span> <span class="keyword">OUTFILE</span> <span class="string">'/var/lib/mysql-files/account_1.txt'</span> <span class="keyword">FIELDS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">','</span> <span class="keyword">ENCLOSED</span> <span class="keyword">BY</span> <span class="string">'\"'</span>;</span><br><span class="line"><span class="keyword">LOAD</span> <span class="keyword">DATA</span> <span class="keyword">INFILE</span> <span class="string">'/var/lib/mysql-files/account_1.txt'</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> atguigu.account <span class="keyword">FIELDS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">','</span> <span class="keyword">ENCLOSED</span> <span class="keyword">BY</span> <span class="string">'\"'</span>;</span><br></pre></td></tr></table></figure><h4 id="2、使用mysqlimport方式导入文本文件">2、使用mysqlimport方式导入文本文件</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 导出文件account.txt，字段之间使用逗号"，"间隔，字段值用双引号括起来</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> atguigu.account <span class="keyword">INTO</span> <span class="keyword">OUTFILE</span> <span class="string">'/var/lib/mysql-files/account.txt'</span> <span class="keyword">FIELDS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">','</span> <span class="keyword">ENCLOSED</span> <span class="keyword">BY</span> <span class="string">'\"'</span>;</span><br><span class="line"><span class="comment">-- 使用mysqlimport命令将account.txt文件内容导入到数据库atguigu的account表中</span></span><br><span class="line">mysqlimport -uroot -p atguigu '/var/lib/mysql-files/account.txt' <span class="comment">--fields-terminated-by=',' --fields-optionally-enclosed-by='\"'</span></span><br></pre></td></tr></table></figure><h2 id="6、数据库迁移">6、数据库迁移</h2><h3 id="6-1-概述">6.1 概述</h3><p>数据迁移（data migration）是指选择、准备、提取和转换数据，并<strong>将数据从一个计算机存储系统永久地传输到另一个计算机存储系统的过程</strong>。此外，验证迁移数据的完整性 和 退役原来旧的数据存储 ，也被认为是整个数据迁移过程的一部分。<br>数据库迁移的原因是多样的，包括服务器或存储设备更换、维护或升级，应用程序迁移，网站集成，灾难恢复和数据中心迁移。根据不同的需求可能要采取不同的迁移方案，但总体来讲，MySQL 数据迁移方案大致可以分为物理迁移和 逻辑迁移 两类。通常以尽可能 自动化 的方式执行，从而将人力资源从繁琐的任务中解放出来。</p><h3 id="6-2-迁移方案">6.2 迁移方案</h3><ul><li>物理迁移</li></ul><p>物理迁移适用于大数据量下的整体迁移。使用物理迁移方案的优点是比较快速，但需要停机迁移并且要 求 MySQL 版本及配置必须和原服务器相同，也可能引起未知问题。物理迁移包括拷贝数据文件和使用 XtraBackup 备份工具两种。<br>不同服务器之间可以采用物理迁移，我们可以在新的服务器上安装好同版本的数据库软件，创建好相同目录，建议配置文件也要和原数据库相同，然后从原数据库方拷贝来数据文件及日志文件，配置好文件组权限，之后在新服务器这边使用 mysqld 命令启动数据库。</p><ul><li>逻辑迁移</li></ul><p>逻辑迁移适用范围更广，无论是 <code>部分迁移</code> 还是 <code>全量迁移</code> ，都可以使用逻辑迁移。逻辑迁移中使用最多的就是通过 mysqldump 等备份工具</p><h3 id="6-3-迁移注意点">6.3 迁移注意点</h3><p><strong>1、相同版本的数据库之间迁移注意点</strong><br>指的是在主版本号相同的MySQL数据库之间进行数据库移动。<br>方式1： 因为迁移前后MySQL数据库的 主版本号相同 ，所以可以通过复制数据库目录来实现数据库迁移，但是物理迁移方式只适用于MyISAM引擎的表。对于InnoDB表，不能用直接复制文件的方式备份数据库。<br>方式2： 最常见和最安全的方式是使用 mysqldump命令 导出数据，然后在目标数据库服务器中使用 MySQL命令导入。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#host1的机器中备份所有数据库,并将数据库迁移到名为host2的机器上</span></span><br><span class="line">mysqldump –h host1 –uroot –p –-all-databases| mysql –h host2 –uroot –p</span><br><span class="line"></span><br><span class="line"><span class="comment"># “|”符号表示管道，其作用是将mysqldump备份的文件给mysql命令；</span></span><br><span class="line"><span class="comment"># “--all-databases”表示要迁移所有的数据库。通过这种方式可以直接实现迁移。</span></span><br></pre></td></tr></table></figure><p><strong>2、不同版本的数据库之间迁移注意点</strong><br>例如，原来很多服务器使用5.7版本的MySQL数据库，在8.0版本推出来以后，改进了5.7版本的很多缺陷， 因此需要把数据库升级到8.0版本旧版本与新版本的MySQL可能使用不同的默认字符集，例如有的旧版本中使用latin1作为默认字符集，而最新版本的MySQL默认字符集为utf8mb4。如果数据库中有中文数据，那么迁移过程中需要对 默认字符集 进行修改 ，不然可能无法正常显示数据。<br>高版本的MySQL数据库通常都会 兼容低版本 ，因此可以从低版本的MySQL数据库迁移到高版本的MySQL 数据库。<br><strong>3、不同数据库之间迁移注意点</strong><br>不同数据库之间迁移是指从其他类型的数据库迁移到MySQL数据库，或者从MySQL数据库迁移到其他类 型的数据库。这种迁移没有普适的解决方法。<br>迁移之前，需要了解不同数据库的架构， 比较它们之间的差异 。不同数据库中定义相同类型的数据的 关键字可能会不同 。例如，MySQL中日期字段分为DATE和TIME两种，而ORACLE日期字段只有DATE；SQL Server数据库中有ntext、Image等数据类型，MySQL数据库没有这些数据类型；MySQL支持的ENUM和SET 类型，这些SQL Server数据库不支持。<br>另外，数据库厂商并没有完全按照SQL标准来设计数据库系统，导致不同的数据库系统的 SQL语句 有差别。例如，微软的SQL Server软件使用的是T-SQL语句，T-SQL中包含了非标准的SQL语句，不能和MySQL的SQL语句兼容。不同类型数据库之间的差异造成了互相 迁移的困难 ，这些差异其实是商业公司故意造成的技术壁垒。但 是不同类型的数据库之间的迁移并 不是完全不可能 。例如，可以使用MyODBC 实现MySQL和SQL Server之 间的迁移。MySQL官方提供的工具 MySQL Migration Toolkit 也可以在不同数据之间进行数据迁移。 MySQL迁移到Oracle时，需要使用mysqldump命令导出sql文件，然后， 手动更改 sql文件中的CREATE语句。</p><h3 id="6-4-迁移小结">6.4 迁移小结</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/9d08c83e5ee07c07c1d56ab68ab73080.png" alt="image-20220718165515965.png"></p><h2 id="7、误删数据集合">7、误删数据集合</h2><p>传统的高可用架构是不能预防误删数据的，因为主库的一个drop table命令，会通过binlog传给所有从库和级联从库，进而导致整个集群的实例都会执行这个命令。为了找到解决误删数据的更高效的方法，我们需要先对和MySQL相关的误删数据，做下分类:</p><ul><li>使用delete语句误删数据行;</li><li>使用drop table或者truncate table语句误删数据表;</li><li>使用drop database语句误删数据库;</li><li>使用rm命令误删整个MySQL实例。</li></ul><h3 id="7-1-delete：误删行">7.1 delete：误删行</h3><p><strong>处理措施1：数据恢复</strong><br>使用<code>Flashback</code>工具恢复数据。原理:<code>修改binlog</code>内容，拿回原库重放。如果误删数据涉及到了多个事务的话，需要将事务的顺序调过来再执行。使用前提:<code>binlog_format=row</code>和<code>binlog_row_image=FULL</code>。<br><strong>处理措施2：预防</strong></p><ul><li>代码上线前，必须SQL审查、审计</li><li>建议可以打开安全模式，<strong>把sql_safe_updates参数设置为on</strong>。强制要求加where 条件且where后需要是索引字段，否则必须使用limit。否则就会报错。</li></ul><h3 id="7-2-truncate-drop-：误删库-表">7.2 truncate/drop ：误删库/表</h3><p><strong>背景:</strong><br>delete全表是很慢的，需要生成回滚日志、写redo、写binlog。所以，从性能角度考虑，优先考虑使用<code>truncate table</code>或者<code>drop table</code>命令。使用delete命令删除的数据，你还可以用Flashback来恢复。而使用<code>truncate /drop table</code>和<code>drop database</code>命令删除的数据，就没办法通过Flashback来恢复了。因为，即使我们配置了binlog_format=row，执行这三个命令时，记录的binlog还是statement格式。binlog里面就只有一个truncate/drop语句，这些信息是恢复不出数据的。<br><strong>方案:</strong><br>这种情况下恢复数据，需要使用<strong>全量备份</strong>与<strong>增量日志</strong>结合的方式。方案的前提:有定期的全量备份，并且实时备份binlog。举例:有人误删了一个库，时间为下午3点。步骤如下:</p><ul><li>取最近一次<strong>全量备份</strong>。假设设置数据库库是一天一备，最近备份数据是当天<strong>凌晨2点</strong>;</li><li>用备份恢复出一个<strong>临时库;</strong>（注意:这里选择临时库，而不是直接操作主库)</li><li>取出凌晨2点之后的binlog日志;</li><li>剔除误删除数据的语句外，其它语句全部应用到临时库。(前面讲过binlog的恢复)</li><li>最后恢复到主库</li></ul><h3 id="7-3-预防使用truncate-drop误删库-表">7.3 预防使用truncate/drop误删库/表</h3><p><strong>权限分离</strong></p><ul><li>限制帐户权限，核心的数据库，一般都<strong>不能随便分配写权限</strong>，想要获取写权限需要<strong>审批</strong>。比如只给业务开发人员DML权限，不给truncate/drop权限。即使是DBA团队成员，日常也都规定只使用<strong>只读账号</strong>，必要的时候才使用有更新权限的账号</li><li>不同的账号，不同的数据之间要进行权限分离，避免一个账号可以删除所有库</li></ul><p><strong>制定操作规范</strong><br>比如在删除数据表之前，必须先对表做改名操作（比如加<code>_to_be_deleted</code> )。然后，观察一段时间，确保对业务无影响以后再删除这张表<br><strong>设置延迟复制备库</strong><br>简单的说延迟复制就是设置一个固定的延迟时间，比如1个小时，让从库落后主库一个小时。出现误删除操作1小时内，到这个备库上执行<code>stop slave</code>，再通过之前介绍的方法，跳过误操作命令，就可以恢复出需要的数据。这里通过<code>CHANGE MASTER TO MASTER_DELAY = N</code>命令，可以指定这个备库持续保持跟主库有N秒的延迟。比如把N设置为3600，即代表1个小时<br>此外，延迟复制还可以用来解决以下问题:|<br>用来做<code>延迟测试</code>，比如做好的数据库读写分离，把从库作为读库，那么想知道当数据产生延迟的时候到底会发生什么，就可以使用这个特性模拟延迟。用于<code>老数据的查询等需求</code>，比如你经常需要查看某天前一个表或者字段的数值，你可能需要把备份恢复后进行查看，如果有延迟从库，比如延迟一周，那么就可以解决这样类似的需求。</p><h3 id="7-4-rm：误删MySQL实例">7.4 rm：误删MySQL实例</h3><p>对于一个有高可用机制的MySQL集群来说，不用担心 rm删除数据 了。只是删掉了其中某一个节点的数据的话，HA系统就会开始工作，选出一个新的主库，从而保证整个集群的正常工作。我们要做的就是在这个节点上把数据恢复回来，再接入整个集群。<br>但如果是恶意地把整个集群删除，那就需要考虑跨机房备份，跨城市备份。</p><hr><p>参考<br><a href="https://www.bilibili.com/video/BV1iq4y1u7vj" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1iq4y1u7vj</a></p><h2 id="7、误删数据集合-v2">7、误删数据集合</h2><p>传统的高可用架构是不能预防误删数据的，因为主库的一个drop table命令，会通过binlog传给所有从库和级联从库，进而导致整个集群的实例都会执行这个命令。为了找到解决误删数据的更高效的方法，我们需要先对和MySQL相关的误删数据，做下分类:</p><ul><li>使用delete语句误删数据行;</li><li>使用drop table或者truncate table语句误删数据表;</li><li>使用drop database语句误删数据库;</li><li>使用rm命令误删整个MySQL实例。</li></ul><h3 id="7-1-delete：误删行-v2">7.1 delete：误删行</h3><p><strong>处理措施1：数据恢复</strong><br>使用<code>Flashback</code>工具恢复数据。原理:<code>修改binlog</code>内容，拿回原库重放。如果误删数据涉及到了多个事务的话，需要将事务的顺序调过来再执行。使用前提:<code>binlog_format=row</code>和<code>binlog_row_image=FULL</code>。<br><strong>处理措施2：预防</strong></p><ul><li>代码上线前，必须SQL审查、审计</li><li>建议可以打开安全模式，<strong>把sql_safe_updates参数设置为on</strong>。强制要求加where 条件且where后需要是索引字段，否则必须使用limit。否则就会报错。</li></ul><h3 id="7-2-truncate-drop-：误删库-表-v2">7.2 truncate/drop ：误删库/表</h3><p><strong>背景:</strong><br>delete全表是很慢的，需要生成回滚日志、写redo、写binlog。所以，从性能角度考虑，优先考虑使用<code>truncate table</code>或者<code>drop table</code>命令。使用delete命令删除的数据，你还可以用Flashback来恢复。而使用<code>truncate /drop table</code>和<code>drop database</code>命令删除的数据，就没办法通过Flashback来恢复了。因为，即使我们配置了binlog_format=row，执行这三个命令时，记录的binlog还是statement格式。binlog里面就只有一个truncate/drop语句，这些信息是恢复不出数据的。<br><strong>方案:</strong><br>这种情况下恢复数据，需要使用<strong>全量备份</strong>与<strong>增量日志</strong>结合的方式。方案的前提:有定期的全量备份，并且实时备份binlog。举例:有人误删了一个库，时间为下午3点。步骤如下:</p><ul><li>取最近一次<strong>全量备份</strong>。假设设置数据库库是一天一备，最近备份数据是当天<strong>凌晨2点</strong>;</li><li>用备份恢复出一个<strong>临时库;</strong>（注意:这里选择临时库，而不是直接操作主库)</li><li>取出凌晨2点之后的binlog日志;</li><li>剔除误删除数据的语句外，其它语句全部应用到临时库。(前面讲过binlog的恢复)</li><li>最后恢复到主库</li></ul><h3 id="7-3-预防使用truncate-drop误删库-表-v2">7.3 预防使用truncate/drop误删库/表</h3><p><strong>权限分离</strong></p><ul><li>限制帐户权限，核心的数据库，一般都<strong>不能随便分配写权限</strong>，想要获取写权限需要<strong>审批</strong>。比如只给业务开发人员DML权限，不给truncate/drop权限。即使是DBA团队成员，日常也都规定只使用<strong>只读账号</strong>，必要的时候才使用有更新权限的账号</li><li>不同的账号，不同的数据之间要进行权限分离，避免一个账号可以删除所有库</li></ul><p><strong>制定操作规范</strong><br>比如在删除数据表之前，必须先对表做改名操作（比如加<code>_to_be_deleted</code> )。然后，观察一段时间，确保对业务无影响以后再删除这张表<br><strong>设置延迟复制备库</strong><br>简单的说延迟复制就是设置一个固定的延迟时间，比如1个小时，让从库落后主库一个小时。出现误删除操作1小时内，到这个备库上执行<code>stop slave</code>，再通过之前介绍的方法，跳过误操作命令，就可以恢复出需要的数据。这里通过<code>CHANGE MASTER TO MASTER_DELAY = N</code>命令，可以指定这个备库持续保持跟主库有N秒的延迟。比如把N设置为3600，即代表1个小时<br>此外，延迟复制还可以用来解决以下问题:|<br>用来做<code>延迟测试</code>，比如做好的数据库读写分离，把从库作为读库，那么想知道当数据产生延迟的时候到底会发生什么，就可以使用这个特性模拟延迟。用于<code>老数据的查询等需求</code>，比如你经常需要查看某天前一个表或者字段的数值，你可能需要把备份恢复后进行查看，如果有延迟从库，比如延迟一周，那么就可以解决这样类似的需求。</p><h3 id="7-4-rm：误删MySQL实例-v2">7.4 rm：误删MySQL实例</h3><p>对于一个有高可用机制的MySQL集群来说，不用担心 rm删除数据 了。只是删掉了其中某一个节点的数据的话，HA系统就会开始工作，选出一个新的主库，从而保证整个集群的正常工作。我们要做的就是在这个节点上把数据恢复回来，再接入整个集群。<br>但如果是恶意地把整个集群删除，那就需要考虑跨机房备份，跨城市备份。</p><hr><p>参考<br><a href="https://www.bilibili.com/video/BV1iq4y1u7vj" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1iq4y1u7vj</a></p>]]></content>
    
    
    <summary type="html">&lt;h1&gt;一、事务基础知识&lt;/h1&gt;
&lt;h2 id=&quot;1、数据库事务概述&quot;&gt;1、数据库事务概述&lt;/h2&gt;
&lt;h3 id=&quot;1-1-基本概念&quot;&gt;1.1 基本概念&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;SHOW ENGINES`命令来查看当前 MySQL 支持的存储引擎都有哪些，以及这些存储引擎是否支持事务&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;**事务：**一组逻辑操作单元，使数据从一种状态变换到另一种状态。&lt;br&gt;
**事务处理的原则：**保证所有事务都作为 一个工作单元 来执行，即使出现了故障，都不能改变这种执行方 式。当在一个事务中执行多个操作时，要么所有的事务都被提交( commit )，那么这些修改就 永久 地保 存下来；要么数据库管理系统将 放弃 所作的所有 修改 ，整个事务回滚( rollback )到最初状态。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://www.shawn22.xyz/categories/Java/"/>
    
    
    <category term="SQL" scheme="https://www.shawn22.xyz/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL8.0高级篇(上)-架构与索引</title>
    <link href="https://www.shawn22.xyz/posts/f2fcb8fb.html"/>
    <id>https://www.shawn22.xyz/posts/f2fcb8fb.html</id>
    <published>2023-03-05T16:17:13.000Z</published>
    <updated>2023-03-05T16:33:56.256Z</updated>
    
    <content type="html"><![CDATA[<h1>一、MySQL环境安装与介绍</h1><h2 id="1、MySQL安装">1、MySQL安装</h2><h3 id="1-1-安装前说明">1.1 安装前说明</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果你是用rpm安装, 检查一下RPM PACKAGE</span></span><br><span class="line">rpm -qa | grep -i mysql <span class="comment"># -i 忽略大小写</span></span><br><span class="line"><span class="comment"># 检查mysql service</span></span><br><span class="line">systemctl status mysqld.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># MySQL的卸载</span></span><br><span class="line"><span class="comment"># 关闭 mysql 服务</span></span><br><span class="line">systemctl stop mysqld.service</span><br><span class="line">rpm -qa | grep -i mysql</span><br><span class="line"><span class="comment"># 查看当前 mysql 安装状况</span></span><br><span class="line">yum list installed | grep mysql</span><br><span class="line"><span class="comment"># 卸载上述命令查询出的已安装程序</span></span><br><span class="line">yum remove mysql-xxx mysql-xxx mysql-xxx mysqk-xxxx</span><br><span class="line"><span class="comment"># 务必卸载干净，反复执行rpm -qa | grep -i mysql确认是否有卸载残留</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除 mysql 相关文件</span></span><br><span class="line">find / -name mysql</span><br><span class="line">rm -rf xxx</span><br><span class="line"><span class="comment"># 删除 my.cnf</span></span><br><span class="line">rm -rf /etc/my.cnf</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="1-2-MySQL的Linux版安装">1.2 MySQL的Linux版安装</h3><blockquote><p>官网下载地址：<a href="https://dev.mysql.com/downloads/" target="_blank" rel="noopener">https://dev.mysql.com/downloads/</a></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查/tmp临时目录权限（必不可少）</span></span><br><span class="line"><span class="comment"># 由于mysql安装过程中，会通过mysql用户在/tmp目录下新建tmp_db文件，所以请给/tmp较大的权限</span></span><br><span class="line">chmod -R 777 /tmp</span><br><span class="line"><span class="comment"># 安装前，检查依赖</span></span><br><span class="line">rpm -qa|grep libaio</span><br><span class="line">rpm -qa|grep net-tools</span><br><span class="line"><span class="comment"># ========================离线安装=====================</span></span><br><span class="line"><span class="comment"># https://dev.mysql.com/downloads/mysql/</span></span><br><span class="line"><span class="comment"># CentOS7下MySQL安装过程</span></span><br><span class="line"><span class="comment"># 将安装程序拷贝到/opt目录下,在mysql的安装文件目录下执行：（必须按照顺序执行）</span></span><br><span class="line">rpm -ivh mysql-community-common-8.0.25-1.el7.x86_64.rpm </span><br><span class="line">rpm -ivh mysql-community-client-plugins-8.0.25-1.el7.x86_64.rpm </span><br><span class="line">rpm -ivh mysql-community-libs-8.0.25-1.el7.x86_64.rpm </span><br><span class="line">rpm -ivh mysql-community-client-8.0.25-1.el7.x86_64.rpm </span><br><span class="line">rpm -ivh mysql-community-server-8.0.25-1.el7.x86_64.rpm</span><br><span class="line"><span class="comment"># rpm是Redhat Package Manage缩写，通过RPM的管理，用户可以把源代码包装成以rpm为扩展名的文件形式，易于安装。</span></span><br><span class="line"><span class="comment"># -i, –install 安装软件包</span></span><br><span class="line"><span class="comment"># -v, –verbose 提供更多的详细信息输出</span></span><br><span class="line"><span class="comment"># -h, –hash 软件包安装的时候列出哈希标记 (和 -v 一起使用效果更好)，展示进度条</span></span><br><span class="line"><span class="comment"># 若存在mariadb-libs问题，则执行yum remove mysql-libs即可</span></span><br><span class="line"><span class="comment"># 服务的初始化</span></span><br><span class="line"><span class="comment"># 为了保证数据库目录与文件的所有者为 mysql 登录用户，如果你是以 root 身份运行 mysql 服务，需要执行下面的命令初始化</span></span><br><span class="line">mysqld --initialize --user=mysql</span><br><span class="line"><span class="comment"># 说明： –initialize 选项默认以“安全”模式来初始化，则会为 root 用户生成一个密码并将该密码标记为过期，登录后你需要设置一个新的密码。生成的临时密码会往日志中记录一份</span></span><br><span class="line"><span class="comment"># ======================在线安装==========================</span></span><br><span class="line">wget -i -c https://dev.mysql.com/get/mysql80-community-release-el7-7.noarch.rpm</span><br><span class="line">yum -y install mysql80-community-release-el7-7.noarch.rpm</span><br><span class="line">yum -y install mysql-community-server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看MySQL版本</span></span><br><span class="line">mysql --version </span><br><span class="line">mysqladmin --version</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动mysql,加不加.service后缀都可以 </span></span><br><span class="line">systemctl start mysqld.service </span><br><span class="line">systemctl stop mysqld.service </span><br><span class="line">systemctl restart mysqld.service </span><br><span class="line">systemctl status mysqld.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看MySQL服务是否自启动</span></span><br><span class="line">systemctl list-unit-files|grep mysqld.service</span><br><span class="line"><span class="comment"># 开机自启</span></span><br><span class="line">systemctl <span class="built_in">enable</span> mysqld.service</span><br><span class="line"><span class="comment"># 关闭开机自启</span></span><br><span class="line">systemctl <span class="built_in">disable</span> mysqld.service</span><br></pre></td></tr></table></figure><h3 id="1-3-MySQL登录">1.3 MySQL登录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看临时密码</span></span><br><span class="line">cat /var/<span class="built_in">log</span>/mysqld.log</span><br><span class="line"><span class="comment"># 输入密码进行登录</span></span><br><span class="line">mysql -hlocalhost -P3306 -uroot -p</span><br><span class="line"><span class="comment"># 首次登录需要更改密码，注意这里有密码检验，可以先设置这样（mysql8默认开启了安全加密插件模块）</span></span><br><span class="line">ALTER USER <span class="string">'root'</span>@<span class="string">'localhost'</span> IDENTIFIED BY <span class="string">'ROOTroot123?'</span>;</span><br><span class="line"><span class="comment"># 查看MySQL完整的初始密码规则</span></span><br><span class="line">SHOW VARIABLES LIKE <span class="string">'validate_password%'</span>;</span><br><span class="line"><span class="comment"># 修改密码最小长度</span></span><br><span class="line"><span class="built_in">set</span> global validate_password.length=4;</span><br><span class="line"><span class="comment"># 验证密码的复杂程度，我们把它改成0，也可以是low/high/medium</span></span><br><span class="line"><span class="built_in">set</span> global validate_password.policy=0;</span><br><span class="line"><span class="comment"># 用户名检查，用户名和密码不能相同，我们也把它去掉</span></span><br><span class="line"><span class="built_in">set</span> global validate_password.check_user_name=off;</span><br><span class="line"><span class="comment"># 最后就可以改成简单的密码(生产环境要复杂)</span></span><br><span class="line">ALTER USER <span class="string">'root'</span>@<span class="string">'localhost'</span> IDENTIFIED BY <span class="string">'root'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置远程访问</span></span><br><span class="line"><span class="comment"># 在远程机器上使用telnet命令保证端口号开放访问</span></span><br><span class="line"><span class="comment"># telnet 192.168.249.139 3306</span></span><br><span class="line"><span class="comment"># 开启防火墙</span></span><br><span class="line">systemctl start firewalld.service</span><br><span class="line"><span class="comment"># 查看防火墙状态</span></span><br><span class="line">systemctl status firewalld.service</span><br><span class="line"><span class="comment"># 关闭防火墙</span></span><br><span class="line">systemctl stop firewalld.service</span><br><span class="line"><span class="comment"># 设置开机启用防火墙 </span></span><br><span class="line">systemctl <span class="built_in">enable</span> firewalld.service </span><br><span class="line"><span class="comment"># 设置开机禁用防火墙 </span></span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld.service</span><br><span class="line"><span class="comment"># 查看开放的端口号</span></span><br><span class="line">firewall-cmd --list-all</span><br><span class="line"><span class="comment"># 设置开放的端口号</span></span><br><span class="line">firewall-cmd --add-service=http --permanent</span><br><span class="line">firewall-cmd --add-port=3306/tcp --permanent</span><br><span class="line"><span class="comment"># 重启防火墙</span></span><br><span class="line">firewall-cmd --reload</span><br><span class="line"><span class="comment"># 修改允许远程登陆</span></span><br><span class="line">use mysql;</span><br><span class="line">select Host,User from user;</span><br><span class="line">update user <span class="built_in">set</span> host = <span class="string">'%'</span> <span class="built_in">where</span> user =<span class="string">'root'</span>;</span><br><span class="line">flush privileges;</span><br><span class="line"><span class="comment"># 或者重新创建一个账号</span></span><br><span class="line">CREATE USER <span class="string">'root'</span>@<span class="string">'%'</span> IDENTIFIED BY <span class="string">'root'</span>;</span><br><span class="line">GRANT ALL ON *.* TO <span class="string">'root'</span>@<span class="string">'%'</span>; </span><br><span class="line"><span class="comment"># %是个 通配符 ，如果Host=192.168.1.%，那么就表示只要是IP地址前缀为“192.168.1.”的客户端都可以连接。如果Host=%，表示所有IP都有连接权限。</span></span><br><span class="line"><span class="comment"># 注意：在生产环境下不能为了省事将host设置为%，这样做会存在安全问题，具体的设置可以根据生产环境的IP进行设置。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果可视化工具配置新连接报错：错误号码 2058，分析是 mysql 密码加密方法变了</span></span><br><span class="line"><span class="comment"># 解决方法一：升级远程连接工具版本</span></span><br><span class="line"><span class="comment"># 解决方法二：ALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY 'root';</span></span><br></pre></td></tr></table></figure><h3 id="1-4-字符集的相关操作">1.4 字符集的相关操作</h3><ul><li>character_set_server：服务器级别的字符集</li><li>character_set_database：当前数据库的字符集</li><li>character_set_client：服务器解码请求时使用的字符集</li><li>character_set_connection：服务器处理请求时会把请求字符串从character_set_client转为character_set_connection</li><li>character_set_results：服务器向客户端返回数据时使用的字符集</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'character%'</span>;</span><br></pre></td></tr></table></figure><ul><li>如果创建或修改列时没有显式的指定字符集和比较规则，则该列默认用表的字符集和比较规则</li><li>如果创建表时没有显式的指定字符集和比较规则，则该表默认用数据库的字符集和比较规则</li><li>如果创建数据库时没有显式的指定字符集和比较规则，则该数据库默认用服务器的字符集和比较规则</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在mysql5.7之前的版本中，可以直接在/etc/my.cnf修改</span></span><br><span class="line">character_set_server=utf8</span><br><span class="line"><span class="comment"># 然后重启即可，不过影响的是以后创建的数据库，不影响原来的</span></span><br><span class="line"><span class="comment"># 更改之前表的字符集</span></span><br><span class="line">alter table xxx convert to character <span class="built_in">set</span> <span class="string">'utf8'</span>;</span><br><span class="line"><span class="comment"># 也可以在表或字段创建的时候指定，不过一般直接默认</span></span><br><span class="line">CREATE TABLE 表名 (列的信息)</span><br><span class="line">[[DEFAULT] CHARACTER SET 字符集名称]</span><br><span class="line">[COLLATE 比较规则名称]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># utf8相当于utf8mb3,三个字节,一般也够用</span></span><br><span class="line"><span class="comment"># utf8mb4四个字节，可以存储emoji</span></span><br></pre></td></tr></table></figure><h3 id="1-5-字符集与比较规则-了解">1.5 字符集与比较规则(了解)</h3><ul><li>utf8mb3 ：阉割过的utf8 字符集，只使用1～3个字节表示字符</li><li>utf8mb4 ：正宗的utf8 字符集，使用1～4个字节表示字符，可以描述emoji表情</li></ul><p>MySQL版本一共支持41种字符集，其中的Default collation 列表示这种字符集中一种默认的比较规则，里面包含着该比较规则主要作用于哪种语言，比如utf8_polish_ci 表示以波兰语的规则比较， utf8_spanish_ci 是以西班牙语的规则比较， utf8_general_ci 是一种通用的比较规则</p><table><thead><tr><th><strong>后缀</strong></th><th><strong>英文释义</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>_ai</td><td>accent insensitive</td><td>不区分重音</td></tr><tr><td>_as</td><td>accent sensitive</td><td>区分重音</td></tr><tr><td>_ci</td><td>case insensitive</td><td>不区分大小写</td></tr><tr><td>_cs</td><td>case sensitive</td><td>区分大小写</td></tr><tr><td>_bin</td><td>binary</td><td>以二进制方式比较</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看GBK字符集的比较规则</span></span><br><span class="line">SHOW COLLATION LIKE <span class="string">'gbk%'</span>;</span><br><span class="line"><span class="comment">#查看UTF-8字符集的比较规则</span></span><br><span class="line">SHOW COLLATION LIKE <span class="string">'utf8%'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看服务器的字符集和比较规则</span></span><br><span class="line">SHOW VARIABLES LIKE <span class="string">'%_server'</span>;</span><br><span class="line"><span class="comment">#查看数据库的字符集和比较规则</span></span><br><span class="line">SHOW VARIABLES LIKE <span class="string">'%_database'</span>;</span><br><span class="line"><span class="comment">#查看具体数据库的字符集</span></span><br><span class="line">SHOW CREATE DATABASE dbtest1;</span><br><span class="line"><span class="comment">#修改具体数据库的字符集</span></span><br><span class="line">ALTER DATABASE dbtest1 DEFAULT CHARACTER SET <span class="string">'utf8'</span> COLLATE <span class="string">'utf8_general_ci'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看表的字符集</span></span><br><span class="line">show create table employees;</span><br><span class="line"><span class="comment">#查看表的比较规则</span></span><br><span class="line">show table status from atguigudb like <span class="string">'employees'</span>;</span><br><span class="line"><span class="comment">#修改表的字符集和比较规则</span></span><br><span class="line">ALTER TABLE emp1 DEFAULT CHARACTER SET <span class="string">'utf8'</span> COLLATE <span class="string">'utf8_general_ci'</span>;</span><br></pre></td></tr></table></figure><h3 id="1-6-请求到响应过程中字符集的变化">1.6 请求到响应过程中字符集的变化</h3><table><thead><tr><th><strong>系统变量描述</strong></th><th><strong>系统变量描述</strong></th></tr></thead><tbody><tr><td><code>character_set_client</code></td><td>服务器解码请求时使用的字符集</td></tr><tr><td><code>character_set_connection</code></td><td>服务器处理请求时会把请求字符串从</td></tr><tr><td><code>character_set_client</code> 转为<code>character_set_connection</code></td><td></td></tr><tr><td><code>character_set_results</code></td><td>服务器向客户端返回数据时使用的字符集</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">A(客户端) --&gt; |<span class="string">"使用操作系统的字符集编码请求字符串"</span>| B(从character_set_client转换为character_set_connection)</span><br><span class="line">B --&gt; C(从character_set_connection转换为具体的列使用的字符集)</span><br><span class="line">C --&gt; D(将查询结果从具体的列上使用的字符集转换为character_set_results)</span><br><span class="line">D --&gt; |<span class="string">"使用操作系统的字符集解码响应的字符串"</span>| A</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/ea80ed0273f4435fb8a8ac0d78ced04e.jpeg" alt="第01章_Linux下MySQL的安装与使用.jpg"></p><h3 id="1-7-SQL大小写规范">1.7 SQL大小写规范</h3><p><strong>在 SQL 中，关键字和函数名是不用区分字母大小写的，比如 SELECT、WHERE、ORDER、GROUP BY 等关键字，以及 ABS、MOD、ROUND、MAX 等函数名</strong>。不过在 SQL 中，你还是要确定大小写的规范，因为在 Linux 和 Windows 环境下，你可能会遇到不同的大小写问题。<strong>windows系统默认大小写不敏感，但是linux系统是大小写敏感的</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认为0，大小写敏感</span></span><br><span class="line"><span class="comment"># 设置1，大小写不敏感。创建的表，数据库都是以小写形式存放在磁盘上，对于sql语句都是转换为小写对表和数据库进行查</span></span><br><span class="line"><span class="comment"># 设置2，创建的表和数据库依据语句上格式存放，凡是查找都是转换为小写进行</span></span><br><span class="line">SHOW VARIABLES LIKE <span class="string">'%lower_case_table_names%'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当想设置为大小写不敏感时，要在my.cnf 这个配置文件 [mysqld] 中加入lower_case_table_names=1 ，然后重启服务器</span></span><br><span class="line"><span class="comment"># 然后需要将原来的数据库都删除</span></span><br><span class="line"><span class="comment"># 建议不要改</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ===================建议=====================</span></span><br><span class="line"><span class="comment"># 关键字和函数名称全部大写；</span></span><br><span class="line"><span class="comment"># 数据库名、表名、表别名、字段名、字段别名等全部小写；</span></span><br><span class="line"><span class="comment"># SQL 语句必须以分号结尾。</span></span><br></pre></td></tr></table></figure><h3 id="1-8-sql-mode的合理设置">1.8 sql_mode的合理设置</h3><p><strong>宽松模式：</strong><br>如果设置的是宽松模式，那么我们在插入数据的时候，即便是给了一个错误的数据，也可能会被接受，并且不报错。<br><strong>举例</strong>：我在创建一个表时，该表中有一个字段为name，给name设置的字段类型时<code>char(10)</code> ，如果我在插入数据的时候，其中name这个字段对应的有一条数据的<strong>长度超过了10 <strong>，例如’1234567890abc’，超过了设定的字段长度10，那么不会报错，并且取前10个字符存上，也就是说你这个数据被存为了’1234567890’，而’abc’就没有了。但是，我们给的这条数据是错误的，因为超过了字段长度，但是并没有报错，并且mysql自行处理并接受了，这就是宽松模式的效果。<br><strong>应用场景</strong>：通过设置sql mode为宽松模式，来保证大多数sql符合标准的sql语法，这样应用在不同数据库之间进行</strong>迁移</strong>时，则不需要对业务sql 进行较大的修改<br><strong>严格模式：</strong><br>出现上面宽松模式的错误，应该报错才对，所以MySQL5.7版本就将sql_mode默认值改为了严格模式。所以在<strong>生产等环境中</strong>，我们必须采用的是严格模式，进而<strong>开发、测试环境</strong>的数据库也必须要设置，这样在开发测试阶段就可以发现问题。并且我们即便是用的MySQL5.6，也应该自行将其改为严格模式。<br><strong>开发经验</strong>：MySQL等数据库总想把关于数据的所有操作都自己包揽下来，包括数据的校验，其实开发中，我们应该在自己<strong>开发的项目程序级别将这些校验给做了</strong>，虽然写项目的时候麻烦了一些步骤，但是这样做之后，我们在进行数据库迁移或者在项目的迁移时，就会方便很多。<br>改为严格模式后可能会存在的问题：若设置模式中包含了<code>NO_ZERO_DATE</code> ，那么MySQL数据库不允许插入零日期，插入零日期会抛出错误而不是警告。例如，表中含字段TIMESTAMP列（如果未声明为NULL或显示DEFAULT子句）将自动分配DEFAULT ‘0000-00-00 00:00:00’（零时间戳），这显然是不满足sql_mode中的NO_ZERO_DATE而报错</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 宽松模式举例</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> employees <span class="keyword">group</span> <span class="keyword">by</span> department_id <span class="keyword">limit</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">set</span> sql_mode = ONLY_FULL_GROUP_BY;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> employees <span class="keyword">group</span> <span class="keyword">by</span> department_id <span class="keyword">limit</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看当前的sql_mode</span></span><br><span class="line"><span class="keyword">select</span> @@session.sql_mode</span><br><span class="line"><span class="keyword">select</span> @@global.sql_mode</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'sql_mode'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 临时设置方式：设置当前窗口中设置sql_mode</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> sql_mode = <span class="string">'modes...'</span>; </span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">SESSION</span> sql_mode = <span class="string">'modes...'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 改为严格模式。此方法只在当前会话中生效，关闭当前会话就不生效了。</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">SESSION</span> sql_mode=<span class="string">'STRICT_TRANS_TABLES'</span>;</span><br><span class="line"><span class="comment">-- 改为严格模式。此方法在当前服务中生效，重启MySQL服务后失效。</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">GLOBAL</span> sql_mode=<span class="string">'STRICT_TRANS_TABLES'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 永久设置方式：在/etc/my.cnf中配置sql_mode</span></span><br><span class="line"><span class="comment">-- 在my.cnf文件(windows系统是my.ini文件)，新增，最后重启即可</span></span><br><span class="line">[mysqld]</span><br><span class="line">sql_mode=ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR</span><br><span class="line">_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION</span><br></pre></td></tr></table></figure><h2 id="2、MySQL的数据目录">2、MySQL的数据目录</h2><h3 id="2-1-MySQL8的主要目录结构">2.1 MySQL8的主要目录结构</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">find / -name mysql</span><br><span class="line"><span class="comment"># /var/lib/mysql/</span></span><br><span class="line">show variables like <span class="string">'datadir'</span>; </span><br><span class="line"><span class="comment"># 相关命令目录：/usr/bin 和/usr/sbin。</span></span><br><span class="line"><span class="comment"># 配置文件目录：/usr/share/mysql-8.0（命令及配置文件），/etc/mysql（如my.cnf）</span></span><br></pre></td></tr></table></figure><h3 id="2-2-查看默认数据库">2.2 查看默认数据库</h3><ul><li><strong>mysql</strong></li></ul><p>MySQL 系统自带的核心数据库，它存储了MySQL的用户账户和权限信息，一些存储过程、事件的定义信息，一些运行过程中产生的日志信息，一些帮助信息以及时区信息等。</p><ul><li><strong>information_schema</strong></li></ul><p>MySQL 系统自带的数据库，这个数据库保存着MySQL服务器<strong>维护的所有其他数据库的信息</strong>，比如有哪些表、哪些视图、哪些触发器、哪些列、哪些索引。这些信息并不是真实的用户数据，而是一些描述性信息，有时候也称之为<strong>元数据</strong>。在系统数据库<strong>information_schema</strong> 中提供了一些以<strong>innodb_sys</strong> 开头的表，用于表示内部系统表。<code>SHOW TABLES LIKE 'innodb_sys%';</code></p><ul><li><strong>performance_schema</strong></li></ul><p>MySQL 系统自带的数据库，这个数据库里主要保存MySQL服务器运行过程中的一些状态信息，可以用来<strong>监控 MySQL 服务的各类性能指标</strong>。包括统计最近执行了哪些语句，在执行过程的每个阶段都花费了多长时间，内存的使用情况等信息。</p><ul><li><strong>sys</strong></li></ul><p>MySQL 系统自带的数据库，这个数据库主要是通过视图的形式把<code>information_schema</code> 和<code>performance_schema</code> 结合起来，帮助系统管理员和开发人员监控 MySQL 的技术性能。</p><h3 id="2-3-InnoDB存储引擎模式">2.3 InnoDB存储引擎模式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /var/lib/mysql</span><br><span class="line">ll</span><br><span class="line"><span class="comment"># 这个数据目录下的文件和子目录比较多，除了information_schema 这个系统数据库外，其他的数据库在数据目录下都有对应的子目录。</span></span><br></pre></td></tr></table></figure><p>为了保存表结构，InnoDB在数据目录下对应的数据库子目录下创建了一个专门用于描述表结构的文件，即<code>表名.frm</code><br><strong>系统表空间（system tablespace）</strong><br>默认情况下，InnoDB会在数据目录下创建一个名为ibdata1、大小为12M的自拓展文件，这个文件就是对应的系统表空间在文件系统上的表示。如果你想让系统表空间对应文件系统上多个实际文件，或者仅仅觉得原来的ibdata1 这个文件名难听，那可以在MySQL启动时配置对应的文件路径以及它们的大小，比如我们这样修改一下my.cnf 配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_data_file_path=data1:512M;data2:512M:autoextend</span><br></pre></td></tr></table></figure><p><strong>独立表空间(file-per-table tablespace)</strong><br>在MySQL5.6.6以及之后的版本中，InnoDB并不会默认的把各个表的数据存储到系统表空间中，而是为<strong>每一个表建立一个独立表空间</strong>，也就是说我们创建了多少个表，就有多少个独立表空间。使用独立表空间来存储表数据的话，会在该表所属数据库对应的子目录下创建一个表示该独立表空间的文件，文件名和表名相同，只不过添加了一个<code>.ibd</code> 的扩展名而已，所以完整的文件名称长这样：<code>表名.ibd</code><br><strong>系统表空间与独立表空间的设置</strong><br>我们可以自己指定使用<strong>系统表空间</strong>还是<strong>独立表空间</strong>来存储数据，这个功能由启动参数<code>innodb_file_per_table</code> 控制，比如说我们想刻意将表数据都存储到<strong>系统表空间</strong>时，可以在启动MySQL服务器的时候这样配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_file_per_table=0 <span class="comment"># 0：代表使用系统表空间； 1：代表使用独立表空间</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># show variables like 'innodb_file_per_table';</span></span><br></pre></td></tr></table></figure><h3 id="2-4-MyISAM存储引擎模式">2.4 MyISAM存储引擎模式</h3><ul><li>test.frm 存储表结构(MySQL8.0 改为了 b.xxx.sdi )</li><li>test.MYD 存储数据 (MYData)</li><li>test.MYI 存储索引 (MYIndex)</li></ul><h3 id="2-5-小结">2.5 小结</h3><p>举例：** 数据库a** ， **表b **<br>1、如果表b采用<code>InnoDB</code> ，data\a中会产生1个或者2个文件：</p><ul><li><code>b.frm</code> ：描述表结构文件，字段长度等</li><li>如果采用<strong>系统表空间</strong>模式的，数据信息和索引信息都存储在<code>ibdata1</code> 中</li><li>如果采用<strong>独立表空间</strong>存储模式，data\a中还会产生<code>b.ibd</code> 文件（存储数据信息和索引信息）</li></ul><p>此外：<br>① MySQL5.7 中会在data/a的目录下生成<code>db.opt</code> 文件用于保存数据库的相关配置。比如：字符集、比较<br>规则。而MySQL8.0不再提供db.opt文件。<br>② MySQL8.0中不再单独提供b.frm，而是合并在b.ibd文件中。<br>2、如果表b采用<code>MyISAM </code>，data\a中会产生3个文件：</p><ul><li>MySQL5.7 中： <code>b.frm</code> ：描述表结构文件，字段长度等。MySQL8.0 中 <code>b.xxx.sdi</code> ：描述表结构文件，字段长度等</li><li><code>b.MYD (MYData)</code>：数据信息文件，存储数据信息(如果采用独立表存储模式)</li><li><code>b.MYI (MYIndex)</code>：存放索引信息文件</li></ul><h1>二、用户与权限管理</h1><h2 id="1、用户管理">1、用户管理</h2><h3 id="1-1-登录MySQL服务器">1.1 登录MySQL服务器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动MySQL服务后，可以通过mysql命令来登录MySQL服务器</span></span><br><span class="line">mysql –h hostname|hostIP –P port –u username –p DatabaseName –e <span class="string">"SQL语句"</span></span><br></pre></td></tr></table></figure><ul><li><code>-h参数</code>后面接主机名或者主机IP，hostname为主机，hostIP为主机IP。</li><li><code>-P参数</code>后面接MySQL服务的端口，通过该参数连接到指定的端口。MySQL服务的默认端口是3306，不使用该参数时自动连接到3306端口，port为连接的端口号。</li><li><code>-u参数</code>后面接用户名，username为用户名。</li><li><code>-p参数</code>会提示输入密码。DatabaseName参数指明登录到哪一个数据库中。如果没有该参数，就会直接登录到MySQL数据库中，然后可以使用USE命令来选择数据库。</li><li><code>-e参数</code>后面可以直接加SQL语句。登录MySQL服务器以后即可执行这个SQL语句，然后退出MySQL服务器。</li></ul><h3 id="1-2-用户常用操作">1.2 用户常用操作</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- =====================创建用户===========================</span></span><br><span class="line"><span class="comment">-- CREATE USER语句的基本语法形式如下</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> 用户名 [<span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'密码'</span>][,用户名 [<span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'密码'</span>]];</span><br><span class="line"><span class="comment">-- 用户名参数表示新建用户的账户，由用户（User） 和主机名（Host） 构成；</span></span><br><span class="line"><span class="comment">-- “[ ]”表示可选，也就是说，可以指定用户登录时需要密码验证，也可以不指定密码验证，这样用户可以直接登录。不过，不指定密码的方式不安全，不推荐使用。如果指定密码值，这里需要使用IDENTIFIED BY指定明文密码值。</span></span><br><span class="line"><span class="comment">-- CREATE USER语句可以同时创建多个用户</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 举例默认host是 %</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> zhang3 <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'123123'</span>; </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">'kangshifu'</span>@<span class="string">'localhost'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'123456'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ===========================修改用户=========================</span></span><br><span class="line"><span class="keyword">UPDATE</span> mysql.user <span class="keyword">SET</span> <span class="keyword">USER</span>=<span class="string">'li4'</span> <span class="keyword">WHERE</span> <span class="keyword">USER</span>=<span class="string">'wang5'</span>;</span><br><span class="line"><span class="keyword">FLUSH</span> <span class="keyword">PRIVILEGES</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ===========================删除用户=========================</span></span><br><span class="line"><span class="comment">-- 使用DROP方式删除（推荐）</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> <span class="keyword">user</span>[,<span class="keyword">user</span>];</span><br><span class="line"><span class="comment">-- 举例，默认删除host为%的用户</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> li4 ;</span><br><span class="line"><span class="comment">-- 方式2：使用DELETE方式删除</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> mysql.user <span class="keyword">WHERE</span> Host=<span class="string">'hostname'</span> <span class="keyword">AND</span> <span class="keyword">User</span>=<span class="string">'username'</span>;</span><br><span class="line"><span class="keyword">FLUSH</span> <span class="keyword">PRIVILEGES</span>;</span><br><span class="line"><span class="comment">-- 不推荐通过DELETE FROM USER u WHERE USER='li4' 进行删除，系统会有残留信息保留。而drop user命令会删除用户以及对应的权限，执行命令后你会发现mysql.user表和mysql.db表的相应记录都消失了</span></span><br></pre></td></tr></table></figure><h3 id="1-3-设置用户密码">1.3 设置用户密码</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 设置当前用户密码</span></span><br><span class="line"><span class="comment">-- 旧的写法如下（不推荐！！！！）</span></span><br><span class="line"><span class="comment">-- 修改当前用户的密码：（MySQL5.7测试有效）</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">PASSWORD</span> = <span class="keyword">PASSWORD</span>(<span class="string">'123456'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 推荐写法</span></span><br><span class="line"><span class="comment">-- 方法一，使用ALTER USER命令来修改当前用户密码 用户可以使用ALTER命令来修改自身密码，如下语句代表修改当前登录用户的密码。</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="keyword">USER</span>() <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'new_password'</span>;</span><br><span class="line"><span class="comment">-- 方法二，使用SET语句来修改当前用户密码 使用root用户登录MySQL后，可以使用SET语句来修改密码，该语句会自动将密码加密后再赋给当前用户</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">PASSWORD</span>=<span class="string">'new_password'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改其它用户密码</span></span><br><span class="line"><span class="comment">-- 方法一，使用ALTER语句来修改普通用户的密码 可以使用ALTER USER语句来修改普通用户的密码</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="keyword">user</span> [<span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'新密码'</span>][,<span class="keyword">user</span>[<span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'新密码'</span>]];</span><br><span class="line"><span class="comment">-- 方法二，使用SET命令来修改普通用户的密码 使用root用户登录到MySQL服务器后，可以使用SET语句来修改普通用户的密码</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">PASSWORD</span> <span class="keyword">FOR</span> <span class="string">'username'</span>@<span class="string">'hostname'</span>=<span class="string">'new_password'</span>;</span><br><span class="line"><span class="comment">-- 方法三，使用UPDATE语句修改普通用户的密码（不推荐）</span></span><br><span class="line"><span class="keyword">UPDATE</span> MySQL.user <span class="keyword">SET</span> authentication_string=<span class="keyword">PASSWORD</span>(<span class="string">"123456"</span>) <span class="keyword">WHERE</span> <span class="keyword">User</span> = <span class="string">"username"</span> <span class="keyword">AND</span> Host = <span class="string">"hostname"</span>;</span><br></pre></td></tr></table></figure><h3 id="1-4-MySQL8密码管理-了解">1.4 MySQL8密码管理(了解)</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 密码过期策略</span></span><br><span class="line"><span class="comment">-- 在MySQL中，数据库管理员可以手动设置账号密码过期，也可以建立一个自动密码过期策略。</span></span><br><span class="line"><span class="comment">-- 过期策略可以是全局的，也可以为每个账号设置单独的过期策略</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="keyword">user</span> <span class="keyword">PASSWORD</span> <span class="keyword">EXPIRE</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">'kangshifu'</span>@<span class="string">'localhost'</span> <span class="keyword">PASSWORD</span> <span class="keyword">EXPIRE</span>;</span><br><span class="line"><span class="comment">-- 使用SQL语句更改该变量的值并持久化</span></span><br><span class="line"><span class="comment">-- 建立全局策略，设置密码每隔180天过期</span></span><br><span class="line"><span class="keyword">SET</span> PERSIST default_password_lifetime = <span class="number">180</span>; </span><br><span class="line"><span class="comment">-- 配置文件my.cnf中进行维护</span></span><br><span class="line">[mysqld]</span><br><span class="line">default_password_lifetime=180 </span><br><span class="line"><span class="comment">-- 手动设置指定时间过期方式2：单独设置</span></span><br><span class="line"><span class="comment">-- 每个账号既可延用全局密码过期策略，也可单独设置策略。在CREATE USER 和ALTER USER 语句上加入PASSWORD EXPIRE 选项可实现单独设置策略</span></span><br><span class="line"><span class="comment">-- 设置kangshifu账号密码每90天过期：</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">'kangshifu'</span>@<span class="string">'localhost'</span> <span class="keyword">PASSWORD</span> <span class="keyword">EXPIRE</span> <span class="built_in">INTERVAL</span> <span class="number">90</span> <span class="keyword">DAY</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">'kangshifu'</span>@<span class="string">'localhost'</span> <span class="keyword">PASSWORD</span> <span class="keyword">EXPIRE</span> <span class="built_in">INTERVAL</span> <span class="number">90</span> <span class="keyword">DAY</span>;</span><br><span class="line"><span class="comment">-- 设置密码永不过期：</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">'kangshifu'</span>@<span class="string">'localhost'</span> <span class="keyword">PASSWORD</span> <span class="keyword">EXPIRE</span> <span class="keyword">NEVER</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">'kangshifu'</span>@<span class="string">'localhost'</span> <span class="keyword">PASSWORD</span> <span class="keyword">EXPIRE</span> <span class="keyword">NEVER</span>;</span><br><span class="line"><span class="comment">-- 延用全局密码过期策略：</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">'kangshifu'</span>@<span class="string">'localhost'</span> <span class="keyword">PASSWORD</span> <span class="keyword">EXPIRE</span> <span class="keyword">DEFAULT</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">'kangshifu'</span>@<span class="string">'localhost'</span> <span class="keyword">PASSWORD</span> <span class="keyword">EXPIRE</span> <span class="keyword">DEFAULT</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 密码重用策略</span></span><br><span class="line"><span class="comment">-- 手动设置密码重用方式1：全局</span></span><br><span class="line"><span class="comment">-- 方式一，sql实现</span></span><br><span class="line"><span class="comment">-- 设置不能选择最近使用过的6个密码</span></span><br><span class="line"><span class="keyword">SET</span> PERSIST password_history = <span class="number">6</span>; </span><br><span class="line"><span class="comment">-- 设置不能选择最近一年内的密码</span></span><br><span class="line"><span class="keyword">SET</span> PERSIST password_reuse_interval = <span class="number">365</span>; </span><br><span class="line"><span class="comment">-- 方式二：my.cnf配置文件</span></span><br><span class="line">[mysqld]</span><br><span class="line">password_history=6</span><br><span class="line">password_reuse_interval=365</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 手动设置密码重用方式2：单独设置</span></span><br><span class="line"><span class="comment">-- 不能使用最近5个密码：</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">'kangshifu'</span>@<span class="string">'localhost'</span> <span class="keyword">PASSWORD</span> HISTORY <span class="number">5</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">'kangshifu'</span>@<span class="string">'localhost'</span> <span class="keyword">PASSWORD</span> HISTORY <span class="number">5</span>;</span><br><span class="line"><span class="comment">-- 不能使用最近365天内的密码：</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">'kangshifu'</span>@<span class="string">'localhost'</span> <span class="keyword">PASSWORD</span> <span class="keyword">REUSE</span> <span class="built_in">INTERVAL</span> <span class="number">365</span> <span class="keyword">DAY</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">'kangshifu'</span>@<span class="string">'localhost'</span> <span class="keyword">PASSWORD</span> <span class="keyword">REUSE</span> <span class="built_in">INTERVAL</span> <span class="number">365</span> <span class="keyword">DAY</span>;</span><br><span class="line"><span class="comment">-- 既不能使用最近5个密码，也不能使用365天内的密码</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">'kangshifu'</span>@<span class="string">'localhost'</span> <span class="keyword">PASSWORD</span> HISTORY <span class="number">5</span> <span class="keyword">PASSWORD</span> <span class="keyword">REUSE</span> <span class="built_in">INTERVAL</span> <span class="number">365</span> <span class="keyword">DAY</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">'kangshifu'</span>@<span class="string">'localhost'</span> <span class="keyword">PASSWORD</span> HISTORY <span class="number">5</span> <span class="keyword">PASSWORD</span> <span class="keyword">REUSE</span> <span class="built_in">INTERVAL</span> <span class="number">365</span> <span class="keyword">DAY</span>;</span><br></pre></td></tr></table></figure><h2 id="2、权限管理">2、权限管理</h2><h3 id="2-1-权限列表">2.1 权限列表</h3><p><code>show privileges;</code>查看权限</p><ul><li><strong>CREATE和DROP权限</strong>，可以创建新的数据库和表，或删除（移掉）已有的数据库和表。如果将MySQL数据库中的DROP权限授予某用户，用户就可以删除MySQL访问权限保存的数据库</li><li><strong>SELECT、INSERT、UPDATE和DELETE权限</strong>允许在一个数据库现有的表上实施操作</li><li><strong>SELECT权限</strong>只有在它们真正从一个表中检索行时才被用到</li><li><strong>INDEX权限</strong>允许创建或删除索引，INDEX适用于已有的表。如果具有某个表的CREATE权限，就可以在CREATE TABLE语句中包括索引定义</li><li><strong>ALTER权限</strong>可以使用ALTER TABLE来更改表的结构和重新命名表</li><li><strong>CREATE ROUTINE权限</strong>用来创建保存的程序（函数和程序），ALTER ROUTINE权限用来更改和删除保存的程序， <strong>EXECUTE权限</strong>用来执行保存的程序</li><li><strong>GRANT权限</strong>允许授权给其他用户，可用于数据库、表和保存的程序</li><li><strong>FILE权限</strong>使用户可以使用LOAD DATA INFILE和SELECT … INTO OUTFILE语句读或写服务器上的文件，任何被授予FILE权限的用户都能读或写MySQL服务器上的任何文件（说明用户可以读任何数据库目录下的文件，因为服务器可以访问这些文件）</li></ul><h3 id="2-2-授予权限的原则">2.2 授予权限的原则</h3><ul><li>只授予能满足需要的最小权限，防止用户干坏事。比如用户只是需要查询，那就只给select权限就可以了，不要给用户赋予update、insert或者delete权限</li><li>创建用户的时候限制用户的登录主机，一般是限制成指定IP或者内网IP段</li><li>为每个用户设置满足密码复杂度的密码</li><li>定期清理不需要的用户，回收权限或者删除用户</li></ul><h3 id="2-3-权限操作">2.3 权限操作</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- =======================授予权限==========================</span></span><br><span class="line"><span class="comment">-- 分别是通过把角色赋予用户给用户授权和直接给用户授权</span></span><br><span class="line"><span class="comment">-- 该权限如果发现没有该用户，则会直接新建一个用户</span></span><br><span class="line"><span class="keyword">GRANT</span> 权限<span class="number">1</span>,权限<span class="number">2</span>,…权限n <span class="keyword">ON</span> 数据库名称.表名称 <span class="keyword">TO</span> 用户名@用户地址 [<span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'密码口令'</span>];</span><br><span class="line"><span class="comment">-- 举例，给li4用户用本地命令行方式，授予atguigudb这个库下的所有表的插删改查的权限</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>,<span class="keyword">INSERT</span>,<span class="keyword">DELETE</span>,<span class="keyword">UPDATE</span> <span class="keyword">ON</span> atguigudb.* <span class="keyword">TO</span> li4@localhost ;</span><br><span class="line"><span class="comment">-- 授予通过网络方式登录的joe用户 ，对所有库所有表的全部权限，密码设为123。注意这里唯独不包括grant的权限</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">PRIVILEGES</span> <span class="keyword">ON</span> *.* <span class="keyword">TO</span> joe@<span class="string">'%'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'123'</span>;</span><br><span class="line"><span class="comment">-- 如果结尾加了 WITH GRANT OPTION，该用户就可以将自己的权限分给他的子用户</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- =======================查看权限==========================</span></span><br><span class="line"><span class="comment">-- 查看当前用户权限</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GRANTS</span>;</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GRANTS</span> <span class="keyword">FOR</span> <span class="keyword">CURRENT_USER</span>;</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GRANTS</span> <span class="keyword">FOR</span> <span class="keyword">CURRENT_USER</span>();</span><br><span class="line"><span class="comment">-- 查看某用户的全局权限</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GRANTS</span> <span class="keyword">FOR</span> <span class="string">'user'</span>@<span class="string">'主机地址'</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- =======================收回权限==========================</span></span><br><span class="line"><span class="comment">-- 收回权限就是取消已经赋予用户的某些权限。收回用户不必要的权限可以在一定程度上保证系统的安全性。MySQL中使用REVOKE语句取消用户的某些权限</span></span><br><span class="line"><span class="comment">-- 使用REVOKE收回权限之后，用户账户的记录将从db、host、tables_priv和columns_priv表中删除，但是用户账户记录仍然在user表中保存（删除user表中的账户记录使用DROP USER语句）</span></span><br><span class="line"><span class="comment">-- 注意：在将用户账户从user表删除之前，应该收回相应用户的所有权限</span></span><br><span class="line"><span class="comment">-- 收回权限命令</span></span><br><span class="line"><span class="keyword">REVOKE</span> 权限<span class="number">1</span>,权限<span class="number">2</span>,…权限n <span class="keyword">ON</span> 数据库名称.表名称 <span class="keyword">FROM</span> 用户名@用户地址;</span><br><span class="line"><span class="comment">-- 收回全库全表的所有权限</span></span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">ALL</span> <span class="keyword">PRIVILEGES</span> <span class="keyword">ON</span> *.* <span class="keyword">FROM</span> joe@<span class="string">'%'</span>;</span><br><span class="line"><span class="comment">-- 收回mysql库下的所有表的插删改查权限</span></span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">SELECT</span>,<span class="keyword">INSERT</span>,<span class="keyword">UPDATE</span>,<span class="keyword">DELETE</span> <span class="keyword">ON</span> mysql.* <span class="keyword">FROM</span> joe@localhost;</span><br><span class="line"><span class="comment">-- 注意： 须用户重新登录后才能生效</span></span><br></pre></td></tr></table></figure><h2 id="3、权限表">3、权限表</h2><h3 id="3-1-user表">3.1 user表</h3><p>user表是MySQL中最重要的一个权限表，** 记录用户账号和权限信息，有49个字段。<br><img src="https://img-blog.csdnimg.cn/img_convert/b96058a4711aa7b508388d2849562bc9.jpeg" alt="第03章_用户与权限管理.jpg"><br>这些字段可以分成4类，分别是范围列（或用户列）、权限列、安全列和资源控制列<br>范围列（或用户列）**</p><ul><li>host ： 表示连接类型<ul><li><code>%</code> 表示所有远程通过 TCP方式的连接</li><li><code>IP 地址 </code>如 (192.168.1.2、127.0.0.1) 通过制定ip地址进行的TCP方式的连接</li><li><code>机器名 </code>通过制定网络中的机器名进行的TCP方式的连接</li><li><code>::1</code> IPv6的本地ip地址，等同于IPv4的 127.0.0.1</li><li><code>localhost </code>本地方式通过命令行方式的连接 ，比如mysql -u xxx -p xxx 方式的连接。</li></ul></li><li>user ： 表示用户名，同一用户通过不同方式链接的权限是不一样的</li><li>password ： 密码<ul><li>所有密码串通过 password(明文字符串) 生成的密文字符串。MySQL 8.0 在用户管理方面增加了角色管理，默认的密码加密方式也做了调整，由之前的 <strong>SHA1 改为了 SHA2</strong> ，不可逆 。同时加上 MySQL 5.7 的禁用用户和用户过期的功能，MySQL 在用户管理方面的功能和安全性都较之前版本大大的增强了。</li><li>mysql 5.7 及之后版本的密码保存到** authentication_string** 字段中不再使用password 字段</li></ul></li></ul><p><strong>权限列</strong></p><ul><li>Grant_priv字段<ul><li>表示是否拥有GRANT权限</li></ul></li><li>Shutdown_priv字段<ul><li>表示是否拥有停止MySQL服务的权限</li></ul></li><li>Super_priv字段<ul><li>表示是否拥有超级权限</li></ul></li><li>Execute_priv字段<ul><li>表示是否拥有EXECUTE权限。拥有EXECUTE权限，可以执行存储过程和函数。</li></ul></li><li>Select_priv , Insert_priv等<ul><li>为该用户所拥有的权限</li></ul></li></ul><p><strong>安全列</strong><br>安全列只有6个字段，其中两个是ssl相关的（ssl_type、ssl_cipher），用于<code>加密</code>；两个是x509相关的（x509_issuer、x509_subject），用于<code>标识用户</code>；另外两个Plugin字段用于<code>验证用户身份</code>的插件，该字段不能为空。如果该字段为空，服务器就使用内建授权验证机制验证用户身份<br><strong>资源控制列</strong><br>资源控制列的字段用来<code>限制用户使用的资源</code>，包含4个字段，分别为：①max_questions，用户每小时允许执行的查询操作次数； ②max_updates，用户每小时允许执行的更新操作次数； ③max_connections，用户每小时允许执行的连接操作次数； ④max_user_connections，用户允许同时建立的连接次数。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看字段</span></span><br><span class="line">DESC mysql.user;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> mysql.user \G;</span><br><span class="line"><span class="comment">-- 查询特定字段</span></span><br><span class="line"><span class="keyword">SELECT</span> host,<span class="keyword">user</span>,authentication_string,select_priv,insert_priv,drop_priv <span class="keyword">FROM</span> mysql.user;</span><br></pre></td></tr></table></figure><h3 id="3-2-db表">3.2 db表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用DESCRIBE查看db表的基本结构</span></span><br><span class="line"><span class="keyword">DESCRIBE</span> mysql.db;</span><br></pre></td></tr></table></figure><p><strong>用户列</strong><br>db表用户列有3个字段，分别是Host、User、Db。这3个字段分别表示主机名、用户名和数据库<br>名。表示从某个主机连接某个用户对某个数据库的操作权限，这3个字段的组合构成了db表的主键。<br><strong>权限列</strong><br>Create_routine_priv和Alter_routine_priv这两个字段决定用户是否具有创建和修改存储过程的权限</p><h3 id="3-3-tables-priv表和columns-priv表">3.3 tables_priv表和columns_priv表</h3><p>tables_priv表用来<code>对表设置操作权限</code>，columns_priv表用来对表的<code>某一列设置权限</code>。<code>desc mysql.tables_priv;</code><br>tables_priv表有8个字段，分别是Host、Db、User、Table_name、Grantor、Timestamp、Table_priv和Column_priv，各个字段说明如下：</p><ul><li><code>Host 、Db 、User 和Table_name</code> 四个字段分别表示主机名、数据库名、用户名和表名。</li><li>Grantor表示修改该记录的用户</li><li>Timestamp表示修改该记录的时间</li><li><code>Table_priv</code> 表示对象的操作权限。包括Select、Insert、Update、Delete、Create、Drop、Grant、References、Index和Alter</li><li>Column_priv字段表示对表中的列的操作权限，包括Select、Insert、Update和References</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">desc mysql.columns_priv;</span><br></pre></td></tr></table></figure><h3 id="3-4-procs-priv表">3.4 procs_priv表</h3><p>rocs_priv表可以对<code>存储过程和存储函数设置操作权限</code>，<code>desc mysql.procs_priv;</code></p><h2 id="4、访问控制-了解">4、访问控制(了解)</h2><h3 id="4-1-连接核实阶段">4.1 连接核实阶段</h3><p>当用户试图连接MySQL服务器时，服务器基于用户的身份以及用户是否能提供正确的密码验证身份来确定接受或者拒绝连接。即客户端用户会在连接请求中提供用户名、主机地址、用户密码，MySQL服务器接收到用户请求后，会<strong>使用user表中的host、user和authentication_string这3个字段匹配客户端提供信息</strong>。<br>服务器只有在user表记录的Host和User字段匹配客户端主机名和用户名，并且提供正确的密码时才接受连接。<strong>如果连接核实没有通过，服务器就完全拒绝访问；否则，服务器接受连接，然后进入阶段2等待用户请求</strong>。</p><h3 id="4-2-请求核实阶段">4.2 请求核实阶段</h3><p>一旦建立了连接，服务器就进入了访问控制的阶段2，也就是请求核实阶段。对此连接上进来的每个请求，服务器检查该请求要执行什么操作、是否有足够的权限来执行它，这正是需要授权表中的权限列发挥作用的地方。这些权限可以来自<code>user、db、table_priv和column_priv表</code>。<br>确认权限时，MySQL首先<strong>检查user表</strong>，如果指定的权限没有在user表中被授予，那么MySQL就会继续<strong>检查db表</strong>，db表是下一安全层级，其中的权限限定于数据库层级，在该层级的SELECT权限允许用户查看指定数据库的所有表中的数据；如果在该层级没有找到限定的权限，则MySQL继续<strong>检查tables_priv表</strong>以及<strong>columns_priv表</strong>，如果所有权限表都检查完毕，但还是没有找到允许的权限操作，MySQL将返回<strong>错误信息</strong>，用户请求的操作不能执行，操作失败。</p><blockquote><p>提示： MySQL通过向下层级的顺序（从user表到columns_priv表）检查权限表，但并不是所有的权限都要执行该过程。例如，一个用户登录到MySQL服务器之后只执行对MySQL的管理操作，此时只涉及管理权限，因此MySQL只检查user表。另外，如果请求的权限操作不被允许，MySQL也不会继续检查下一层级的表。</p></blockquote><h2 id="5、角色管理">5、角色管理</h2><h3 id="5-1-角色的理解">5.1 角色的理解</h3><p>引入角色的目的是<strong>方便管理拥有相同权限的用户</strong><br><img src="https://img-blog.csdnimg.cn/img_convert/0773969ffbe523f7c9c69672b3c3c007.png" alt="image.png"></p><h3 id="5-2-角色常见操作">5.2 角色常见操作</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- ========================创建角色===========================</span></span><br><span class="line"><span class="comment">-- 创建角色使用CREATE ROLE 语句</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">ROLE</span> <span class="string">'role_name'</span>[@<span class="string">'host_name'</span>] [,<span class="string">'role_name'</span>[@<span class="string">'host_name'</span>]]</span><br><span class="line"><span class="comment">-- 如果host_name省略，默认为% ， role_name不可省略，不可为空</span></span><br><span class="line"><span class="comment">-- 举例</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">ROLE</span> <span class="string">'manager'</span>@<span class="string">'localhost'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ========================赋予角色权限===========================</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">privileges</span> <span class="keyword">ON</span> table_name <span class="keyword">TO</span> <span class="string">'role_name'</span>[@<span class="string">'host_name'</span>];</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">PRIVILEGES</span>\G;</span><br><span class="line"><span class="comment">-- 举例</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> demo.settlement <span class="keyword">TO</span> <span class="string">'manager'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ========================查看角色权限===========================</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GRANTS</span> <span class="keyword">FOR</span> <span class="string">'manager'</span>;</span><br><span class="line"><span class="comment">-- 只要你创建了一个角色，系统就会自动给你一个“ USAGE ”权限，意思是连接登录数据库的权限。</span></span><br><span class="line"><span class="comment">-- 代码的最后三行代表了我们给角色“manager”赋予的权限，也就是对商品信息表、盘点表和应付账款表的只读权限。</span></span><br><span class="line"><span class="comment">-- 结果显示，库管角色拥有商品信息表的只读权限和盘点表的增删改查权限。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- ========================回收角色权限===========================</span></span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">privileges</span> <span class="keyword">ON</span> tablename <span class="keyword">FROM</span> <span class="string">'rolename'</span>;</span><br><span class="line"><span class="comment">-- 举例，撤销school_write角色的权限。</span></span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">INSERT</span>, <span class="keyword">UPDATE</span>, <span class="keyword">DELETE</span> <span class="keyword">ON</span> school.* <span class="keyword">FROM</span> <span class="string">'school_write'</span>;</span><br><span class="line"><span class="comment">-- 撤销后使用SHOW语句查看school_write对应的权限</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GRANTS</span> <span class="keyword">FOR</span> <span class="string">'school_write'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ========================删除角色===========================</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">ROLE</span> <span class="keyword">role</span> [,role2]</span><br><span class="line"><span class="comment">-- 如果你删除了角色，那么用户也就失去了通过这个角色所获得的所有权限</span></span><br></pre></td></tr></table></figure><h3 id="5-3-角色权限赋予">5.3 角色权限赋予</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- ========================给用户赋予角色===========================</span></span><br><span class="line"><span class="comment">-- 角色创建并授权后，要赋给用户并处于激活状态才能发挥作用。给用户添加角色可使用GRANT语句</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">role</span> [,role2,...] <span class="keyword">TO</span> <span class="keyword">user</span> [,user2,...];</span><br><span class="line"><span class="comment">-- 举例</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="string">'school_read'</span> <span class="keyword">TO</span> <span class="string">'kangshifu'</span>@<span class="string">'localhost'</span>;</span><br><span class="line">HOW GRANTS FOR 'kangshifu'@'localhost';</span><br><span class="line"><span class="comment">-- 查询当前角色</span></span><br><span class="line"><span class="keyword">SELECT</span> CURRENT_ROLE();</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ========================激活角色===========================</span></span><br><span class="line"><span class="comment">-- 方式1：使用set default role 命令激活角色</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">DEFAULT</span> <span class="keyword">ROLE</span> <span class="keyword">ALL</span> <span class="keyword">TO</span> <span class="string">'kangshifu'</span>@<span class="string">'localhost'</span>;</span><br><span class="line"><span class="comment">-- 方式2：将activate_all_roles_on_login设置为ON</span></span><br><span class="line"><span class="comment">-- 对所有角色永久激活</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'activate_all_roles_on_login'</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> activate_all_roles_on_login=<span class="keyword">ON</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ========================撤销用户的角色===========================</span></span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">role</span> <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br><span class="line"><span class="comment">-- 举例</span></span><br><span class="line"><span class="keyword">REVOKE</span> <span class="string">'school_read'</span> <span class="keyword">FROM</span> <span class="string">'kangshifu'</span>@<span class="string">'localhost'</span>;</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GRANTS</span> <span class="keyword">FOR</span> <span class="string">'kangshifu'</span>@<span class="string">'localhost'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ========================设置强制角色(mandatory role)===========================</span></span><br><span class="line"><span class="comment">-- 给每个用户创建的默认角色，不需要手动设置，无法被回收和删除</span></span><br><span class="line"><span class="comment">-- 服务启动前设置</span></span><br><span class="line">[mysqld]</span><br><span class="line">mandatory_roles='role1,role2@localhost,r3@%.atguigu.com'</span><br><span class="line"><span class="comment">-- 运行时设置</span></span><br><span class="line"><span class="comment">-- 系统重启后仍然有效</span></span><br><span class="line"><span class="keyword">SET</span> PERSIST mandatory_roles = <span class="string">'role1,role2@localhost,r3@%.example.com'</span>;</span><br><span class="line"><span class="comment">-- 系统重启后失效</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> mandatory_roles = <span class="string">'role1,role2@localhost,r3@%.example.com'</span>;</span><br></pre></td></tr></table></figure><h1>三、逻辑架构与存储引擎</h1><h2 id="1、逻辑架构剖析">1、逻辑架构剖析</h2><h3 id="1-1-服务器处理客户端请求">1.1 服务器处理客户端请求</h3><p>MySQL是典型的C/S架构，即Clinet/Server 架构，服务端程序使用的mysqld。<strong>客户端进程向服务器进程发送一段文本（SQL语句），服务器进程处理后再向客户端进程发送一段文本（处理结果）</strong><br><img src="https://img-blog.csdnimg.cn/img_convert/0edb106369b53cdbbbcd9deba3dab8d9.png" alt="image-20220615133227202.png"></p><h3 id="1-2-Connectors">1.2 Connectors</h3><p>Connectors,指的是不同语言中与SQL的交互。MySQL首先是一个网络程序，在TCP之上定义了自己的应用层协议。所以要使用MySQL，我们可以编写代码，跟MySQL Server 建立TCP连接，之后按照其定义好的协议进行交互。或者比较方便的方法是调用SDK，比如Native C API、JDBC、PHP等各语言MySQL Connecotr,或者通过JDBC。但<strong>通过SDK来访问MySQL，本质上还是在TCP连接上通过MySQL协议跟MySQL进行交互，MySQL Server结构可以分为三层：连接层、服务层、引擎层</strong></p><h3 id="1-3-第一层：连接层">1.3 第一层：连接层</h3><p>系统（客户端）访问 MySQL 服务器前，做的第一件事就是建立 TCP 连接。 经过三次握手建立连接成功后， MySQL 服务器对 TCP 传输过来的账号密码做身份认证、权限获取。</p><ul><li>用户名或密码不对，会收到一个Access denied for user错误，客户端程序结束执行</li><li>用户名密码认证通过，会从权限表查出账号拥有的权限与连接关联，之后的权限判断逻辑，都将依赖于此时读到的权限</li></ul><p>TCP 连接收到请求后，必须要分配给一个线程专门与这个客户端的交互。所以还会有个线程池，去走后面的流程。每一个连接从线程池中获取线程，省去了创建和销毁线程的开销。所以<strong>连接管理</strong>的职责是负责认证、管理连接、获取权限信息。</p><h3 id="1-4-第二层：服务层">1.4 第二层：服务层</h3><p>第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成<code>缓存的查询</code>，SQL的分析和优化及部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如过程、函数等。在该层，服务器会<code>解析查询</code>并创建相应的内部<code>解析树</code>，并对其完成相应的<code>优化</code>：如确定查询表的顺序，是否利用索引等，最后生成相应的执行操作。如果是SELECT语句，服务器还会<code>查询内部的缓存</code>。如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能。</p><ul><li>SQL Interface: SQL接口<ul><li>接收用户的SQL命令，并且返回用户需要查询的结果。比如SELECT … FROM就是调用SQL Interface</li><li>MySQL支持DML（数据操作语言）、DDL（数据定义语言）、存储过程、视图、触发器、自定 义函数等多种SQL语言接口</li></ul></li><li>Parser: 解析器<ul><li>在解析器中对 SQL 语句进行语法分析、语义分析。将SQL语句分解成数据结构，并将这个结构 传递到后续步骤，以后SQL语句的传递和处理就是基于这个结构的。如果在分解构成中遇到错 误，那么就说明这个SQL语句是不合理的。</li><li>在SQL命令传递到解析器的时候会被解析器验证和解析，并为其创建 语法树 ，并根据数据字 典丰富查询语法树，会 验证该客户端是否具有执行该查询的权限 。创建好语法树后，MySQL还 会对SQl查询进行语法上的优化，进行查询重写。</li></ul></li><li>Optimizer: 查询优化器<ul><li>SQL语句在语法解析之后、查询之前会使用查询优化器确定 SQL 语句的执行路径，生成一个 执行计划 。</li><li>这个执行计划表明应该 使用哪些索引 进行查询（全表检索还是使用索引检索），表之间的连 接顺序如何，最后会按照执行计划中的步骤调用存储引擎提供的方法来真正的执行查询，并将 查询结果返回给用户。</li><li>它使用“ 选取-投影-连接 ”策略进行查询。例如：<code>SELECT id,name FROM student WHERE gender = '女';</code>这个SELECT查询先根据WHERE语句进行 选取 ，而不是将表全部查询出来以后再进行gender过 滤。 这个SELECT查询先根据id和name进行属性 投影 ，而不是将属性全部取出以后再进行过 滤，将这两个查询条件 连接 起来生成最终查询结果。</li></ul></li><li>Caches &amp; Buffers： 查询缓存组件<ul><li>MySQL内部维持着一些Cache和Buffer，比如Query Cache用来缓存一条SELECT语句的执行结 果，如果能够在其中找到对应的查询结果，那么就不必再进行查询解析、优化和执行的整个过 程了，直接将结果反馈给客户端。</li><li>这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等 。 这个查询缓存可以在 不同客户端之间共享 。</li><li>从MySQL 5.7.20开始，不推荐使用查询缓存，并在 MySQL 8.0中删除 。</li></ul></li></ul><h3 id="1-5-第三层：引擎层">1.5 第三层：引擎层</h3><p>插件式存储引擎层（ Storage Engines），<strong>真正的负责了MySQL中数据的存储和提取，对物理服务器级别维护的底层数据执行操作</strong>，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样 我们可以根据自己的实际需要进行选取。可以通过<code>show engines;</code>查看</p><h3 id="1-6-存储层">1.6 存储层</h3><p>所有的数据，数据库、表的定义，表的每一行的内容，索引，都是存在文件系统 上，以文件的方式存在的，并完成与存储引擎的交互。当然有些存储引擎比如InnoDB，也支持不使用文件系统直接管理裸设备，但现代文件系统的实现使得这样做没有必要了。在文件系统之下，可以使用本地磁盘，可以使用 DAS、NAS、SAN等各种存储系统。</p><h2 id="2、SQL执行流程">2、SQL执行流程</h2><h3 id="2-1-MySQL中的SQL执行流程">2.1 MySQL中的SQL执行流程</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/3e9b925a3a0dac020883e50a226e1105.png" alt="image-20220615141934531.png"><br><strong>1、查询缓存</strong></p><blockquote><p>Server 如果在查询缓存中发现了这条 SQL 语句，就会直接将结果返回给客户端；如果没 有，就进入到解析器阶段。需要说明的是，因为查询缓存往往效率不高，所以在 MySQL8.0 之后就抛弃了这个功能</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一般建议大家在静态表里使用查询缓存,例如系统配置表，MySQL也提供了这种“`按需使用`”的方式。</span></span><br><span class="line"><span class="comment">#可以将 my.cnf 参数 query_cache_type 设置成 DEMAND，代表当 sql 语句中有 SQL_CACHE关键字时才缓存</span></span><br><span class="line"><span class="comment"># query_cache_type 有3个值。 0代表关闭查询缓存OFF，1代表开启ON，2代表(DEMAND)</span></span><br><span class="line">query_cache_type=2</span><br><span class="line">SELECT SQl_CACHE * FROM <span class="built_in">test</span> WHERE ID=5;</span><br><span class="line"><span class="comment"># MySQL5.7中,查看当前 mysql 实例是否开启缓存机制</span></span><br><span class="line">show global variables like <span class="string">"%query_cache_type%"</span>;</span><br><span class="line"><span class="comment"># 监控查询缓存的命中率：</span></span><br><span class="line">show status like <span class="string">'%Qcache%'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Qcache_free_blocks: 表示查询缓存中海油多少剩余的blocks，如果该值显示较大，则说明查询缓存中的`内部碎片`过多了，可能在一定的时间进行整理。</span></span><br><span class="line"><span class="comment">#Qcache_free_memory: 查询缓存的内存大小，通过这个参数可以很清晰的知道当前系统的查询内存是否够用，DBA可以根据实际情况做出调整。</span></span><br><span class="line"><span class="comment">#Qcache_hits: 表示有 `多少次命中缓存`。我们主要可以通过该值来验证我们的查询缓存的效果。数字越大，缓存效果越理想。</span></span><br><span class="line"><span class="comment">#Qcache_inserts: 表示`多少次未命中然后插入`，意思是新来的SQL请求在缓存中未找到，不得不执行查询处理，执行查询处理后把结果insert到查询缓存中。这样的情况的次数越多，表示查询缓存应用到的比较少，效果也就不理想。当然系统刚启动后，查询缓存是空的，这也正常。</span></span><br><span class="line"><span class="comment">#Qcache_lowmem_prunes: 该参数记录有`多少条查询因为内存不足而被移除`出查询缓存。通过这个值，用户可以适当的调整缓存大小。</span></span><br><span class="line"><span class="comment">#Qcache_not_cached: 表示因为query_cache_type的设置而没有被缓存的查询数量。</span></span><br><span class="line"><span class="comment">#Qcache_queries_in_cache: 当前缓存中`缓存的查询数量`。</span></span><br><span class="line"><span class="comment">#Qcache_total_blocks: 当前缓存的block数量。</span></span><br></pre></td></tr></table></figure><p><strong>2、解析器</strong></p><blockquote><p>在解析器中对 SQL 语句进行语法分析、语义分析</p></blockquote><p>分析器先做“ 词法分析 ”。你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面 的字符串分别是什么，代表什么。 MySQL 从你输入的&quot;select&quot;这个关键字识别出来，这是一个查询语 句。它也要把字符串“T”识别成“表名 T”，把字符串“ID”识别成“列 ID”。接着，要做“ 语法分析 ”。根据词法分析的结果，语法分析器（比如：Bison）会根据语法规则，判断你输 入的这个 SQL 语句是否 满足 MySQL 语法<br><strong>3、优化器</strong></p><blockquote><p>在优化器中会确定 SQL 语句的执行路径，比如是根据 <code>全表检索</code> ，还是根据 <code>索引检索</code> 等。</p></blockquote><p>经过解释器，MySQL就知道你要做什么了。在开始执行之前，还要先经过优化器的处理。<strong>一条查询可以有很多种执行方式，最后都返回相同的结果。优化器的作用就是找到这其中最好的执行计划</strong>。比如：优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联 (join) 的时候，决定各个表的连接顺序，还有表达式简化、子查询转为连接、外连接转为内连接等。<br>在查询优化器中，可以分为 <strong>逻辑查询</strong> 优化阶段和 <strong>物理查询</strong> 优化阶段。<strong>逻辑查询优化</strong>就是通过改变SQL语句的内容来使得SQL查询更高效，同时为物理查询优化提供更多的候选执行计划。通常采用的方式是对SQL语句进行等价变换，对查询进行重写，而查询重写的数学基础就是关系代数。对条件表达式进行等价谓词重写、条件简化，对视图进行重写，对子查询进行优化，对连接语义进行了外连接消除、嵌套连接消除等。<strong>物理查询优化</strong>是基于关系代数进行的查询重写，而关系代数的每一步都对应着物理计算，这些物理计算往往存在多种算法，因此需要计算各种物理路径的代价，从中选择代价最小的作为执行计划。在这个阶段里，对于单表和多表连接的操作，需要高效地使用索引，提升查询效率<br><strong>4、执行器</strong></p><blockquote><p>在执行之前需要判断该用户是否 具备权限 。如果没有，就会返回权限错误。如果具备权限，就执行 SQL 查询并返回结果。在 MySQL8.0 以下的版本，如果设置了查询缓存，这时会将查询结果进行缓存</p></blockquote><h3 id="2-2-MySQL8中SQL执行原理">2.2 MySQL8中SQL执行原理</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 了解查询语句底层执行的过程：`select @profiling` 或者 `show variables like '%profiling'` 查看是否开启计划。</span></span><br><span class="line"><span class="comment">-- 开启它可以让MySQL收集在SQL</span></span><br><span class="line"><span class="keyword">select</span> @@profiling;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'profiling'</span>;</span><br><span class="line"><span class="comment">-- profiling=0 代表关闭，我们需要把 profiling 打开，即设置为 1</span></span><br><span class="line"><span class="keyword">set</span> profiling=<span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 然后我们执行一个 SQL 查询（你可以执行任何一个 SQL 查询）</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> employees;</span><br><span class="line"><span class="comment">-- 查看当前会话所产生的所有 profiles</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">profiles</span>;</span><br><span class="line"><span class="comment">-- 显示执行计划，查看程序的执行步骤</span></span><br><span class="line"><span class="keyword">show</span> profile;</span><br><span class="line"><span class="comment">-- 查询指定的 Query ID</span></span><br><span class="line"><span class="keyword">show</span> profile <span class="keyword">for</span> <span class="keyword">query</span> <span class="number">7</span>;</span><br><span class="line"><span class="comment">-- 查询更丰富的内容</span></span><br><span class="line"><span class="keyword">show</span> profile cpu,<span class="keyword">block</span> io <span class="keyword">for</span> <span class="keyword">query</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 除了查看cpu、io阻塞等参数情况，还可以查询下列参数的利用情况</span></span><br><span class="line">Syntax:</span><br><span class="line"><span class="keyword">SHOW</span> PROFILE [<span class="keyword">type</span> [, <span class="keyword">type</span>] ... ]</span><br><span class="line">[<span class="keyword">FOR</span> <span class="keyword">QUERY</span> n]</span><br><span class="line">[<span class="keyword">LIMIT</span> <span class="keyword">row_count</span> [<span class="keyword">OFFSET</span> <span class="keyword">offset</span>]]</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span>: &#123;</span><br><span class="line">| <span class="keyword">ALL</span> <span class="comment">-- 显示所有参数的开销信息</span></span><br><span class="line">| <span class="keyword">BLOCK</span> IO <span class="comment">-- 显示IO的相关开销</span></span><br><span class="line">| <span class="keyword">CONTEXT</span> SWITCHES <span class="comment">-- 上下文切换相关开销</span></span><br><span class="line">| CPU <span class="comment">-- 显示CPU相关开销信息</span></span><br><span class="line">| IPC <span class="comment">-- 显示发送和接收相关开销信息</span></span><br><span class="line">| <span class="keyword">MEMORY</span> <span class="comment">-- 显示内存相关开销信息</span></span><br><span class="line">| PAGE FAULTS <span class="comment">-- 显示页面错误相关开销信息</span></span><br><span class="line">| <span class="keyword">SOURCE</span> <span class="comment">-- 显示和Source_function,Source_file,Source_line 相关的开销信息</span></span><br><span class="line">| SWAPS <span class="comment">-- 显示交换次数相关的开销信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 发现两次查询当前情况都一致，说明没有缓存，在 8.0 版本之后，MySQL 不再支持缓存的查询</span></span><br><span class="line"><span class="comment">-- mysql5.7多了缓存，相同查询两次可能执行过程会不一样</span></span><br></pre></td></tr></table></figure><h2 id="3、数据库缓冲池（buffer-pool）">3、数据库缓冲池（buffer pool）</h2><blockquote><p>InnoDB 存储引擎是以页为单位来管理存储空间的，我们进行的增删改查操作其实本质上都是在访问页面（包括读页面、写页面、创建新页面等操作）。而磁盘 I/O 需要消耗的时间很多，而在内存中进行操作，效率则会高很多，为了能让数据表或者索引中的数据随时被我们所用，DBMS 会申请占用内存来作为数据缓冲池 ，在真正访问页面之前，需要把在磁盘上的页缓存到内存中的 Buffer Pool 之后才可以访问</p></blockquote><h3 id="3-1-缓冲池（Buffer-Pool）">3.1 缓冲池（Buffer Pool）</h3><p>在 InnoDB 存储引擎中有一部分数据会放到内存中，缓冲池则占了这部分内存的大部分，它用来存储各种数据的缓存，包括了<strong>数据页、索引页、插入缓冲、锁信息、自适应 Hash 和数据字典信息</strong>等<br><strong>缓存原则</strong><br>“<strong>位置 * 频次</strong>”这个原则，可以帮我们对 I/O 访问效率进行优化。首先，<strong>位置决定效率</strong>，提供缓冲池就是为了在内存中可以直接访问数据。其次，<strong>频次决定优先级顺序</strong>。因为缓冲池的大小是有限的，比如磁盘有 200G，但是内存只有 16G，缓冲池大小只有 1G，就无法将所有数据都加载到缓冲池里，这时就涉及到优先级顺序，会优先对使用频次高的热数据进行加载；<br>**缓冲池的预读特性，**缓冲池的作用就是提升 I/O 效率，而我们进行读取数据的时候存在一个“<strong>局部性原理</strong>”，也就是说我们使用了一些数据，<strong>大概率还会使用它周围的一些数据</strong>，因此采用“预读”的机制提前加载，可以减少未来可能的磁盘 I/O 操作</p><h3 id="3-2-缓冲池如何读取数据">3.2 缓冲池如何读取数据</h3><p>冲池管理器会尽量将经常使用的数据保存起来，在数据库进行页面读操作的时候，首先会判断该页面 是否在缓冲池中，如果存在就直接读取，如果不存在，就会通过内存或磁盘将页面存放到缓冲池中再进行读取。<br><img src="https://img-blog.csdnimg.cn/img_convert/a221480f2ffb80fdcb16e81c7b4f83bc.png" alt="image-20220615193131719.png"><br><strong>如果我们执行 SQL 语句的时候更新了缓存池中的数据，那么这些数据会马上同步到磁盘上吗？</strong><br>实际上，当我们对数据库中的记录进行修改的时候，首先会修改缓冲池中页里面的记录信息，然后数据库会<strong>以一定的频率</strong>刷新到磁盘中。注意并不是每次发生更新操作，都会立即进行磁盘回写。缓冲池会采用一种叫做** checkpoint 的机制 <strong>将数据回写到磁盘上，这样做的好处就是提升了数据库的整体性能。比如，当</strong>缓冲池不够用时**，需要释放掉一些不常用的页，此时就可以强行采用checkpoint的方式，将不常用的脏页回写到磁盘上，然后再从缓存池中将这些页释放掉。这里的脏页 (dirty page) 指的是缓冲池中被修改过的页，与磁盘上的数据页不一致。</p><h3 id="3-3-查看-设置缓冲池">3.3 查看/设置缓冲池</h3><p>如果你使用的是 MySQL MyISAM 存储引擎，它只缓存索引，不缓存数据，对应的键缓存参数为<code>key_buffer_size</code>，你可以用它进行查看。如果你使用的是 InnoDB 存储引擎，可以通过查看 <code>innodb_buffer_pool_size</code> 变量来查看缓冲池的大小</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 此时 InnoDB 的缓冲池大小只有 134217728/1024/1024=128MB</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'innodb_buffer_pool_size'</span>;</span><br><span class="line"><span class="comment">-- 我们可以修改缓冲池大小，比如改为256MB</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> innodb_buffer_pool_size = <span class="number">268435456</span>;</span><br><span class="line"><span class="comment">-- 或者配置文件修改</span></span><br><span class="line">[server]</span><br><span class="line">innodb_buffer_pool_size = 268435456</span><br></pre></td></tr></table></figure><h3 id="3-4-多个Buffer-Pool实例">3.4 多个Buffer Pool实例</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 修改多个实例</span></span><br><span class="line">[server]</span><br><span class="line">innodb_buffer_pool_instances = 2</span><br><span class="line"><span class="comment">-- 查看个数</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'innodb_buffer_pool_instances'</span>;</span><br><span class="line"><span class="comment">-- 每个 Buffer Pool 实例实际占多少内存空间</span></span><br><span class="line"><span class="comment">-- innodb_buffer_pool_size/innodb_buffer_pool_instances</span></span><br></pre></td></tr></table></figure><p>不是说 Buffer Pool 实例创建的越多越好，分别管理各个 Buffer Pool 也是需要性能开销的，InnDB规定：当innodb_buffer_pool_size的值小于1G的时候设置多个实例是无效的，InnoDB会默认把innodb_buffer_pool_instances的值修改为1。而我们鼓励在 Buffer Pool 大于等于 1G 的时候设置多个 Buffer Pool 实例。</p><h3 id="3-5-引申问题">3.5 引申问题</h3><p>当我们查询数据的时候，会先去 Buffer Pool 中查询。如果 Buffer Pool 中不存在，存储引擎会先将数据从磁盘加载到 Buffer Pool 中，然后将数据返回给客户端；同理，当我们更新某个数据的时候，如果这个数据不存在于 Buffer Pool，同样会先数据加载进来，然后修改内存的数据。被修改的数据会在之后统一刷入磁盘。<br><img src="https://img-blog.csdnimg.cn/img_convert/59275db3b3b9862f62b035a3a62cb85b.png" alt="image-20220615222455867.png"><br>更新到一半突然发生错误了，想要回滚到更新之前的版本，该怎么办？连数据持久化的保证、事务回滚都做不到还谈什么崩溃恢复？答案：<strong>Redo Log</strong> &amp; <strong>Undo Log</strong></p><h2 id="4、存储引擎">4、存储引擎</h2><h3 id="4-1-查看与设置默认引擎">4.1 查看与设置默认引擎</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看mysql提供什么存储引擎</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">engines</span>;</span><br><span class="line"><span class="comment">-- 查看默认的存储引擎</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%storage_engine%'</span>;</span><br><span class="line"><span class="keyword">SELECT</span> @@default_storage_engine;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改默认的存储引擎</span></span><br><span class="line"><span class="comment">-- 如果在创建表的语句中没有显式指定表的存储引擎的话，那就会默认使用 InnoDB 作为表的存储引擎</span></span><br><span class="line"><span class="keyword">SET</span> DEFAULT_STORAGE_ENGINE=MyISAM;</span><br><span class="line"><span class="comment">-- 或者修改配置文件</span></span><br><span class="line">default-storage-engine=MyISAM</span><br><span class="line"><span class="comment">-- 重启服务</span></span><br><span class="line">systemctl restart mysqld.service</span><br></pre></td></tr></table></figure><h3 id="4-2-设置表的存储引擎">4.2 设置表的存储引擎</h3><blockquote><p>存储引擎是负责对表中的数据进行提取和写入工作的，我们可以为 不同的表设置不同的存储引擎 ，也就是 说不同的表可以有不同的物理存储结构，不同的提取和写入方式</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 我们之前创建表的语句都没有指定表的存储引擎，那就会使用默认的存储引擎 InnoDB，如果我们想显 式的指定一下表的存储引擎</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(</span><br><span class="line">建表语句;</span><br><span class="line">) ENGINE = 存储引擎名称;</span><br><span class="line"><span class="comment">-- 修改</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ENGINE</span> = 存储引擎名称;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> engine_demo_table <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span>;</span><br><span class="line"><span class="comment">-- 查看表结构</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> engine_demo_table\G</span><br></pre></td></tr></table></figure><h3 id="4-3-引擎介绍">4.3 引擎介绍</h3><p><strong>InnoDB 引擎：具备外键支持功能的事务存储引擎</strong></p><ul><li>MySQL从3.23.34a开始就包含InnoDB存储引擎。 <code>大于等于5.5之后，默认采用InnoDB引擎</code></li><li>InnoDB是MySQL的 默认事务型引擎 ，它被设计用来处理大量的短期(short-lived)事务。可以确保事务的完整提交(Commit)和回滚(Rollback)</li><li>除了增加和查询外，还需要更新、删除操作，那么，应优先选择InnoDB存储引擎。 除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑InnoDB引擎</li><li>数据文件结构：（在《第02章_MySQL数据目录》章节已讲）<ul><li>表名.frm 存储表结构（MySQL8.0时，合并在表名.ibd中）</li><li>表名.ibd 存储数据和索引</li></ul></li><li>InnoDB是 为处理巨大数据量的最大性能设计<ul><li>在以前的版本中，字典数据以元数据文件、非事务表等来存储。现在这些元数据文件被删除 了。比如： .frm ， .par ， .trn ， .isl ， .db.opt 等都在MySQL8.0中不存在了</li></ul></li><li>对比MyISAM的存储引擎， InnoDB写的处理效率差一些 ，并且会占用更多的磁盘空间以保存数据和索引</li><li>MyISAM只缓存索引，不缓存真实数据；InnoDB不仅缓存索引还要缓存真实数据， 对内存要求较 高 ，而且内存大小对性能有决定性的影响</li></ul><p><strong>MyISAM 引擎：主要的非事务处理存储引擎</strong></p><ul><li>MyISAM提供了大量的特性，包括全文索引、压缩、空间函数(GIS)等，但MyISAM不支持事务、行级 锁、外键 ，有一个毫无疑问的缺陷就是崩溃后无法安全恢复 。</li><li>5.5之前默认的存储引擎</li><li>优势是访问的速度快 ，对事务完整性没有要求或者以SELECT、INSERT为主的应用</li><li>针对数据统计有额外的常数存储。故而 count(*) 的查询效率很高 数据文件结构：（在《第02章_MySQL数据目录》章节已讲）<ul><li>表名.frm 存储表结构</li><li>表名.MYD 存储数据 (MYData)</li><li>表名.MYI 存储索引 (MYIndex)</li></ul></li><li>应用场景：只读应用或者以读为主的业务</li></ul><p><strong>Archive 引擎：用于数据存档</strong><br><img src="https://img-blog.csdnimg.cn/img_convert/98d601dc3138fa439679a7bdf03f1f2f.png" alt="image-20220616124743732.png"><br><strong>Blackhole 引擎：丢弃写操作，读操作会返回空内容</strong><br><strong>CSV 引擎：存储数据时，以逗号分隔各个数据项</strong><br><strong>Memory 引擎：置于内存的表</strong></p><blockquote><p>Memory采用的逻辑介质是内存 ，响应速度很快 ，但是当mysqld守护进程崩溃的时候数据会丢失 。另外，要求存储的数据是数据长度不变的格式，比如，Blob和Text类型的数据不可用(长度不固定的)。</p></blockquote><p><strong>主要特征：</strong></p><ul><li>Memory同时 支持哈希（HASH）索引 和 B+树索引 。</li><li>Memory表至少比MyISAM表要快一个数量级 。</li><li>MEMORY 表的大小是受到限制 的。表的大小主要取决于两个参数，分别是 max_rows 和 max_heap_table_size 。其中，max_rows可以在创建表时指定；max_heap_table_size的大小默 认为16MB，可以按需要进行扩大。</li><li>数据文件与索引文件分开存储。</li><li>缺点：其数据易丢失，生命周期短。基于这个缺陷，选择MEMORY存储引擎时需要特别小心。</li></ul><p><strong>使用Memory存储引擎的场景：</strong></p><ol><li>目标数据比较小 ，而且非常频繁的进行访问 ，在内存中存放数据，如果太大的数据会造成内存溢出 。可以通过参数 max_heap_table_size 控制Memory表的大小，限制Memory表的最大的大小。</li><li>如果数据是临时的 ，而且必须立即可用得到，那么就可以放在内存中。</li><li>存储在Memory表中的数据如果突然间丢失的话也没有太大的关系</li></ol><p><strong>Federated 引擎：访问远程表</strong><br><strong>NDB引擎：MySQL集群专用存储引擎</strong></p><blockquote><p>也叫做 NDB Cluster 存储引擎，主要用于 MySQL Cluster 分布式集群 环境，类似于 Oracle 的 RAC 集 群</p></blockquote><h3 id="4-4-引擎对比">4.4 引擎对比</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/8de8224f6c6255bdd7613b1b9e97ae32.png" alt="image-20220616125928861.png"></p><h1>四、索引与InnoDB数据存储结构</h1><h2 id="1、索引概述">1、索引概述</h2><h3 id="1-1-索引作用">1.1 索引作用</h3><blockquote><p>索引是存储引擎用于快速找到数据记录的一种数据结构，MySQL进行数据查找时，首先查看查询条件是否命中某条索引，符合则通过索引查找相关数据，如果不符合则需要全表扫描，即需要一条一条地查找记录，直到找到与条件符合的记录</p></blockquote><p><img src="https://img-blog.csdnimg.cn/img_convert/80f6f60743b1a3a8f919b9ce5b2343ea.png" alt="image-20220616142723266.png"><br>MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。<br><strong>索引的本质</strong>：索引是数据结构。你可以简单理解为“排好序的快速查找数据结构”，满足特定查找算法。 这些数据结构以某种方式指向数据， 这样就可以在这些数据结构的基础上实现 高级查找算法 。索引是在存储引擎中实现的，因此每种存储引擎的索引不一定完全相同，并且每种存储引擎不一定支持所有索引类型。同时，存储引擎可以定义每个表的 最大索引数和 最大索引长度。所有存储引擎支持每个表至少16个索引，总索引长度至少为256字节。有些存储引擎支持更多的索引数和更大的索引长度。</p><h3 id="1-2-索引优点">1.2 索引优点</h3><ul><li>类似大学图书馆建书目索引，提高数据检索的效率，降低 <strong>数据库的IO成本</strong> ，这也是创建索引最主 要的原因</li><li>通过创建唯一索引，可以保证数据库表中每一行 <strong>数据的唯一性</strong></li><li>在实现数据的 参考完整性方面，可以 <strong>加速表和表之间的连接</strong> 。换句话说，对于有依赖关系的子表和父表联合查询时， 可以提高查询速度</li><li>在使用分组和排序子句进行数据查询时，可以显著 <strong>减少查询中分组和排序的时间</strong> ，降低了CPU的消耗</li></ul><h3 id="1-3-缺点">1.3 缺点</h3><ul><li>创建索引和维护索引要 <strong>耗费时间</strong> ，并 且随着数据量的增加，所耗费的时间也会增加</li><li>索引需要占 <strong>磁盘空间</strong> ，除了数据表占数据空间之 外，每一个索引还要占一定的物理空间， 存储在磁盘上 ，如果有大量的索引，索引文件就可能比数据文 件更快达到最大文件尺寸</li><li>虽然索引大大提高了查询速度，同时却会 <strong>降低更新表的速度</strong> 。当对表 中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。 因此，选择使用索引时，需要综合考虑索引的优点和缺点</li><li>索引可以提高查询的速度，但是会影响插入记录的速度。这种情况下，最好的办法是先删除表中的索引，然后插入数据，插入完成后再创建索引</li></ul><h2 id="2、InnoDB中索引的推演">2、InnoDB中索引的推演</h2><h3 id="2-1-索引之前的查找">2.1 索引之前的查找</h3><p>假设目前表中的记录比较少，<strong>所有的记录都可以被存放到一个页中</strong>，在查找记录的时候可以根据搜索条件的不同分为两种情况：</p><ul><li>以主键为搜索条件，可以在页目录中使用 <code>二分法</code> 快速定位到对应的槽，然后再遍历该槽对用分组中的记录即可快速找到指定记录。</li><li>以其他列作为搜索条件，因为在数据页中并没有对非主键列简历所谓的页目录，所以我们无法通过二分法快速定位相应的槽。这种情况下只能从 <code>最小记录</code> 开始 <code>依次遍历单链表中的每条记录</code>， 然后对比每条记录是不是符合搜索条件。很显然，这种查找的效率是非常低的。</li></ul><p>在<strong>很多页中查找记录</strong>的活动可以分为两个步骤：</p><ul><li>定位到记录所在的页</li><li>从所在的页内中查找相应的记录</li></ul><p>在没有索引的情况下，不论是根据主键列或者其他列的值进行查找，由于我们并不能快速的定位到记录所在的页，所以只能 从第一个页沿着双向链表 一直往下找，在每一个页中根据我们上面的查找方式去查 找指定的记录。因为要遍历所有的数据页，所以这种方式显然是 <strong>超级耗时</strong> 的。如果一个表有一亿条记录呢？此时 索引 应运而生</p><h3 id="2-2-设计索引">2.2 设计索引</h3><p>首先建一个表</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE index_demo(</span><br><span class="line">-&gt; c1 INT,</span><br><span class="line">-&gt; c2 INT,</span><br><span class="line">-&gt; c3 CHAR(1),</span><br><span class="line">-&gt; PRIMARY KEY(c1)</span><br><span class="line">-&gt; ) ROW_FORMAT = Compact;</span><br></pre></td></tr></table></figure><p>这个新建的 <strong>index_demo</strong> 表中有2个INT类型的列，1个CHAR(1)类型的列，而且我们规定了c1列为主键， 这个表使用 <strong>Compact</strong> 行格式来实际存储记录的。这里我们简化了index_demo表的行格式示意图<br><img src="https://img-blog.csdnimg.cn/img_convert/88ac52a0d9db228f61df24cf374042eb.png" alt="image-20220616152453203.png"><br>随着数据量的增大(一页一般是16K)，存放数据远远大于一页，这就需要**给所有的页建立一个目录项，**每个页对应一个目录项，每个目录项包括下边两个部分：页的用户记录中最小的主键值，我们用 <strong>key</strong> 来表示；页号，我们用 <strong>page_on</strong> 表示。至此，针对数据页做的简易目录就搞定了。这个目录有一个别名，称为 <strong>索引</strong><br><img src="https://img-blog.csdnimg.cn/img_convert/fe3f61d4bbe0100c1a598302cce2f8bb.png" alt="image-20220616160857381.png"><br>InnoDB怎么区分一条记录是普通的 <strong>用户记录</strong> 还是 <strong>目录项记录</strong> 呢？使用记录头信息里的 <strong>record_type</strong> 属性，它的各自取值代表的意思如下：0：普通的用户记录；1：目录项记录；2：最小记录；3：最大记录<br><img src="https://img-blog.csdnimg.cn/img_convert/59ecf8ab87b6b25941152c25302d9cd2.png" alt="image-20220616162944404.png"><br>从图中可以看出来，我们新分配了一个编号为30的页来专门存储目录项记录。这里再次强调 <strong>目录项记录</strong> 和普通的 <strong>用户记录</strong> 的不同点：</p><ul><li><strong>目录项记录</strong> 的 record_type 值是1，而 <strong>普通用户记录</strong> 的 record_type 值是0。</li><li>目录项记录只有 <strong>主键值和页的编号</strong> 两个列，而普通的用户记录的列是用户自己定义的，可能包含 <strong>很多列</strong> ，另外还有InnoDB自己添加的隐藏列。</li><li>了解：记录头信息里还有一个叫 <strong>min_rec_mask</strong> 的属性，只有在存储 <strong>目录项记录</strong> 的页中的主键值最小的 <strong>目录项记录</strong> 的 <strong>min_rec_mask</strong> 值为 <strong>1</strong> ，其他别的记录的 <strong>min_rec_mask</strong> 值都是 <strong>0</strong> 。</li></ul><p><strong>相同点</strong>：两者用的是一样的数据页，都会为主键值生成 <strong>Page Directory （页目录）</strong>，从而在按照主键值进行查找时可以使用 <strong>二分法</strong> 来加快查询速度。现在以查找主键为 20 的记录为例，根据某个主键值去查找记录的步骤就可以大致拆分成下边两步：</p><ul><li>先到存储 目录项记录 的页，也就是页30中通过 二分法 快速定位到对应目录项，因为 12 &lt; 20 &lt; 209 ，所以定位到对应的记录所在的页就是页9。</li><li>再到存储用户记录的页9中根据 二分法 快速定位到主键值为 20 的用户记录</li></ul><p><strong>随着数据量增大</strong>，如果我们表中的数据非常多则会产生很多存储目录项记录的页，那我们怎么根据主键值快速定位一个存储目录项记录的页呢？那就为这些存储目录项记录的页再生成一个更高级的目录，就像是一个多级目录一样，大目录里嵌套小目录，小目录里才是实际的数据，所以现在各个页的示意图就是这样子；这个数据结构，它的名称是 B+树<br><img src="https://img-blog.csdnimg.cn/img_convert/a5f55d0bf4350f1668bdfdedabba4c77.png" alt="image-20220616173512780.png"><br>对于**B+Tree，**一个B+树的节点其实可以分成好多层，规定最下边的那层，也就是存放我们用户记录的那层为第 0 层， 之后依次往上加。之前我们做了一个非常极端的假设：存放用户记录的页 最多存放3条记录 ，存放目录项 记录的页 最多存放4条记录 。其实真实环境中一个页存放的记录数量是非常大的，假设所有存放用户记录 的叶子节点代表的数据页可以存放 100条用户记录 ，所有存放目录项记录的内节点代表的数据页可以存 放 1000条目录项记录 ，那么：</p><ul><li>如果B+树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放 100 条记录</li><li>如果B+树有2层，最多能存放 1000×100=10,0000 条记录</li><li>如果B+树有3层，最多能存放 1000×1000×100=1,0000,0000 条记录</li><li>如果B+树有4层，最多能存放 1000×1000×1000×100=1000,0000,0000 条记录。相当多的记录</li></ul><p>你的表里能存放 <strong>100000000000</strong> 条记录吗？所以一般情况下，我们用到的 <strong>B+树都不会超过4层</strong> ，那我们通过主键值去查找某条记录最多只需要做4个页面内的查找（查找3个目录项页和一个用户记录页），又因为在每个页面内有所谓的 <strong>Page Directory</strong> （页目录），所以在页面内也可以通过 <strong>二分法</strong> 实现快速 定位记录。</p><h3 id="2-3-常见索引概念">2.3 常见索引概念</h3><blockquote><p>索引按照物理实现方式，索引可以分为 2 种：聚簇（聚集）和非聚簇（非聚集）索引。我们也把非聚集 索引称为二级索引或者辅助索引。</p></blockquote><h4 id="聚簇索引">聚簇索引</h4><p>聚簇索引并不是一种单独的索引类型，而是<strong>一种数据存储方式</strong>（所有的用户记录都存储在了叶子结点），也就是所谓的 索引即数据，数据即索引。<strong>术语&quot;聚簇&quot;表示当前数据行和相邻的键值聚簇的存储在一起</strong><br><strong>特点：</strong></p><ul><li>使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：<ul><li><code>页内</code> 的记录是按照主键的大小顺序排成一个 <code>单向链表</code></li><li>各个存放 <code>用户记录的页</code> 也是根据页中用户记录的主键大小顺序排成一个 <code>双向链表</code></li><li>存放 <code>目录项记录的页</code> 分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个 <code>双向链表</code></li></ul></li><li>B+树的 叶子节点 存储的是完整的用户记录。所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。</li></ul><p>我们把具有这两种特性的<strong>B+树称为聚簇索引</strong>，所有完整的用户记录都存放在这个<code>聚簇索引</code>的叶子节点处。这种聚簇索引并不需要我们在MySQL语句中显式的使用INDEX 语句去创建， <code>InnDB</code> 存储引擎会 <code>自动</code> 的为我们创建聚簇索引。<br><strong>优点：</strong></p><ul><li><code>数据访问更快</code> ，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快</li><li>聚簇索引对于主键的 <code>排序查找</code> 和 <code>范围查找</code> 速度非常快</li><li>按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多 个数据块中提取数据，所以 <code>节省了大量的io操作</code></li></ul><p><strong>缺点：</strong></p><ul><li><code>插入速度严重依赖于插入顺序</code> ，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个<code>自增的ID列为主键</code></li><li><code>更新主键的代价很高</code> ，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义<strong>主键为不可更新</strong></li><li><code>二级索引访问需要两次索引查找</code> ，第一次找到主键值，第二次根据主键值找到行数据</li></ul><h4 id="二级索引（辅助索引、非聚簇索引）">二级索引（辅助索引、非聚簇索引）</h4><p>如果我们想以别的列作为搜索条件，我们可以多建几颗B+树，不同的B+树中的数据采用不同的排列规则。比方说我们用c2列的大小作为数据页、页中记录的排序规则，再建一课B+树，<br><img src="https://img-blog.csdnimg.cn/img_convert/1afa2706ff0897563b7617e3ff86ecc6.png" alt="image-20220616203852043.png"><br>这个B+树与上边介绍的聚簇索引有几处不同<br><img src="https://img-blog.csdnimg.cn/img_convert/4c1d681944659e95fb254000c08352e5.png" alt="image-20220616210404733.png"><br>**概念：回表 **<br>我们根据这个以c2列大小排序的B+树只能确定我们要查找记录的主键值，所以如果我们想根 据c2列的值查找到完整的用户记录的话，仍然需要到 聚簇索引 中再查一遍，这个过程称为 回表 。也就 是根据c2列的值查询一条完整的用户记录需要使用到 2 棵B+树<br><strong>小结</strong></p><ul><li>聚簇索引的<code>叶子节点</code>存储的就是我们的<code>数据记录</code>, 非聚簇索引的叶子节点存储的是<code>数据位置</code>。非聚簇索引不会影响数据表的物理存储顺序。</li><li>一个表<code>只能有一个聚簇索引</code>，因为只能有一种排序存储的方式，但可以有<code>多个非聚簇索引</code>，也就是多个索引目录提供数据检索。</li><li>使用聚簇索引的时候，数据的<code>查询效率高</code>，但如果对数据进行插入，删除，更新等操作，效率会比非聚簇索引低。</li></ul><h4 id="联合索引">联合索引</h4><p>我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让B+树按 照 c2和c3列 的大小进行排序，这个包含两层含义：</p><ul><li>先把各个记录和页按照c2列进行排序。</li><li>在记录的c2列相同的情况下，采用c3列进行排序</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/742263d1c6f72af1718a45b4f8949dc7.png" alt="image-20220616215251172.png"><br>如图所示，我们需要注意以下几点：</p><ul><li>每条目录项都有c2、c3、页号这三个部分组成，各条记录先按照c2列的值进行排序，如果记录的c2列相同，则按照c3列的值进行排序</li><li>B+树叶子节点处的用户记录由c2、c3和主键c1列组成</li></ul><p>注意一点，以c2和c3列的大小为排序规则建立的B+树称为 联合索引 ，本质上也是一个二级索引。它的意 思与分别为c2和c3列分别建立索引的表述是不同的，不同点如下：</p><ul><li>建立 联合索引 只会建立如上图一样的1棵B+树。</li><li>为c2和c3列分别建立索引会分别以c2和c3列的大小为排序规则建立2棵B+树。</li></ul><h3 id="2-4-InnoDB的B-树索引的注意事项">2.4 InnoDB的B+树索引的注意事项</h3><p>实际上B+树的形成过程是这样的：</p><ul><li>每当为某个表创建一个B+树索引（聚簇索引不是人为创建的，默认就有）的时候，都会为这个索引创建一个 <code>根结点</code> 页面。最开始表中没有数据的时候，每个B+树索引对应的 <code>根结点</code> 中即没有用户记录，也没有目录项记录。</li><li>随后向表中插入用户记录时，先把用户记录存储到这个<code>根节点</code> 中。</li><li>当根节点中的可用 <code>空间用完时</code> 继续插入记录，此时会将根节点中的所有记录复制到一个新分配的页，比如 <code>页a</code> 中，然后对这个新页进行 <code>页分裂</code> 的操作，得到另一个新页，比如<code>页b</code> 。这时新插入的记录根据键值（也就是聚簇索引中的主键值，二级索引中对应的索引列的值）的大小就会被分配到 <code>页a</code> 或者 <code>页b</code> 中，而 <code>根节点</code> 便升级为存储目录项记录的页。</li></ul><p>这个过程特别注意的是：一个B+树索引的根节点自诞生之日起，便不会再移动。这样只要我们对某个表建议一个索引，那么它的根节点的页号便会被记录到某个地方。然后凡是 <code>InnoDB</code> 存储引擎需要用到这个索引的时候，都会从哪个固定的地方取出根节点的页号，从而来访问这个索引<br>为了让新插入记录找到自己在那个页面，我们需要<strong>保证在B+树的同一层页节点的目录项记录除页号这个字段以外是唯一的</strong>。所以对于二级索引的内节点的目录项记录的内容实际上是由三个部分构成的：</p><ul><li>索引列的值</li><li>主键值</li><li>页号</li></ul><p>最后一个B+树只需要很少的层级就可以轻松存储数亿条记录，查询速度相当不错！这是因为B+树本质上就是一个大的多层级目录，每经过一个目录时都会过滤掉许多无效的子目录，直到最后访问到存储真实数据的目录。那如果一个大的目录中只存放一个子目录是个啥效果呢？那就是目录层级非常非常多，而且最后的那个存放真实数据的目录中只存放一条数据。所以 <strong>InnoDB 的一个数据页至少可以存放两条记录</strong>。</p><h2 id="3、MyISAM中的索引方案">3、MyISAM中的索引方案</h2><table><thead><tr><th>索引 / 存储引擎</th><th>MyISAM</th><th>InnoDB</th><th>Memory</th></tr></thead><tbody><tr><td>B-Tree索引</td><td>支持</td><td>支持</td><td>支持</td></tr></tbody></table><p>即使多个存储引擎支持同一种类型的索引，但是他们的实现原理也是不同的。Innodb和MyISAM默认的索 引是Btree索引；而Memory默认的索引是Hash索引。MyISAM引擎使用 B+Tree 作为索引结构，叶子节点的data域存放的是 数据记录的地址</p><h3 id="3-1-MyISAM索引与总结">3.1 MyISAM索引与总结</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/aadadddfcb75b729f680f4dfeb65e237.png" alt="image-20220617160325201.png"><br><img src="https://img-blog.csdnimg.cn/img_convert/be21867c46b1ada4f6072ab16ba357b9.png" alt="image-20220617160413479.png"></p><h3 id="3-2-MyISAM-与-InnoDB对比">3.2 MyISAM 与 InnoDB对比</h3><p><strong>MyISAM的索引方式都是“非聚簇”的，与InnoDB包含1个聚簇索引是不同的。</strong></p><ul><li>在InnoDB存储引擎中，我们只需要根据主键值对 聚簇索引 进行一次查找就能找到对应的记录，而在 MyISAM 中却需要进行一次 回表 操作，意味着MyISAM中建立的索引相当于全部都是 二级索引 。</li><li>InnoDB的数据文件本身就是索引文件，而MyISAM索引文件和数据文件是 分离的 ，索引文件仅保存数 据记录的地址。</li><li>InnoDB的非聚簇索引data域存储相应记录 主键的值 ，而MyISAM索引记录的是 地址 。换句话说， InnoDB的所有非聚簇索引都引用主键作为data域。</li><li>MyISAM的回表操作是十分 快速 的，因为是拿着地址偏移量直接到文件中取数据的，反观InnoDB是通 过获取主键之后再去聚簇索引里找记录，虽然说也不慢，但还是比不上直接用地址去访问。</li><li>InnoDB要求表 必须有主键 （ MyISAM可以没有 ）。如果没有显式指定，则MySQL系统会自动选择一个 可以非空且唯一标识数据记录的列作为主键。如果不存在这种列，则MySQL自动为InnoDB表生成一个隐 含字段作为主键，这个字段长度为6个字节，类型为长整型</li></ul><h3 id="3-3-索引的代价">3.3 索引的代价</h3><p>索引是个好东西，可不能乱建，它在空间和时间上都会有消耗：</p><ul><li><strong>空间上的代价</strong><br>每建立一个索引都要为它建立一棵B+树，每一棵B+树的每一个节点都是一个数据页，一个页默认会 占用 16KB 的存储空间，一棵很大的B+树由许多数据页组成，那就是很大的一片存储空间。</li><li><strong>时间上的代价</strong><br>每次对表中的数据进行 增、删、改 操作时，都需要去修改各个B+树索引。而且我们讲过，B+树每 层节点都是按照索引列的值 从小到大的顺序排序 而组成了 双向链表 。不论是叶子节点中的记录，还 是内节点中的记录（也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序 而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需 要额外的时间进行一些 记录移位 ， 页面分裂 、 页面回收 等操作来维护好节点和记录的排序。如果 我们建了许多索引，每个索引对应的B+树都要进行相关的维护操作，会给性能拖后腿。</li></ul><blockquote><p>一个表上索引建的越多，就会占用越多的存储空间，在增删改记录的时候性能就越差。为了能建立又好又少的索引，我们得学学这些索引在哪些条件下起作用的。</p></blockquote><p>另外，<strong>InnoDB本身不支持 Hash索引</strong>，但是提供自适应 Hash索引(Adaptive Hash Index)。什么情况下才会使用自适应Hash索引呢?如果某个数据经常被访问，当满足一定条件的时候，就会将这个数据页的地址存放到Hash表中。这样下次查询的时候，就可以直接找到这个页面的所在位置。这样让B+树也具备了Hash索引的优点。自适应 Hash 索引目的是方便根据 SQL 的查询条件加速定位到叶子节点，特别是当 B+ 树比较深的时候，通过自适应 Hash 索引可以明显提高数据的检索效率。我们可以通过 <code>innodb_adaptive_hash_index</code> 变量来查看是否开启了自适应 Hash，比如：<code>show variables like '%adaptive_hash_index';</code></p><h3 id="3-4-思考题">3.4 思考题</h3><p><strong>为了减少IO，索引树会一次性加载吗？</strong></p><ul><li>数据库索引是存储在磁盘上的，如果数据量很大，必然导致索引的大小也会很大，超过几个G。</li><li>当我们利用索引查询时候，是不可能将全部几个G的索引都加载进内存的，我们能做的只能是:逐一加载每一个磁盘页，因为磁盘页对应着索引树的节点。</li></ul><p><strong>B+树的存储能力如何？为何说一般查找行记录，最多只需1~3次磁盘IO</strong><br>InnoDB存储引擎中页的大小为16KB，一般表的主键类型为INT(占用4个字节)或BIGINT(占用8个字节)，指针类型也一般为4或8个字节，也就是说一个页(B+Tree中的一个节点)中大概存储16KB/(8B+8B)=1K个键值（因为是估值，为方便计算，这里的K取值为10<sup>3。也就是说一个深度为3的B+Tree索引可以维护10</sup>3*10<sup>3*10</sup>3=10亿条记录。(这里假定一个数据页也存储10^3条行记录数据了)实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree 的高度一般都在2~4层。MysQL的InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1-3次磁盘I/O操作。<br><strong>为什么说B+树比B-树更适合实际应用中操作系统的文件索引和数据库索引？</strong></p><ul><li>B+树的磁盘读写代价更低，B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说Io读写次数也就降低了。</li><li>B+树的查询效率更加稳定，由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</li></ul><p><strong>Hash 索引与 B+ 树索引的区别</strong></p><ul><li>Hash索引不能进行范围查询，而B+树可以。这是因为Hash索引指向的数据是无序的，而B+树的叶子节点是个有序的链表</li><li>Hash索引不支持联合索引的最左侧原则（即联合索引的部分索引无法使用)，而B+树可以。对于联合索引来说，Hash索引在计算Hash值的时候是将索引键合并后再一起计算Hash值，所以不会针对每个索引单独计算Hash值。因此如果用到联合索引的一个或者几个索引时，联合索引无法被利用</li><li>Hash索引不支持ORDER BY排序，因为Hash索引指向的数据是无序的，因此无法起到排序优化的作用，而主树索引数据是有序的，可以起到对该字段ORDER BY排序优化的作用。同理，我们也无法用Hash索引进行模糊查询，而B+树使用LIKE进行模糊查询的时候，LIKE后面后模糊查询（比如%结尾）的话就可以起到优化作用</li><li>InnoDB 不支持哈希索引</li></ul><p><strong>Hash 索引与 B+ 树索引是在建索引的时候手动指定的吗？</strong><br>针对InnoDB和MyISAM存储引擎，都会默认采用B+树索引，无法使用Hash 索引。InnoDB提供的自适应Hash是不需要手动指定的。如果是Memory/Heap和NDB存储引擎，是可以进行选择Hash索引的。<br><strong>R树概念</strong><br>R-Tree在MySQL很少使用，仅支持 geometry数据类型 ，支持该类型的存储引擎只有myisam、bdb、 innodb、ndb、archive几种</p><h2 id="4、InnoDB数据存储结构">4、InnoDB数据存储结构</h2><h3 id="4-1-数据库的存储结构：页">4.1 数据库的存储结构：页</h3><blockquote><p>lnnoDB将数据划分为若干个页，InnoDB中页的大小默认为16KB，以页作为磁盘和内存之间交互的基本单位，也就是一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中。也就是说，在数据库中，不论读一行，还是读多行，都是将这些行所在的页进行加载。也就是说，数据库管理存储空间的基本单位是页(Page)，数据库Ⅳ/O操作的最小单位是页。一个页中可以存储多个行记录。</p></blockquote><p>不同的数据库管理系统（简称DBMS）的页大小不同。比如在 MySQL 的 InnoDB 存储引擎中，默认页的大小是 16KB，我们可以通过下面的命令来进行查看：<code>show variables like '%innodb_page_size%'</code>；SQL Server 中页的大小为 8KB，而在 Oracle 中我们用术语 “块” （Block）来表示 “页”，Oracle 支持的快大小为2KB, 4KB, 8KB, 16KB, 32KB 和 64KB。<br>另外在数据库中，还存在着区（Extent）、段（Segment）和表空间（Tablespace）的概念。行、页、区、段、表空间的关系如下图所示<br><img src="https://img-blog.csdnimg.cn/img_convert/336654e539addd96c4ea7aa480bb0171.png" alt="image-20220617194256988.png"><br>区(Extent)是比页大一级的存储结构，在InnoDB存储引擎中，一个区会分配<strong>64个连续的页</strong>。因为InnoDB中的页大小默认是16KB，所以一个区的大小是<strong>64*16KB= 1MB</strong>。段(Segment)由一个或多个区组成，区在文件系统是一个连续分配的空间(在InnoDB中是连续的64个页)，不过在段中不要求区与区之间是相邻的。<strong>段是数据库中的分配单位，不同类型的数据库对象以不同的段形式存在</strong>。当我们创建数据表、索引的时候，就会相应创建对应的段，比如创建一张表时会创建一个表段，创建一个索引时会创建一个索引段。表空间(Tablespace)是一个逻辑容器，表空间存储的对象是段，在一个表空间中可以有一个或多个段，但是一个段只能属于一个表空间。数据库由一个或多个表空间组成，表空间从管理上可以划分为<strong>系统表空间、用户表空间、撤销表空间、临时表空间</strong>等。</p><h3 id="4-2-页的内部结构-重要">4.2 页的内部结构(重要)</h3><p>页如果按类型划分的话，常见的有<strong>数据页（保存B+树节点）、系统表、Undo 页 和 事物数据页</strong>等。数据页是我们最常使用的页。数据页的 <strong>16KB</strong> 大小的存储空间被划分为七个部分，分别是文件头（File Header）、页头（Page Header）、最大最小记录（Infimum + supremum）、用户记录（User Records）、空闲空间（Free Space）、页目录（Page Directory）和文件尾（File Tailer），页结构的示意图如下所示<br><img src="https://img-blog.csdnimg.cn/img_convert/be4e62c5c4c270d029433384e54c6bd0.png" alt="image-20220617195012446.png"><br>这7个部分如下所示<br><img src="https://img-blog.csdnimg.cn/img_convert/74fe1900a9b97051e027ce20046619b9.png" alt="image-20220617195148164.png"><br><strong>B+树是如何进行记录检索的？</strong><br>如果通过B+树的索引查询行记录，首先是从B+树的根开始，逐层检索，直到找到叶子节点，也就是找到对应的数据页为止，将数据页加载到内存中，页目录中的槽（slot)采用二分查找的方式先找到一个粗略的记录分组，然后再在分组中通过链表遍历的方式查找记录。<br><strong>普通索引和唯一索引在查询效率上有什么不同?</strong><br>唯一索引就是在普通索引上增加了约束性，也就是<strong>关键字唯一</strong>，找到了关键字就停止检索。而<strong>普通索引，可能会存在用户记录中的关键字相同的情况</strong>，根据页结构的原理，当我们读取一条记录的时候，不是单独将这条记录从磁盘中读出去，而是将这个记录所在的页加载到内存中进行读取。InnoDB存储引擎的页大小为16KB，在一个页中可能存储着上千个记录，因此在普通索引的字段上进行查找也就是在内存中多几次“判断下一条记录&quot;的操作，对于CPU来说，这些操作所消耗的时间是可以忽略不计的。所以对一个索引字段进行检索，采用普通索引还是唯一索引在检索效率上基本上没有差别。</p><h3 id="4-3-InnoDB行格式-或记录格式">4.3 InnoDB行格式 (或记录格式)</h3><p>见文件InnoDB数据库存储结构，可以二进制打开看看<br>mysql5.1，默认是COMPACT行格式<br><img src="https://img-blog.csdnimg.cn/img_convert/f6e06bc2a7135aa6670972de541b82c1.png" alt="image.png"><br>在MySQL 8.0中，<strong>默认行格式就是Dynamic</strong>，Dynamic、Compressed行格式和Compact行格式挺像，只不过在处理行溢出数据时有分歧:</p><ul><li>Compressed和Dynamic两种记录格式对于存放在BLOB中的数据采用了完全的行溢出的方式，实际的数据都存放在Off Page（溢出页）中</li><li>Compact和Redundant两种格式会在记录的真实数据处存储一部分数据（存放768个前缀字节）。</li></ul><h3 id="4-4-区、段与碎片区">4.4 区、段与碎片区</h3><h4 id="区的作用">区的作用</h4><p>B+树的每一层中的页都会形成一个双向链表，如果是<strong>以页为单位</strong>来分配存储空间的话，双向链表相邻的两个页之间的<strong>物理位置可能离得非常远</strong>。我们介绍B+树索引的适用场景的时候特别提到范围查询只需要定位到最左边的记录和最右边的记录，然后沿着双向链表一直扫描就可以了，而如果链表中相邻的两个页物理位置离得非常远，就是所谓的随机I/0。再一次强调，磁盘的速度和内存的速度差了好几个数量级，<strong>随机I/O是非常慢的</strong>，所以我们应该尽量让链表中相邻的页的物理位置也相邻，这样进行范围查询的时候才可以使用所谓的<strong>顺序I/O</strong>。<br>引入区的概念，一个区就是在物理位置上连续的<strong>64个页</strong>。因为InnoDB 中的页大小默认是16KB，所以一个区的大小是64*16KB= <strong>1MB</strong>。在表中<strong>数据量大</strong>的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照<strong>区为单位分配</strong>，甚至在表中的数据特别多的时候，可以一次性分配多个连续的区。虽然可能造成<strong>一点点空间的浪费</strong>（数据不足以填充满整个区)，但是从性能角度看，可以消除很多的随机I/o，功大于过!</p><h4 id="段的作用">段的作用</h4><p>对于范围查询，其实是对B+树叶子节点中的记录进行顺序扫描，而如果不区分叶子节点和非叶子节点，统统把节点代表的页面放到申请到的区中的话，进行范围扫描的效果就大打折扣了。所以InnoDB对B+树的<strong>叶子节点</strong>和<strong>非叶子节点</strong>进行了区别对待，也就是说叶子节点有自己独有的区，非叶子节点也有自己独有的区。存放叶子节点的区的集合就算是一个段( segment )，存放非叶子节点的区的集合也算是一个段。也就是说一个索引会生成2个段，一个叶子节点段，一个非叶子节点段。<br>除了索引的叶子节点段和非叶子节点段之外，InnoDB中还有为存储一些特殊的数据而定义的段，比如回滚段。所以，常见的段有<strong>数据段、索引段、回滚段</strong>。数据段即为B+树的叶子节点，索引段即为B+树的非叶子节点。在InnoDB存储引擎中，对段的管理都是由引擎自身所完成，DBA不能也没有必要对其进行控制。这从一定程度上简化了DBA对于段的管理。段其实不对应表空间中某一个连续的物理区域，而是一个逻辑上的概念，由若干个<strong>零散的页面</strong>以及一些完整的区组成。</p><h4 id="为什么要有碎片区">为什么要有碎片区</h4><p>默认情况下，一个使用InnoDB存储引擎的表只有一个聚簇索引，一个索引会生成2个段，而段是以区为单位申请存储空间的，<strong>一个区默认占用1M (64*16Kb=1024Kb）存储空间</strong>，所以<strong>默认情况下一个只存了几条记录的小表也需要2M的存储空间么?<strong>以后每次添加一个索引都要多申请2M的存储空间么?这对于存储记录比较少的表简直是天大的浪费。<br>为了考虑以完整的区为单位分配给某个段对于</strong>数据量较小</strong>的表太浪费存储空间的这种情况，InnoDB提出了一个<strong>碎片(fragment)区</strong>的概念。在一个碎片区中，并不是所有的页都是为了存储同一个段的数据而存在的，而是碎片区中的页可以用于不同的目的，比如有些页用于段A，有些页用于段B，有些页甚至哪个段都不属于。<strong>碎片区直属于表空间</strong>，并不属于任何一个段。<br>所以此后为某个段分配存储空间的策略是这样的:</p><ul><li>在刚开始向表中插入数据的时候，段是从某个碎片区以单个页面为单位来分配存储空间的</li><li>当某个段已经占用了<strong>32个碎片区</strong>页面之后，就会申请以完整的区为单位来分配存储空间</li></ul><p>所以现在段不能仅定义为是某些区的集合，更精确的应该是<strong>某些零散的页面</strong>以及<strong>一些完整的区</strong>的集合。</p><h4 id="区的分类">区的分类</h4><ul><li>空闲的区 (FREE) : 现在还没有用到这个区中的任何页面。</li><li>有剩余空间的碎片区 (FREE_FRAG)：表示碎片区中还有可用的页面。</li><li>没有剩余空间的碎片区 (FULL_FRAG)：表示碎片区中的所有页面都被使用，没有空闲页面。</li><li>附属于某个段的区 (FSEG)：每一个索引都可以分为叶子节点段和非叶子节点段。</li></ul><h3 id="4-5-表空间">4.5 表空间</h3><blockquote><p>表空间可以看做是InnoDB存储引擎逻辑结构的最高层，所有的数据都存放在表空间中。表空间是一个逻辑容器，表空间存储的对象是段，在一个表空间中可以有一个或多个段，但是一个段只能属于一个表空间。表空间数据库由一个或多个表空间组成，表空间从管理上可以划分为系统表空间(System tablespace)、独立表空间(File-per-table tablespace)、撤销表空间(Undo Tablespace)和临时表空间(Temporary Tablespace)等。</p></blockquote><h4 id="独立表空间">独立表空间</h4><p>独立表空间，即每张表有一个独立的表空间，也就是数据和索引信息都会保存在自己的表空间中。独立的表空间 (即：单表) 可以在不同的数据库之间进行 迁移。空间可以回收 (DROP TABLE 操作可自动回收表空间；其他情况，表空间不能自己回收) 。如果对于统计分析或是日志表，删除大量数据后可以通过：alter table TableName engine=innodb; 回收不用的空间。对于使用独立表空间的表，不管怎么删除，表空间的碎片不会太严重的影响性能，而且还有机会处理.<br><strong>独立表空间结构</strong>由段、区、页组成，我们到数据目录里看，会发现一个新建的表对应的 .ibd 文件只占用了 96K，才6个页面大小 (MySQL5.7中)，这是因为一开始表空间占用的空间很小，因为表里边都没有数据。不过别忘了这些 .ibd 文件是自扩展的，随着表中数据的增多，表空间对应的文件也逐渐增大，可以查看表空间类型：<code>show variables like 'innodb_file_per_table'</code>;能看到<code>innodb_file_per_table=ON</code>, 这就意味着每张表都会单词保存一个 .ibd 文件。</p><h4 id="系统表空间">系统表空间</h4><p>系统表空间的结构和独立表空间基本类似，只不过由于整个MySQL进程只有一个系统表空间，在系统表空间中会额外记录一些有关整个系统信息的页面，这部分是独立表空间中没有的。<br>在 information_scheme 数据库中的这些以 INNODB_SYS 开头的表并不是真正的内部系统表 (内部系统表就是我们上边以 SYS 开头的那些表)，而是在存储引擎启动时读取这些以 SYS 开头的系统表，然后填充到这些以 INNODB_SYS 开头的表中。以 INNODB_SYS 开头的表和以 SYS 开头的表中的字段并不完全一样</p><h2 id="5、索引的创建">5、索引的创建</h2><h3 id="5-1-索引的声明">5.1 索引的声明</h3><p>MySQL的索引包括<strong>普通索引、唯一性索引、全文索引、单列索引、多列索引和空间索引</strong>等。从 功能逻辑 上说，索引主要有 4 种，分别是普通索引、唯一索引、主键索引、全文索引。 按照 物理实现方式 ，索引可以分为 2 种：<strong>聚簇索引和非聚簇索引</strong>。 按照 作用字段个数 进行划分，分成<strong>单列索引和联合索引</strong></p><ul><li><strong>普通索引。<strong>在创建普通索引时，不附加任何限制条件，只是用于提高查询效率。这类索引可以创建</strong>在任何数据类型</strong>中，其值是否唯一和非空，要由字段本身的完整性约束条件决定。建立索引以后，可以通过索引进行查询例如，在表<strong>student</strong>的字段<strong>name</strong> 上建立一个普通索引，查询记录时就可以根据该索引进行查询。</li><li><strong>唯一性索引。<strong>使用UNIQUE参数可以设置索引为唯一性索引，在创建唯一性索引时，限制该索引的值必须是唯一的，但允许有空值。在一张数据表里</strong>可以有多个唯一索引</strong>。例如，在表student的字段email中创建唯一性索引，那么字段email的值就必须是唯一的。通过唯一性索引可以更快速地确定某条记录。</li><li>**主键索引。**主键索引就是一种特殊的唯一性索引，在唯一索引的基础上增加了不为空的约束，也就是NOTNULL+UNIQUE，一张表里最多只有一个主键索引。这是由主键索引的物理实现方式决定的，因为数据存储在文件中只能按照一种顺序进行存储。</li><li>**单列索引。**在表中的单个字段上创建索引。单列索引只根据该字段进行索引。单列索可以是普通索引，也可以是唯一性索引，还可以是全文索引。只要保证该索引只对应一个字段即可。一个表可以有多个单列索引。</li><li>**多列(联合)索引。**多列索引是在表的多个字段组合上创建一个索引。该索引指向创建时对应的多个字段，可以通过这几个字段进行查询，但是只有查询条件中使用了这些字段中的第一个字段时才会被使用。</li><li>**全文索引。**全文索引(也称全文检索）是目前搜索引擎使用的一种关键技术。它能够利用【分词技术】等多种算法智能分析出文本文字中关键词的频率和重要性，然后按照一定的算法规则智能地筛选出我们想要的搜索结果，全文索引非常适合大型数据集，对于小的数据集，它的用处比较小。现在基本被solr、elasticSearch代替</li><li>**空间索引。**使用参数SPATIAL可以设置索引为空间索引。空间索引只能建立在空间数据类型上，这样可以提高系统获取空间数据的效率。MySQL中的空间数据类型包括GEOMETRY、POINT、LINESTRING和POLYGON等。目前只有MyISAM存储引擎支持空间检索，而且索引的字段不能为空值。对于初学者来说，这类索引很少会用到。</li></ul><p><strong>小结：不同的存储引擎支持的索引类型也不一样</strong></p><ul><li>InnoDB ：支持 B-tree、Full-text 等索引，不支持 Hash 索引</li><li>MyISAM ： 支持 B-tree、Full-text 等索引，不支持 Hash 索引</li><li>Memory ：支持 B-tree、Hash 等 索引，不支持 Full-text 索引</li><li>NDB ：支持 Hash 索引，不支持 B-tree、Full-text 等索引</li><li>Archive ：不支 持 B-tree、Hash、Full-text 等索引</li></ul><h3 id="5-2索引的使用">5.2索引的使用</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用CREATE TABLE创建表时，除了可以定义列的数据类型外，还可以定义主键约束、外键约束或者唯一性约束，而不论创建哪种约束，在定义约束的同时相当于在指定列上创建了一个索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> dept(</span><br><span class="line">dept_id <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span> AUTO_INCREMENT,</span><br><span class="line">dept_name <span class="built_in">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp(</span><br><span class="line">emp_id <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span> AUTO_INCREMENT,</span><br><span class="line">emp_name <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">UNIQUE</span>,</span><br><span class="line">dept_id <span class="built_in">INT</span>,</span><br><span class="line"><span class="keyword">CONSTRAINT</span> emp_dept_id_fk <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span>(dept_id) <span class="keyword">REFERENCES</span> dept(dept_id)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 显式创建表时创建索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name [col_name data_type]</span><br><span class="line">[<span class="keyword">UNIQUE</span> | FULLTEXT | SPATIAL] [<span class="keyword">INDEX</span> | <span class="keyword">KEY</span>] [index_name] (col_name [<span class="keyword">length</span>]) [<span class="keyword">ASC</span> |</span><br><span class="line"><span class="keyword">DESC</span>]</span><br><span class="line"><span class="comment">-- UNIQUE 、 FULLTEXT 和 SPATIAL 为可选参数，分别表示唯一索引、全文索引和空间索引； </span></span><br><span class="line"><span class="comment">-- INDEX 与 KEY 为同义词，两者的作用相同，用来指定创建索引； </span></span><br><span class="line"><span class="comment">-- index_name 指定索引的名称，为可选参数，如果不指定，那么MySQL默认col_name为索引名； </span></span><br><span class="line"><span class="comment">-- col_name 为需要创建索引的字段列，该列必须从数据表中定义的多个列中选择； </span></span><br><span class="line"><span class="comment">-- length 为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度； </span></span><br><span class="line"><span class="comment">-- ASC 或 DESC 指定升序或者降序的索引值存储</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建普通索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> book(</span><br><span class="line">book_id <span class="built_in">INT</span> ,</span><br><span class="line">book_name <span class="built_in">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line"><span class="keyword">authors</span> <span class="built_in">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">info <span class="built_in">VARCHAR</span>(<span class="number">100</span>) ,</span><br><span class="line"><span class="keyword">comment</span> <span class="built_in">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">year_publication <span class="keyword">YEAR</span>,</span><br><span class="line"><span class="keyword">INDEX</span>(year_publication)</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 创建唯一索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test1(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="keyword">UNIQUE</span> <span class="keyword">INDEX</span> uk_idx_id(<span class="keyword">id</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">INDEX</span> <span class="keyword">FROM</span> test1 \G;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设定为主键后数据库会自动建立索引，innodb为聚簇索引</span></span><br><span class="line"><span class="comment">-- 随表一起建索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student (</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">INT</span>(<span class="number">10</span>) <span class="keyword">UNSIGNED</span> AUTO_INCREMENT ,</span><br><span class="line">student_no <span class="built_in">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">student_name <span class="built_in">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 删除主键索引</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student <span class="keyword">drop</span> PRIMARY <span class="keyword">KEY</span>;</span><br><span class="line"><span class="comment">-- 修改主键索引：必须先删除掉(drop)原索引，再新建(add)索引</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建组合索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test3(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="keyword">name</span> <span class="built_in">CHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">age <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">info <span class="built_in">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line"><span class="keyword">INDEX</span> multi_idx(<span class="keyword">id</span>,<span class="keyword">name</span>,age)</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 使用EXPLAIN语句查看索引的使用情况</span></span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> test3 <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">AND</span> <span class="keyword">name</span>=<span class="string">'songhongkang'</span> \G;</span><br><span class="line"></span><br><span class="line"><span class="comment">--  创建全文索引</span></span><br><span class="line"><span class="comment">-- FULLTEXT全文索引可以用于全文检索，并且只为 `CHAR` 、`VARCHAR` 和 `TEXT` 列创建索引。索引总是对整个列进行，不支持局部 (前缀) 索引</span></span><br><span class="line"><span class="comment">-- 在MySQL5.7及之后版本中可以不指定最后的ENGINE了，因为在此版本中InnoDB支持全文索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test4(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="keyword">name</span> <span class="built_in">CHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">age <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">info <span class="built_in">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">FULLTEXT <span class="keyword">INDEX</span> futxt_idx_info(info)</span><br><span class="line">) <span class="keyword">ENGINE</span>=MyISAM;</span><br><span class="line"><span class="comment">-- 全文索引用match+against方式查询。全文索引比 like + % 快 N 倍，但是可能存在精度问题</span></span><br><span class="line"><span class="comment">-- 如果需要全文索引的是大量数据，建议先添加数据，再创建索引</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> papers <span class="keyword">WHERE</span> <span class="keyword">MATCH</span>(title,<span class="keyword">content</span>) AGAINST (<span class="string">'查询字符串'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建空间索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test5(</span><br><span class="line">geo GEOMETRY <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">SPATIAL <span class="keyword">INDEX</span> spa_idx_geo(geo)</span><br><span class="line">) <span class="keyword">ENGINE</span>=MyISAM;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- ==========================已经存在的表上创建索引======================</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> [<span class="keyword">UNIQUE</span> | FULLTEXT | SPATIAL] [<span class="keyword">INDEX</span> | <span class="keyword">KEY</span>]</span><br><span class="line">[index_name] (col_name[<span class="keyword">length</span>],...) [<span class="keyword">ASC</span> | <span class="keyword">DESC</span>]</span><br><span class="line"><span class="comment">-- 第二种方式</span></span><br><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">UNIQUE</span> | FULLTEXT | SPATIAL] <span class="keyword">INDEX</span> index_name</span><br><span class="line"><span class="keyword">ON</span> table_name (col_name[<span class="keyword">length</span>],...) [<span class="keyword">ASC</span> | <span class="keyword">DESC</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ========================删除索引=====================================</span></span><br><span class="line"><span class="comment">--  删除表中的列时，如果要删除的列为索引的组成部分，则该列也会从索引中删除。如果组成索引的所有列都被删除，则整个索引将被删除。</span></span><br><span class="line"><span class="comment">-- AUTO_INCREMENT约束字段的唯一索引不能被删除</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">DROP</span> <span class="keyword">INDEX</span> index_name;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">INDEX</span> index_name <span class="keyword">ON</span> table_name;</span><br></pre></td></tr></table></figure><h3 id="5-3-MySQL8-0索引新特性">5.3 MySQL8.0索引新特性</h3><p><strong>第一支持降序索引，降序索引以降序存储键值</strong>。虽然在语法上，从MySQL 4版本开始就已经支持降序索引的语法了，但实际上DESC定义是被忽略的，直到MySQL 8.x版本才开始真正支持降序索引 (仅限于InnoDBc存储引擎)。MySQL在8.0版本之前创建的仍然是升序索引，使用时进行反向扫描，这大大降低了数据库的效率。在某些场景下，降序索引意义重大。例如，如果一个查询，需要对多个列进行排序，且顺序要求不一致，那么使用降序索引将会避免数据库使用额外的文件排序操作，从而提高性能。<br><strong>第二支持隐藏索引。<strong>在MySQL 5.7版本及之前，只能通过显式的方式删除索引。此时，如果删除索引后出现错误，又只能通过显式创建索引的方式将删除的索引创建回来。如果数据表中的数据量非常大，或者数据表本身比较 大，这种操作就会消耗系统过多的资源，操作成本非常高。从MySQL 8.x开始支持 <strong>隐藏索引（invisible indexes）</strong> ，只需要将待删除的索引设置为隐藏索引，使 查询优化器不再使用这个索引（即使使用force index（强制使用索引），优化器也不会使用该索引）， 确认将索引设置为隐藏索引后系统不受任何响应，就可以彻底删除索引。 这种通过先将索引设置为隐藏索引，再删除索引的方式就是</strong>软删除</strong>。同时，如果你想验证某个索引删除之后的 查询性能影响，就可以暂时先隐藏该索引</p><blockquote><p>主键不能被设置为隐藏索引。当表中没有显式主键时，表中第一个唯一非空索引会成为隐式主键，也不能设置为隐藏索引</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建表时直接创建</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tablename(</span><br><span class="line">propname1 type1[CONSTRAINT1],</span><br><span class="line">propname2 type2[CONSTRAINT2],</span><br><span class="line">propnamen typen,</span><br><span class="line"><span class="keyword">INDEX</span> [indexname](propname1 [(<span class="keyword">length</span>)]) <span class="keyword">INVISIBLE</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 在已经存在的表上创建</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> indexname</span><br><span class="line"><span class="keyword">ON</span> tablename(propname[(<span class="keyword">length</span>)]) <span class="keyword">INVISIBLE</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 通过ALTER TABLE语句创建</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tablename</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">INDEX</span> indexname (propname [(<span class="keyword">length</span>)]) <span class="keyword">INVISIBLE</span>;</span><br><span class="line"><span class="comment">-- 换索引可见状态</span></span><br><span class="line"><span class="comment">-- 如果将index_cname索引切换成可见状态，通过explain查看执行计划，发现优化器选择了index_cname索引</span></span><br><span class="line"><span class="comment">-- 当索引被隐藏时，它的内容仍然是和正常索引一样实时更新的。如果一个索引需要长期被隐藏，那么可以将其删除，因为索引的存在会影响插入、更新和删除的性能</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tablename <span class="keyword">ALTER</span> <span class="keyword">INDEX</span> index_name <span class="keyword">INVISIBLE</span>; <span class="comment">--切换成隐藏索引</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tablename <span class="keyword">ALTER</span> <span class="keyword">INDEX</span> index_name <span class="keyword">VISIBLE</span>; <span class="comment">--切换成非隐藏索引</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使隐藏索引对查询优化器可见</span></span><br><span class="line"><span class="comment">-- 如果use_invisible_indexes 设置为off (默认)，优化器会忽略隐藏索引。如果设置为on，即使隐藏索引不可见，优化器在生成执行计 划时仍会考虑使用隐藏索引</span></span><br><span class="line"> <span class="keyword">select</span> @@optimizer_switch \G</span><br><span class="line"><span class="comment">-- 在输出的结果信息中找到如下属性配置，use_invisible_indexes=off</span></span><br><span class="line"><span class="comment">-- 使隐藏索引对查询优化器可见</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">session</span> optimizer_switch=<span class="string">"use_invisible_indexes=on"</span>;</span><br><span class="line"><span class="comment">-- 如果需要使隐藏索引对查询优化器不可见</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">session</span> optimizer_switch=<span class="string">"use_invisible_indexes=off"</span>;</span><br></pre></td></tr></table></figure><h2 id="6、索引的设计原则">6、索引的设计原则</h2><h3 id="6-1-数据准备">6.1 数据准备</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 第1步创建数据库、创建表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> atguigudb1;</span><br><span class="line"><span class="keyword">USE</span> atguigudb1;</span><br><span class="line"><span class="comment">-- 1.创建学生表和课程表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`student_info`</span> (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line"><span class="string">`student_id`</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> ,</span><br><span class="line"><span class="string">`name`</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`course_id`</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> ,</span><br><span class="line"><span class="string">`class_id`</span> <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`create_time`</span> DATETIME <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">INNODB</span> AUTO_INCREMENT=<span class="number">1</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`course`</span> (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line"><span class="string">`course_id`</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> ,</span><br><span class="line"><span class="string">`course_name`</span> <span class="built_in">VARCHAR</span>(<span class="number">40</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">INNODB</span> AUTO_INCREMENT=<span class="number">1</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 第2步创建模拟数据必需的存储函数</span></span><br><span class="line"><span class="comment">#函数1：创建随机产生字符串函数</span></span><br><span class="line">DELIMITER //</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> rand_string(n <span class="built_in">INT</span>)</span><br><span class="line"><span class="keyword">RETURNS</span> <span class="built_in">VARCHAR</span>(<span class="number">255</span>) <span class="comment">#该函数会返回一个字符串</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> chars_str <span class="built_in">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span></span><br><span class="line"><span class="string">'abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ'</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> return_str <span class="built_in">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> i <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">    WHILE i &lt; n DO</span><br><span class="line">    <span class="keyword">SET</span> return_str =<span class="keyword">CONCAT</span>(return_str,<span class="keyword">SUBSTRING</span>(chars_str,<span class="keyword">FLOOR</span>(<span class="number">1</span>+<span class="keyword">RAND</span>()*<span class="number">52</span>),<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">SET</span> i = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">WHILE</span>;</span><br><span class="line">    RETURN return_str;</span><br><span class="line"><span class="keyword">END</span> //</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 函数2：创建随机数函数</span></span><br><span class="line">DELIMITER //</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> rand_num (from_num <span class="built_in">INT</span> ,to_num <span class="built_in">INT</span>) <span class="keyword">RETURNS</span> <span class="built_in">INT</span>(<span class="number">11</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">SET</span> i = <span class="keyword">FLOOR</span>(from_num +<span class="keyword">RAND</span>()*(to_num - from_num+<span class="number">1</span>)) ;</span><br><span class="line">RETURN i;</span><br><span class="line"><span class="keyword">END</span> //</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 如果报错This function has none of DETERMINISTIC......，由于开启过慢查询日志bin-log, 我们就必须为我们的function指定一个参数</span></span><br><span class="line"><span class="comment">-- 主从复制，主机会将写操作记录在bin-log日志中。从机读取bin-log日志，执行语句来同步数据</span></span><br><span class="line"><span class="comment">-- 如果使 用函数来操作数据，会导致从机和主键操作时间不一致。所以，默认情况下，mysql不开启创建函数设置</span></span><br><span class="line"><span class="comment">-- 查看mysql是否允许创建函数</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'log_bin_trust_function_creators'</span>;</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> log_bin_trust_function_creators=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 第3步创建插入模拟数据的存储过程</span></span><br><span class="line"><span class="comment">--  存储过程1：创建插入课程表存储过程</span></span><br><span class="line">DELIMITER //</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> insert_course( max_num <span class="built_in">INT</span> )</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">SET</span> autocommit = <span class="number">0</span>; <span class="comment">--设置手动提交事务</span></span><br><span class="line">REPEAT <span class="comment">--循环</span></span><br><span class="line"><span class="keyword">SET</span> i = i + <span class="number">1</span>; <span class="comment">--赋值</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> course (course_id, course_name ) <span class="keyword">VALUES</span></span><br><span class="line">(rand_num(<span class="number">10000</span>,<span class="number">10100</span>),rand_string(<span class="number">6</span>));</span><br><span class="line">UNTIL i = max_num</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">REPEAT</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>; <span class="comment">--提交事务</span></span><br><span class="line"><span class="keyword">END</span> //</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 存储过程2：创建插入学生信息表存储过程</span></span><br><span class="line">DELIMITER //</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> insert_stu( max_num <span class="built_in">INT</span> )</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">SET</span> autocommit = <span class="number">0</span>; <span class="comment">--设置手动提交事务</span></span><br><span class="line">REPEAT <span class="comment">--循环</span></span><br><span class="line"><span class="keyword">SET</span> i = i + <span class="number">1</span>; <span class="comment">--赋值</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student_info (course_id, class_id ,student_id ,<span class="keyword">NAME</span> ) <span class="keyword">VALUES</span></span><br><span class="line">(rand_num(<span class="number">10000</span>,<span class="number">10100</span>),rand_num(<span class="number">10000</span>,<span class="number">10200</span>),rand_num(<span class="number">1</span>,<span class="number">200000</span>),rand_string(<span class="number">6</span>));</span><br><span class="line">UNTIL i = max_num</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">REPEAT</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>; <span class="comment">--提交事务</span></span><br><span class="line"><span class="keyword">END</span> //</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 第4步：调用存储过程</span></span><br><span class="line"><span class="keyword">CALL</span> insert_course(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">CALL</span> insert_stu(<span class="number">1000000</span>);</span><br></pre></td></tr></table></figure><h3 id="6-2-适合索引的场景">6.2 适合索引的场景</h3><p><strong>1、字段的数值有唯一性的限制</strong><br>索引本身可以起到约束的作用，比如唯一索引、主键索引都是可以起到唯一性约束的，因此在我们的数据表中,如果某个字段是唯一性的，就可以直接创建唯一性索引，或者主键索引。这样可以更快速地通过该索引来确定某条记录。例如，学生表中学号是具有唯一性的字段，为该字段建立唯一性索引可以很快确定某个学生的信息，如果使用姓名的话，可能存在同名现象，从而降低查询速度。</p><blockquote><p>业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。（来源：Alibaba） 说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的。</p></blockquote><p><strong>2、频繁作为 WHERE 查询条件的字段</strong><br>某个字段在SELECT语句的 WHERE 条件中经常被使用到，那么就需要给这个字段创建索引了。尤其是在 数据量大的情况下，创建普通索引就可以大幅提升数据查询的效率。 比如student_info数据表（含100万条数据），假设我们想要查询 student_id=123110 的用户信息<br><strong>3、经常 GROUP BY 和 ORDER BY 的列</strong><br>索引就是让数据按照某种顺序进行存储或检索，因此当我们使用 GROUP BY 对数据进行分组查询，或者使用 ORDER BY 对数据进行排序的时候，就需要对分组或者排序的字段进行索引 。如果待排序的列有多个，那么可以在这些列上建立组合索引<br><strong>4、UPDATE、DELETE 的 WHERE 条件列</strong><br>对数据按照某个条件进行查询后再进行 UPDATE 或 DELETE 的操作，如果对 WHERE 字段创建了索引，就能大幅提升效率。原理是因为我们需要先根据 WHERE 条件列检索出来这条记录，然后再对它进行更新或删除。<strong>如果进行更新的时候，更新的字段是非索引字段，提升的效率会更明显，这是因为非索引字段更新不需要对索引进行维护</strong><br><strong>5、DISTINCT 字段需要创建索引</strong><br>有时候我们需要对某个字段进行去重，使用 DISTINCT，那么对这个字段创建索引，也会提升查询效率。<br><strong>6、多表 JOIN 连接操作时，创建索引注意事项</strong><br>首先， <code>连接表的数量尽量不要超过 3 张</code>，因为每增加一张表就相当于增加了一次嵌套的循环，数量级增 长会非常快，严重影响查询的效率。 其次， <code>对 WHERE 条件创建索引</code>，因为 WHERE 才是对数据条件的过滤。如果在数据量非常大的情况下， 没有 WHERE 条件过滤是非常可怕的。 最后， <code>对用于连接的字段创建索引</code>，并且该字段在多张表中的 类型必须一致 。比如 course_id 在 student_info 表和 course 表中都为 int(11) 类型，而不能一个为 int 另一个为 varchar 类型<br><strong>7、使用列的类型小的创建索引</strong><br>我们这里所说的类型大小指的就是该类型表示的数据范围的大小。我们在定义表结构的时候要显式的指定列的类型，以整数类型为例，有TINYINT、MEDIUNINT、INT、BIGINT等，它们占用的存储空间依次递增，能表示的整数范围当然也是依次递增</p><ul><li>数据类型越小，在查询时进行的比较操作越快</li><li>数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以放下更多的记录，从而减少磁盘I/0带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率</li></ul><p><strong>8、使用字符串前缀创建索引</strong><br>我们可以通过截取字段的前面一部分内容建立索引，这个就叫<code>前缀索引</code>。这样在查找记录时虽然不能精确的定位到记录的位置，但是能定位到相应前缀所在的位置，然后根据前缀相同的记录的主键值回表查询完整的字符串值。既<code>节约空间</code>，又<code>减少了字符串的比较时间</code>，还大体能解决排序的问题</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> shop(address <span class="built_in">varchar</span>(<span class="number">120</span>) <span class="keyword">not</span> <span class="literal">null</span>);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> shop <span class="keyword">add</span> <span class="keyword">index</span>(address(<span class="number">12</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 越接近于1越好，说明越有区分度</span></span><br><span class="line">count(distinct left(列名, 索引长度))/count(*)</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(address,<span class="number">10</span>)) / <span class="keyword">count</span>(*) <span class="keyword">as</span> sub10, <span class="comment">-- 截取前10个字符的选择度</span></span><br><span class="line"><span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(address,<span class="number">15</span>)) / <span class="keyword">count</span>(*) <span class="keyword">as</span> sub11, <span class="comment">-- 截取前15个字符的选择度</span></span><br><span class="line"><span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(address,<span class="number">20</span>)) / <span class="keyword">count</span>(*) <span class="keyword">as</span> sub12, <span class="comment">-- 截取前20个字符的选择度</span></span><br><span class="line"><span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(address,<span class="number">25</span>)) / <span class="keyword">count</span>(*) <span class="keyword">as</span> sub13 <span class="comment">-- 截取前25个字符的选择度</span></span><br><span class="line"><span class="keyword">from</span> shop;</span><br></pre></td></tr></table></figure><p><strong>9、区分度高(散列性高)的列适合作为索引</strong><br>列的基数 指的是某一列中不重复数据的个数，比方说某个列包含值 2, 5, 8, 2, 5, 8, 2, 5, 8，虽然有9条记录，但该列的基数却是3。也就是说**在记录行数一定的情况下，列的基数越大，该列中的值越分散；列的基数越小，该列中的值越集中。**这个列的基数指标非常重要，直接影响我们是否能有效的利用索引。最好为列的基数大的列简历索引，为基数太小的列的简历索引效果可能不好。可以使用公式select count(distinct a) / count(*) from t1 计算区分度，越接近1越好，一般超过33%就算比较高效的索引了。扩展：联合索引把区分度搞(散列性高)的列放在前面。<br><strong>10、使用最频繁的列放到联合索引的左侧</strong><br><strong>11、在多个字段都要创建索引的情况下，联合索引优于单值索引</strong></p><h3 id="6-3-限制索引的数目">6.3 限制索引的数目</h3><p>在实际工作中，我们也需要注意平衡，索引的数目不是越多越好。我们需要限制每张表上的索引数量，建议单张表索引数量<strong>不超过6个</strong>。原因:</p><ul><li>每个索引都需要占用磁盘空间，索引越多，需要的磁盘空间就越大。</li><li>索引会影响INSERT、DELETE、UPDATE等语句的性能，因为表中的数据更改的同时，索引也会进行调整和更新，会造成负担。</li><li>优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，会增加MySQL优化器生成执行计划时间，降低查询性能。</li></ul><h3 id="6-4-不适合创建索引场景">6.4 不适合创建索引场景</h3><p><strong>1、在where中使用不到的字段，不要设置索引</strong><br>WHERE条件 (包括 GROUP BY、ORDER BY) 里用不到的字段不需要创建索引，索引的价值是快速定位，如果起不到定位的字段通常是不需要创建索引的。<br><strong>2、 数据量小的表最好不要使用索引</strong><br>如果表记录太少，比如少于1000个，那么是不需要创建索引的。表记录太少，是否创建索引 对查询效率的影响并不大。甚至说，查询花费的时间可能比遍历索引的时间还要短，索引可能不会产生优化效果。<br><strong>3、有大量重复数据的列上不要建立索引</strong><br>在条件表达式中经常用到的不同值较多的列上建立索引，但字段中如果有大量重复数据，也不用创建索引。比如在学生表的&quot;性别&quot;字段上只有“男”与“女”两个不同值，因此无须建立索引。如果建立索引，不但不会提高查询效率，反而会严重降低数据更新速度。结论：当数据重复度大，比如 高于 10% 的时候，也不需要对这个字段使用索引<br><strong>4、避免对经常更新的表创建过多的索引</strong><br>第一层含义：频繁更新的字段不一定要创建索引。因为更新数据的时候，也需要更新索引，如果索引太多，在更新索引的时候也会造成负担，从而影响效率。<br>第二层含义：避免对经常更新的表创建过多的索引，并且索引中的列尽可能少。此时，虽然提高了查询速度，同时却降低更新表的速度。<br><strong>5、不建议用无序的值作为索引</strong><br>例如身份证、UUID(在索引比较时需要转为ASCII，并且插入时可能造成页分裂)、MD5、HASH、无序长字 符串等<br><strong>6、删除不再使用或者很少使用的索引</strong><br>表中的数据被大量更新，或者数据的使用方式被改变后，原有的一些索引可能不再需要。数据库管理员应当定期找出这些索引，将它们删除，从而减少索引对更新操作的影响<br><strong>7、不要定义夯余或重复的索引</strong></p><h1>五、性能分析工具与索引优化</h1><h2 id="1、查看系统性能参数">1、查看系统性能参数</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> [<span class="keyword">GLOBAL</span>|<span class="keyword">SESSION</span>] <span class="keyword">STATUS</span> <span class="keyword">LIKE</span> <span class="string">'参数'</span>;</span><br></pre></td></tr></table></figure><ul><li>Connections：连接MySQL服务器的次数。</li><li>Uptime：MySQL服务器的上线时间。</li><li>Slow_queries：慢查询的次数。</li><li>Innodb_rows_read：Select查询返回的行数</li><li>Innodb_rows_inserted：执行INSERT操作插入的行数</li><li>Innodb_rows_updated：执行UPDATE操作更新的 行数</li><li>Innodb_rows_deleted：执行DELETE操作删除的行数</li><li>Com_select：查询操作的次数。</li><li>Com_insert：插入操作的次数。对于批量插入的 INSERT 操作，只累加一次。</li><li>Com_update：更新操作 的次数。</li><li>Com_delete：删除操作的次数。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 若查询MySQL服务器的连接次数，则可以执行如下语句</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">STATUS</span> <span class="keyword">LIKE</span> <span class="string">'Connections'</span>;</span><br><span class="line"><span class="comment">-- 若查询服务器工作时间</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">STATUS</span> <span class="keyword">LIKE</span> <span class="string">'Uptime'</span>;</span><br><span class="line"><span class="comment">-- 若查询MySQL服务器的慢查询次数</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">STATUS</span> <span class="keyword">LIKE</span> <span class="string">'Slow_queries'</span>;</span><br><span class="line"><span class="comment">-- 慢查询次数参数可以结合慢查询日志找出慢查询语句，然后针对慢查询语句进行`表结构优化`或者`查询语句优化`。</span></span><br><span class="line"><span class="comment">-- 查看相关的指令情况</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">STATUS</span> <span class="keyword">LIKE</span> <span class="string">'Innodb_rows_%'</span>;</span><br></pre></td></tr></table></figure><h2 id="2、统计SQL的查询成本-last-query-cost">2、统计SQL的查询成本: last_query_cost</h2><p>一条SQL查询语句在执行前需要查询执行计划，如果存在多种执行计划的话，MySQL会计算每个执行计划所需要的成本，从中选择成本最小的一个作为最终执行的执行计划。<br>如果我们想要查看某条SQL语句的查询成本，可以在执行完这条SQL语句之后，通过查看当前会话中的last_query_cost变量值来得到当前查询的成本： <code>SHOW STATUS LIKE 'last_query_cost'</code>。它通常也是我们评价一个查询的执行效率的一个常用指标。这个查询成本对应的是SQL 语句所需要读取的读页的数量。<br>**使用场景：**它对于比较开销是非常有用的，特别是我们有好几种查询方式可选的时候</p><blockquote><p>SQL查询时一个动态的过程，从页加载的角度来看，我们可以得到以下两点结论：</p><ol><li><code>位置决定效率</code>。如果页就在数据库 <code>缓冲池</code> 中，那么效率是最高的，否则还需要从 <code>内存</code> 或者 <code>磁盘</code> 中进行读取，当然针对单个页的读取来说，如果页存在于内存中，会比在磁盘中读取效率高很多。</li><li><code>批量决定效率</code>。如果我们从磁盘中对单一页进行随机读，那么效率是很低的(差不多10ms)，而采用顺序读取的方式，批量对页进行读取，平均一页的读取效率就会提升很多，甚至要快于单个页面在内存中的随机读取。</li></ol><p>所以说，遇到I/O并不用担心，方法找对了，效率还是很高的。我们首先要考虑数据存放的位置，如果是进程使用的数据就要尽量放到<code>缓冲池</code>中，其次我们可以充分利用磁盘的吞吐能力，一次性批量读取数据，这样单个页的读取效率也就得到了提升。</p></blockquote><h2 id="3、-定位执行慢的-SQL：慢查询日志">3、 定位执行慢的 SQL：慢查询日志</h2><h3 id="3-1-慢查询概述">3.1 慢查询概述</h3><p>MySQL的慢查询日志，用来记录在MysQL中<strong>响应时间超过阀值</strong>的语句，具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。<strong>long_query_time的默认值为10，意思是运行10秒以上(不含10秒)的语句</strong>，认为是超出了我们的最大忍耐时间值。<br>它的主要作用是，帮助我们发现那些执行时间特别长的SQL查询，并且有针对性地进行优化，从而提高系统的整体效率。当我们的数据库服务器发生阻塞、运行变慢的时候，检查一下慢查询日志，找到那些慢查询，对解决问题很有帮助。比如一条sql执行超过5秒钟，我们就算慢sQL，希望能收集超过5秒的sql，结合explain进行全面分析。<br>默认情况下，<strong>MySQL数据库没有开启慢查询日志</strong>，需要我们手动来设置这个参数。<strong>如果不是调优需要的话，一般不建议启动该参数</strong>，因为开启慢查询日志会或多或少带来一定的性能影响。<br>慢查询日志支持将日志记录写入文件。</p><h3 id="3-2-慢查询日志参数开启与查看">3.2 慢查询日志参数开启与查看</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 开启 slow_query_log</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%slow_query_log'</span>;</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> slow_query_log=<span class="string">'ON'</span>;</span><br><span class="line"><span class="comment">-- 能看到这时慢查询分析已经开启，同时文件保存在 /var/lib/mysql/atguigu02-slow.log`文件 中</span></span><br><span class="line"><span class="comment">-- 修改 long_query_time 阈值</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%long_query_time%'</span>;</span><br><span class="line"><span class="comment">-- 设置为 1 秒</span></span><br><span class="line"><span class="comment">-- 测试发现：设置global的方式对当前session的long_query_time失效。对新连接的客户端有效。所以可以一并执行下述语句</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> long_query_time = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%long_query_time%'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> long_query_time=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%long_query_time%'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 补充：配置文件中一并设置参数</span></span><br><span class="line"><span class="comment">-- 修改 `my.cnf` 文件，[mysqld] 下增加或修改参数 `long_query_time、slow_query_log` 和 `slow_query_log_file` 后，然后重启 MySQL 服务器</span></span><br><span class="line">[mysqld]</span><br><span class="line">slow_query_log=ON  <span class="comment"># 开启慢查询日志开关</span></span><br><span class="line">slow_query_log_file=/var/lib/mysql/atguigu-low.log  <span class="comment"># 慢查询日志的目录和文件名信息</span></span><br><span class="line">long_query_time=3  <span class="comment"># 设置慢查询的阈值为3秒，超出此设定值的SQL即被记录到慢查询日志</span></span><br><span class="line">log_output=FILE</span><br><span class="line"><span class="comment">-- 如果不指定存储路径，慢查询日志默认存储到MySQL数据库的数据文件夹下。</span></span><br><span class="line"><span class="comment">-- 如果不指定文件名，默认文件名为hostname_slow.log</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询当前系统中有多少条慢查询记录</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> <span class="keyword">STATUS</span> <span class="keyword">LIKE</span> <span class="string">'%Slow_queries%'</span>;</span><br></pre></td></tr></table></figure><h3 id="3-3-案例演示">3.3 案例演示</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`student`</span> (</span><br><span class="line">    <span class="string">`id`</span> <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    <span class="string">`stuno`</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> ,</span><br><span class="line">    <span class="string">`name`</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`age`</span> <span class="built_in">INT</span>(<span class="number">3</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`classId`</span> <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">INNODB</span> AUTO_INCREMENT=<span class="number">1</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"><span class="comment">-- 如果创建函数出错，This function has none of DETERMINISTIC......</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> log_bin_trust_function_creators=<span class="number">1</span>; <span class="comment">-- 不加global只是当前窗口有效。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 步骤3：创建函数，随机产生字符串：</span></span><br><span class="line">DELIMITER //</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> rand_string(n <span class="built_in">INT</span>)</span><br><span class="line"><span class="keyword">RETURNS</span> <span class="built_in">VARCHAR</span>(<span class="number">255</span>) <span class="comment">#该函数会返回一个字符串</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> chars_str <span class="built_in">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span></span><br><span class="line"><span class="string">'abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ'</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> return_str <span class="built_in">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> i <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">    WHILE i &lt; n DO</span><br><span class="line">    <span class="keyword">SET</span> return_str =<span class="keyword">CONCAT</span>(return_str,<span class="keyword">SUBSTRING</span>(chars_str,<span class="keyword">FLOOR</span>(<span class="number">1</span>+<span class="keyword">RAND</span>()*<span class="number">52</span>),<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">SET</span> i = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">WHILE</span>;</span><br><span class="line">    RETURN return_str;</span><br><span class="line"><span class="keyword">END</span> //</span><br><span class="line">DELIMITER ;</span><br><span class="line"><span class="comment">-- 测试</span></span><br><span class="line"><span class="keyword">SELECT</span> rand_string(<span class="number">10</span>);</span><br><span class="line"><span class="comment">-- 产生随机数值</span></span><br><span class="line">DELIMITER //</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> rand_num (from_num <span class="built_in">INT</span> ,to_num <span class="built_in">INT</span>) <span class="keyword">RETURNS</span> <span class="built_in">INT</span>(<span class="number">11</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> i <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">SET</span> i = <span class="keyword">FLOOR</span>(from_num +<span class="keyword">RAND</span>()*(to_num - from_num+<span class="number">1</span>)) ;</span><br><span class="line">    RETURN i;</span><br><span class="line"><span class="keyword">END</span> //</span><br><span class="line">DELIMITER ;</span><br><span class="line"><span class="comment">-- 测试：</span></span><br><span class="line"><span class="keyword">SELECT</span> rand_num(<span class="number">10</span>,<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 步骤4：创建存储过程</span></span><br><span class="line">DELIMITER //</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> insert_stu1( <span class="keyword">START</span> <span class="built_in">INT</span> , max_num <span class="built_in">INT</span> )</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">SET</span> autocommit = <span class="number">0</span>;<span class="comment">--#设置手动提交事务</span></span><br><span class="line">    REPEAT <span class="comment">--循环</span></span><br><span class="line">    <span class="keyword">SET</span> i = i + <span class="number">1</span>; <span class="comment">--赋值</span></span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> student (stuno, <span class="keyword">NAME</span> ,age ,classId ) <span class="keyword">VALUES</span></span><br><span class="line">    ((<span class="keyword">START</span>+i),rand_string(<span class="number">6</span>),rand_num(<span class="number">10</span>,<span class="number">100</span>),rand_num(<span class="number">10</span>,<span class="number">1000</span>));</span><br><span class="line">    UNTIL i = max_num</span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">REPEAT</span>;</span><br><span class="line">    <span class="keyword">COMMIT</span>; <span class="comment">--提交事务</span></span><br><span class="line"><span class="keyword">END</span> //</span><br><span class="line">DELIMITER ;</span><br><span class="line"><span class="comment">-- 步骤5：调用存储过程</span></span><br><span class="line"><span class="comment">-- 调用刚刚写好的函数, 4000000条记录,从100001号开始</span></span><br><span class="line"><span class="keyword">CALL</span> insert_stu1(<span class="number">100001</span>,<span class="number">4000000</span>);</span><br></pre></td></tr></table></figure><h3 id="3-4-测试与分析">3.4 测试与分析</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> stuno = <span class="number">3455655</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'oQmLUr'</span>;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'slow_queries'</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/34679f6a0ee98bc7eb37629c49d64d6d.png" alt="image-20220628195650079.png"></p><h3 id="3-5-慢查询日志分析工具：mysqldumpslow">3.5 慢查询日志分析工具：mysqldumpslow</h3><p>在生产环境中，如果要手工分析日志，查找、分析SQL，显然是个体力活，MySQL提供了日志分析工具 mysqldumpslow 。<code>mysqldumpslow --help</code>，mysqldumpslow 命令的具体参数如下：</p><ul><li>-a: 不将数字抽象成N，字符串抽象成S</li><li>-s: 是表示按照何种方式排序：<ul><li>c: 访问次数</li><li>l: 锁定时间</li><li>r: 返回记录</li><li>t: 查询时间</li><li>al:平均锁定时间</li><li>ar:平均返回记录数</li><li>at:平均查询时间 （默认方式）</li><li>ac:平均查询次数</li></ul></li><li>-t: 即为返回前面多少条的数据；</li><li>-g: 后边搭配一个正则匹配模式，大小写不敏感的；</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 举例：我们想要按照查询时间排序，查看前五条 SQL 语句</span></span><br><span class="line">mysqldumpslow -s t -t 5 /var/lib/mysql/atguigu01-slow.log</span><br><span class="line"><span class="comment"># 工作常用参考</span></span><br><span class="line"><span class="comment">#得到返回记录集最多的10个SQL</span></span><br><span class="line">mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log</span><br><span class="line"><span class="comment">#得到访问次数最多的10个SQL</span></span><br><span class="line">mysqldumpslow -s c -t 10 /var/lib/mysql/atguigu-slow.log</span><br><span class="line"><span class="comment">#得到按照时间排序的前10条里面含有左连接的查询语句</span></span><br><span class="line">mysqldumpslow -s t -t 10 -g <span class="string">"left join"</span> /var/lib/mysql/atguigu-slow.log</span><br><span class="line"><span class="comment">#另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现爆屏情况</span></span><br><span class="line">mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log | more</span><br></pre></td></tr></table></figure><h3 id="3-6-关闭与删除慢查询日志">3.6 关闭与删除慢查询日志</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 永久性方式,或者，把slow_query_log一项注释掉 或 删除</span></span><br><span class="line">[mysqld]</span><br><span class="line">slow_query_log=OFF</span><br><span class="line"><span class="comment">-- 重启MySQL服务，执行如下语句查询慢日志功能</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">'%slow%'</span>; <span class="comment">--查询慢查询日志所在目录</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">'%long_query_time%'</span>; <span class="comment">--查询超时时长</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 临时性方式</span></span><br><span class="line"><span class="comment">-- 停止MySQL慢查询日志功能</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> slow_query_log=<span class="keyword">off</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除慢查询日志</span></span><br><span class="line"><span class="comment">-- 使用SHOW语句显示慢查询日志信息</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">`slow_query_log%`</span>;</span><br><span class="line"><span class="comment">-- 从执行结果可以看出，慢查询日志的目录默认为MySQL的数据目录，在该目录下 `手动删除慢查询日志文件` 即可。</span></span><br><span class="line"><span class="comment">-- 使用命令 `mysqladmin flush-logs` 来重新生成查询日志文件，具体命令如下，执行完毕会在数据目录下重新生成慢查询日志文件。</span></span><br><span class="line">mysqladmin -uroot -p <span class="keyword">flush</span>-<span class="keyword">logs</span> slow</span><br><span class="line"><span class="comment">-- 慢查询日志都是使用mysqladmin flush-logs命令来删除重建的。使用时一定要注意，一旦执行了这个命令，慢查询日志都只存在新的日志文件中，如果需要旧的查询日志，就必须事先备份</span></span><br></pre></td></tr></table></figure><h2 id="4、查看-SQL-执行成本：SHOW-PROFILE">4、查看 SQL 执行成本：SHOW PROFILE</h2><p>show profile 在《逻辑架构》章节中讲过，这里作为复习。show profile 是 MySQL 提供的可以用来分析当前会话中 SQL 都做了什么、执行的资源消耗工具的情况，可用于 sql 调优的测量。默认情况下处于关闭状态，并保存最近15次的运行结果。我们可以在会话级别开启这个功能。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'profiling'</span>;</span><br><span class="line"><span class="comment">-- 开启 show profile;</span></span><br><span class="line"><span class="keyword">set</span> profiling = <span class="string">'ON'</span>;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">profiles</span>;</span><br><span class="line"><span class="comment">-- 查看最近一次查询的开销</span></span><br><span class="line"><span class="keyword">show</span> profile;</span><br><span class="line"><span class="keyword">show</span> profile cpu,<span class="keyword">block</span> io <span class="keyword">for</span> <span class="keyword">query</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>**show profile的常用查询参数： **</p><ul><li>ALL：显示所有的开销信息。</li><li>BLOCK IO：显示块IO开销。</li><li>CONTEXT SWITCHES：上下文切换开销。</li><li>CPU：显示CPU开销信息。</li><li>IPC：显示发送和接收开销信息。</li><li>MEMORY：显示内存开销信 息。</li><li>PAGE FAULTS：显示页面错误开销信息。</li><li>SOURCE：显示和Source_function，Source_file， Source_line相关的开销信息。</li><li>SWAPS：显示交换次数开销信息。</li></ul><p><strong>日常开发需注意的结论：</strong></p><ul><li>converting HEAP to MyISAM: 查询结果太大，内存不够，数据往磁盘上搬了。</li><li>Creating tmp table：创建临时表。先拷贝数据到临时表，用完后再删除临时表。</li><li>Copying to tmp table on disk：把内存中临时表复制到磁盘上，警惕！</li><li>locked。</li></ul><p>如果在show profile诊断结果中出现了以上4条结果中的任何一条，则sql语句需要优化。<br><strong>注意：</strong><br>不过SHOW PROFILE命令将被启用，我们可以从 information_schema 中的 profiling 数据表进行查看</p><h2 id="5、分析查询语句：EXPLAIN-重要">5、分析查询语句：EXPLAIN(重要)</h2><h3 id="5-1-概述">5.1 概述</h3><blockquote><p>官网介绍：<br><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/explain-output.html</a><br><a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/8.0/en/explain-output.html</a></p></blockquote><p><strong>定位了查询慢的SQL之后，我们就可以使用EXPLAIN或DESCRIBE工具做针对性的分析查询语句</strong>。DESCRIBE语句的使用方法与EXPLAIN语句是一样的，并且分析结果也是一样的。<br>MysQL中有专门负责优化SELECT语句的优化器模块，主要功能:通过计算分析系统中收集到的统计信息，为客户端请求的Query提供它认为最优的<strong>执行计划</strong>（他认为最优的数据检索方式，但不见得是DBA认为是最优的，这部分最耗费时间)。这个执行计划展示了接下来具体执行查询的方式，比如多表连接的顺序是什么，对于每个表采用什么访问方法来具体执行查询等等。MySQL为我们提供了EXPLAIN语句来帮助我们查看某个查询语句的具体执行计划，大家看懂EXPLAIN语句的各个输出项，可以有针对性的提升我们查询语句的性能。</p><ul><li>MySQL 5.6.3以前只能 EXPLAIN SELECT ；MYSQL 5.6.3以后就可以 EXPLAIN SELECT，UPDATE， DELETE</li><li>在5.7以前的版本中，想要显示 partitions 需要使用 explain partitions 命令；想要显示 filtered 需要使用 explain extended 命令。在5.7版本后，默认explain直接显示partitions和 filtered中的信息。</li></ul><h3 id="5-2-基本语法">5.2 基本语法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> select_options</span><br><span class="line"><span class="comment">-- 或者</span></span><br><span class="line"><span class="keyword">DESCRIBE</span> <span class="keyword">SELECT</span> select_options</span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>EXPLAIN 语句输出的各个列的作用如下：</p><table><thead><tr><th><strong>列名</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>id</td><td>在一个大的查询语句中每个SELECT关键字都对应一个<code>唯一的id</code></td></tr><tr><td>select_type</td><td>SELECT关键字对应的那个查询的类型</td></tr><tr><td>table</td><td>表名</td></tr><tr><td>type</td><td>针对单表的访问方法⭐</td></tr><tr><td>possible_keys</td><td>可能用到的索引</td></tr><tr><td>key</td><td>实际用到的索引</td></tr><tr><td>key_len</td><td>实际用到的索引长度</td></tr><tr><td>ref</td><td>当使用索引列等值查询时，与索引列进行等值匹配的对象信息</td></tr><tr><td>rows</td><td>预估的需要读取的记录条数</td></tr><tr><td>filtered</td><td>某个表经过搜索条件过滤后剩余记录条数的百分比</td></tr><tr><td>Extra</td><td>一些额外的信息</td></tr></tbody></table><h3 id="5-3-EXPLAIN各列作用">5.3 EXPLAIN各列作用</h3><p><strong>1、table</strong><br>不论我们的查询语句有多复杂，里边儿 包含了多少个表 ，到最后也是需要对每个表进行 单表访问 的，所 以MySQL规定EXPLAIN语句输出的每条记录都对应着某个单表的访问方法，该条记录的table列代表着该 表的表名（有时不是真实的表名字，可能是简称）<br><strong>2、id</strong></p><ul><li>id如果相同，可以认为是一组，从上往下顺序执行</li><li>在所有组中，id值越大，优先级越高，越先执行</li><li>关注点：id号每个号码，表示一趟独立的查询, 一个sql的查询趟数越少越好</li></ul><p><strong>3、select_type</strong><br>一条大的查询语句里边可以包含若干个SELECT关键字，每个SELECT关键字代表着一个小的查询语句，而每个SELECT关键字的FROM子句中都可以包含若干张表(这些表用来做连接查询)，每一张表都对应着执行计划输出中的一条记录，对于在同一个SELECT关键字中的表来说，它们的id值是相同的。MySQL为每一个SELECT关键字代表的小查询都定义了一个称之为select_type的属性，意思是我们只要知道了某个小查询的select_type属性，就知道了这个小查询在整个大查询中扮演了一个什么角色</p><ul><li>SIMPLE，查询语句中不包含UNION或者子查询的查询都算作是SIMPLE类型，连接查询也算是 SIMPLE 类型</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2;</span><br></pre></td></tr></table></figure><ul><li>PRIMARY，对于包含UNION、UNION ALL或者子查询的大查询来说，它是由几个小查询组成的，其中最左边的那个查询的select_type的值就是PRIMARY</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> s1 <span class="keyword">UNION</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> s2;</span><br></pre></td></tr></table></figure><ul><li>UNION，对于包含UNION或者UNION ALL的大查询来说，它是由几个小查询组成的，其中除了最左边的那个小查询意外，其余的小查询的select_type值就是UNION</li><li>UNION RESULT，MySQL 选择使用临时表来完成UNION查询的去重工作，针对该临时表的查询的select_type就是UNION RESULT</li><li>SUBQUERY，如果包含子查询的查询语句不能够转为对应的semi-join的形式，并且该子查询是不相关子查询，并且查询优化器决定采用将该子查询物化的方案来执行该子查询时，该子查询的第一个SELECT关键字代表的那个查询的select_type就是SUBQUERY</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> key1 <span class="keyword">FROM</span> s2) <span class="keyword">OR</span> key3 = <span class="string">'a'</span>;</span><br></pre></td></tr></table></figure><ul><li>DEPENDENT SUBQUERY，相关查询的子查询</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> key1 <span class="keyword">FROM</span> s2 <span class="keyword">WHERE</span> s1.key2 = s2.key2) <span class="keyword">OR</span> key3 = <span class="string">'a'</span>;</span><br></pre></td></tr></table></figure><ul><li>DEPENDENT UNION</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2 WHERE key1 = 'a' UNION SELECT key1 FROM s1 WHERE key1 = 'b');</span><br></pre></td></tr></table></figure><ul><li>DERIVED，select_type是DERIVED, 说明该子查询是以物化的方式执行的</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> key1, <span class="keyword">count</span>(*) <span class="keyword">as</span> c <span class="keyword">FROM</span> s1 <span class="keyword">GROUP</span> <span class="keyword">BY</span> key1) <span class="keyword">AS</span> derived_s1 <span class="keyword">where</span> c &gt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure><ul><li>MATERIALIZED，当查询优化器在执行包含子查询的语句时，选择将子查询物化之后的外层查询进行连接查询时，该子查询对应的select_type属性就是DERIVED</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> key1 <span class="keyword">FROM</span> s2);</span><br></pre></td></tr></table></figure><ul><li>UNCACHEABLE SUBQUERY</li><li>UNCACHEABLE UNION</li></ul><p><strong>4、partitions (可略)</strong><br><strong>5、type ☆</strong></p><ul><li>system，当表中只有一条记录并且该表使用的存储引擎的统计数据是精确的</li><li>const，当我们根据主键或者唯一二级索引列与常数进行等值匹配时，对单表的访问方法就是const</li><li>eq_ref，在连接查询时，如果被驱动表是通过主键或者唯一二级索引列等值匹配的方式进行访问的（如果该主键或者唯一二级索引是联合索引的话，所有的索引列都必须进行等值比较）。则对该被驱动表的访问方法就是eq_ref</li><li>ref，当通过普通的二级索引列与常量进行等值匹配时来查询某个表，那么对该表的访问方法就可能是ref</li><li>fulltext，全文索引</li><li>ref_or_null，当对普通二级索引进行等值匹配查询，该索引列的值也可以是NULL值时，那么对该表的访问方法就可能是ref_or_null</li><li>index_merge，一般情况下对于某个表的查询只能使用到一个索引，但单表访问方法时在某些场景下可以使用Interseation、union、Sort-Union这三种索引合并的方式来执行查询</li><li>unique_subquery，类似于两表连接中被驱动表的eq_ref访问方法，unique_subquery是针对在一些包含IN子查询的查询语句中，如果查询优化器决定将IN子查询转换为EXISTS子查询，而且子查询可以使用到主键进行等值匹配的话，那么该子查询执行计划的type列的值就是unique_subquery</li><li>index_subquery，index_subquery 与 unique_subquery 类似，只不过访问子查询中的表时使用的是普通的索引</li><li>range，范围</li><li>index，当我们可以使用索引覆盖，但需要扫描全部的索引记录时，该表的访问方法就是index</li><li>ALL，最熟悉的全表扫描</li></ul><p><strong>结果值从最好到最坏依次是： system &gt; const &gt; eq_ref &gt; ref</strong> &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL 。<strong>SQL 性能优化的目标：至少要达到 range 级别，要求是 ref 级别，最好是 consts级别。（阿里巴巴 开发手册要求）</strong><br><strong>6、possible_keys和key</strong><br>在EXPLAIN语句输出的执行计划中，possible_keys列表示在某个查询语句中，对某个列执行单表查询时可能用到的索引有哪些。一般查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用。key列表示实际用到的索引有哪些，如果为NULL，则没有使用索引<br><strong>7、key_len ☆</strong><br>实际使用到的索引长度 (即：字节数)，帮你检查是否充分的利用了索引，值越大越好，主要针对于联合索引，有一定的参考意义。<br><strong>8、ref</strong><br>显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值。当使用索引列等值匹配的条件去执行查询时，也就是在访问方法是<code>const、eq_ref、ref、ref_or_null 、unique_subquery,、index_subquery</code>其中之一时，<code>ref</code>列展示的就是与索引列作等值匹配的结构是什么，比如只是一个常数或者是某个列。<br><strong>9、rows ☆</strong><br>预估的需要读取的记录条数，值越小越好。<br><strong>10、filtered</strong><br>某个表经过搜索条件过滤后剩余记录条数的百分比。如果使用的是索引执行的单表扫描，那么计算时需要估计出满足除使用到对应索引的搜索条件外的其他搜索条件的记录有多少条。对于单表查询来说，这个filtered的值没有什么意义，我们<strong>更关注在连接查询中驱动表对应的执行计划记录的filtered值</strong>，它决定了被驱动表要执行的次数 (即: rows * filtered)<br><strong>11、Extra ☆</strong><br>用来说明一些额外信息的，包含不适合在其他列中显示但十分重要的额外信息。我们可以通过这些额外信息来更准确的理解MySQL到底将如何执行给定的查询语句。</p><ul><li>No tables used，当查询语句没有FROM子句时将会提示该额外信息</li><li>Impossible WHERE，当查询语句的WHERE子句永远为FALSE时将会提示该额外信息</li><li>Using where，搜索没有索引覆盖的列</li><li>No matching min/max row，当查询列表处有MIN或者MAX聚合函数，但是并没有符合WHERE子句中的搜索条件的记录时</li><li>Using index，当我们的查询列表以及搜索条件中只包含属于某个索引的列，也就是在可以使用覆盖索引的情况下，在Extra列将会提示该额外信息。比方说下边这个查询中只需要用到idx_key1而不需要回表操</li><li>Using index condition，有些搜索条件中虽然出现了索引列，但却不能使用到索引，比如范围查询了</li><li>Using join buffer (Block Nested Loop)，在连接查询执行过程中，当被驱动表不能有效的利用索引加快访问速度，MySQL一般会为其分配一块名叫join buffer的内存块来加快查询速度，也就是我们所讲的基于块的嵌套循环算法</li><li>Not exists，当我们使用左(外)连接时，如果WHERE子句中包含要求被驱动表的某个列等于NULL值的搜索条件，而且那个列是不允许存储NULL值的，那么在该表的执行计划的Extra列就会提示这个信息</li><li>Using intersect(…) 、 Using union(…) 和 Using sort_union(…)，如果执行计划的Extra列出现了Using intersect(…)提示，说明准备使用Intersect索引合并的方式执行查询，括号中的…表示需要进行索引合并的索引名称；如果出现Using union(…)提示，说明准备使用Union索引合并的方式执行查询;如果出现Using sort_union(…)提示，说明准备使用Sort-Union索引合并的方式执行查询</li><li>Zero limit，当我们的LIMIT子句的参数为0时，表示压根儿不打算从表中读取任何记录，将会提示该额外信息</li><li>Using filesort，有一些情况下对结果集中的记录进行排序是可以使用到索引的，如果查询中需要使用filesort的方式进行排序的记录非常多，那么这个过程是很耗费性能的，我们最好想办法将使用文件排序的执行方式改为索引进行排序</li><li>Using temporary，在许多查询的执行过程中，MySQL可能会借助临时表来完成一些功能，比如去重、排序之类的，比如我们在执行许多包含DISTINCT、GROUP BY、UNION等子句的查询过程中，如果不能有效利用索引来完成查询，MysQL很有可能寻求通过建立内部的临时表来执行查询。如果查询中使用到了内部的临时表，在执行计划的Extra列将会显示Using temporary提示</li></ul><h2 id="6、EXPLAIN进阶">6、EXPLAIN进阶</h2><h3 id="6-1-EXPLAIN四种输出格式">6.1 EXPLAIN四种输出格式</h3><p>EXPLAIN可以输出四种格式： 传统格式 ，JSON格式 ， TREE格式 以及 可视化输出 。用户可以根据需要选择适用于自己的格式。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 传统格式简单明了，输出是一个表格形式，概要说明查询计划</span></span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> s1.key1, s2.key1 <span class="keyword">FROM</span> s1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.key1 = s2.key1 <span class="keyword">WHERE</span> s2.common_field <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">-- 第1种格式中介绍的`EXPLAIN`语句输出中缺少了一个衡量执行好坏的重要属性 —— `成本`。而JSON格式是四种格式里面输出`信息最详尽`的格式，里面包含了执行的成本信息</span></span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">FORMAT</span>=<span class="keyword">JSON</span> <span class="keyword">SELECT</span> ....</span><br><span class="line"><span class="comment">-- TREE格式是8.0.16版本之后引入的新格式，主要根据查询的 `各个部分之间的关系` 和 `各部分的执行顺序` 来描述如何查询</span></span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">FORMAT</span>=tree <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.key1 = s2.key2 <span class="keyword">WHERE</span> s1.common_field = <span class="string">'a'</span>\G</span><br><span class="line"><span class="comment">-- 可视化输出，可以通过MySQL Workbench可视化查看MySQL的执行计划。通过点击Workbench的放大镜图标，即可生成可视化的查询计划</span></span><br></pre></td></tr></table></figure><h3 id="6-2-SHOW-WARNINGS的使用">6.2 SHOW WARNINGS的使用</h3><p>在我们使用EXPLAIN语句查看了某个查询的执行计划后，紧接着还可以使用SHOW WARNINGS语句查看与这个查询的执行计划有关的一些扩展信息</p><h2 id="7、分析优化器执行计划：trace">7、分析优化器执行计划：trace</h2><p><code>OPTIMIZER_TRACE</code>是MySQL 5.6引入的一项跟踪功能，它可以跟踪优化器做出的各种决策〈比如访问表的方法、各种开销计算、各种转换等），并将跟踪结果记录到<code>INFORMATION_SCHEMA.OPTIMIZER_TRACE</code>表中。此功能默认关闭。开启trace，并设置格式为JSON，同时设置trace最大能够使用的内存大小，避免解析过程中因为默认内存过小而不能够完整展示。|</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> optimizer_trace=<span class="string">"enabled=on"</span>,end_markers_in_json=<span class="keyword">on</span>;</span><br><span class="line"><span class="keyword">set</span> optimizer_trace_max_mem_size=<span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 开启后进行测试</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">id</span> &lt; <span class="number">10</span>;</span><br><span class="line"><span class="comment">--  查询 information_schema.optimizer_trace 就可以知道MySQL是如何执行SQL的</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> information_schema.optimizer_trace\G</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ==================================================</span></span><br><span class="line"><span class="comment">-- 第1部分：查询语句</span></span><br><span class="line"><span class="comment">-- 第2部分：QUERY字段对应语句的跟踪信息</span></span><br><span class="line"><span class="comment">-- 第3部分：跟踪信息过长时，被截断的跟踪信息的字节数</span></span><br><span class="line"><span class="comment">-- 第4部分：执行跟踪语句的用户是否有查看对象的权限。当不具有权限时，该列信息为1且TRACE字段为空，一般在调用带有SQL SECURITY DEFINER的视图或者是存储过程的情况下，会出现此问题</span></span><br></pre></td></tr></table></figure><h2 id="8、MySQL监控分析视图-sys-schema">8、MySQL监控分析视图-sys schema</h2><blockquote><p>关于MysQL的性能监控和问题诊断，我们一般都从performance_schema中去获取想要的数据，在MySQL5.7.7版本中新增sys schema，它将performance_schema和information_schema中的数据以更容易理解的方式总结归纳为&quot;视图”，其目的就是为了降低查询performance_schema的复杂度，让DBA能够快速的定位问题。</p></blockquote><h3 id="8-1-Sys-schema视图摘要">8.1 Sys schema视图摘要</h3><ul><li><strong>主机相关</strong>：以host_summary开头，主要汇总了IO延迟的信息</li><li><strong>Innodb相关</strong>：以innodb开头，汇总了innodb buffer信息和事务等待innodb锁的信息</li><li><strong>I/o相关</strong>：以io开头，汇总了等待I/O、I/O使用量情况</li><li><strong>内存使用情况</strong>：以memory开头，从主机、线程、事件等角度展示内存的使用情况</li><li><strong>连接与会话信息</strong>：processlist和session相关视图，总结了会话相关信息</li><li><strong>表相关</strong>：以schema_table开头的视图，展示了表的统计信息</li><li><strong>索引信息</strong>：统计了索引的使用情况，包含冗余索引和未使用的索引情况</li><li><strong>语句相关</strong>：以statement开头，包含执行全表扫描、使用临时表、排序等的语句信息</li><li><strong>用户相关</strong>：以user开头的视图，统计了用户使用的文件I/O、执行语句统计信息</li><li><strong>等待事件相关信息</strong>：以wait开头，展示等待事件的延迟情况</li></ul><h3 id="8-2-Sys-schema视图使用场景">8.2 Sys schema视图使用场景</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- ============================索引情况</span></span><br><span class="line"><span class="comment">-- 1. 查询冗余索引</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> sys.schema_redundant_indexes;</span><br><span class="line"><span class="comment">-- 2. 查询未使用过的索引</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> sys.schema_unused_indexes;</span><br><span class="line"><span class="comment">-- 3. 查询索引的使用情况</span></span><br><span class="line"><span class="keyword">select</span> index_name,rows_selected,rows_inserted,rows_updated,rows_deleted <span class="keyword">from</span> sys.schema_index_statistics <span class="keyword">where</span> table_schema=<span class="string">'dbname'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ==============================表相关</span></span><br><span class="line"><span class="comment">-- 1. 查询表的访问量</span></span><br><span class="line"><span class="keyword">select</span> table_schema,table_name,<span class="keyword">sum</span>(io_read_requests+io_write_requests) <span class="keyword">as</span> io <span class="keyword">from</span></span><br><span class="line">sys.schema_table_statistics <span class="keyword">group</span> <span class="keyword">by</span> table_schema,table_name <span class="keyword">order</span> <span class="keyword">by</span> io <span class="keyword">desc</span>;</span><br><span class="line"><span class="comment">-- 2. 查询占用bufferpool较多的表</span></span><br><span class="line"><span class="keyword">select</span> object_schema,object_name,allocated,<span class="keyword">data</span></span><br><span class="line"><span class="keyword">from</span> sys.innodb_buffer_stats_by_table <span class="keyword">order</span> <span class="keyword">by</span> allocated <span class="keyword">limit</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment">-- 3. 查看表的全表扫描情况</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> sys.statements_with_full_table_scans <span class="keyword">where</span> db=<span class="string">'dbname'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ==============================语句相关</span></span><br><span class="line"><span class="comment">-- 1. 监控SQL执行的频率</span></span><br><span class="line"><span class="keyword">select</span> db,exec_count,<span class="keyword">query</span> <span class="keyword">from</span> sys.statement_analysis</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> exec_count <span class="keyword">desc</span>;</span><br><span class="line"><span class="comment">-- 2. 监控使用了排序的SQL</span></span><br><span class="line"><span class="keyword">select</span> db,exec_count,first_seen,last_seen,<span class="keyword">query</span></span><br><span class="line"><span class="keyword">from</span> sys.statements_with_sorting <span class="keyword">limit</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 3. 监控使用了临时表或者磁盘临时表的SQL</span></span><br><span class="line"><span class="keyword">select</span> db,exec_count,tmp_tables,tmp_disk_tables,<span class="keyword">query</span></span><br><span class="line"><span class="keyword">from</span> sys.statement_analysis <span class="keyword">where</span> tmp_tables&gt;<span class="number">0</span> <span class="keyword">or</span> tmp_disk_tables &gt;<span class="number">0</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> (tmp_tables+tmp_disk_tables) <span class="keyword">desc</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ==============================IO相关</span></span><br><span class="line"><span class="comment">-- 1. 查看消耗磁盘IO的文件</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">file</span>,avg_read,avg_write,avg_read+avg_write <span class="keyword">as</span> avg_io</span><br><span class="line"><span class="keyword">from</span> sys.io_global_by_file_by_bytes <span class="keyword">order</span> <span class="keyword">by</span> avg_read <span class="keyword">limit</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ===============================Innodb 相关</span></span><br><span class="line"><span class="comment">-- 1. 行锁阻塞情况</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> sys.innodb_lock_waits;</span><br></pre></td></tr></table></figure><blockquote><p>通过sys库去查询时，MySQL会消耗大量资源去收集相关信息，严重的可能会导致业务请求被阻塞，从而引起故障。建议生产上不要频繁的去查询sys或者performance_schema、information_schema来完成监控、巡检等工作。</p></blockquote><h2 id="9、查询优化">9、查询优化</h2><h3 id="9-1-索引生-失效场景">9.1 索引生/失效场景</h3><ul><li><strong>全值匹配</strong>，索引加快速度</li><li><strong>最佳左前缀法则</strong>，在检索数据时从联合索引的最左边开始匹配</li><li>主键插入顺序，自定义的主键列 id 拥有 AUTO_INCREMENT 属性，在插入记录时存储引擎会自动为我们填入自增的主键值。这样的主键占用空间小，顺序写入，减少页分裂</li><li><strong>计算、函数、类型转换(自动或手动)导致索引失效</strong></li><li><strong>类型转换导致索引失效</strong>，比如int和char的等值查找</li><li>**范围条件右边的列索引失效，**范围右边的列不能使用索引了，主要针对索引，sql的前后顺序无所谓</li><li><strong>不等于(!= 或者&lt;&gt;)索引失效</strong></li><li>**is null可以使用索引，is not null无法使用索引，**最好在设计数据库的时候就将字段设置为 NOT NULL 约束，比如你可以将 INT 类型的字段，默认值设置为0。将字符类型的默认值设置为空字符串(’’)</li><li>**like以通配符%开头索引失效，**如果匹配字符串的第一个字符为’%’，索引就不会起作用。只有’%'不在第一个位置，索引才会起作用</li><li><strong>OR 前后存在非索引的列，索引失效</strong></li></ul><p><strong>一般性建议</strong></p><ul><li>统一使用utf8mb4( 5.5.3版本以上支持)兼容性更好，统一字符集可以避免由于字符集转换产生的乱码。不 同的 字符集 进行比较前需要进行 转换 会造成索引失效。</li><li>对于单列索引，尽量选择针对当前query过滤性更好的索引</li><li>在选择组合索引的时候，当前query中过滤性最好的字段在索引字段顺序中，位置越靠前越好</li><li>在选择组合索引的时候，尽量选择能够当前query中where子句中更多的索引</li><li>在选择组合索引的时候，如果某个字段可能出现范围查询时，尽量把这个字段放在索引次序的最后面</li></ul><h3 id="9-2-关联查询优化">9.2 关联查询优化</h3><ul><li>保证被驱动表的JOIN字段已经创建了索引</li><li>需要JOIN 的字段，数据类型保持绝对一致。</li><li>LEFT JOIN 时，选择小表作为驱动表， 大表作为被驱动表 。减少外层循环的次数。</li><li>INNER JOIN 时，MySQL会自动将 小结果集的表选为驱动表 。选择相信MySQL优化策略。</li><li>能够直接多表关联的尽量直接关联，不用子查询。(减少查询的趟数)</li><li>不建议使用子查询(结果集不走索引)，建议将子查询SQL拆开结合程序多次查询，或使用 JOIN 来代替子查询。</li><li>衍生表建不了索引</li></ul><h3 id="9-3-子查询优化">9.3 子查询优化</h3><p>MySQL从4.1版本开始支持子查询，使用子查询可以进行SELECT语句的嵌套查询，即一个SELECT查询的结 果作为另一个SELECT语句的条件。 子查询可以一次性完成很多逻辑上需要多个步骤才能完成的SQL操作 。<br>**子查询是 MySQL 的一项重要的功能，可以帮助我们通过一个 SQL 语句实现比较复杂的查询。但是，子 查询的执行效率不高。**原因：</p><ul><li>执行子查询时，MySQL需要为内层查询语句的查询结果 <strong>建立一个临时表</strong> ，然后外层查询语句从临时表 中查询记录。查询完毕后，再 撤销这些临时表 。这样会消耗过多的CPU和IO资源，产生大量的慢查询。</li><li>子查询的结果集存储的临时表，不论是**内存临时表还是磁盘临时表都 不会存在索引 **，所以查询性能会 受到一定的影响。</li><li>对于返回结果集比较大的子查询，其对查询性能的影响也就越大。</li></ul><p>**在MySQL中，可以使用连接（JOIN）查询来替代子查询。**连接查询 不需要建立临时表 ，其 速度比子查询 要快 ，如果查询中使用索引的话，性能就会更好</p><h3 id="9-4-排序优化">9.4 排序优化</h3><p>在MySQL中，支持两种排序方式，分别是 <code>FileSort</code> 和 <code>Index</code> 排序。</p><ul><li>Index 排序中，索引可以保证数据的有序性，不需要再进行排序，<code>效率更高</code></li><li>FileSort 排序则一般在 <code>内存中</code> 进行排序，占用<code>CPU较多</code>。如果待排结果较大，会产生临时文件 I/O 到磁盘进行排序的情况，效率较低</li></ul><p><strong>优化建议：</strong></p><ul><li>SQL 中，可以在 WHERE 子句和 ORDER BY 子句中使用索引，目的是在 WHERE 子句中 <code>避免全表扫描</code> ，在 ORDER BY 子句 <code>避免使用 FileSort 排序</code> 。当然，某些情况下全表扫描，或者 FileSort 排序不一定比索引慢。但总的来说，我们还是要避免，以提高查询效率。</li><li>尽量使用 Index 完成 ORDER BY 排序。如果 WHERE 和 ORDER BY 后面是相同的列就使用单索引列； 如果不同就使用联合索引。</li><li>无法使用 Index 时，需要对 FileSort 方式进行调优</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">INDEX a_b_c(a,b,c)</span><br><span class="line"><span class="comment">-- order by 能使用索引最左前缀</span></span><br><span class="line">- ORDER BY a</span><br><span class="line">- ORDER BY a,b</span><br><span class="line">- ORDER BY a,b,c</span><br><span class="line">- ORDER BY a DESC,b DESC,c DESC</span><br><span class="line"><span class="comment">-- 如果WHERE使用索引的最左前缀定义为常量，则order by 能使用索引</span></span><br><span class="line">- WHERE a = const ORDER BY b,c</span><br><span class="line">- WHERE a = const AND b = const ORDER BY c</span><br><span class="line">- WHERE a = const ORDER BY b,c</span><br><span class="line">- WHERE a = const AND b &gt; const ORDER BY b,c</span><br><span class="line"><span class="comment">-- 不能使用索引进行排序</span></span><br><span class="line">- ORDER BY a ASC,b DESC,c DESC <span class="comment">/* 排序不一致 */</span></span><br><span class="line">- WHERE g = const ORDER BY b,c <span class="comment">/*丢失a索引*/</span></span><br><span class="line">- WHERE a = const ORDER BY c <span class="comment">/*丢失b索引*/</span></span><br><span class="line">- WHERE a = const ORDER BY a,d <span class="comment">/*d不是索引的一部分*/</span></span><br><span class="line">- WHERE a in (...) ORDER BY b,c <span class="comment">/*对于排序来说，多个相等条件也是范围查询*/</span></span><br></pre></td></tr></table></figure><p>ORDER BY子句，尽量使用Index方式排序，避免使用FileSort方式排序</p><ul><li>方案一: 为了去掉filesort我们可以把索引建成联合索引</li><li>方案二：尽量让where的过滤条件和排序使用上索引</li></ul><p>1.两个索引同时存在，mysql自动选择最优的方案。(对于这个例子，mysal选择idx_age _stuno_name)。但是，随着数据量的变化，选择的索引也会随之变化的。<br>2.当【范围条件】和【group by或者order by】的字段出现二选一时，优先观察条件字段的过滤数量，如果过滤的数据足够多，而需要排序的数据并不多时，优先把索引放在范围字段上。反之，亦然。<br><strong>filesort算法：双路排序和单路排序</strong></p><ul><li><strong>双路排序 （慢）</strong></li></ul><p>MySQL 4.1之前是使用双路排序 ，字面意思就是两次扫描磁盘，最终得到数据， 读取行指针和 order by列 ，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据输出；从磁盘取排序字段，在buffer进行排序，再从磁盘取其他字段 。</p><ul><li><strong>单路排序 （快，现在用）</strong></li></ul><p>从磁盘读取查询需要的 所有列 ，按照order by列在buffer对它们进行排序，然后扫描排序后的列表进行输出， 它的效率更快一些，避免了第二次读取数据。并且把随机IO变成了顺序IO，但是它会使用更多的空间， 因为它把每一行都保存在内存中了<br><strong>优化策略</strong></p><ul><li><strong>尝试提高 sort_buffer_size</strong>，InnoDB默认是1048576字节，1MB</li><li><strong>尝试提高 max_length_for_sort_data</strong></li><li><strong>Order by 时select * 是一个大忌。最好只Query需要的字段</strong></li></ul><h3 id="9-5-GROUP-BY优化">9.5 GROUP BY优化</h3><ul><li>group by 使用索引的原则几乎跟order by一致 ，group by 即使没有过滤条件用到索引，也可以直接使用索引。</li><li>group by 先排序再分组，遵照索引建的最佳左前缀法则</li><li>当无法使用索引列，增大 <code>max_length_for_sort_data</code> 和 <code>sort_buffer_size</code> 参数的设置</li><li>where效率高于having，能写在where限定的条件就不要写在having中了</li><li>减少使用order by，和业务沟通能不排序就不排序，或将排序放到程序端去做。Order by、group by、distinct这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的。</li><li>包含了order by、group by、distinct这些查询的语句，where条件过滤出来的结果集请保持在1000行 以内，否则SQL会很慢。</li></ul><h3 id="9-6-优化分页查询">9.6 优化分页查询</h3><p>一般分页查询时，通过创建覆盖索引能够比较好地提高性能。一个常见又非常头疼的问题就是limit 2000000,10，此时需要MysQL排序前20oo010记录，仅仅返回2o00000-2000010的记录，其他记录丢弃，查询排序的代价非常大。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 原句</span></span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">LIMIT</span> <span class="number">2000000</span>,<span class="number">10</span>;</span><br><span class="line"><span class="comment">-- 优化思路一</span></span><br><span class="line"><span class="comment">-- 在索引上完成排序分页操作，最后根据主键关联回原表查询所需要的其他列内容。</span></span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student t,(<span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">id</span> <span class="keyword">LIMIT</span> <span class="number">2000000</span>,<span class="number">10</span>) a <span class="keyword">WHERE</span> t.id = a.id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 优化思路二</span></span><br><span class="line"><span class="comment">-- 该方案适用于主键自增的表，可以把Limit 查询转换成某个位置的查询</span></span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> <span class="keyword">id</span> &gt; <span class="number">2000000</span> <span class="keyword">LIMIT</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure><h2 id="10、索引优化">10、索引优化</h2><h3 id="10-1-优先考虑覆盖索引">10.1 优先考虑覆盖索引</h3><blockquote><p>**一个索引包含了满足查询结果的数据就叫做覆盖索引，**简单说就是， 索引列+主键 包含 SELECT 到 FROM之间查询的列</p></blockquote><p><strong>好处</strong></p><ul><li>**避免Innodb表进行索引的二次查询(回表)，**Innodb是以聚集索引的顺序来存储的，对于Innodb来说，二级索引在叶子节点中所保存的是行的主键信息，如果是用二级索引查询数据，在查找到相应的键值后，还需通过主键进行二次查询才能获取我们真实所需要的数据。在覆盖索引中，二级索引的键值中可以获取所要的数据，避免了对主键的二次查询，减少了IO操作，提升了查询效率</li><li><strong>可以把随机lO变成顺序IO加快查询效率</strong>，由于覆盖索引是按键值的顺序存储的，对于I0密集型的范围查找来说，对比随机从磁盘读取每一行的数据IO要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的IO转变成索引查找的顺序IO</li></ul><p>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。<br><strong>弊端</strong><br>索引字段的维护总是有代价的。因此，在建立冗余索引来支持覆盖索引时就需要权衡考虑了。这是业务DBA，或者称为业务数据架构师的工作。</p><h3 id="10-2-如何给字符串添加索引">10.2 如何给字符串添加索引</h3><p>**使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本。**前面 已经讲过区分度，区分度越高越好。因为区分度越高，意味着重复的键值越少。</p><blockquote><p>结论： 使用前缀索引就用不上覆盖索引对查询性能的优化了，这也是你在选择是否使用前缀索引时需要考虑的一个因素</p></blockquote><h3 id="10-3-索引下推">10.3 索引下推</h3><blockquote><p>Index Condition Pushdown(ICP)是MySQL 5.6中新特性，是一种在存储引擎层使用索引过滤数据的一种优化方式</p></blockquote><ul><li>如果没有ICP，存储引擎会遍历索引以定位基表中的行，并将它们返回给MySQL服务器，由MySQL服务器评估<strong>WHERE</strong>后面的条件是否保留行</li><li>启用ICP后，如果部分<strong>WHERE</strong>条件可以仅使用索引中的列进行筛选，则MySQL服务器会把这部分WHERE条件放到存储引擎筛选。然后，存储引擎通过使用索引条目来筛选数据，并且只有在满足这一条件时才从表中读取行</li><li>好处:ICP可以减少存储引擎必须访问基表的次数和MySQL服务器必须访问存储引擎的次数。但是，ICP的<strong>加速效果</strong>取决于在存储引擎内通过<strong>ICP筛选</strong>掉的数据的比例</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 默认情况下启动索引条件下推。可以通过设置系统变量optimizer_switch控制：index_condition_pushdown</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 打开索引下推</span></span><br><span class="line"><span class="keyword">SET</span> optimizer_switch = <span class="string">'index_condition_pushdown=on'</span>;</span><br><span class="line"><span class="comment">-- 关闭索引下推</span></span><br><span class="line"><span class="keyword">SET</span> optimizer_switch = <span class="string">'index_condition_pushdown=off'</span>;</span><br><span class="line"><span class="comment">-- 当使用索引条件下推是，EXPLAIN语句输出结果中Extra列内容显示为Using index condition</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 例如有索引(zipcode,lastname,address),如果没有索引下推就会全表，因为失效了</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">FROM</span> people </span><br><span class="line"><span class="keyword">WHERE</span> zipcode= <span class="string">'88B801'</span> </span><br><span class="line"><span class="keyword">AND</span> lastname <span class="keyword">LIKE</span> <span class="string">'%张%'</span> </span><br><span class="line"><span class="keyword">AND</span> address <span class="keyword">LIKE</span> <span class="string">'%北京市%'</span>;</span><br></pre></td></tr></table></figure><p><strong>ICP的使用条件</strong></p><ul><li>如果表的访问类型为 range 、 ref 、 eq_ref 或者 ref_or_null 可以使用ICP</li><li>ICP可以使用<code>InnDB</code>和<code>MyISAM</code>表，包括分区表<code>InnoDB</code>和<code>MyISAM</code>表</li><li>对于<code>InnoDB</code>表，ICP仅用于<code>二级索引</code>。ICP的目标是减少全行读取次数，从而减少I/O操作</li><li>当SQL使用覆盖索引时，不支持ICP优化方法。因为这种情况下使用ICP不会减少I/O</li><li>相关子查询的条件不能使用ICP</li></ul><h3 id="10-4-普通索引-vs-唯一索引">10.4 普通索引 vs 唯一索引</h3><p>**对于查询过程，**假设，执行查询的语句是 select id from test where k=5</p><ul><li>对于普通索引来说，查找到满足条件的第一个记录(5,500)后，需要查找下一个记录，直到碰到第一个不满足k=5条件的记录。</li><li>对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检 索。</li></ul><p>那么，这个不同带来的性能差距会有多少呢？答案是， 微乎其微<br>为了说明普通索引和唯一索引对更新语句性能的影响这个问题，介绍一下change buffer。<br><strong>对于更新过程</strong>，当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话， 在不影响数据一致性的前提下， InooDB会将这些更新操作缓存在change buffer中 ，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行change buffer中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。<br>将change buffer中的操作应用到原数据页，得到最新结果的过程称为 merge 。除了 访问这个数据页 会触 发merge外，系统有 后台线程会定期 merge。在 数据库正常关闭（shutdown） 的过程中，也会执行merge 操作。如果能够将更新操作先记录在change buffer， 减少读磁盘 ，语句的执行速度会得到明显的提升。而且，数据读入内存是需要占用 buffer pool 的，所以这种方式还能够 避免占用内存，提高内存利用率。唯一索引的更新就不能使用change buffer ，实际上也只有普通索引可以使用。<br><strong>change buffer的使用场景</strong></p><ul><li>普通索引和唯一索引应该怎么选择？其实，这两类索引在查询能力上是没差别的，主要考虑的是 对 更新性能 的影响。所以，建议你 尽量选择普通索引</li><li>在实际使用中会发现， 普通索引 和 change buffer 的配合使用，对于 数据量大 的表的更新优化 还是很明显的</li><li>如果所有的更新后面，都马上伴随着对这个记录的查询 ，那么你应该关闭change buffer。而在 其他情况下，change buffer都能提升更新性能。</li><li>由于唯一索引用不上change buffer的优化机制，因此如果 业务可以接受 ，从性能角度出发建议优 先考虑非唯一索引。但是如果&quot;业务可能无法确保&quot;的情况下，怎么处理呢？<ul><li>首先， 业务正确性优先 。我们的前提是“业务代码已经保证不会写入重复数据”的情况下，讨论性能 问题。如果业务不能保证，或者业务就是要求数据库来做约束，那么没得选，必须创建唯一索引。 这种情况下，本节的意义在于，如果碰上了大量插入数据慢、内存命中率低的时候，给你多提供一 个排查思路。</li><li>然后，在一些“ 归档库 ”的场景，你是可以考虑使用唯一索引的。比如，线上数据只需要保留半年， 然后历史数据保存在归档库。这时候，归档数据已经是确保没有唯一键冲突了。要提高归档效率， 可以考虑把表里面的唯一索引改成普通索引。</li></ul></li></ul><h3 id="10-5-其它查询优化策略">10.5 其它查询优化策略</h3><p><strong>1、EXISTS 和 IN 的区分</strong><br>索引是个前提，其实选择与否还是要看表的大小。你可以将选择的标准理解为<strong>小表驱动大表</strong>。在这种方式下效率是最高的。哪个表小就用哪个表来驱动，A表小就用EXISTS，B表小就用IN。<br><strong>2、COUNT(*)与COUNT(具体字段)效率</strong></p><ul><li><code>COUNT(*)</code>和<code>COUNT(1)</code>都是对所有结果进行<code>COUNT</code>，<code>COUNT(*)</code>和<code>COUNT(1)</code>本质上并没有区别(二者执行时间可能略有差别，不过你还是可以把它俩的执行效率看成是相等的)。如果有WHERE子句，则是对所有符合筛选条件的数据行进行统计;如果没有WHERE子句，则是对数据表的数据行数进行统计。</li><li>如果是MylSAM存储引擎，统计数据表的行数只需要<code>O(1)</code>的复杂度，这是因为每张 MyISAM的数据表都有一个meta信息存储了<code>row_count</code>值，而一致性则由表级锁来保证；如果是InnoDB存储引擎，因为InnoDB支持事务，采用行级锁和MVCC机制，所以无法像MyISAM一样，维护一个row_count变量，因此需要采用<code>扫描全表</code>，是<code>O(n)</code>的复杂度，进行循环＋计数的方式来完成统计。</li><li>在InnoDB引擎中，如果采用<code>COUNT(具体字段)</code>来统计数据行数，要尽量采用二级索引。因为主键采用的索引是聚簇索引，聚簇索引包含的信息多，明显会大于二级索引(非聚簇索引)。对于<code>COUNT(*)</code>和<code>COUNT(1)</code>来说，它们不需要查找具体的行，只是统计行数，系统会自动采用占用空间更小的二级索引来进行统计。如果有多个二级索引，会使用key_len小的二级索引进行扫描。当没有二级索引的时候，才会采用主键索引来进行统计。</li></ul><p><strong>3、关于SELECT(*)</strong><br>在表查询中，建议明确字段，不要使用 * 作为查询的字段列表，推荐使用<code>SELECT &lt;字段列表&gt; 查询</code>。原因：</p><ul><li>MySQL 在解析的过程中，会通过查询数据字典 将&quot;*&quot;按序转换成所有列名，这会大大的耗费资源和时间。</li><li>无法使用 覆盖索引</li></ul><p><strong>4、LIMIT 1 对优化的影响</strong><br>针对的是会扫描全表的 SQL 语句，如果你可以确定结果集只有一条，那么加上 LIMIT 1 的时候，当找到一条结果的时候就不会继续扫描了，这样会加快查询速度；如果数据表已经对字段建立了唯一索引，那么可以通过索引进行查询，不会全表扫描的话，就不需要加上 LIMIT 1 了。<br><strong>5、多使用COMMIT</strong><br>只要有可能，在程序中尽量多使用 COMMIT，这样程序的性能得到提高，需求也会因为 COMMIT 所释放 的资源而减少。COMMIT 所释放的资源：</p><ul><li>回滚段上用于恢复数据的信息</li><li>被程序语句获得的锁</li><li>redo / undo log buffer 中的空间</li><li>管理上述 3 种资源中的内部花费</li></ul><h1>六、数据库其它调优策略</h1><h2 id="1、数据库调优的措施">1、数据库调优的措施</h2><h3 id="1-1-调优的目标">1.1 调优的目标</h3><ul><li>尽可能节省系统资源 ，以便系统可以提供更大负荷的服务。（吞吐量更大）</li><li>合理的结构设计和参数调整，以提高用户操作响应的速度 。（响应速度更快）</li><li>减少系统的瓶颈，提高MySQL数据库整体的性能。</li></ul><h3 id="1-2-如何定位调优问题">1.2 如何定位调优问题</h3><ul><li><strong>用户的反馈（主要)</strong></li></ul><p>用户是我们的服务对象，因此他们的反馈是最直接的。虽然他们不会直接提出技术建议，但是有些问题往往是用户第一时间发现的。我们要重视用户的反馈，找到和数据相关的问题。</p><ul><li><strong>日志分析（(主要)</strong></li></ul><p>我们可以通过查看数据库日志和操作系统日志等方式找出异常情况，通过它们来定位遇到的问题。</p><ul><li><strong>服务器资源使用监控</strong></li></ul><p>通过监控服务器的CPU、内存、I/o等使用情况，可以实时了解服务器的性能使用，与历史情况进行对比。</p><ul><li><strong>数据库内部状况监控</strong></li></ul><p>在数据库的监控中，活动会话（Active Session）监控是一个重要的指标。通过它，你可以清楚地了解数据库当前是否处于非常繁忙的状态，是否存在SQL堆积等。</p><ul><li><strong>其它</strong></li></ul><p>除了活动会话监控以外，我们也可以对事务、锁等待等进行监控，这些都可以帮助我们对数据库的运行状态有更全面的认识</p><h3 id="1-3-调优的维度和步骤">1.3 调优的维度和步骤</h3><p>1、选择适合的 DBMS<br>2、优化表设计<br>3、优化逻辑查询<br>4、优化物理查询<br>5、使用 Redis 或 Memcached 作为缓存<br>6、库级优化</p><h2 id="2、优化MySQL服务器">2、优化MySQL服务器</h2><h3 id="2-1-优化服务器硬件">2.1 优化服务器硬件</h3><ul><li>配置较大的内存 。足够大的显存是提高MySQL数据库性能的方法之一。内存的速度比磁盘I/O快得多，可以通过增加系统的缓冲区容量使数据在内存中停留的时间更长，以减少磁盘I/O。</li><li>配置高速磁盘系统，以减少读盘的等待时间，提高响应速度。磁盘的I/O能力，也就是它的寻道能力，目前的SCSI高速旋转的是7200转/分钟，这样的速度，一旦访问的用户量上去，磁盘的压力就会过大，如果是每天的网站pv (page view) 在150w，这样的一般的配置就无法满足这样的需求了。现在SSD盛行，在SSD上随机访问和顺序访问性能差不多，使用SSD可以减少随机IO带来的性能损耗。</li><li>合理分布磁盘I/O，把磁盘I/O分散在多个设备，以减少资源竞争，提高冰箱操作能力。</li><li>配置多处理器, MySQL是多线程的数据库，多处理器可同时执行多个线程</li></ul><h3 id="2-2-优化MySQL的参数">2.2 优化MySQL的参数</h3><ul><li><code> innodb_buffer_pool_size</code> ：这个参数是Mysql数据库最重要的参数之一，表示InnoDB类型的 表 和索引的最大缓存 。它不仅仅缓存 索引数据 ，还会缓存 表的数据 。这个值越大，查询的速度就会越 快。值太大会影响操作系统的性能。</li><li><code>key_buffer_size</code> ：表示 索引缓冲区的大小 。索引缓冲区是所有的 线程共享 。增加索引缓冲区可 以得到更好处理的索引（对所有读和多重写）。当然，这个值不是越大越好，它的大小取决于内存 的大小。如果这个值太大，就会导致操作系统频繁换页，也会降低系统性能。对于内存在 4GB 左右 的服务器该参数可设置为 256M 或 384M 。</li><li><code>table_cache</code> ：表示 同时打开的表的个数 。这个值越大，能够同时打开的表的个数越多。物理内 存越大，设置就越大。默认为2402，调到512-1024最佳。这个值不是越大越好，因为同时打开的表 太多会影响操作系统的性能。</li><li><code>query_cache_size</code> ：表示 查询缓冲区的大小 。可以通过在MySQL控制台观察，如果 Qcache_lowmem_prunes的值非常大，则表明经常出现缓冲不够的情况，就要增加Query_cache_size 的值；如果Qcache_hits的值非常大，则表明查询缓冲使用非常频繁，如果该值较小反而会影响效 率，那么可以考虑不用查询缓存；Qcache_free_blocks，如果该值非常大，则表明缓冲区中碎片很 多。MySQL8.0之后失效。该参数需要和query_cache_type配合使用。</li><li><code>query_cache_type</code> 的值是0时，所有的查询都不使用查询缓存区。但是query_cache_type=0并不 会导致MySQL释放query_cache_size所配置的缓存区内存。<ul><li>当<code>query_cache_type=1</code>时，所有的查询都将使用查询缓存区，除非在查询语句中指定 SQL_NO_CACHE ，如SELECT SQL_NO_CACHE * FROM tbl_name。</li><li>当<code>query_cache_type=2</code>时，只有在查询语句中使用 SQL_CACHE 关键字，查询才会使用查询缓 存区。使用查询缓存区可以提高查询的速度，这种方式只适用于修改操作少且经常执行相同的 查询操作的情况。</li></ul></li><li><code>sort_buffer_size</code> ：表示每个 需要进行排序的线程分配的缓冲区的大小 。增加这个参数的值可以 提高 ORDER BY 或 GROUP BY 操作的速度。默认数值是2 097 144字节（约2MB）。对于内存在4GB 左右的服务器推荐设置为6-8M，如果有100个连接，那么实际分配的总共排序缓冲区大小为100 × 6 ＝ 600MB。</li><li><code>join_buffer_size = 8M</code> ：表示 联合查询操作所能使用的缓冲区大小 ，和sort_buffer_size一样， 该参数对应的分配内存也是每个连接独享。</li><li><code>read_buffer_size</code> ：表示 每个线程连续扫描时为扫描的每个表分配的缓冲区的大小（字节） 。当线 程从表中连续读取记录时需要用到这个缓冲区。SET SESSION read_buffer_size=n可以临时设置该参 数的值。默认为64K，可以设置为4M。</li><li><code>innodb_flush_log_at_trx_commit</code> ：表示 何时将缓冲区的数据写入日志文件 ，并且将日志文件 写入磁盘中。该参数对于innoDB引擎非常重要。该参数有3个值，分别为0、1和2。该参数的默认值 为1。<ul><li>值为 0 时，表示 每秒1次 的频率将数据写入日志文件并将日志文件写入磁盘。每个事务的 commit并不会触发前面的任何操作。该模式速度最快，但不太安全，mysqld进程的崩溃会导 致上一秒钟所有事务数据的丢失。</li><li>值为 1 时，表示 每次提交事务时 将数据写入日志文件并将日志文件写入磁盘进行同步。该模 式是最安全的，但也是最慢的一种方式。因为每次事务提交或事务外的指令都需要把日志写入 （flush）硬盘。</li><li>值为 2 时，表示 每次提交事务时 将数据写入日志文件， 每隔1秒 将日志文件写入磁盘。该模 式速度较快，也比0安全，只有在操作系统崩溃或者系统断电的情况下，上一秒钟所有事务数 据才可能丢失。</li></ul></li><li><code>innodb_log_buffer_size</code> ：这是 InnoDB 存储引擎的 事务日志所使用的缓冲区 。为了提高性能， 也是先将信息写入 Innodb Log Buffer 中，当满足 innodb_flush_log_trx_commit 参数所设置的相应条 件（或者日志缓冲区写满）之后，才会将日志写到文件（或者同步到磁盘）中。</li><li><code>max_connections</code> ：表示 允许连接到MySQL数据库的最大数量 ，默认值是 151 。如果状态变量 connection_errors_max_connections 不为零，并且一直增长，则说明不断有连接请求因数据库连接 数已达到允许最大值而失败，这是可以考虑增大max_connections 的值。在Linux 平台下，性能好的 服务器，支持 500-1000 个连接不是难事，需要根据服务器性能进行评估设定。这个连接数 不是越大 越好 ，因为这些连接会浪费内存的资源。过多的连接可能会导致MySQL服务器僵死。</li><li><code>back_log</code> ：用于 控制MySQL监听TCP端口时设置的积压请求栈大小 。如果MySql的连接数达到 max_connections时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即 back_log，如果等待连接的数量超过back_log，将不被授予连接资源，将会报错。5.6.6 版本之前默 认值为 50 ， 之后的版本默认为 50 + （max_connections / 5）， 对于Linux系统推荐设置为小于512 的整数，但最大不超过900。<br>如果需要数据库在较短的时间内处理大量连接请求， 可以考虑适当增大back_log 的值。</li><li><code>thread_cache_size</code> ： 线程池缓存线程数量的大小 ，当客户端断开连接后将当前线程缓存起来， 当在接到新的连接请求时快速响应无需创建新的线程 。这尤其对那些使用短连接的应用程序来说可 以极大的提高创建连接的效率。那么为了提高性能可以增大该参数的值。默认为60，可以设置为 120。</li><li><code>wait_timeout</code>：指定 一个请求的最大连接时间 ，对于4GB左右内存的服务器可以设置为5-10。</li><li><code>interactive_timeout </code>：表示服务器在关闭连接前等待行动的秒数。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">port = 3306 </span><br><span class="line">serverid = 1 </span><br><span class="line">socket = /tmp/mysql.sock </span><br><span class="line">skip-locking <span class="comment">#避免MySQL的外部锁定，减少出错几率增强稳定性。 </span></span><br><span class="line">skip-name-resolve <span class="comment">#禁止MySQL对外部连接进行DNS解析，使用这一选项可以消除MySQL进行DNS解析的时间。但需要注意，如果开启该选项，则所有远程主机连接授权都要使用IP地址方式，否则MySQL将无法正常处理连接请求！ </span></span><br><span class="line">back_log = 384</span><br><span class="line">key_buffer_size = 256M </span><br><span class="line">max_allowed_packet = 4M </span><br><span class="line">thread_stack = 256K</span><br><span class="line">table_cache = 128K </span><br><span class="line">sort_buffer_size = 6M </span><br><span class="line">read_buffer_size = 4M</span><br><span class="line">read_rnd_buffer_size=16M </span><br><span class="line">join_buffer_size = 8M </span><br><span class="line">myisam_sort_buffer_size =64M </span><br><span class="line">table_cache = 512 </span><br><span class="line">thread_cache_size = 64 </span><br><span class="line">query_cache_size = 64M</span><br><span class="line">tmp_table_size = 256M </span><br><span class="line">max_connections = 768 </span><br><span class="line">max_connect_errors = 10000000</span><br><span class="line">wait_timeout = 10 </span><br><span class="line">thread_concurrency = 8 <span class="comment">#该参数取值为服务器逻辑CPU数量*2，在本例中，服务器有2颗物理CPU，而每颗物理CPU又支持H.T超线程，所以实际取值为4*2=8</span></span><br><span class="line">skip-networking <span class="comment">#开启该选项可以彻底关闭MySQL的TCP/IP连接方式，如果WEB服务器是以远程连接的方式访问MySQL数据库服务器则不要开启该选项！否则将无法正常连接！ </span></span><br><span class="line">table_cache=1024</span><br><span class="line">innodb_additional_mem_pool_size=4M <span class="comment">#默认为2M </span></span><br><span class="line">innodb_flush_log_at_trx_commit=1</span><br><span class="line">innodb_log_buffer_size=2M <span class="comment">#默认为1M </span></span><br><span class="line">innodb_thread_concurrency=8 <span class="comment">#你的服务器CPU有几个就设置为几。建议用默认一般为8 </span></span><br><span class="line">tmp_table_size=64M <span class="comment">#默认为16M，调到64-256最挂</span></span><br><span class="line">thread_cache_size=120 </span><br><span class="line">query_cache_size=32M</span><br></pre></td></tr></table></figure><h2 id="3、优化数据库结构">3、优化数据库结构</h2><h3 id="3-1-拆分表：冷热数据分离">3.1 拆分表：冷热数据分离</h3><p>拆分表的思路是，<strong>把1个包含很多字段的表拆分成2个或者多个相对较小的表</strong>。这样做的原因是，这些表中某些字段的操作频率很高（热数据），经常要进行查询或者更新操作，而另外一些字段的使用频率却很低（冷数据），冷热数据分离，可以减小表的宽度。如果放在一个表里面，每次查询都要读取大记录，会消耗较多的资源。<br>MySQL限制每个表最多存储4096列，并且每一行数据的大小不能超过65535字节。表越宽，把表装载进内存缓冲池时所占用的内存也就越大，也会消耗更多的IO。冷热数据分离的目的是:<strong>①减少磁盘lO，保证热数据的内存缓存命中率。②更有效的利用缓存，避免读入无用的冷数据</strong>。</p><h3 id="3-2-增加中间表">3.2 增加中间表</h3><p>对于需要经常联合查询的表，可以建立中间表以提高查询效率。通过建立中间表，把需要经常联合查询的数据插入中间表中，然后将原来的联合查询改为对中间表的查询，以此来提高查询效率。<br>首先，分析经常联合查询表中的字段;然后，使用这些字段建立一个中间表，并将原来联合查询的表的数据插入中间表中;最后，使用中间表来进行查询。</p><h3 id="3-3-增加冗余字段">3.3 增加冗余字段</h3><p>设计数据库表时应尽量遵循范式理论的规约，尽可能减少冗余字段，让数据库设计看起来精致、优雅。 但是，合理地加入冗余字段可以提高查询速度</p><h3 id="3-4-优化数据类型">3.4 优化数据类型</h3><p>列的字段越大，建立索引时所需要的空间也就越大，这样一页中所能存储的索引节点的数量也就越少，在遍历时所需要的IO次数也就越多，索引的性能也就越差。</p><ul><li>对整数类型数据进行优化</li><li>既可以使用文本类型也可以使用整数类型的字段，要选择使用整数类型</li><li>避免使用TEXT、BLOB数据类型</li><li>避免使用ENUM类型</li><li>使用TIMESTAMP存储时间</li><li>用DECIMAL代替FLOAT和DOUBLE存储精确浮点数</li></ul><h3 id="3-5-优化插入记录的速度">3.5 优化插入记录的速度</h3><p><strong>1、MyISAM引擎的表</strong><br>① 禁用索引<br>② 禁用唯一性检查<br>③ 使用批量插入<br>④ 使用LOAD DATA INFILE 批量导入<br><strong>2、InnoDB引擎的表</strong><br>① 禁用唯一性检查<br>② 禁用外键检查<br>③ 禁止自动提交</p><h3 id="3-6-使用非空约束">3.6 使用非空约束</h3><p>在设计字段的时候，如果业务允许，建议尽量使用非空约束。这样做的好处是:</p><ul><li>进行比较和计算时，省去要对NULL值的字段判断是否为空的开销，提高存储效率。</li><li>非空字段也容易创建索引。因为索引NULL列需要额外的空间来保存，所以要占用更多的空间。使用非空约束，就可以节省存储空间(每个字段1个bit)。</li></ul><h3 id="3-7-分析表、检查表与优化表">3.7 分析表、检查表与优化表</h3><blockquote><p>MySQL提供了分析表、检查表和优化表的语句。分析表主要是分析关键字的分布，检查表主要是检查表是否存在错误，优化表主要是消除删除或者更新造成的空间浪费</p></blockquote><p>ANALYZE/CHECK/OPTIMIZE TABLE xxx</p><h3 id="3-8-小结">3.8 小结</h3><p>上述这些方法都是有利有弊的。比如：</p><ul><li>修改数据类型，节省存储空间的同时，你要考虑到数据不能超过取值范围；</li><li>增加冗余字段的时候，不要忘了确保数据一致性；</li><li>把大表拆分，也意味着你的查询会增加新的连接，从而增加额外的开销和运维的成本。</li></ul><h2 id="4、大表优化">4、大表优化</h2><p>当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下</p><h3 id="4-1-限定查询的范围">4.1 限定查询的范围</h3><p>禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制 在一个月的范围内；</p><h3 id="4-2-读-写分离">4.2 读/写分离</h3><h3 id="4-3-垂直拆分与水平拆分">4.3 垂直拆分与水平拆分</h3><h2 id="5、其它调优策略">5、其它调优策略</h2><h3 id="5-1-服务器语句超时处理">5.1 服务器语句超时处理</h3><p>在MySQL 8.0中可以设置 服务器语句超时的限制 ，单位可以达到 毫秒级别 。当中断的执行语句超过设置的 毫秒数后，服务器将终止查询影响不大的事务或连接，然后将错误报给客户端。设置服务器语句超时的限制，可以通过设置系统变量<code> MAX_EXECUTION_TIME</code> 来实现。<strong>默认情况下， MAX_EXECUTION_TIME的值为0，代表没有时间限制</strong>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 指定该会话中SELECT语句的超时时间</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> MAX_EXECUTION_TIME=<span class="number">2000</span>;</span><br></pre></td></tr></table></figure><h3 id="5-2-创建全局通用表空间">5.2 创建全局通用表空间</h3><p>MySQL8.0使用<code>CREATE TABLESPACE</code>语句来创建一个全局通用表空间。全局表空间可以被所有的数据库的表共享，而且相比于独享表空间，<strong>使用手动创建共享表空间可以节约元数据方面的内存</strong>。可以在创建表的时候，指定属于哪个表空间，也可以对已有表进行表空间修改等。</p><h3 id="5-3-MySQL-8-0新特性：隐藏索引对调优的帮助">5.3  MySQL 8.0新特性：隐藏索引对调优的帮助</h3><p>不可见索引的特性对于性能调试非常有用。在MySQL 8.0中，索引可以被&quot;隐藏&quot;和“显示”。<strong>当一个索引被隐藏时，它不会被查询优化器所使用</strong>。也就是说，管理员可以隐藏一个索引，然后观察对数据库的影响。如果数据库性能有所下降，就说明这个索引是有用的，于是将其&quot;恢复显示&quot;即可;如果数据库性能看不出变化，就说明这个索引是多余的，可以删掉了。<br>需要注意的是当索引被隐藏时，它的内容仍然是和正常索引一样<strong>实时更新</strong>的。如果一个索引需要长期被隐藏，那么可以将其删除，因为索引的存在会影响插入、更新和删除的性能。<strong>数据表中的主键不能被设置为invisible</strong>。</p><hr><p>参考<br><a href="https://www.bilibili.com/video/BV1iq4y1u7vj" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1iq4y1u7vj</a></p>]]></content>
    
    
    <summary type="html">&lt;h1&gt;一、MySQL环境安装与介绍&lt;/h1&gt;
&lt;h2 id=&quot;1、MySQL安装&quot;&gt;1、MySQL安装&lt;/h2&gt;
&lt;h3 id=&quot;1-1-安装前说明&quot;&gt;1.1 安装前说明&lt;/h3&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 如果你是用rpm安装, 检查一下RPM PACKAGE&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;rpm -qa | grep -i mysql &lt;span class=&quot;comment&quot;&gt;# -i 忽略大小写&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 检查mysql service&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;systemctl status mysqld.service&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# MySQL的卸载&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 关闭 mysql 服务&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;systemctl stop mysqld.service&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;rpm -qa | grep -i mysql&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 查看当前 mysql 安装状况&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;yum list installed | grep mysql&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 卸载上述命令查询出的已安装程序&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;yum remove mysql-xxx mysql-xxx mysql-xxx mysqk-xxxx&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 务必卸载干净，反复执行rpm -qa | grep -i mysql确认是否有卸载残留&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 删除 mysql 相关文件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;find / -name mysql&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;rm -rf xxx&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 删除 my.cnf&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;rm -rf /etc/my.cnf&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Java" scheme="https://www.shawn22.xyz/categories/Java/"/>
    
    
    <category term="SQL" scheme="https://www.shawn22.xyz/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>Linux中curl详解</title>
    <link href="https://www.shawn22.xyz/posts/4bb6ed86.html"/>
    <id>https://www.shawn22.xyz/posts/4bb6ed86.html</id>
    <published>2023-03-05T16:17:04.000Z</published>
    <updated>2023-03-05T16:35:01.274Z</updated>
    
    <content type="html"><![CDATA[<h1>一、简介</h1><p>curl 是常用的命令行工具，用来请求 Web 服务器。它的名字就是客户端（client）的 URL 工具的意思。它的功能非常强大，命令行参数多达几十种。如果熟练的话，完全可以取代 Postman 这一类的图形界面工具</p><a id="more"></a><h1>二、命令详解</h1><h2 id="1、常用命令">1、常用命令</h2><h3 id="1-1-A和-H">1.1 -A和-H</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不带有任何参数时，curl 就是发出 GET 请求。</span></span><br><span class="line">curl https://www.baidu.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># -A参数指定客户端的用户代理标头，即User-Agent。curl 的默认用户代理字符串是curl/[version]</span></span><br><span class="line">curl -A <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36'</span> https://www.baidu.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 命令会移除User-Agent标头。</span></span><br><span class="line">curl -A <span class="string">''</span> https://www.baidu.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># -H参数直接指定标头，更改User-Agent</span></span><br><span class="line">curl -H <span class="string">'User-Agent: php/1.0'</span> https://www.baidu.com</span><br></pre></td></tr></table></figure><h3 id="1-2-b-参数用来向服务器发送-Cookie">1.2 -b 参数用来向服务器发送 Cookie</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成一个标头Cookie: foo=bar，向服务器发送一个名为foo、值为bar的 Cookie。</span></span><br><span class="line">curl -b <span class="string">'foo=bar'</span> https://www.baidu.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送两个 Cookie</span></span><br><span class="line">curl -b <span class="string">'foo1=bar;foo2=bar2'</span> https://www.baidu.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取本地文件cookies.txt，里面是服务器设置的 Cookie（参见-c参数），将其发送到服务器。</span></span><br><span class="line">curl -b cookies.txt https://www.baidu.com</span><br></pre></td></tr></table></figure><h3 id="1-3-c参数将服务器设置的-Cookie-写入一个文件">1.3 -c参数将服务器设置的 Cookie 写入一个文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将服务器的 HTTP 回应所设置 Cookie 写入文本文件cookies.txt。</span></span><br><span class="line">curl -c cookies.txt https://www.baidu.com</span><br></pre></td></tr></table></figure><h3 id="1-4-d-参数-和-data-urlencode">1.4 -d 参数 和 --data-urlencode</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -d参数用于发送 POST 请求的数据体。</span></span><br><span class="line">curl -d<span class="string">'login=emma＆password=123'</span>-X POST https://www.baidu.com/login</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者 使用-d参数以后，HTTP 请求会自动加上标头Content-Type : application/x-www-form-urlencoded。</span></span><br><span class="line"><span class="comment"># 并且会自动将请求转为 POST 方法，因此可以省略-X POST。</span></span><br><span class="line">curl -d <span class="string">'login=emma'</span> -d <span class="string">'password=123'</span> -X POST  https://www.baidu.com/login</span><br><span class="line"></span><br><span class="line"><span class="comment"># -d参数可以读取本地文本文件的数据，向服务器发送  读取data.txt文件的内容，作为数据体向服务器发送。</span></span><br><span class="line">curl -d <span class="string">'@data.txt'</span> https://www.baidu.com/login</span><br><span class="line"></span><br><span class="line"><span class="comment"># --data-urlencode参数等同于-d，发送 POST 请求的数据体，区别在于会自动将发送的数据进行 URL 编码</span></span><br><span class="line"><span class="comment"># 发送的数据hello world之间有一个空格，需要进行 URL 编码。</span></span><br><span class="line">curl --data-urlencode <span class="string">'comment=hello world'</span> https://www.baidu.com/login</span><br></pre></td></tr></table></figure><h3 id="1-5-H参数添加-HTTP-请求的标头">1.5 -H参数添加 HTTP 请求的标头</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加 HTTP 标头Accept-Language: en-US。</span></span><br><span class="line">curl -H <span class="string">'Accept-Language: en-US'</span> https://google.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加两个 HTTP 标头。</span></span><br><span class="line">curl -H <span class="string">'Accept-Language: en-US'</span> -H <span class="string">'Secret-Message: xyzzy'</span> https://google.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加 HTTP 请求的标头是Content-Type: application/json，然后用-d参数发送 JSON 数据。</span></span><br><span class="line">curl -d <span class="string">'&#123;"login": "emma", "pass": "123"&#125;'</span> -H <span class="string">'Content-Type: application/json'</span> https://google.com/login</span><br></pre></td></tr></table></figure><h3 id="1-6-显示-HTTP-头">1.6 显示 HTTP 头</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只想要显示 HTTP 头，而不显示文件内容,可以使用 -I 选项</span></span><br><span class="line">curl -I https://www.baidu.com</span><br><span class="line"><span class="comment"># 也可以同时显示 HTTP 头和文件内容，使用 -i 选项</span></span><br><span class="line">curl -i https://www.baidu.com</span><br></pre></td></tr></table></figure><h3 id="1-7-L参数会让-HTTP-请求跟随服务器的重定向">1.7  -L参数会让 HTTP 请求跟随服务器的重定向</h3><p>curl 默认不跟随重定向，如果直接使用 curl 打开某些被重定向后的链接，这种情况下就无法获取我们想要的网页内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认会得到以下错误</span></span><br><span class="line">&lt;html&gt; </span><br><span class="line">&lt;head&gt;&lt;title&gt;301 Moved Permanently&lt;/title&gt;&lt;/head&gt; </span><br><span class="line">&lt;body bgcolor=<span class="string">"white"</span>&gt; </span><br><span class="line">&lt;center&gt;&lt;h1&gt;301 Moved Permanently&lt;/h1&gt;&lt;/center&gt; </span><br><span class="line">&lt;hr&gt;&lt;center&gt;nginx/1.10.3&lt;/center&gt; </span><br><span class="line">&lt;/body&gt; </span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在命令中添加 -L 选项来跟随链接重定向</span></span><br><span class="line">curl -L https://www.baidu.com</span><br></pre></td></tr></table></figure><h3 id="1-8-保存内容">1.8 保存内容</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用linux的重定向功能保存</span></span><br><span class="line">curl http://www.linux.com &gt;&gt; linux.html</span><br><span class="line"><span class="comment"># 使用curl的内置option:-o(小写)保存网页</span></span><br><span class="line">curl -o linux.html http://www.linux.com</span><br></pre></td></tr></table></figure><h3 id="1-9-F参数用来向服务器上传二进制文件">1.9 -F参数用来向服务器上传二进制文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给 HTTP 请求加上标头Content-Type: multipart/form-data，然后将文件photo.png作为file字段上传。</span></span><br><span class="line">curl -F <span class="string">'file=@photo.png'</span> https://google.com/profile</span><br><span class="line"></span><br><span class="line"><span class="comment"># -F参数可以指定 MIME 类型。指定 MIME 类型为image/png，否则 curl 会把 MIME 类型设为application/octet-stream。</span></span><br><span class="line">curl -F <span class="string">'file=@photo.png;type=image/png'</span> https://google.com/profile</span><br><span class="line"></span><br><span class="line"><span class="comment"># -F参数也可以指定文件名。原始文件名为photo.png，但是服务器接收到的文件名为me.png。</span></span><br><span class="line">curl -F <span class="string">'file=@photo.png;filename=me.png'</span> https://google.com/profile</span><br></pre></td></tr></table></figure><h3 id="1-10-k参数指定跳过-SSL-检测">1.10 -k参数指定跳过 SSL 检测</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不会检查服务器的 SSL 证书是否正确</span></span><br><span class="line">curl -k https://www.example.com</span><br></pre></td></tr></table></figure><h2 id="2、curl的下载">2、curl的下载</h2><h3 id="2-1-curl的内置option-O-大写-保存网页中的文件">2.1 curl的内置option:-O(大写)保存网页中的文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里后面的url要具体到某个文件，不然抓不下来</span></span><br><span class="line">curl -O http://www.linux.com/hello.sh</span><br></pre></td></tr></table></figure><h3 id="2-2-循环下载">2.2 循环下载</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 有时候下载图片可以能是前面的部分名称是一样的，就最后的尾椎名不一样，这样就会把dodo1，dodo2，dodo3，dodo4，dodo5全部保存下来</span></span><br><span class="line">curl -O http://www.linux.com/dodo[1-5].JPG</span><br></pre></td></tr></table></figure><h3 id="2-3-下载重命名">2.3 下载重命名</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这样会被覆盖，这样就需要对文件进行重命名(这是错误示例)</span></span><br><span class="line">curl -O http://www.linux.com/&#123;hello,bb&#125;/dodo[1-5].JPG</span><br><span class="line"><span class="comment"># 这样在hello/dodo1.JPG的文件下载下来就会变成hello_dodo1.JPG,其他文件依此类推，从而有效的避免了文件被覆盖</span></span><br><span class="line">curl -o <span class="comment">#1_#2.JPG http://www.linux.com/&#123;hello,bb&#125;/dodo[1-5].JPG</span></span><br></pre></td></tr></table></figure><h3 id="2-4-分块下载">2.4 分块下载</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 有时候下载的东西会比较大，这个时候我们可以分段下载。使用内置option：-r</span></span><br><span class="line">curl -r 0-100 -o dodo1_part1.JPG http://www.linux.com/dodo1.JPG</span><br><span class="line">curl -r 100-200 -o dodo1_part2.JPG http://www.linux.com/dodo1.JPG</span><br><span class="line">curl -r 200- -o dodo1_part3.JPG http://www.linux.com/dodo1.JPG</span><br><span class="line">cat dodo1_part* &gt; dodo1.JPG</span><br></pre></td></tr></table></figure><h3 id="2-5-通过ftp下载文件">2.5 通过ftp下载文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># curl可以通过ftp下载文件，curl提供两种从ftp中下载的语法</span></span><br><span class="line">curl -O -u 用户名:密码 ftp://www.linux.com/dodo1.JPG</span><br><span class="line">curl -O ftp://用户名:密码@www.linux.com/dodo1.JPG</span><br></pre></td></tr></table></figure><h3 id="2-6-显示-不显示下载进度条">2.6 显示/不显示下载进度条</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -<span class="comment"># -O http://www.linux.com/dodo1.JPG</span></span><br><span class="line"><span class="comment"># 不会显示下载进度信息</span></span><br><span class="line">curl -s -O http://www.linux.com/dodo1.JPG</span><br></pre></td></tr></table></figure><h3 id="2-7-断点续传">2.7 断点续传</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在windows中，我们可以使用迅雷这样的软件进行断点续传。curl可以通过内置option:-C同样可以达到相同的效果。如果在下载dodo1.JPG的过程中突然掉线了，可以使用以下的方式续传</span></span><br><span class="line">curl -C -O http://www.linux.com/dodo1.JPG</span><br></pre></td></tr></table></figure><h2 id="3、其他命令">3、其他命令</h2><h3 id="3-1-测试网页返回值">3.1 测试网页返回值</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在脚本中，这是很常见的测试网站是否正常的用法,-w 指定输出内容</span></span><br><span class="line">curl -o /dev/null -s -w %&#123;http_code&#125; www.linux.com</span><br></pre></td></tr></table></figure><h3 id="3-2-指定proxy服务器以及其端口">3.2 指定proxy服务器以及其端口</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 很多时候上网需要用到代理服务器(比如是使用代理服务器上网或者因为使用curl别人网站而被别人屏蔽IP地址的时候)，幸运的是curl通过使用内置option：-x来支持设置代理</span></span><br><span class="line">curl -x 192.168.100.100:1080 http://www.linux.com</span><br></pre></td></tr></table></figure><h3 id="3-3-保存http的response里面的header信息">3.3 保存http的response里面的header信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 内置option: -D</span></span><br><span class="line">curl -D cookied.txt http://www.linux.com</span><br></pre></td></tr></table></figure><h3 id="3-4-伪造referer（盗链）">3.4 伪造referer（盗链）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 很多服务器会检查http访问的referer从而来控制访问。</span></span><br><span class="line"><span class="comment"># 比如：你是先访问首页，然后再访问首页中的邮箱页面，这里访问邮箱的referer地址就是访问首页成功后的页面地址，</span></span><br><span class="line"><span class="comment"># 如果服务器发现对邮箱页面访问的referer地址不是首页的地址，就断定那是个盗连了curl中内置option：-e可以让我们设定referer，</span></span><br><span class="line"><span class="comment"># 这样就会让服务器其以为你是从www.linux.com点击某个链接过来的</span></span><br><span class="line">curl -e <span class="string">"www.linux.com"</span> http://mail.linux.com</span><br></pre></td></tr></table></figure><h3 id="3-5-上传文件">3.5 上传文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># curl不仅仅可以下载文件，还可以上传文件。通过内置option:-T来实现</span></span><br><span class="line">curl -T dodo1.JPG -u 用户名:密码 ftp://www.linux.com/img/</span><br></pre></td></tr></table></figure><h3 id="3-6-显示抓取错误">3.6 显示抓取错误</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -w 指定输出内容</span></span><br><span class="line">curl -f http://www.linux.com/error</span><br></pre></td></tr></table></figure><hr><p>参考：</p><p><a href="https://www.jianshu.com/p/069f2fe7c16a" target="_blank" rel="noopener" title="https://www.jianshu.com/p/069f2fe7c16a">https://www.jianshu.com/p/069f2fe7c16a</a></p><p><a href="https://www.toolnb.com/linuxsearch/curl.html" target="_blank" rel="noopener" title="https://www.toolnb.com/linuxsearch/curl.html">https://www.toolnb.com/linuxsearch/curl.html</a></p>]]></content>
    
    
    <summary type="html">&lt;h1&gt;一、简介&lt;/h1&gt;
&lt;p&gt;curl 是常用的命令行工具，用来请求 Web 服务器。它的名字就是客户端（client）的 URL 工具的意思。它的功能非常强大，命令行参数多达几十种。如果熟练的话，完全可以取代 Postman 这一类的图形界面工具&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.shawn22.xyz/categories/Linux/"/>
    
    
    <category term="linux基础" scheme="https://www.shawn22.xyz/tags/linux%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>KubeSphere实战</title>
    <link href="https://www.shawn22.xyz/posts/f1b2e745.html"/>
    <id>https://www.shawn22.xyz/posts/f1b2e745.html</id>
    <published>2023-03-05T16:16:06.000Z</published>
    <updated>2023-03-05T16:35:59.321Z</updated>
    
    <content type="html"><![CDATA[<h1>一、KubeSphere平台安装</h1><blockquote><p>官网：<a href="https://kubesphere.com.cn/" target="_blank" rel="noopener" title="https://kubesphere.com.cn/">https://kubesphere.com.cn/</a></p></blockquote><h2 id="1、Kubernetes上安装KubeSphere">1、Kubernetes上安装KubeSphere</h2><h3 id="1-1-安装docker">1.1 安装docker</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># centos7.9，建议机器4核8G</span></span><br><span class="line">sudo yum remove docker*</span><br><span class="line">sudo yum install -y yum-utils</span><br><span class="line"></span><br><span class="line"><span class="comment">#配置docker的yum地址</span></span><br><span class="line">sudo yum-config-manager \</span><br><span class="line">--add-repo \</span><br><span class="line">http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#安装指定版本</span></span><br><span class="line">sudo yum install -y docker-ce-20.10.7 docker-ce-cli-20.10.7 containerd.io-1.4.6</span><br><span class="line"></span><br><span class="line"><span class="comment">#  启动&amp;开机启动docker</span></span><br><span class="line">systemctl <span class="built_in">enable</span> docker --now</span><br><span class="line"></span><br><span class="line"><span class="comment"># docker加速配置</span></span><br><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-<span class="string">'EOF'</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"registry-mirrors"</span>: [<span class="string">"https://82m9ar63.mirror.aliyuncs.com"</span>],</span><br><span class="line">  <span class="string">"exec-opts"</span>: [<span class="string">"native.cgroupdriver=systemd"</span>],</span><br><span class="line">  <span class="string">"log-driver"</span>: <span class="string">"json-file"</span>,</span><br><span class="line">  <span class="string">"log-opts"</span>: &#123;</span><br><span class="line">    <span class="string">"max-size"</span>: <span class="string">"100m"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"storage-driver"</span>: <span class="string">"overlay2"</span></span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="1-2-安装Kubernetes">1.2 安装Kubernetes</h3><p>首先基本环境的安装，每个机器使用内网ip互通，每个机器配置自己的hostname，不能用localhost</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置每个机器自己的hostname，k8s-master/node1/node2</span></span><br><span class="line">hostnamectl <span class="built_in">set</span>-hostname xxx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 SELinux 设置为 permissive 模式（相当于将其禁用）</span></span><br><span class="line">sudo setenforce 0</span><br><span class="line">sudo sed -i <span class="string">'s/^SELINUX=enforcing$/SELINUX=permissive/'</span> /etc/selinux/config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭防火墙，云的花内网需要互通</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line"><span class="comment"># 禁用 firewalld 服务</span></span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld</span><br><span class="line"></span><br><span class="line"><span class="comment">#关闭swap</span></span><br><span class="line">swapoff -a  </span><br><span class="line">sed -ri <span class="string">'s/.*swap.*/#&amp;/'</span> /etc/fstab</span><br><span class="line"></span><br><span class="line"><span class="comment">#允许 iptables 检查桥接流量</span></span><br><span class="line">cat &lt;&lt;EOF | sudo tee /etc/modules-load.d/k8s.conf</span><br><span class="line">br_netfilter</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">cat &lt;&lt;EOF | sudo tee /etc/sysctl.d/k8s.conf</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">EOF</span><br><span class="line">sudo sysctl --system</span><br></pre></td></tr></table></figure><p>然后<strong>安装kubelet、kubeadm、kubectl</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置k8s的yum源地址</span></span><br><span class="line">cat &lt;&lt;EOF | sudo tee /etc/yum.repos.d/kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg</span><br><span class="line">   http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#安装 kubelet，kubeadm，kubectl</span></span><br><span class="line">sudo yum install -y kubelet-1.21.9 kubeadm-1.21.9 kubectl-1.21.9</span><br><span class="line"></span><br><span class="line"><span class="comment">#启动kubelet</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> --now kubelet</span><br><span class="line"></span><br><span class="line"><span class="comment">#所有机器配置master域名,改成自己的ip</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"192.168.249.146  k8s-master"</span> &gt;&gt; /etc/hosts</span><br><span class="line">cat &gt; /etc/hosts &lt;&lt;EOF</span><br><span class="line">192.168.249.146  k8s-master</span><br><span class="line">192.168.249.147  node1</span><br><span class="line">192.168.249.148  node2</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p><strong>初始化master节点</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意ip和主机名的修改</span></span><br><span class="line">kubeadm init \</span><br><span class="line">--apiserver-advertise-address=192.168.249.146 \</span><br><span class="line">--control-plane-endpoint=k8s-master \</span><br><span class="line">--image-repository registry.aliyuncs.com/google_containers \</span><br><span class="line">--kubernetes-version v1.21.9 \</span><br><span class="line">--service-cidr=10.96.0.0/12  \</span><br><span class="line">--pod-network-cidr=10.244.0.0/16</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后记录相关信息</span></span><br><span class="line">mkdir -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) <span class="variable">$HOME</span>/.kube/config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装Calico网络插件</span></span><br><span class="line">curl https://docs.projectcalico.org/v3.20/manifests/calico.yaml -O</span><br><span class="line"><span class="comment"># 如果失败了就自己手动下载导入</span></span><br><span class="line"><span class="comment"># https://github.com/projectcalico/calico/releases</span></span><br><span class="line">kubectl apply -f calico.yaml</span><br><span class="line"><span class="comment"># 如果手动下载，无法下载镜像时，所有结点导入calico-cni/calico-node/calico-pod2daemon-flexvol，master结点需要额外导入calico-kube-controllers</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最后node结点加入集群</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于重置结点，现在主节点去除</span></span><br><span class="line">kubectl delete node  node2</span><br><span class="line">kubectl get node</span><br><span class="line"><span class="comment"># 然后node2从节点重置</span></span><br><span class="line">kubeadm reset</span><br></pre></td></tr></table></figure><h3 id="1-3-前置环境之nfs存储">1.3 前置环境之nfs存储</h3><p><strong>安装nfs-server</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在每个机器</span></span><br><span class="line">yum install -y nfs-utils</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在master 执行以下命令 </span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"/nfs/data/ *(insecure,rw,sync,no_root_squash)"</span> &gt; /etc/exports</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行以下命令，启动 nfs 服务;创建共享目录</span></span><br><span class="line">mkdir -p /nfs/data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在master执行</span></span><br><span class="line">systemctl <span class="built_in">enable</span> rpcbind</span><br><span class="line">systemctl <span class="built_in">enable</span> nfs-server</span><br><span class="line">systemctl start rpcbind</span><br><span class="line">systemctl start nfs-server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使配置生效</span></span><br><span class="line">exportfs -r</span><br><span class="line"></span><br><span class="line"><span class="comment">#检查配置是否生效</span></span><br><span class="line">exportfs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置nfs-client（选做）</span></span><br><span class="line"><span class="comment"># 注意在非master结点，注意ip修改</span></span><br><span class="line">showmount -e 192.168.249.146</span><br><span class="line">mkdir -p /nfs/data</span><br><span class="line">mount -t nfs 192.168.249.146:/nfs/data /nfs/data</span><br></pre></td></tr></table></figure><p>配置默认存储，在master执行，<code>vim sc.yaml</code>，注意nfs地址改成自己的</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 创建了一个存储类</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">storage.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StorageClass</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nfs-storage</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">storageclass.kubernetes.io/is-default-class:</span> <span class="string">"true"</span></span><br><span class="line"><span class="attr">provisioner:</span> <span class="string">k8s-sigs.io/nfs-subdir-external-provisioner</span></span><br><span class="line"><span class="attr">parameters:</span></span><br><span class="line">  <span class="attr">archiveOnDelete:</span> <span class="string">"true"</span>  <span class="comment">## 删除pv的时候，pv的内容是否要备份</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nfs-client-provisioner</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nfs-client-provisioner</span></span><br><span class="line">  <span class="comment"># replace with namespace where provisioner is deployed</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">strategy:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">Recreate</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nfs-client-provisioner</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nfs-client-provisioner</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">serviceAccountName:</span> <span class="string">nfs-client-provisioner</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nfs-client-provisioner</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">registry.cn-beijing.aliyuncs.com/kubesphereio/nfs-subdir-external-provisioner:v4.0.2</span></span><br><span class="line">          <span class="comment"># resources:</span></span><br><span class="line">          <span class="comment">#    limits:</span></span><br><span class="line">          <span class="comment">#      cpu: 10m</span></span><br><span class="line">          <span class="comment">#    requests:</span></span><br><span class="line">          <span class="comment">#      cpu: 10m</span></span><br><span class="line">          <span class="attr">volumeMounts:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nfs-client-root</span></span><br><span class="line">              <span class="attr">mountPath:</span> <span class="string">/persistentvolumes</span></span><br><span class="line">          <span class="attr">env:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">PROVISIONER_NAME</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">k8s-sigs.io/nfs-subdir-external-provisioner</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">NFS_SERVER</span></span><br><span class="line">              <span class="attr">value:</span> <span class="number">192.168</span><span class="number">.249</span><span class="number">.146</span> <span class="comment">## 指定自己nfs服务器地址</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">NFS_PATH</span>  </span><br><span class="line">              <span class="attr">value:</span> <span class="string">/nfs/data</span>  <span class="comment">## nfs服务器共享的目录</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nfs-client-root</span></span><br><span class="line">          <span class="attr">nfs:</span></span><br><span class="line">            <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.249</span><span class="number">.146</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/nfs/data</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nfs-client-provisioner</span></span><br><span class="line">  <span class="comment"># replace with namespace where provisioner is deployed</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nfs-client-provisioner-runner</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span> <span class="string">[""]</span></span><br><span class="line">    <span class="attr">resources:</span> <span class="string">["nodes"]</span></span><br><span class="line">    <span class="attr">verbs:</span> <span class="string">["get",</span> <span class="string">"list"</span><span class="string">,</span> <span class="string">"watch"</span><span class="string">]</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span> <span class="string">[""]</span></span><br><span class="line">    <span class="attr">resources:</span> <span class="string">["persistentvolumes"]</span></span><br><span class="line">    <span class="attr">verbs:</span> <span class="string">["get",</span> <span class="string">"list"</span><span class="string">,</span> <span class="string">"watch"</span><span class="string">,</span> <span class="string">"create"</span><span class="string">,</span> <span class="string">"delete"</span><span class="string">]</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span> <span class="string">[""]</span></span><br><span class="line">    <span class="attr">resources:</span> <span class="string">["persistentvolumeclaims"]</span></span><br><span class="line">    <span class="attr">verbs:</span> <span class="string">["get",</span> <span class="string">"list"</span><span class="string">,</span> <span class="string">"watch"</span><span class="string">,</span> <span class="string">"update"</span><span class="string">]</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span> <span class="string">["storage.k8s.io"]</span></span><br><span class="line">    <span class="attr">resources:</span> <span class="string">["storageclasses"]</span></span><br><span class="line">    <span class="attr">verbs:</span> <span class="string">["get",</span> <span class="string">"list"</span><span class="string">,</span> <span class="string">"watch"</span><span class="string">]</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span> <span class="string">[""]</span></span><br><span class="line">    <span class="attr">resources:</span> <span class="string">["events"]</span></span><br><span class="line">    <span class="attr">verbs:</span> <span class="string">["create",</span> <span class="string">"update"</span><span class="string">,</span> <span class="string">"patch"</span><span class="string">]</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">run-nfs-client-provisioner</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nfs-client-provisioner</span></span><br><span class="line">    <span class="comment"># replace with namespace where provisioner is deployed</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nfs-client-provisioner-runner</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">leader-locking-nfs-client-provisioner</span></span><br><span class="line">  <span class="comment"># replace with namespace where provisioner is deployed</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span> <span class="string">[""]</span></span><br><span class="line">    <span class="attr">resources:</span> <span class="string">["endpoints"]</span></span><br><span class="line">    <span class="attr">verbs:</span> <span class="string">["get",</span> <span class="string">"list"</span><span class="string">,</span> <span class="string">"watch"</span><span class="string">,</span> <span class="string">"create"</span><span class="string">,</span> <span class="string">"update"</span><span class="string">,</span> <span class="string">"patch"</span><span class="string">]</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">RoleBinding</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">leader-locking-nfs-client-provisioner</span></span><br><span class="line">  <span class="comment"># replace with namespace where provisioner is deployed</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nfs-client-provisioner</span></span><br><span class="line">    <span class="comment"># replace with namespace where provisioner is deployed</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">leader-locking-nfs-client-provisioner</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></table></figure><p>确认配置是否生效，<code>kubectl get sc</code>，这样配置完成之后就拥有动态创建pv的能力，例如如下可以自行测试</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-pvc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">3Gi</span></span><br></pre></td></tr></table></figure><h3 id="1-4-前置环境之metrics-server">1.4 前置环境之metrics-server</h3><p>metrics-server是集群指标监控组件(这里用了别人的镜像库)，<code>vim metrics.yaml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">metrics-server</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">metrics-server</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">metrics-server</span></span><br><span class="line">    <span class="attr">rbac.authorization.k8s.io/aggregate-to-admin:</span> <span class="string">"true"</span></span><br><span class="line">    <span class="attr">rbac.authorization.k8s.io/aggregate-to-edit:</span> <span class="string">"true"</span></span><br><span class="line">    <span class="attr">rbac.authorization.k8s.io/aggregate-to-view:</span> <span class="string">"true"</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">system:aggregated-metrics-reader</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">metrics.k8s.io</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">pods</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">nodes</span></span><br><span class="line">  <span class="attr">verbs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">get</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">list</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">watch</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">metrics-server</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">system:metrics-server</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">""</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">pods</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">nodes</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">nodes/stats</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">namespaces</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">configmaps</span></span><br><span class="line">  <span class="attr">verbs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">get</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">list</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">watch</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">RoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">metrics-server</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">metrics-server-auth-reader</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">extension-apiserver-authentication-reader</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">metrics-server</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">metrics-server</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">metrics-server:system:auth-delegator</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">system:auth-delegator</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">metrics-server</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">metrics-server</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">system:metrics-server</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">system:metrics-server</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">metrics-server</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">metrics-server</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">metrics-server</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">https</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">443</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="string">https</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">metrics-server</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">metrics-server</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">metrics-server</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">k8s-app:</span> <span class="string">metrics-server</span></span><br><span class="line">  <span class="attr">strategy:</span></span><br><span class="line">    <span class="attr">rollingUpdate:</span></span><br><span class="line">      <span class="attr">maxUnavailable:</span> <span class="number">0</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">k8s-app:</span> <span class="string">metrics-server</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">args:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">--cert-dir=/tmp</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">--kubelet-insecure-tls</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">--secure-port=4443</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">--kubelet-preferred-address-types=InternalIP,ExternalIP,Hostname</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">--kubelet-use-node-status-port</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images/metrics-server:v0.4.3</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">        <span class="attr">livenessProbe:</span></span><br><span class="line">          <span class="attr">failureThreshold:</span> <span class="number">3</span></span><br><span class="line">          <span class="attr">httpGet:</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/livez</span></span><br><span class="line">            <span class="attr">port:</span> <span class="string">https</span></span><br><span class="line">            <span class="attr">scheme:</span> <span class="string">HTTPS</span></span><br><span class="line">          <span class="attr">periodSeconds:</span> <span class="number">10</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">metrics-server</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">4443</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">https</span></span><br><span class="line">          <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">        <span class="attr">readinessProbe:</span></span><br><span class="line">          <span class="attr">failureThreshold:</span> <span class="number">3</span></span><br><span class="line">          <span class="attr">httpGet:</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/readyz</span></span><br><span class="line">            <span class="attr">port:</span> <span class="string">https</span></span><br><span class="line">            <span class="attr">scheme:</span> <span class="string">HTTPS</span></span><br><span class="line">          <span class="attr">periodSeconds:</span> <span class="number">10</span></span><br><span class="line">        <span class="attr">securityContext:</span></span><br><span class="line">          <span class="attr">readOnlyRootFilesystem:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">runAsNonRoot:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">runAsUser:</span> <span class="number">1000</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/tmp</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">tmp-dir</span></span><br><span class="line">      <span class="attr">nodeSelector:</span></span><br><span class="line">        <span class="attr">kubernetes.io/os:</span> <span class="string">linux</span></span><br><span class="line">      <span class="attr">priorityClassName:</span> <span class="string">system-cluster-critical</span></span><br><span class="line">      <span class="attr">serviceAccountName:</span> <span class="string">metrics-server</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">emptyDir:</span> <span class="string">&#123;&#125;</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">tmp-dir</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apiregistration.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">APIService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">metrics-server</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">v1beta1.metrics.k8s.io</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">group:</span> <span class="string">metrics.k8s.io</span></span><br><span class="line">  <span class="attr">groupPriorityMinimum:</span> <span class="number">100</span></span><br><span class="line">  <span class="attr">insecureSkipTLSVerify:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">service:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">metrics-server</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line">  <span class="attr">version:</span> <span class="string">v1beta1</span></span><br><span class="line">  <span class="attr">versionPriority:</span> <span class="number">100</span></span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl top nodes</span><br><span class="line">kubectl top pod -A</span><br></pre></td></tr></table></figure><h3 id="1-5-安装KubeSphere">1.5 安装KubeSphere</h3><blockquote><p>安装文档参考：<a href="https://kubesphere.com.cn/docs/v3.3/quick-start/minimal-kubesphere-on-k8s/" target="_blank" rel="noopener" title="https://kubesphere.com.cn/docs/v3.3/quick-start/minimal-kubesphere-on-k8s/">https://kubesphere.com.cn/docs/v3.3/quick-start/minimal-kubesphere-on-k8s/</a></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里安装需要国外源网络</span></span><br><span class="line"><span class="comment"># 下载核心文件</span></span><br><span class="line">wget https://github.com/kubesphere/ks-installer/releases/download/v3.3.1/kubesphere-installer.yaml</span><br><span class="line">wget https://github.com/kubesphere/ks-installer/releases/download/v3.3.1/cluster-configuration.yaml</span><br><span class="line"></span><br><span class="line">kubectl apply -f kubesphere-installer.yaml</span><br><span class="line"><span class="comment"># 注意在启动这个文件前可以选择额外功能，这里默认最小安装，要啥功能将false改为true即可</span></span><br><span class="line">kubectl apply -f cluster-configuration.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 cluster-configuration.yaml中指定我们需要开启的功能参照官网"启用可插拔组件"：https://kubesphere.com.cn/docs/pluggable-components/overview/</span></span><br><span class="line"></span><br><span class="line">kubectl logs -n kubesphere-system $(kubectl get pod -n kubesphere-system -l app=ks-install -o jsonpath=<span class="string">'&#123;.items[0].metadata.name&#125;'</span>) -f</span><br><span class="line"><span class="comment"># 成功后访问</span></span><br><span class="line"><span class="comment"># 访问任意机器的 30880端口</span></span><br><span class="line"><span class="comment"># 账号 ： admin</span></span><br><span class="line"><span class="comment"># 密码 ： P@88w0rd</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解决etcd监控证书找不到问题</span></span><br><span class="line">kubectl -n kubesphere-monitoring-system create secret generic kube-etcd-client-certs  --from-file=etcd-client-ca.crt=/etc/kubernetes/pki/etcd/ca.crt  --from-file=etcd-client.crt=/etc/kubernetes/pki/apiserver-etcd-client.crt  --from-file=etcd-client.key=/etc/kubernetes/pki/apiserver-etcd-client.key</span><br></pre></td></tr></table></figure><h2 id="2、Linux单节点部署KubeSphere">2、Linux单节点部署KubeSphere</h2><blockquote><p>官网参考：<a href="https://kubesphere.com.cn/docs/v3.3/quick-start/all-in-one-on-linux/" target="_blank" rel="noopener" title="https://kubesphere.com.cn/docs/v3.3/quick-start/all-in-one-on-linux/">https://kubesphere.com.cn/docs/v3.3/quick-start/all-in-one-on-linux/</a></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先指定一下hostname</span></span><br><span class="line">hostnamectl <span class="built_in">set</span>-hostname node1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装</span></span><br><span class="line"><span class="comment"># 准备KubeKey，国内的下载</span></span><br><span class="line"><span class="built_in">export</span> KKZONE=cn</span><br><span class="line">curl -sfL https://get-kk.kubesphere.io | VERSION=v2.3.0 sh -</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使其拥有可执行权限</span></span><br><span class="line">chmod +x kk</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始安装下载</span></span><br><span class="line"><span class="comment"># ./kk create cluster [--with-kubernetes version] [--with-kubesphere version]</span></span><br><span class="line">./kk create cluster --with-kubernetes v1.22.12 --with-kubesphere v3.3.1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证安装结果</span></span><br><span class="line">kubectl logs -n kubesphere-system $(kubectl get pod -n kubesphere-system -l <span class="string">'app in (ks-install, ks-installer)'</span> -o jsonpath=<span class="string">'&#123;.items[0].metadata.name&#125;'</span>) -f</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出信息会显示 Web 控制台的 IP 地址和端口号，默认的 NodePort 是 30880。现在，您可以使用默认的帐户和密码 (admin/P@88w0rd) 通过 &lt;NodeIP&gt;:30880 访问控制台</span></span><br><span class="line"><span class="comment"># kubectl get pod --all-namespaces 查看相关组件情况</span></span><br></pre></td></tr></table></figure><p>仅适用于默认的最小化安装。若要在 KubeSphere 中启用其他组件，请参见<a href="https://kubesphere.com.cn/docs/v3.3/pluggable-components/" target="_blank" rel="noopener" title="启用可插拔组件">启用可插拔组件</a></p><p>进入可视化后也可以启用需要的组件，以 <code>admin</code> 用户登录控制台，点击左上角的<strong>平台管理</strong>，选择<strong>集群管理</strong>，点击<strong>定制资源定义</strong>，在搜索栏中输入 <code>clusterconfiguration</code>，点击选择需要打开的插件即可</p><h2 id="3、Linux多节点部署KubeSphere-推荐">3、Linux多节点部署KubeSphere(推荐)</h2><blockquote><p>官网：<a href="https://kubesphere.com.cn/docs/v3.3/installing-on-linux/introduction/multioverview/" target="_blank" rel="noopener" title="https://kubesphere.com.cn/docs/v3.3/installing-on-linux/introduction/multioverview/">https://kubesphere.com.cn/docs/v3.3/installing-on-linux/introduction/multioverview/</a></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 最小安装最低要求2c4g(如果性能好，推荐master4c8g/node8c16g)</span></span><br><span class="line"><span class="comment"># 使用KubeKey创建集群</span></span><br><span class="line"><span class="built_in">export</span> KKZONE=cn</span><br><span class="line">curl -sfL https://get-kk.kubesphere.io | VERSION=v2.3.0 sh -</span><br><span class="line">chmod +x kk</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建集群配置文件</span></span><br><span class="line"><span class="comment"># ./kk create config [--with-kubernetes version] [--with-kubesphere version] [(-f | --file) path]</span></span><br><span class="line">./kk create config --with-kubernetes v1.21.4 --with-kubesphere v3.3.1</span><br><span class="line"><span class="comment"># 然后这里会生成配置文件，修改配置文件，主要修改三台主机，例如下面，主要是修改ip以及指定master，node等</span></span><br><span class="line"><span class="comment"># ===================================================================</span></span><br><span class="line"><span class="comment"># address是公有地址，internalAddress是实例的私有 IP 地址，我这里虚拟机都填写私有地址了</span></span><br><span class="line">spec:</span><br><span class="line">  hosts:</span><br><span class="line">  - &#123;name: master, address: 192.168.249.146, internalAddress: 192.168.249.146, user: root, password: <span class="string">" "</span>&#125;</span><br><span class="line">  - &#123;name: node1, address: 192.168.249.147, internalAddress: 192.168.249.147, user: root, password: <span class="string">" "</span>&#125;</span><br><span class="line">  - &#123;name: node2, address: 192.168.249.148, internalAddress: 192.168.249.148, user: root, password: <span class="string">" "</span>&#125;</span><br><span class="line">  roleGroups:</span><br><span class="line">    etcd:</span><br><span class="line">    - master</span><br><span class="line">    control-plane: </span><br><span class="line">    - master</span><br><span class="line">    worker:</span><br><span class="line">    - node1</span><br><span class="line">    - node2</span><br><span class="line">  controlPlaneEndpoint:</span><br><span class="line">    <span class="comment">## Internal loadbalancer for apiservers </span></span><br><span class="line">    <span class="comment"># internalLoadbalancer: haproxy</span></span><br><span class="line"><span class="comment"># ========================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用配置文件创建集群，注意这里可能会有依赖缺失，根据提示yum install xxx安装即可</span></span><br><span class="line">yum install -y conntrack socat conntrack socat conntrack socat</span><br><span class="line">./kk create cluster -f config-sample.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结束后可以通过 &lt;NodeIP:30880 使用默认帐户和密码 (admin/P@88w0rd) 访问 KubeSphere 的 Web 控制台</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看进度，这个版本好像命令行没有kubectl 了，kubectl在web可以查看</span></span><br><span class="line"><span class="comment"># kubectl logs -n kubesphere-system $(kubectl get pod -n kubesphere-system -l 'app in (ks-install, ks-installer)' -o jsonpath='&#123;.items[0].metadata.name&#125;') -f</span></span><br></pre></td></tr></table></figure><h1>二、KubeSphere实战</h1><h2 id="1、多租户实战">1、多租户实战</h2><blockquote><p>参考文档：<a href="https://kubesphere.com.cn/docs/v3.3/quick-start/create-workspace-and-project/" target="_blank" rel="noopener" title="https://kubesphere.com.cn/docs/v3.3/quick-start/create-workspace-and-project/">https://kubesphere.com.cn/docs/v3.3/quick-start/create-workspace-and-project/</a></p></blockquote><p>首先平台管理员admin创建不同用户，包括企业空间管理员bigboss-li和普通成员若干，然后进入企业空间管理员bigboss-li账户，创建不同的企业空间(例如杭州)，他可以管理所有企业空间，每一个企业空间里邀请指定一个人为该空间管理员，例如hangzhou-boss，然后该角色可以邀请其他人为普通人员；</p><p>然后hangzhou-boss邀请pm-wang为项目总监负责人，wang可以创建多个项目，可以邀请该企业空间的人到不同的项目，并分配不同的角色，例如这个项目的管理员，而项目管理员又可以邀请这个企业空间的人到此项目中，并分配不同的权限，例如开发者/观察者等</p><p><img src="https://img-blog.csdnimg.cn/de7002a7bd744471b70c4cb584ede758.jpeg#pic_center" alt="在这里插入图片描述"></p><h2 id="2、中间件部署实战">2、中间件部署实战</h2><blockquote><p>官网快速入门例子：<a href="https://kubesphere.com.cn/docs/v3.3/quick-start/wordpress-deployment/" target="_blank" rel="noopener" title="https://kubesphere.com.cn/docs/v3.3/quick-start/wordpress-deployment/">https://kubesphere.com.cn/docs/v3.3/quick-start/wordpress-deployment/</a><br>dockerhub：<a href="https://hub.docker.com/" target="_blank" rel="noopener" title="https://hub.docker.com/">https://hub.docker.com/</a></p></blockquote><h3 id="2-1-MySql部署">2.1 MySql部署</h3><p><img src="https://img-blog.csdnimg.cn/2ff94e3b087f45e2862c98c1ba41aba8.png#pic_center" alt="在这里插入图片描述"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 正常docker部署</span></span><br><span class="line">docker run -p 3306:3306 --name mysql-01 \</span><br><span class="line">-v /mydata/mysql/<span class="built_in">log</span>:/var/<span class="built_in">log</span>/mysql \</span><br><span class="line">-v /mydata/mysql/data:/var/lib/mysql \</span><br><span class="line">-v /mydata/mysql/conf:/etc/mysql/conf.d \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=root \</span><br><span class="line">--restart=always \</span><br><span class="line">-d mysql:5.7 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 首先进入dev-lu的账号，这里管理员已经创建好了项目mail</span></span><br><span class="line"><span class="comment"># mysql配置示例</span></span><br><span class="line">[client]</span><br><span class="line">default-character-set=utf8mb4</span><br><span class="line"> </span><br><span class="line">[mysql]</span><br><span class="line">default-character-set=utf8mb4</span><br><span class="line"> </span><br><span class="line">[mysqld]</span><br><span class="line">init_connect=<span class="string">'SET collation_connection = utf8mb4_unicode_ci'</span></span><br><span class="line">init_connect=<span class="string">'SET NAMES utf8mb4'</span></span><br><span class="line">character-set-server=utf8mb4</span><br><span class="line">collation-server=utf8mb4_unicode_ci</span><br><span class="line">skip-character-set-client-handshake</span><br><span class="line">skip-name-resolve</span><br><span class="line">lower_case_table_names=1</span><br></pre></td></tr></table></figure><p>kubesphere首先进去项目(例如我这里项目是mail)，然后创建配置(在配置→配置字典里，名字随便取，里面设置key为xx.cnf，值为上面的配置内容)；然后创建存储(持久卷声明，这里暂时是local类型进行测试)；最后创建<strong>有状态副本集</strong>，选择镜像，选择容器(使用容器默认配置，然后注意勾选环境变量和时间同步，把MYSQL_ROOT_PASSWORD=root写入，也可以限制一下资源)，最后挂载卷和配置文件，成功创建(如果创建失败需要更改一下docker源)</p><blockquote><p>注意集群内部可以直接通过应用的 【<strong>服务名.项目名</strong>】 直接访问 (默认)，可以尝试ping</p></blockquote><p><strong>如果要修改内部访问域名，可以在服务里删除默认的，自行创建内部集群和外部访问两个service</strong>（注意是选择指定工作负载），也可以直接从服务里进行部署</p><p><img src="https://img-blog.csdnimg.cn/c504ead532294b07b6c4f2072dd56dd1.png#pic_center" alt="在这里插入图片描述"></p><h3 id="2-2-redis部署">2.2 redis部署</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ================这是之前的部署方式=============================</span></span><br><span class="line"><span class="comment">#创建配置文件</span></span><br><span class="line"><span class="comment">## 1、准备redis配置文件内容</span></span><br><span class="line">mkdir -p /mydata/redis/conf &amp;&amp; vim /mydata/redis/conf/redis.conf</span><br><span class="line"></span><br><span class="line"><span class="comment">##配置示例</span></span><br><span class="line">appendonly yes</span><br><span class="line">port 6379</span><br><span class="line"><span class="built_in">bind</span> 0.0.0.0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#docker启动redis</span></span><br><span class="line">docker run -d -p 6379:6379 --restart=always \</span><br><span class="line">-v /mydata/redis/conf/redis.conf:/etc/redis/redis.conf \</span><br><span class="line">-v  /mydata/redis-01/data:/data \</span><br><span class="line"> --name redis-01 redis:6.2.5 \</span><br><span class="line"> redis-server /etc/redis/redis.conf</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/7a83bed716b14f2cbdd20d1647decca7.png#pic_center" alt="在这里插入图片描述"></p><p>kubesphere方式部署和mysql类似，不过注意有状态副本集建议在内部直接创建存储，这样每增加一个副本就会新增一个pvc，否则会共用一个</p><h3 id="2-3-部署ElasticSearch">2.3 部署ElasticSearch</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建数据目录</span></span><br><span class="line">mkdir -p /mydata/es-01 &amp;&amp; chmod 777 -R /mydata/es-01</span><br><span class="line"></span><br><span class="line"><span class="comment"># 容器启动</span></span><br><span class="line">docker run --restart=always -d -p 9200:9200 -p 9300:9300 \</span><br><span class="line">-e <span class="string">"discovery.type=single-node"</span> \</span><br><span class="line">-e ES_JAVA_OPTS=<span class="string">"-Xms512m -Xmx512m"</span> \</span><br><span class="line">-v es-config:/usr/share/elasticsearch/config \</span><br><span class="line">-v /mydata/es-01/data:/usr/share/elasticsearch/data \</span><br><span class="line">--name es-01 \</span><br><span class="line">elasticsearch:7.13.4</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/fcb757aa8df5428ca6de5f0acd7664fb.png#pic_center" alt="在这里插入图片描述"></p><p>因为考虑到<code>/usr/share/elasticsearch/config</code>文件夹下有很多默认配置文件，所以不能直接使用配置文件挂载，否则会直接被覆盖，注意这里创建副本时要选择子路径，选择到具体文件覆盖</p><p><img src="https://img-blog.csdnimg.cn/a505f433416145d0aa4182c8a2d566cd.png#pic_center" alt="在这里插入图片描述"></p><h3 id="2-4-应用商店部署">2.4 应用商店部署</h3><blockquote><p>参考：<a href="https://kubesphere.com.cn/docs/v3.3/pluggable-components/app-store/" target="_blank" rel="noopener" title="https://kubesphere.com.cn/docs/v3.3/pluggable-components/app-store/">https://kubesphere.com.cn/docs/v3.3/pluggable-components/app-store/</a></p></blockquote><h3 id="2-5-应用仓库部署-推荐">2.5 应用仓库部署(推荐)</h3><blockquote><p>官网参考：<a href="https://helm.sh/zh/" target="_blank" rel="noopener" title="https://helm.sh/zh/">https://helm.sh/zh/</a><br>包搜索中心：<a href="https://artifacthub.io/" target="_blank" rel="noopener" title="https://artifacthub.io/">https://artifacthub.io/</a></p></blockquote><p>应用商店应用少，更多建议直接使用helm应用仓库进行安装部署，类似于dockerhub。首先去企业空间→应用管理→应用仓库添加bitnami仓库(需要对应权限角色，仓库地址<code>https://charts.bitnami.com/bitnami</code>)，同步完成后进入<strong>项目→应用负载→应用→从项目模板</strong>导入，选择导入的bitnami仓库即可选择对应的镜像了</p><h2 id="3、RuoYi-Cloud部署实战">3、RuoYi-Cloud部署实战</h2><blockquote><p>官网：<a href="https://gitee.com/y_project/RuoYi-Cloud" target="_blank" rel="noopener" title="https://gitee.com/y_project/RuoYi-Cloud">https://gitee.com/y_project/RuoYi-Cloud</a><br>架构图：<a href="https://gitee.com/zhangmrit/ruoyi-cloud/blob/nacos/doc/ruoyi-cloud.png" target="_blank" rel="noopener" title="https://gitee.com/zhangmrit/ruoyi-cloud/blob/nacos/doc/ruoyi-cloud.png">https://gitee.com/zhangmrit/ruoyi-cloud/blob/nacos/doc/ruoyi-cloud.png</a></p></blockquote><h3 id="3-1-本地部署">3.1 本地部署</h3><p>首先需要在本地进行跑起来，才能成功上云，首先clone若依项目，然后在本地创建数据库，根据<a href="https://gitee.com/y_project/RuoYi-Cloud/tree/v3.6.1/sql" target="_blank" rel="noopener" title="项目数据库文件">项目数据库文件</a>，注<strong>意这里需要自行创建ry-cloud数据库，然后再将quartz和ry表导入，其他两个会自行创建数据库</strong>，然后下载<a href="https://nacos.io/zh-cn/docs/deployment.html" target="_blank" rel="noopener" title="Nacos">Nacos</a>配置中心，进入<code>conf/application.properties</code>，可以直接在文件末尾直接添加</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.platform=mysql</span><br><span class="line">db.num=1</span><br><span class="line">db.url.0=jdbc:mysql://127.0.0.1:3306/ry-config?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=<span class="literal">true</span>&amp;useUnicode=<span class="literal">true</span>&amp;useSSL=<span class="literal">false</span>&amp;serverTimezone=UTC</span><br><span class="line">db.user.0=root</span><br><span class="line">db.password.0=root</span><br></pre></td></tr></table></figure><p>然后进入bin目录<code>startup.cmd -m standalone</code>启动，进入后在配置列表修改所有数据库的账号密码(根据自己账号密码来修改)，最后启动redis即可，然后启动前后端</p><h3 id="3-2-k8s中间件部署">3.2 k8s中间件部署</h3><p>首先创建一个新项目his，然后点击应用负载→服务→创建有状态服务(这样就可以直接自定义DNS域名了)，根据上面情况部署mysql和redis，然后将<a href="https://gitee.com/y_project/RuoYi-Cloud/tree/v3.6.1/sql" target="_blank" rel="noopener" title="数据库文件">数据库文件</a>导入(<strong>注意这里需要自行创建ry-cloud数据库，然后再将quartz和ry表导入，其他两个会自行创建数据库</strong>)；</p><p>其次<a href="https://nacos.io/zh-cn/docs/cluster-mode-quick-start.html" target="_blank" rel="noopener" title="部署nacos集群">部署nacos集群</a>，这里有个问题，nacos集群要设置每个naocs的IP地址，这里就需要进行有状态部署，这样就可以使用<strong>固定域名</strong>进行配置。然后我们需要获取一下固定域名，首先创建多个nacos有状态副本，然后进入nacos服务，获取总的nacos域名，打开随机一个nacos容器进行<code>ping his-nacos.his</code>，这样就可以获取每个nacos的域名规律，比如我的<code>his-nacos-v1-0.his-nacos.his.svc.cluster.local</code>(pod名+服务名+固定)就代表是nacos1</p><p><img src="https://img-blog.csdnimg.cn/eab667cd351d454ba23c6bdb788eab03.png#pic_center" alt="在这里插入图片描述"></p><p>然后正式创建nacos集群，首先需要抽取两个配置文件<code>application.properties</code>(上面粘贴，但是数据库ip换成mysql服务器域名，比如我的<code>his-mysql.his</code>)和<code>cluster.conf</code>(然后选择服务→有状态部署，取名his-nacos，版本v1)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">his-nacos-v1-0.his-nacos.his.svc.cluster.local:8848</span><br><span class="line">his-nacos-v1-1.his-nacos.his.svc.cluster.local:8848</span><br><span class="line">his-nacos-v1-2.his-nacos.his.svc.cluster.local:8848</span><br></pre></td></tr></table></figure><p>然后重新创建nacos，挂载映射路径为<code>/home/nacos/conf/xxx</code>(需要挂载到子路径，否则其他就被覆盖了)，启动三个nacos，然后查看日志，成功暴露一下外部service，最后登录尝试<code>http://192.168.249.146:32735/nacos/</code>，然后修改里面mysql和redis的连接ip，换成DNS域名，同时账号密码设置一下。这里集群模式的话需要版本v2.1.0，也可以直接单节点模式启动(单节点增加环境变量<code>MODE=standalone</code>，如果集群的话需要增加环境变量<code>PREFER_HOST_MODE=hostname</code>，具体可以参考<a href="https://hub.docker.com/r/nacos/nacos-server" target="_blank" rel="noopener" title="nacos dockerhub">nacos dockerhub</a>)</p><h3 id="3-3-微服务层部署">3.3 微服务层部署</h3><p>下面的Dockerfile文件需要放置在每一个项目根目录，方便打包，官方可以参考：<a href="https://gitee.com/y_project/RuoYi-Cloud/tree/v3.6.1/docker" target="_blank" rel="noopener" title="https://gitee.com/y_project/RuoYi-Cloud/tree/v3.6.1/docker">https://gitee.com/y_project/RuoYi-Cloud/tree/v3.6.1/docker</a></p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 规则：</span></span><br><span class="line"><span class="comment"># 容器默认以8080端口启动</span></span><br><span class="line"><span class="comment"># 时间为CST</span></span><br><span class="line"><span class="comment"># 环境变量 PARAMS 可以动态指定配置文件中任意的值</span></span><br><span class="line"><span class="comment"># nacos集群内地址为  his-nacos.his:8848 </span></span><br><span class="line"><span class="comment"># 微服务默认启动加载 nacos中   服务名-激活的环境.yml  文件，所以线上的配置可以全部写在nacos中</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">8</span>-jdk</span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> maintainer=shawn</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意这里要登陆nacos创建prod命名空间。然后将dev的配置文件克隆到prod，同时改dev后缀为prod</span></span><br><span class="line"><span class="comment">#docker run -e PARAMS="--server.port 9090"</span></span><br><span class="line"><span class="keyword">ENV</span> PARAMS=<span class="string">"--server.port=8080 --spring.profiles.active=prod --spring.cloud.nacos.discovery.server-addr=his-nacos.his:8848 --spring.cloud.nacos.config.server-addr=his-nacos.his:8848 --spring.cloud.nacos.config.namespace=prod --spring.cloud.nacos.config.file-extension=yml"</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> /bin/cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp; <span class="built_in">echo</span> <span class="string">'Asia/Shanghai'</span> &gt;/etc/timezone</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> target/*.jar /app.jar</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"/bin/sh"</span>,<span class="string">"-c"</span>,<span class="string">"java -Dfile.encoding=utf8 -Djava.security.egd=file:/dev/./urandom -jar app.jar <span class="variable">$&#123;PARAMS&#125;</span>"</span>]</span></span><br></pre></td></tr></table></figure><p>打包好docker镜像后可以推送到仓库，也可以搭建自己私有仓库Harbor</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">docker login --username=forsum**** registry.cn-hangzhou.aliyuncs.com</span><br><span class="line"></span><br><span class="line"><span class="comment">#把本地镜像，改名，成符合阿里云名字规范的镜像。</span></span><br><span class="line">docker tag [ImageId] registry.cn-hangzhou.aliyuncs.com/lfy_ruoyi/镜像名:[镜像版本号]</span><br><span class="line"><span class="comment">## docker tag 461955fe1e57 registry.cn-hangzhou.aliyuncs.com/lfy_ruoyi/ruoyi-visual-monitor:v1</span></span><br><span class="line"></span><br><span class="line">docker push registry.cn-hangzhou.aliyuncs.com/lfy_ruoyi/镜像名:[镜像版本号]</span><br><span class="line"><span class="comment">## docker push registry.cn-hangzhou.aliyuncs.com/lfy_ruoyi/ruoyi-visual-monitor:v1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ruoyi所有镜像</span></span><br><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com/lfy_ruoyi/ruoyi-auth:v2</span><br><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com/lfy_ruoyi/ruoyi-file:v2</span><br><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com/lfy_ruoyi/ruoyi-gateway:v2</span><br><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com/lfy_ruoyi/ruoyi-job:v2</span><br><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com/lfy_ruoyi/ruoyi-system:v2</span><br><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com/lfy_ruoyi/ruoyi-visual-monitor:v2</span><br><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com/lfy_ruoyi/ruoyi-ui:v2</span><br></pre></td></tr></table></figure><p>然后开始正式部署微服务层，</p><ul><li>应用一启动会获取到 “应用名-激活的环境标识.yml”  </li><li>每次部署应用的时候，需要提前修改nacos线上配置，确认好每个中间件的连接地址是否正确</li></ul><p><img src="https://img-blog.csdnimg.cn/b83ea2a921ee4d5e8a8de9ed96ef7fc3.png#pic_center" alt="在这里插入图片描述"></p><h2 id="4、云原生DevOps实战">4、云原生DevOps实战</h2><h3 id="4-1-环境和中间件准备">4.1 环境和中间件准备</h3><blockquote><p>项目地址：<br><a href="https://gitee.com/leifengyang/yygh-parent" target="_blank" rel="noopener" title="https://gitee.com/leifengyang/yygh-parent">https://gitee.com/leifengyang/yygh-parent</a><br><a href="https://gitee.com/leifengyang/yygh-admin" target="_blank" rel="noopener" title="https://gitee.com/leifengyang/yygh-admin">https://gitee.com/leifengyang/yygh-admin</a><br><a href="https://gitee.com/leifengyang/yygh-site" target="_blank" rel="noopener" title="https://gitee.com/leifengyang/yygh-site">https://gitee.com/leifengyang/yygh-site</a></p></blockquote><p>首先在kubesphere<a href="https://kubesphere.com.cn/docs/v3.3/pluggable-components/devops/" target="_blank" rel="noopener" title="打开devops开关">打开devops开关</a>，在原来his的项目中添加其他中间件，sentienl可以选择leifengyang/sentinel:1.8.2，mongodb/RabbitMQ可以从模板创建，ElasticSearch创建与之前方法类似吗</p><table><thead><tr><th><strong>中间件</strong></th><th><strong>集群内地址</strong></th><th><strong>外部访问地址</strong></th></tr></thead><tbody><tr><td>Nacos</td><td>his-nacos.his:8848</td><td><a href="http://192.168.249.146:30397/nacos" target="_blank" rel="noopener">http://192.168.249.146:30397/nacos</a></td></tr><tr><td>MySQL</td><td>his-mysql.his:3306</td><td>192.168.249.146:31840</td></tr><tr><td>Redis</td><td>his-redis.his:6379</td><td>192.168.249.146:31968</td></tr><tr><td>Sentinel</td><td>his-sentinel.his:8080</td><td><a href="http://192.168.249.146:31229" target="_blank" rel="noopener">http://192.168.249.146:31229</a></td></tr><tr><td>MongoDB</td><td>mongodb.his:27017</td><td>192.168.249.146:30640</td></tr><tr><td>RabbitMQ</td><td>rabbitm-rabbitmq.his:5672</td><td>192.168.249.146:31018</td></tr><tr><td>ElasticSearch</td><td>his-es.his:9200</td><td>192.168.249.146:31300</td></tr></tbody></table><p>然后抽取项目配置，把生产环境分开，项目默认规则 </p><ul><li>每个微服务项目，在生产环境时，会自动获取 微服务名-prod.yml 作为自己的核心配置文件  </li><li>每个微服务项目，在生产环境时，默认都是使用 8080 端口</li></ul><h3 id="4-2-Jenkins构建">4.2 Jenkins构建</h3><blockquote><p><a href="https://www.jenkins.io/zh/doc/" target="_blank" rel="noopener" title="Jenkins官网">Jenkins官网</a><br>构建和部署 Maven 项目参考：<a href="https://kubesphere.io/zh/docs/v3.3/devops-user-guide/examples/a-maven-project/" target="_blank" rel="noopener" title="https://kubesphere.io/zh/docs/v3.3/devops-user-guide/examples/a-maven-project/">https://kubesphere.io/zh/docs/v3.3/devops-user-guide/examples/a-maven-project/</a></p></blockquote><p>首先在企业空间创建DevOps项目(如果一直处于等待状态，可以尝试重启一下docker或者换个密码)，点击进入后创建流水线，编辑流水线，可以先选择一个CI/CD模板，这样就可以看见可视化界面了，然后编辑可视化流水线，最后可以导出Jenkinsfile。这里kubesphere有内置容器和代理，可以参考<a href="https://kubesphere.com.cn/docs/v3.3/devops-user-guide/how-to-use/pipelines/choose-jenkins-agent/" target="_blank" rel="noopener" title="Jenkins代理文档">Jenkins代理文档</a>，然后一步步进行编辑即可。</p><p><strong>第一步拉取代码</strong>，配置好地址和凭证，可以打印一下输出</p><p><img src="https://img-blog.csdnimg.cn/e06727ba4f7146128b66ed786a890314.png#pic_center" alt="在这里插入图片描述"></p><p><strong>第二步项目编译</strong>，maven项目打包，<code>mvn clean package -Dmaven.test.skip=true</code>(如果有弹框要输入，先随便输入)，这里我们可以配置maven加速(已经下载过的jar包，下一次流水线的启动，不会重复下载)</p><ul><li>使用admin登陆ks</li><li>进入集群管理</li><li>进入配置中心</li><li>找到配置ks-devops-agent</li><li>修改这个配置，加入maven阿里云镜像加速地址</li></ul><p><strong>第三步打包Docker镜像</strong>，将每个jar包打包成镜像</p><p><strong>第四步推送最新镜像到镜像仓库</strong>，注意改成自己镜像仓库，这里jenkinsfile可以设置环境变量，然后再推送那里进行变量替换</p><p><strong>第五步进行镜像部署</strong>，注意这一步要创建好kubectl集群凭证和阿里云凭证，然后在每一个项目放置好deploy.yml文件，变量都需要在jenkinsfile里定义好(发布到生产环境可以卡点)</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">hospital-manage</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">hospital-manage</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">his</span>   <span class="comment">#一定要写名称空间</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">progressDeadlineSeconds:</span> <span class="number">600</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">hospital-manage</span></span><br><span class="line">  <span class="attr">strategy:</span></span><br><span class="line">    <span class="attr">rollingUpdate:</span></span><br><span class="line">      <span class="attr">maxSurge:</span> <span class="number">50</span><span class="string">%</span></span><br><span class="line">      <span class="attr">maxUnavailable:</span> <span class="number">50</span><span class="string">%</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">RollingUpdate</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">hospital-manage</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">imagePullSecrets:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">aliyun-docker-hub</span>  <span class="comment">#提前在项目下配置访问阿里云的账号密码</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">$REGISTRY/$ALIYUNHUB_NAMESPACE/hospital-manage:SNAPSHOT-$BUILD_NUMBER</span></span><br><span class="line"> <span class="comment">#         readinessProbe:</span></span><br><span class="line"> <span class="comment">#           httpGet:</span></span><br><span class="line"> <span class="comment">#             path: /actuator/health</span></span><br><span class="line"> <span class="comment">#             port: 8080</span></span><br><span class="line"> <span class="comment">#           timeoutSeconds: 10</span></span><br><span class="line"> <span class="comment">#           failureThreshold: 30</span></span><br><span class="line"> <span class="comment">#           periodSeconds: 5</span></span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">app</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line">              <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">          <span class="attr">resources:</span></span><br><span class="line">            <span class="attr">limits:</span></span><br><span class="line">              <span class="attr">cpu:</span> <span class="string">300m</span></span><br><span class="line">              <span class="attr">memory:</span> <span class="string">600Mi</span></span><br><span class="line">          <span class="attr">terminationMessagePath:</span> <span class="string">/dev/termination-log</span></span><br><span class="line">          <span class="attr">terminationMessagePolicy:</span> <span class="string">File</span></span><br><span class="line">      <span class="attr">dnsPolicy:</span> <span class="string">ClusterFirst</span></span><br><span class="line">      <span class="attr">restartPolicy:</span> <span class="string">Always</span></span><br><span class="line">      <span class="attr">terminationGracePeriodSeconds:</span> <span class="number">30</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">hospital-manage</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">hospital-manage</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">his</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8080</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">hospital-manage</span></span><br><span class="line">  <span class="attr">sessionAffinity:</span> <span class="string">None</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br></pre></td></tr></table></figure><p>jenkinsfile举例，其中几步可以并发构建，自行填写相应信息</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">pipeline</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="string">agent</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="string">node</span> <span class="string">&#123;</span></span><br><span class="line">      <span class="string">label</span> <span class="string">'maven'</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line">  <span class="string">stages</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="string">stage('拉取代码')</span> <span class="string">&#123;</span></span><br><span class="line">      <span class="string">agent</span> <span class="string">none</span></span><br><span class="line">      <span class="string">steps</span> <span class="string">&#123;</span></span><br><span class="line">        <span class="string">container('maven')</span> <span class="string">&#123;</span></span><br><span class="line">          <span class="string">git(url:</span> <span class="string">'https://gitee.com/LXT2017/yygh-parent'</span><span class="string">,</span> <span class="attr">credentialsId:</span> <span class="string">'gitee'</span><span class="string">,</span> <span class="attr">branch:</span> <span class="string">'master'</span><span class="string">,</span> <span class="attr">changelog:</span> <span class="literal">true</span><span class="string">,</span> <span class="attr">poll:</span> <span class="literal">false</span><span class="string">)</span></span><br><span class="line">          <span class="string">sh</span> <span class="string">'ls -la'</span></span><br><span class="line">        <span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line">      <span class="string">&#125;</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">stage('项目编译')</span> <span class="string">&#123;</span></span><br><span class="line">      <span class="string">agent</span> <span class="string">none</span></span><br><span class="line">      <span class="string">steps</span> <span class="string">&#123;</span></span><br><span class="line">        <span class="string">container('maven')</span> <span class="string">&#123;</span></span><br><span class="line">          <span class="string">sh</span> <span class="string">'ls'</span></span><br><span class="line">          <span class="string">sh</span> <span class="string">'mvn clean package -Dmaven.test.skip=true'</span></span><br><span class="line">        <span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="string">sh</span> <span class="string">'ls server-gateway/target'</span></span><br><span class="line">      <span class="string">&#125;</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">stage('default-2')</span> <span class="string">&#123;</span></span><br><span class="line">      <span class="string">parallel</span> <span class="string">&#123;</span></span><br><span class="line">        <span class="string">stage('构建hospital-manage镜像')</span> <span class="string">&#123;</span></span><br><span class="line">          <span class="string">steps</span> <span class="string">&#123;</span></span><br><span class="line">            <span class="string">container('maven')</span> <span class="string">&#123;</span></span><br><span class="line">              <span class="string">sh</span> <span class="string">'ls hospital-manage/target'</span></span><br><span class="line">              <span class="string">sh</span> <span class="string">'docker build -t hospital-manage:latest -f hospital-manage/Dockerfile  ./hospital-manage/'</span></span><br><span class="line">            <span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line">          <span class="string">&#125;</span></span><br><span class="line">        <span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line">      <span class="string">&#125;</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">stage('default-3')</span> <span class="string">&#123;</span></span><br><span class="line">      <span class="string">parallel</span> <span class="string">&#123;</span></span><br><span class="line">        <span class="string">stage('推送hospital-manage镜像')</span> <span class="string">&#123;</span></span><br><span class="line">          <span class="string">agent</span> <span class="string">none</span></span><br><span class="line">          <span class="string">steps</span> <span class="string">&#123;</span></span><br><span class="line">            <span class="string">container('maven')</span> <span class="string">&#123;</span></span><br><span class="line">              <span class="string">withCredentials([usernamePassword(credentialsId</span> <span class="string">:</span> <span class="string">'aliyun-docker'</span> <span class="string">,passwordVariable</span> <span class="string">:</span> <span class="string">'DOCKER_PWD_VAR'</span> <span class="string">,usernameVariable</span> <span class="string">:</span> <span class="string">'DOCKER_USER_VAR'</span> <span class="string">,)])</span> <span class="string">&#123;</span></span><br><span class="line">                <span class="string">sh</span> <span class="string">'echo "$DOCKER_PWD_VAR" | docker login $REGISTRY -u "$DOCKER_USER_VAR" --password-stdin'</span></span><br><span class="line">                <span class="string">sh</span> <span class="string">'docker tag hospital-manage:latest $REGISTRY/$DOCKERHUB_NAMESPACE/hospital-manage:SNAPSHOT-$BUILD_NUMBER'</span></span><br><span class="line">                <span class="string">sh</span> <span class="string">'docker push  $REGISTRY/$DOCKERHUB_NAMESPACE/hospital-manage:SNAPSHOT-$BUILD_NUMBER'</span></span><br><span class="line">              <span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line">            <span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line">          <span class="string">&#125;</span></span><br><span class="line">        <span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line">      <span class="string">&#125;</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">stage('default-4')</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="string">parallel&#123;</span></span><br><span class="line">        <span class="string">stage('hospital-manage</span> <span class="bullet">-</span> <span class="string">部署到dev环境')&#123;</span></span><br><span class="line">             <span class="string">steps</span> <span class="string">&#123;</span></span><br><span class="line">                 <span class="string">container</span> <span class="string">('maven')</span> <span class="string">&#123;</span></span><br><span class="line">                      <span class="string">withCredentials([</span></span><br><span class="line">                          <span class="string">kubeconfigFile(</span></span><br><span class="line">                          <span class="attr">credentialsId:</span> <span class="string">env.KUBECONFIG_CREDENTIAL_ID,</span></span><br><span class="line">                          <span class="attr">variable:</span> <span class="string">'KUBECONFIG'</span><span class="string">)</span></span><br><span class="line">                          <span class="string">])</span> <span class="string">&#123;</span></span><br><span class="line">                          <span class="string">sh</span> <span class="string">'envsubst &lt; hospital-manage/deploy/deploy.yml | kubectl apply -f -'</span></span><br><span class="line">                      <span class="string">&#125;</span></span><br><span class="line">                 <span class="string">&#125;</span></span><br><span class="line">             <span class="string">&#125;</span></span><br><span class="line">        <span class="string">&#125;</span></span><br><span class="line">      <span class="string">&#125;</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line">  <span class="string">environment</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="string">DOCKER_CREDENTIAL_ID</span> <span class="string">=</span> <span class="string">'dockerhub-id'</span></span><br><span class="line">    <span class="string">GITHUB_CREDENTIAL_ID</span> <span class="string">=</span> <span class="string">'github-id'</span></span><br><span class="line">    <span class="string">KUBECONFIG_CREDENTIAL_ID</span> <span class="string">=</span> <span class="string">'demo-kubeconfig'</span></span><br><span class="line">    <span class="string">REGISTRY</span> <span class="string">=</span> <span class="string">'registry.cn-hangzhou.aliyuncs.com'</span></span><br><span class="line">    <span class="string">DOCKERHUB_NAMESPACE</span> <span class="string">=</span> <span class="string">'llxxtt'</span></span><br><span class="line">    <span class="string">GITHUB_ACCOUNT</span> <span class="string">=</span> <span class="string">'kubesphere'</span></span><br><span class="line">    <span class="string">APP_NAME</span> <span class="string">=</span> <span class="string">'devops-java-sample'</span></span><br><span class="line">    <span class="string">ALIYUNHUB_NAMESPACE</span> <span class="string">=</span> <span class="string">'llxxtt'</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line">  <span class="string">parameters</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="string">string(name:</span> <span class="string">'TAG_NAME'</span><span class="string">,</span> <span class="attr">defaultValue:</span> <span class="string">''</span><span class="string">,</span> <span class="attr">description:</span> <span class="string">''</span><span class="string">)</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>最后一步可以添加邮件功能</strong>，kubesphere全局设置在平台设置里配置不同服务(会发生报警监控等)，而流水线的邮件服务可以参考：<a href="https://kubesphere.io/zh/docs/v3.3/devops-user-guide/how-to-use/pipelines/jenkins-email/" target="_blank" rel="noopener" title="为 KubeSphere 流水线设置电子邮件服务器">为 KubeSphere 流水线设置电子邮件服务器</a></p><p>其他模块同理</p><h3 id="4-3-webhook">4.3 webhook</h3><ul><li>每个项目，都有流水线文件(比如创建好连接远程仓库的流水线项目)</li><li>点击流水线，里面谁有webhook地址，可以挂载在远程仓库的webhook</li><li>写代码并提交------&gt; gitee ---------&gt; 给指定的地方发请求（webhook）------&gt; kubesphere平台感知到 -----&gt; 自动启动流水线继续运行</li></ul><hr><p>参考</p><p><a href="https://www.bilibili.com/video/BV13Q4y1C7hS" target="_blank" rel="noopener" title="https://www.bilibili.com/video/BV13Q4y1C7hS">https://www.bilibili.com/video/BV13Q4y1C7hS</a></p><p><a href="https://www.yuque.com/leifengyang/oncloud/" target="_blank" rel="noopener" title="https://www.yuque.com/leifengyang/oncloud/">https://www.yuque.com/leifengyang/oncloud/</a></p>]]></content>
    
    
    <summary type="html">&lt;h1&gt;一、KubeSphere平台安装&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;官网：&lt;a href=&quot;https://kubesphere.com.cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; title=&quot;https://kubesphere.com.cn/&quot;&gt;https://kubesphere.com.cn/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1、Kubernetes上安装KubeSphere&quot;&gt;1、Kubernetes上安装KubeSphere&lt;/h2&gt;
&lt;h3 id=&quot;1-1-安装docker&quot;&gt;1.1 安装docker&lt;/h3&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# centos7.9，建议机器4核8G&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo yum remove docker*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo yum install -y yum-utils&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#配置docker的yum地址&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo yum-config-manager \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;--add-repo \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#安装指定版本&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo yum install -y docker-ce-20.10.7 docker-ce-cli-20.10.7 containerd.io-1.4.6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#  启动&amp;amp;开机启动docker&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;systemctl &lt;span class=&quot;built_in&quot;&gt;enable&lt;/span&gt; docker --now&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# docker加速配置&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo mkdir -p /etc/docker&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo tee /etc/docker/daemon.json &amp;lt;&amp;lt;-&lt;span class=&quot;string&quot;&gt;&#39;EOF&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;string&quot;&gt;&quot;registry-mirrors&quot;&lt;/span&gt;: [&lt;span class=&quot;string&quot;&gt;&quot;https://82m9ar63.mirror.aliyuncs.com&quot;&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;string&quot;&gt;&quot;exec-opts&quot;&lt;/span&gt;: [&lt;span class=&quot;string&quot;&gt;&quot;native.cgroupdriver=systemd&quot;&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;string&quot;&gt;&quot;log-driver&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;json-file&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;string&quot;&gt;&quot;log-opts&quot;&lt;/span&gt;: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;max-size&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;100m&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;string&quot;&gt;&quot;storage-driver&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;overlay2&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;EOF&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo systemctl daemon-reload&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo systemctl restart docker&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.shawn22.xyz/categories/Linux/"/>
    
    
    <category term="K8S" scheme="https://www.shawn22.xyz/tags/K8S/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 1.18学习笔记</title>
    <link href="https://www.shawn22.xyz/posts/3d05dea1.html"/>
    <id>https://www.shawn22.xyz/posts/3d05dea1.html</id>
    <published>2023-03-05T16:15:50.000Z</published>
    <updated>2023-03-05T16:36:30.844Z</updated>
    
    <content type="html"><![CDATA[<h1>一、Kubernetes 概述和架构</h1><h2 id="1、kubernetes-基本介绍">1、kubernetes 基本介绍</h2><p>kubernetes，简称K8s，是用8 代替8 个字符&quot;ubernete&quot;而成的缩写。是一个开源的，用于管理云平台中多个主机上的容器化的应用，Kubernetes 的目标是让部署容器化的应用简单并且高效（powerful）,Kubernetes 提供了应用部署，规划，更新，维护的一种机制。</p><p>传统的应用部署方式是通过插件或脚本来安装应用。这样做的缺点是应用的运行、配置、管理、所有生存周期将与当前操作系统绑定，这样做并不利于应用的升级更新/回滚等操作，当然也可以通过创建虚拟机的方式来实现某些功能，但是虚拟机非常重，并不利于可移植性。新的方式是通过部署容器方式实现，每个容器之间互相隔离，每个容器有自己的文件系统，容器之间进程不会相互影响，能区分计算资源。相对于虚拟机，容器能快速部署，由于容器与底层设施、机器文件系统解耦的</p><ul><li>K8s是谷歌在2014年发布的容器化集群管理系统</li><li>使用k8s进行容器化应用部署</li><li>使用k8s利于应用扩展</li><li>k8s目标实施让部署容器化应用更加简洁和高效</li></ul><a id="more"></a><h2 id="2、Kubernetes-功能">2、Kubernetes 功能</h2><ul><li>自动装箱<ul><li>基于容器对应用运行环境的资源配置要求自动部署应用容器</li></ul></li><li>自我修复<ul><li>当容器失败时，会对容器进行重启</li><li>当所部署的 Node 节点有问题时，会对容器进行重新部署和重新调度</li><li>当容器未通过监控检查时，会关闭此容器直到容器正常运行时，才会对外提供服务</li></ul></li><li><strong>水平扩展</strong><ul><li>通过简单的命令、用户 UI 界面或基于 CPU 等资源使用情况，对应用容器进行规模扩大或规模剪裁</li><li>当我们有大量的请求来临时，我们可以增加副本数量，从而达到水平扩展的效果</li></ul></li><li>服务发现<ul><li>用户不需使用额外的服务发现机制，就能够基于 Kubernetes 自身能力实现服务发现和负载均衡</li></ul></li><li><strong>滚动更新</strong><ul><li>可以根据应用的变化，对应用容器运行的应用，进行一次性或批量式更新</li></ul></li><li><strong>版本回退</strong><ul><li>可以根据应用部署情况，对应用容器运行的应用，进行历史版本即时回退</li></ul></li><li><strong>密钥和配置管理</strong><ul><li>在不需要重新构建镜像的情况下，可以部署和更新密钥和应用配置，类似热部署。</li></ul></li><li><strong>存储编排</strong><ul><li>自动实现存储系统挂载及应用，特别对有状态应用实现数据持久化非常重要</li><li>存储系统可以来自于本地目录、网络存储 (NFS、Gluster、Ceph 等）、公共云存储服务</li></ul></li><li><strong>批处理</strong><ul><li>提供一次性任务，定时任务；满足批量数据处理和分析的场景</li></ul></li></ul><h2 id="3、Kubernetes-架构组件">3、Kubernetes 架构组件</h2><p><img src="https://img-blog.csdnimg.cn/4f8ab49e73f04d208f4d29d1054f44f1.png#pic_center" alt="在这里插入图片描述"></p><p><strong>Master：主控节点</strong></p><ul><li>API Server：集群统一入口，以 restful 风格进行操作，同时交给 etcd 存储<ul><li>提供认证、授权、访问控制、API 注册和发现等机制</li></ul></li><li>scheduler：节点的调度，选择 node 节点应用部署</li><li>controller-manager：处理集群中常规后台任务，一个资源对应一个控制器</li><li>etcd：存储系统，用于保存集群中的相关数据</li></ul><p><strong>Worker node：工作节点</strong></p><ul><li>Kubelet：master 派到 node 节点代表，管理本机容器<ul><li>一个集群中每个节点上运行的代理，它保证容器都运行在 Pod 中</li><li>负责维护容器的生命周期，同时也负责 Volume(CSI) 和 网络 (CNI) 的管理</li></ul></li><li>kube-proxy：提供网络代理，负载均衡等操作</li></ul><p><strong>容器运行环境【Container Runtime】</strong></p><ul><li>容器运行环境是负责运行容器的软件</li><li>Kubernetes 支持多个容器运行环境：Docker、containerd、cri-o、rktlet 以及任何实现 Kubernetes CRI （容器运行环境接口） 的软件。</li></ul><p><strong>fluentd：是一个守护进程，它有助于提升集群层面日志</strong></p><h2 id="4、Kubernetes-核心概念">4、Kubernetes 核心概念</h2><p><strong>Pod</strong></p><ul><li>Pod 是 K8s 中最小的单元</li><li>一组容器的集合</li><li>共享网络【一个 Pod 中的所有容器共享同一网络】</li><li>生命周期是短暂的（服务器重启后，就找不到了）</li></ul><p><strong>Volume</strong></p><ul><li>声明在 Pod 容器中可访问的文件目录</li><li>可以被挂载到 Pod 中一个或多个容器指定路径下</li><li>支持多种后端存储抽象【本地存储、分布式存储、云存储】</li></ul><p><strong>Controller</strong></p><ul><li>确保预期的 pod 副本数量【ReplicaSet】</li><li>无状态应用部署【Deployment】<ul><li>无状态就是指，不需要依赖于网络或者 ip</li></ul></li><li>有状态应用部署【StatefulSet】<ul><li>有状态需要特定的条件</li></ul></li><li>确保所有的 node 运行同一个 pod 【DaemonSet】</li><li>一次性任务和定时任务【Job 和 CronJob】</li></ul><p><strong>Deployment</strong></p><ul><li>定义一组 Pod 副本数目，版本等</li><li>通过控制器【Controller】维持 Pod 数目【自动回复失败的 Pod】</li><li>通过控制器以指定的策略控制版本【滚动升级、回滚等】</li></ul><p><strong>Service</strong></p><ul><li>定义一组 pod 的访问规则</li><li>Pod 的负载均衡，提供一个或多个 Pod 的稳定访问地址</li><li>支持多种方式【ClusterIP、NodePort、LoadBalancer】</li></ul><p><strong>Label</strong></p><ul><li>label：标签，用于对象资源查询，筛选</li></ul><p><strong>Namespace</strong></p><ul><li>命名空间，逻辑隔离</li><li>一个集群内部的逻辑隔离机制【鉴权、资源】</li><li>每个资源都属于一个 namespace</li><li>同一个 namespace 所有资源不能重复</li><li>不同 namespace 可以资源名重复</li></ul><p><strong>API</strong></p><ul><li>我们通过 Kubernetes 的 API 来操作整个集群</li><li>同时我们可以通过 kubectl 、ui、curl 最终发送 http + json/yaml 方式的请求给 API Server，然后控制整个 K8S 集群，K8S 中所有的资源对象都可以采用 yaml 或 json 格式的文件定义或描述</li></ul><h2 id="5、Kubernetes-工作原理">5、Kubernetes 工作原理</h2><p><img src="https://img-blog.csdnimg.cn/f8632ce4fac045dd899be4b2d2b1361d.png#pic_center" alt="在这里插入图片描述"></p><h1>二、Kubernetes 集群搭建</h1><h2 id="1、系统环境准备">1、系统环境准备</h2><h3 id="1-1-安装要求">1.1 安装要求</h3><p>在开始之前，部署 Kubernetes 集群机器需要满足以下几个条件：</p><ul><li>一台或多台机器，操作系统 CentOS7.x-86_x64</li><li>硬件配置：2GB 或更多 RAM，2 个 CPU 或更多 CPU，硬盘 30GB 或更多【注意】【<strong>master 需要两核</strong>】</li><li>可以访问外网，需要拉取镜像，如果服务器不能上网，需要提前下载镜像并导入节点</li><li>禁止 swap 分区</li></ul><h3 id="1-2-系统初始化">1.2 系统初始化</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭防火墙</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line"><span class="comment"># 禁用 firewalld 服务</span></span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld</span><br><span class="line"></span><br><span class="line"><span class="comment">#安装网络工具</span></span><br><span class="line">yum install net-tools -y</span><br><span class="line"><span class="comment">#查看端口</span></span><br><span class="line">netstat -tunlp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭 selinux</span></span><br><span class="line"><span class="comment"># 临时关闭【立即生效】告警，不启用，Permissive，查看使用 getenforce 命令</span></span><br><span class="line">setenforce 0  </span><br><span class="line"><span class="comment"># 永久关闭【重启生效】</span></span><br><span class="line">sed -i <span class="string">'s/SELINUX=enforcing/\SELINUX=disabled/'</span> /etc/selinux/config  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭 swap</span></span><br><span class="line"><span class="comment"># 临时关闭【立即生效】查看使用 free 命令</span></span><br><span class="line">swapoff -a </span><br><span class="line"><span class="comment"># 永久关闭【重启生效】</span></span><br><span class="line">sed -ri <span class="string">'s/.*swap.*/#&amp;/'</span> /etc/fstab</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在主机名静态查询表中添加 3 台主机</span></span><br><span class="line">cat &gt;&gt; /etc/hosts &lt;&lt; EOF</span><br><span class="line">192.168.249.146 k8smaster</span><br><span class="line">192.168.249.147 k8snode1</span><br><span class="line">192.168.249.148 k8snode2</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将桥接的 IPv4 流量传递到 iptables 的链</span></span><br><span class="line">cat &gt; /etc/sysctl.d/k8s.conf &lt;&lt; EOF</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">EOF</span><br><span class="line"><span class="comment"># 使 k8s 配置生效</span></span><br><span class="line">sysctl --system</span><br><span class="line"></span><br><span class="line"><span class="comment"># 时间同步</span></span><br><span class="line">yum install ntpdate -y</span><br><span class="line">ntpdate time.windows.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据规划设置主机名【k8smaster 节点上操作】</span></span><br><span class="line">hostnamectl <span class="built_in">set</span>-hostname k8smaster</span><br><span class="line"><span class="comment"># 根据规划设置主机名【k8snode1 节点上操作】</span></span><br><span class="line">hostnamectl <span class="built_in">set</span>-hostname k8snode1</span><br><span class="line"><span class="comment"># 根据规划设置主机名【k8snode2 节点操作】</span></span><br><span class="line">hostnamectl <span class="built_in">set</span>-hostname k8snode2</span><br></pre></td></tr></table></figure><p>还可以设置一下静态ip(<code>cat /etc/sysconfig/network-scripts/ifcfg-ens33</code>)，以及开机自启网卡（可以使用DHCP，不影响），网段可以在<strong>虚拟网络编辑器</strong>进行编辑</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">TYPE=<span class="string">"Ethernet"</span></span><br><span class="line">PROXY_METHOD=<span class="string">"none"</span></span><br><span class="line">BROWSER_ONLY=<span class="string">"no"</span></span><br><span class="line">BOOTPROTO=<span class="string">"static"</span>              <span class="comment"># 静态ip开启</span></span><br><span class="line">IPADDR=<span class="string">"192.168.249.146"</span>        <span class="comment"># 设置的静态IP地址</span></span><br><span class="line">NETMASK=<span class="string">"255.255.255.0"</span>         <span class="comment"># 子网掩码</span></span><br><span class="line">GATEWAY=<span class="string">"192.168.249.2"</span>         <span class="comment"># 网关地址</span></span><br><span class="line">DNS1=<span class="string">"192.168.249.2"</span>            <span class="comment"># DNS服务器</span></span><br><span class="line">DEFROUTE=<span class="string">"yes"</span></span><br><span class="line">IPV4_FAILURE_FATAL=<span class="string">"no"</span></span><br><span class="line">IPV6INIT=<span class="string">"yes"</span></span><br><span class="line">IPV6_AUTOCONF=<span class="string">"yes"</span></span><br><span class="line">IPV6_DEFROUTE=<span class="string">"yes"</span></span><br><span class="line">IPV6_FAILURE_FATAL=<span class="string">"no"</span></span><br><span class="line">IPV6_ADDR_GEN_MODE=<span class="string">"stable-privacy"</span></span><br><span class="line">NAME=<span class="string">"ens33"</span></span><br><span class="line">UUID=<span class="string">"78250ec9-3095-4140-9e04-e6586d81ba16"</span></span><br><span class="line">DEVICE=<span class="string">"ens33"</span></span><br><span class="line">ONBOOT=<span class="string">"yes"</span>                   <span class="comment"># 开机自启</span></span><br></pre></td></tr></table></figure><p>网络设置完毕后需要重启<code>systemctl restart network</code>，重启完网络服务后ip地址已经发生了改变，此时FinalShell已经连接不上Linux系统，需要创建一个新连接才能连接到Linux</p><h2 id="2、客户端工具kubeadm搭建">2、客户端工具kubeadm搭建</h2><h3 id="2-1-安装步骤">2.1 安装步骤</h3><blockquote><p>kubeadm 是官方社区推出的一个用于快速部署 kubernetes 集群的工具。这个工具能通过两条指令完成一个 kubernetes 集群的部署<br>官方参考：<a href="https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm/" target="_blank" rel="noopener" title="https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm/">https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm/</a></p></blockquote><ul><li>【<strong>环境准备</strong>】准备三台虚拟机，并安装操作系统 CentOS 7.x</li><li>【<strong>系统初始化</strong>】对三个刚安装好的操作系统进行初始化操作</li><li>【<strong>安装工具</strong>】在三个节点安装 <code>docker</code> <code>kubelet</code> <code>kubeadm</code> <code>kubectl</code></li><li>【<strong>集群部署-master</strong>】在 master 节点执行<code>kubeadm init</code>命令初始化</li><li>【<strong>集群部署-node</strong>】在 node 节点上执行 <code>kubeadm join</code>命令，把 node 节点添加到当前集群</li><li>【<strong>安装网络插件</strong>】配置 CNI 网络插件，用于节点之间的连通</li><li>【<strong>测试集群</strong>】通过拉取一个 nginx 进行测试，能否进行外网测试</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个 Master 节点</span></span><br><span class="line">kubeadm init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将一个 Worker node 节点加入到当前集群中</span></span><br><span class="line">kubeadm join &lt;Master 节点的 IP 和端口 &gt;</span><br></pre></td></tr></table></figure><h3 id="2-2-安装组件">2.2 安装组件</h3><p>【所有节点】需要安装以下组件 ，Kubernetes 默认 CRI（容器运行时）为 Docker，因此先安装 Docker，其他操作见上面的系统初始化</p><ul><li>Docker</li><li>kubeadm</li><li>kubelet</li><li>kubectl</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===========================安装docker=============================</span></span><br><span class="line"><span class="comment"># 配置一下 Docker 的 yum 源【阿里云】</span></span><br><span class="line">cat &gt;/etc/yum.repos.d/docker.repo&lt;&lt;EOF</span><br><span class="line">[docker-ce-edge]</span><br><span class="line">name=Docker CE Edge - \<span class="variable">$basearch</span></span><br><span class="line">baseurl=https://mirrors.aliyun.com/docker-ce/linux/centos/7/\<span class="variable">$basearch</span>/edge</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=https://mirrors.aliyun.com/docker-ce/linux/centos/gpg</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后 yum 方式安装 docker，这里为了版本匹配</span></span><br><span class="line">yum -y install docker-ce-18.06.1.ce-3.el7</span><br><span class="line"><span class="comment"># 查看 docker 版本</span></span><br><span class="line">docker --version</span><br><span class="line">systemctl start docker</span><br><span class="line">systemctl <span class="built_in">enable</span> docker</span><br><span class="line">systemctl status docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置 docker 的镜像源【阿里云】</span></span><br><span class="line">cat &gt;/etc/docker/daemon.json &lt;&lt; EOF</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"registry-mirrors"</span>: [<span class="string">"https://b9pmyelo.mirror.aliyuncs.com"</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 docker</span></span><br><span class="line"></span><br><span class="line">systemctl restart docker</span><br><span class="line"><span class="comment"># 查看是否成功</span></span><br><span class="line">docker info</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># =========================安装 kubeadm，kubelet 和 kubectl=================</span></span><br><span class="line"><span class="comment"># 配置 k8s 的 yum 源【阿里云】</span></span><br><span class="line">cat &gt; /etc/yum.repos.d/kubernetes.repo &lt;&lt; EOF</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出该阿里云k8s源，提供那些k8s版本</span></span><br><span class="line">yum list kubeadm --showduplicates</span><br><span class="line"><span class="comment"># 安装 kubelet、kubeadm、kubectl，同时指定版本</span></span><br><span class="line">yum install -y kubelet-1.18.0 kubeadm-1.18.0 kubectl-1.18.0</span><br><span class="line"><span class="comment"># 设置开机自启【这里暂时先不启动 kubelet】</span></span><br><span class="line">systemctl <span class="built_in">enable</span> kubelet</span><br><span class="line"></span><br><span class="line"><span class="comment"># k8s 命令补全</span></span><br><span class="line">yum -y install bash-completion</span><br><span class="line"><span class="built_in">source</span> /usr/share/bash-completion/bash_completion</span><br><span class="line"><span class="built_in">source</span> &lt;(kubectl completion bash)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"source &lt;(kubectl completion bash)"</span> &gt;&gt; ~/.bashrc</span><br></pre></td></tr></table></figure><h3 id="2-3-集群部署">2.3 集群部署</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># master节点执行</span></span><br><span class="line"><span class="comment"># apiserver-advertise-address是masterip</span></span><br><span class="line"><span class="comment"># 由于默认拉取镜像地址 k8s.gcr.io 国内无法访问，这里指定阿里云镜像仓库地址</span></span><br><span class="line"><span class="comment">#【执行命令会比较慢，因为后台其实已经在拉取镜像了】，我们 docker images 命令即可查看已经拉取的镜像</span></span><br><span class="line">kubeadm init \</span><br><span class="line">--apiserver-advertise-address=192.168.249.146 \</span><br><span class="line">--image-repository registry.aliyuncs.com/google_containers \</span><br><span class="line">--kubernetes-version v1.18.0 \</span><br><span class="line">--service-cidr=10.96.0.0/12  \</span><br><span class="line">--pod-network-cidr=10.244.0.0/16</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line">--image-repository                  指定镜像源</span><br><span class="line">--apiserver-advertise-address       masterip地址</span><br><span class="line">--service-cidr                      service ip网段</span><br><span class="line">--pod-network-cidr                  pod网段</span><br><span class="line">--kubernetes-version                指定版本</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 部署成功后，【系统提示】运行以下命令使用 kubectl</span></span><br><span class="line"><span class="comment"># 注意在非root用户</span></span><br><span class="line">mkdir -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) <span class="variable">$HOME</span>/.kube/config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在从节点加入主节点</span></span><br><span class="line">kubeadm join 192.168.249.146:6443 --token nzl3r0.r1skp13wi9vuljbi \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:5d947e66a062c3901f693b98d9d6e271aa42bb2ad2abdd18c37a00e88d47cec4</span><br><span class="line"><span class="comment"># 默认 token 有效期为 24 小时，当过期之后，该 token 就不可用了。这时就需要重新创建 token</span></span><br><span class="line">kubeadm token create --<span class="built_in">print</span>-join-command</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果node节点添加进集群失败，可以删除节点重新添加</span></span><br><span class="line"><span class="comment"># 要删除 ­node1 这个节点，首先在 master 节点上依次执行以下两个命令</span></span><br><span class="line">kubectl drain k8snode1 --delete-local-data --force --ignore-daemonsets</span><br><span class="line">kubectl delete node k8snode1</span><br><span class="line"><span class="comment"># 执行后通过 kubectl get node 命令可以看到 k8snode1已被成功删除，接着在 k8s­node1 这个 Node 节点上执行如下命令，这样该节点即完全从 k8s 集群中脱离开来，之后就可以重新执行命令添加到集群</span></span><br><span class="line">kubeadm reset</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行完成后，我们使用下面命令，查看我们正在运行的节点</span></span><br><span class="line">kubectl get nodes</span><br></pre></td></tr></table></figure><h3 id="2-4-部署-CNI-网络插件">2.4 部署 CNI 网络插件</h3><p>上面的状态还是 NotReady，下面我们需要网络插件，来进行联网访问；<strong>网络插件有两种：flannel和calico</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载网络插件配置</span></span><br><span class="line">wget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span><br><span class="line"><span class="comment"># 执行添加网络插件</span></span><br><span class="line">kubectl apply -f kube-flannel.yml</span><br><span class="line"><span class="comment"># 这里可能会出错，拉取镜像出错，如果出错需要手动将出错的镜像导入，并将其tag为指定标签</span></span><br><span class="line"><span class="comment"># 或者将docker.io/rancher/mirrored-flannelcni-flannel:v0.20.1(两个地方)替换成registry.cn-hangzhou.aliyuncs.com/shawn222/flannel:v0.20.1</span></span><br><span class="line"><span class="comment"># 也可以通过github下载到阿里云，然后从阿里云下载，参考：https://blog.csdn.net/katch/article/details/102575084</span></span><br><span class="line"><span class="comment"># 查看状态 【kube-system 是 k8s 中的最小单元】</span></span><br><span class="line">kubectl get pods -n kube-system</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最后或者直接换网络插件</span></span><br><span class="line">kubectl apply -f https://docs.projectcalico.org/manifests/calico.yaml</span><br><span class="line"><span class="comment"># 运行后的结果为 Ready 状态</span></span><br><span class="line">kubectl get nodes -owide</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有的详细信息</span></span><br><span class="line">kubectl get pod -A -owide</span><br><span class="line"><span class="comment"># 查看某一个容器详细运行状态，-n后跟的是命名空间，排查错误用</span></span><br><span class="line">kubectl describe pod kube-flannel-ds-wclwt -n kube-flannel</span><br><span class="line"><span class="comment"># 查看日志</span></span><br><span class="line">kubectl logs -f --tail 200 -n kube-flannel kube-flannel-ds-5bmpl</span><br></pre></td></tr></table></figure><p>手动导入yaml文件后通过查看日志发现镜像无法拉取，于是手动拉取导入，然后用tag打上与yml文件中的镜像一模一样的名字，这里我每个结点都是这样操作（按理说会自动同步过去其他结点，但是每个结点都报错了，所以我手动下载了；当然换个国内源也可以）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载地址</span></span><br><span class="line">https://github.com/flannel-io/flannel</span><br><span class="line"><span class="comment"># 比如yml中写的是docker.io/rancher/mirrored-flannelcni-flannel:v0.20.0，首先下载对应的包</span></span><br><span class="line">docker load &lt; flanneld-v0.20.0-amd64.docker</span><br><span class="line"><span class="comment"># 查看一下</span></span><br><span class="line">sudo docker images</span><br><span class="line"><span class="comment"># 找到对应的镜像打上对应标签</span></span><br><span class="line">sudo docker tag quay.io/coreos/flannel:v0.20.0-amd64 docker.io/rancher/mirrored-flannelcni-flannel:v0.20.0</span><br></pre></td></tr></table></figure><h3 id="2-5-测试集群">2.5 测试集群</h3><p>在 Kubernetes 集群中创建一个 pod，验证是否正常运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载 nginx 【会联网拉取 nginx 镜像】</span></span><br><span class="line">kubectl create deployment nginx --image=nginx</span><br><span class="line"><span class="comment"># 查看状态</span></span><br><span class="line">kubectl get pod</span><br><span class="line"></span><br><span class="line"><span class="comment"># 暴露端口</span></span><br><span class="line">kubectl expose deployment nginx --port=80 --<span class="built_in">type</span>=NodePort</span><br><span class="line"><span class="comment"># 查看一下对外的端口</span></span><br><span class="line">kubectl get pod,svc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问</span></span><br><span class="line">http://192.168.249.146:31100/</span><br></pre></td></tr></table></figure><h2 id="3、二进制方式搭建">3、二进制方式搭建</h2><blockquote><p>参考：<a href="https://blog.csdn.net/qq_40942490/article/details/114022294" target="_blank" rel="noopener" title="https://blog.csdn.net/qq_40942490/article/details/114022294">https://blog.csdn.net/qq_40942490/article/details/114022294</a></p></blockquote><h3 id="3-1-安装步骤">3.1 安装步骤</h3><ul><li>【<strong>环境准备</strong>】准备三台虚拟机，并安装操作系统 CentOS 7.x</li><li>【<strong>系统初始化</strong>】对三个刚安装好的操作系统进行初始化操作</li><li>【<strong>部署 etcd 集群</strong>】对三个节点安装 etcd</li><li>【<strong>安装 Docker</strong>】对三个节点安装 docker</li><li>【<strong>部署 mastber 组件</strong>】在 master 节点上安装<code>kube-apiserver</code>、<code>kube-controller-manager</code>、<code>kube-scheduler</code></li><li>【<strong>部署 node 组件</strong>】在 node 节点上安装<code>kubelet</code>、<code>kube-proxy</code></li><li>【<strong>安装网络插件</strong>】配置 CNI 网络插件，用于节点之间的连通</li><li>【<strong>测试集群</strong>】通过拉取一个 nginx 进行测试，能否进行外网测试</li></ul><h3 id="3-2-部署-etcd-主节点">3.2 <strong>部署 etcd</strong>(主节点)</h3><p>服务器初始化见上面，这里首先签发证书，让服务器能够正常访问，需要为 etcd 和 apiserver 自签证书</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为 etcd 和 apiserver 自签证书【k8smaster 节点操作】</span></span><br><span class="line"><span class="comment"># 创建工作目录</span></span><br><span class="line">mkdir -p TLS/&#123;etcd,k8s&#125;</span><br><span class="line"><span class="built_in">cd</span> TLS/etcd/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备 cfssl 证书生成工具</span></span><br><span class="line"><span class="comment"># 原地址【下载太慢】 建议迅雷下载，也可以手动下载</span></span><br><span class="line">wget https://pkg.cfssl.org/R1.2/cfssl_linux-amd64</span><br><span class="line">wget https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64</span><br><span class="line">wget https://pkg.cfssl.org/R1.2/cfssl-certinfo_linux-amd64</span><br><span class="line"></span><br><span class="line">chmod +x cfssl_linux-amd64 cfssljson_linux-amd64 cfssl-certinfo_linux-amd64</span><br><span class="line">cp cfssl_linux-amd64 /usr/<span class="built_in">local</span>/bin/cfssl</span><br><span class="line">cp cfssljson_linux-amd64 /usr/<span class="built_in">local</span>/bin/cfssljson</span><br><span class="line">cp cfssl-certinfo_linux-amd64 /usr/<span class="built_in">local</span>/bin/cfssl-certinfo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 【使用自签 CA 生成 etcd 证书】</span></span><br><span class="line"><span class="comment"># 自签 CA</span></span><br><span class="line">cat &gt; ca-config.json&lt;&lt;EOF</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"signing"</span>: &#123;</span><br><span class="line">        <span class="string">"default"</span>: &#123;</span><br><span class="line">            <span class="string">"expiry"</span>: <span class="string">"87600h"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"profiles"</span>: &#123;</span><br><span class="line">            <span class="string">"www"</span>: &#123;</span><br><span class="line">                <span class="string">"expiry"</span>: <span class="string">"87600h"</span>,</span><br><span class="line">                <span class="string">"usages"</span>: [</span><br><span class="line">                    <span class="string">"signing"</span>,</span><br><span class="line">                    <span class="string">"key encipherment"</span>,</span><br><span class="line">                    <span class="string">"server auth"</span>,</span><br><span class="line">                    <span class="string">"client auth"</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">cat &gt; ca-csr.json&lt;&lt;EOF</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"CN"</span>: <span class="string">"etcd CA"</span>,</span><br><span class="line">    <span class="string">"key"</span>: &#123;</span><br><span class="line">        <span class="string">"algo"</span>: <span class="string">"rsa"</span>,</span><br><span class="line">        <span class="string">"size"</span>: 2048</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"names"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"C"</span>: <span class="string">"CN"</span>,</span><br><span class="line">            <span class="string">"L"</span>: <span class="string">"Beijing"</span>,</span><br><span class="line">            <span class="string">"BL"</span>: <span class="string">"Beijing"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 签发 etcd 证书</span></span><br><span class="line">cfssl gencert -initca ca-csr.json | cfssljson -bare ca -</span><br><span class="line">ls *pem</span><br><span class="line"></span><br><span class="line"><span class="comment"># 【使用自签 CA 签发 Etcd HTTPS 证书】</span></span><br><span class="line"><span class="comment"># 自签 CA，创建证书申请文件：（文件 hosts 字段中 IP 为所有 etcd 节点的集群内部通信 IP，一个都不能少！为了 方便后期扩容可以多写几个预留的 IP）</span></span><br><span class="line">cat &gt; server-csr.json &lt;&lt; EOF</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"CN"</span>: <span class="string">"etcd"</span>,</span><br><span class="line">    <span class="string">"hosts"</span>: [</span><br><span class="line">        <span class="string">"192.168.249.146"</span>,</span><br><span class="line">        <span class="string">"192.168.249.147"</span>,</span><br><span class="line">        <span class="string">"192.168.249.148"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"key"</span>: &#123;</span><br><span class="line">        <span class="string">"algo"</span>: <span class="string">"rsa"</span>,</span><br><span class="line">        <span class="string">"size"</span>: 2048</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"name"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"C"</span>: <span class="string">"CN"</span>,</span><br><span class="line">            <span class="string">"L"</span>: <span class="string">"Beijing"</span>,</span><br><span class="line">            <span class="string">"SL"</span>: <span class="string">"Beijing"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 签发 etcd https 证书</span></span><br><span class="line">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=www server-csr.json | cfssljson -bare server</span><br><span class="line">ls server*pem</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载二进制文件</span></span><br><span class="line">wget https://github.com/etcd-io/etcd/releases/download/v3.4.9/etcd-v3.4.9-linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line">mkdir -p /opt/etcd/&#123;bin,cfg,ssl&#125; </span><br><span class="line">tar -zxvf etcd-v3.4.9-linux-amd64.tar.gz</span><br><span class="line">mv etcd-v3.4.9-linux-amd64/&#123;etcd,etcdctl&#125; /opt/etcd/bin/</span><br><span class="line">cp ~/TLS/etcd/ca*pem ~/TLS/etcd/server*pem /opt/etcd/ssl/</span><br></pre></td></tr></table></figure><p>创建配置文件，注意ip地址改成自己的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /opt/etcd/cfg/etcd.conf &lt;&lt; EOF</span><br><span class="line"><span class="comment">#[Member]</span></span><br><span class="line">ETCD_NAME=<span class="string">"etcd-1"</span></span><br><span class="line">ETCD_DATA_DIR=<span class="string">"/var/lib/etcd/default.etcd"</span></span><br><span class="line">ETCD_LISTEN_PEER_URLS=<span class="string">"https://192.168.249.146:2380"</span></span><br><span class="line">ETCD_LISTEN_CLIENT_URLS=<span class="string">"https://192.168.249.146:2379"</span></span><br><span class="line"><span class="comment">#[Clustering]</span></span><br><span class="line">ETCD_INITIAL_ADVERTISE_PEER_URLS=<span class="string">"https://192.168.249.146:2380"</span></span><br><span class="line">ETCD_ADVERTISE_CLIENT_URLS=<span class="string">"https://192.168.249.146:2379"</span></span><br><span class="line">ETCD_INITIAL_CLUSTER=<span class="string">"etcd-1=https://192.168.249.146:2380,etcd-2=https://192.168.249.147:2380,etcd-3=https://192.168.249.148:2380"</span></span><br><span class="line">ETCD_INITIAL_CLUSTER_TOKEN=<span class="string">"etcd-cluster"</span></span><br><span class="line">ETCD_INITIAL_CLUSTER_STATE=<span class="string">"new"</span></span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 名词解释</span></span><br><span class="line"><span class="comment"># ETCD_NAME：节点名称，集群中唯一</span></span><br><span class="line"><span class="comment"># ETCD_DATA_DIR：数据目录</span></span><br><span class="line"><span class="comment"># ETCD_LISTEN_PEER_URLS：集群通信监听地址</span></span><br><span class="line"><span class="comment"># ETCD_LISTEN_CLIENT_URLS：客户端访问监听地址</span></span><br><span class="line"><span class="comment"># ETCD_INITIAL_ADVERTISE_PEER_URLS：集群通告地址</span></span><br><span class="line"><span class="comment"># ETCD_ADVERTISE_CLIENT_URLS：客户端通告地址</span></span><br><span class="line"><span class="comment"># ETCD_INITIAL_CLUSTER：集群节点地址</span></span><br><span class="line"><span class="comment"># ETCD_INITIAL_CLUSTER_TOKEN：集群 Token</span></span><br><span class="line"><span class="comment"># ETCD_INITIAL_CLUSTER_STATE：加入集群的当前状态，new 是新集群，existing 表示加入 已有集群</span></span><br></pre></td></tr></table></figure><p>创建 etcd.service：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /usr/lib/systemd/system/etcd.service &lt;&lt; EOF</span><br><span class="line">[Unit]</span><br><span class="line">Description=Etcd Server</span><br><span class="line">After=network.target</span><br><span class="line">After=network-online.target</span><br><span class="line">Wants=network-online.target</span><br><span class="line">[Service]</span><br><span class="line">Type=notify</span><br><span class="line">EnvironmentFile=/opt/etcd/cfg/etcd.conf</span><br><span class="line">ExecStart=/opt/etcd/bin/etcd \</span><br><span class="line">--cert-file=/opt/etcd/ssl/server.pem \</span><br><span class="line">--key-file=/opt/etcd/ssl/server-key.pem \</span><br><span class="line">--peer-cert-file=/opt/etcd/ssl/server.pem \</span><br><span class="line">--peer-key-file=/opt/etcd/ssl/server-key.pem \</span><br><span class="line">--trusted-ca-file=/opt/etcd/ssl/ca.pem \</span><br><span class="line">--peer-trusted-ca-file=/opt/etcd/ssl/ca.pem \</span><br><span class="line">--logger=zap</span><br><span class="line">Restart=on-failure</span><br><span class="line">LimitNOFILE=65536</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p><strong>转发 etcd 到 node 节点</strong>【k8smaster 节点上操作】【需要输入密码，建议密码设置简单一点】</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">###### 转发到 k8snode1 ######</span></span><br><span class="line">scp -r /opt/etcd/ root@192.168.249.147:/opt/</span><br><span class="line">scp -r /usr/lib/systemd/system/etcd.service root@192.168.249.147:/usr/lib/systemd/system/</span><br><span class="line"><span class="comment">###### 转发到 k8snode2 ######</span></span><br><span class="line">scp -r /opt/etcd/ root@k8snode2:/opt/</span><br><span class="line">scp -r /usr/lib/systemd/system/etcd.service root@k8snode2:/usr/lib/systemd/system/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改 node 节点上 etcd 的配置文件：IP 和名字【k8snode1 和 k8snode2 节点上操作】</span></span><br><span class="line"><span class="comment">##### k8sndoe1 上操作 #####</span></span><br><span class="line">cat &gt; /opt/etcd/cfg/etcd.conf &lt;&lt; EOF</span><br><span class="line"><span class="comment">#[Member]</span></span><br><span class="line">ETCD_NAME=<span class="string">"etcd-2"</span></span><br><span class="line">ETCD_DATA_DIR=<span class="string">"/var/lib/etcd/default.etcd"</span></span><br><span class="line">ETCD_LISTEN_PEER_URLS=<span class="string">"https://192.168.249.147:2380"</span></span><br><span class="line">ETCD_LISTEN_CLIENT_URLS=<span class="string">"https://192.168.249.147:2379"</span></span><br><span class="line"><span class="comment">#[Clustering]</span></span><br><span class="line">ETCD_INITIAL_ADVERTISE_PEER_URLS=<span class="string">"https://192.168.249.147:2380"</span></span><br><span class="line">ETCD_ADVERTISE_CLIENT_URLS=<span class="string">"https://192.168.249.147:2379"</span></span><br><span class="line">ETCD_INITIAL_CLUSTER=<span class="string">"etcd-1=https://192.168.249.146:2380,etcd-2=https://192.168.249.147:2380,etcd-3=https://192.168.249.148:2380"</span></span><br><span class="line">ETCD_INITIAL_CLUSTER_TOKEN=<span class="string">"etcd-cluster"</span></span><br><span class="line">ETCD_INITIAL_CLUSTER_STATE=<span class="string">"new"</span></span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment">##### k8sndoe2 上操作 #####</span></span><br><span class="line">cat &gt; /opt/etcd/cfg/etcd.conf &lt;&lt; EOF</span><br><span class="line"><span class="comment">#[Member]</span></span><br><span class="line">ETCD_NAME=<span class="string">"etcd-3"</span></span><br><span class="line">ETCD_DATA_DIR=<span class="string">"/var/lib/etcd/default.etcd"</span></span><br><span class="line">ETCD_LISTEN_PEER_URLS=<span class="string">"https://192.168.249.148:2380"</span></span><br><span class="line">ETCD_LISTEN_CLIENT_URLS=<span class="string">"https://192.168.249.148:2379"</span></span><br><span class="line"><span class="comment">#[Clustering]</span></span><br><span class="line">ETCD_INITIAL_ADVERTISE_PEER_URLS=<span class="string">"https://192.168.249.148:2380"</span></span><br><span class="line">ETCD_ADVERTISE_CLIENT_URLS=<span class="string">"https://192.168.249.148:2379"</span></span><br><span class="line">ETCD_INITIAL_CLUSTER=<span class="string">"etcd-1=https://192.168.249.146:2380,etcd-2=https://192.168.249.147:2380,etcd-3=https://192.168.249.148:2380"</span></span><br><span class="line">ETCD_INITIAL_CLUSTER_TOKEN=<span class="string">"etcd-cluster"</span></span><br><span class="line">ETCD_INITIAL_CLUSTER_STATE=<span class="string">"existing"</span></span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>启动并设置开机启动：【k8snode1 和 k8snode2 均需一起启动】</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start etcd</span><br><span class="line">systemctl <span class="built_in">enable</span> etcd</span><br><span class="line"><span class="comment"># 查看集群状态</span></span><br><span class="line">/opt/etcd/bin/etcdctl --cacert=/opt/etcd/ssl/ca.pem --cert=/opt/etcd/ssl/server.pem \</span><br><span class="line">--key=/opt/etcd/ssl/server-key.pem \</span><br><span class="line">--endpoints=<span class="string">"https://192.168.249.146:2379,https://192.168.249.147:2379,https://192.168.249.148:2379"</span> endpoint status \</span><br><span class="line">--write-out=table</span><br></pre></td></tr></table></figure><h3 id="3-3-安装-docker">3.3 安装 docker</h3><p>在所有节点操作。这里采用二进制安装，用 yum 安装也一样 （多台节点安装可以采用键盘工具）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/TLS</span><br><span class="line">wget https://download.docker.com/linux/static/stable/x86_64/docker-20.10.3.tgz</span><br><span class="line">tar -zxvf docker-20.10.3.tgz</span><br><span class="line">cp docker/* /usr/bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># systemd 管理 docker</span></span><br><span class="line">cat &gt; /usr/lib/systemd/system/docker.service &lt;&lt; EOF</span><br><span class="line">[Unit]</span><br><span class="line">Description=Docker Application Container Engine</span><br><span class="line">Documentation=https://docs.docker.com</span><br><span class="line">After=network-online.target firewalld.service</span><br><span class="line">Wants=network-online.target</span><br><span class="line">[Service]</span><br><span class="line">Type=notify</span><br><span class="line">ExecStart=/usr/bin/dockerd</span><br><span class="line">ExecReload=/bin/<span class="built_in">kill</span> -s HUP <span class="variable">$MAINPID</span></span><br><span class="line">LimitNOFILE=infinity</span><br><span class="line">LimitNPROC=infinity</span><br><span class="line">LimitCORE=infinity</span><br><span class="line">TimeoutStartSec=0</span><br><span class="line">Delegate=yes</span><br><span class="line">KillMode=process</span><br><span class="line">Restart=on-failure</span><br><span class="line">StartLimitBurst=3</span><br><span class="line">StartLimitInterval=60s</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置阿里云加速</span></span><br><span class="line">mkdir /etc/docker</span><br><span class="line">cat &gt; /etc/docker/daemon.json &lt;&lt; EOF</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"registry-mirrors"</span>: [<span class="string">"https://b9pmyelo.mirror.aliyuncs.com"</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置开机启动</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start docker</span><br><span class="line">systemctl <span class="built_in">enable</span> docker</span><br><span class="line">systemctl status docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 【k8smaster 节点安装 docker 完毕！转发到 k8snode1 和 k8snode2 节点】【k8smaster 节点上操作】</span></span><br><span class="line"><span class="comment">##### 转发到 k8snode1 #####</span></span><br><span class="line">scp -r docker/* root@k8snode1:/usr/bin/</span><br><span class="line">scp -r /usr/lib/systemd/system/docker.service root@k8snode1:/usr/lib/systemd/system/</span><br><span class="line">scp -r /etc/docker/ root@k8snode1:/etc/</span><br><span class="line"><span class="comment">##### 转发到 k8snode2 #####</span></span><br><span class="line">scp -r docker/* root@k8snode2:/usr/bin/</span><br><span class="line">scp -r /usr/lib/systemd/system/docker.service root@k8snode2:/usr/lib/systemd/system/</span><br><span class="line">scp -r /etc/docker/ root@k8snode2:/etc/</span><br></pre></td></tr></table></figure><h3 id="3-4-部署-master-组件">3.4 部署 master 组件</h3><ul><li>kube-apiserver</li><li>kuber-controller-manager</li><li>kube-scheduler</li></ul><p>首先进行apiserver自签证书(添加可信任ip列表方式)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 【生成 kube-apiserver 证书】</span></span><br><span class="line"><span class="comment"># 自签证书颁发机构 CA</span></span><br><span class="line"><span class="built_in">cd</span> ~/TLS/k8s</span><br><span class="line"></span><br><span class="line">cat &gt; ca-config.json &lt;&lt; EOF</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"signing"</span>: &#123;</span><br><span class="line">    <span class="string">"default"</span>: &#123;</span><br><span class="line">      <span class="string">"expiry"</span>: <span class="string">"87600h"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"profiles"</span>: &#123;</span><br><span class="line">      <span class="string">"kubernetes"</span>: &#123;</span><br><span class="line">         <span class="string">"expiry"</span>: <span class="string">"87600h"</span>,</span><br><span class="line">         <span class="string">"usages"</span>: [</span><br><span class="line">            <span class="string">"signing"</span>,</span><br><span class="line">            <span class="string">"key encipherment"</span>,</span><br><span class="line">            <span class="string">"server auth"</span>,</span><br><span class="line">            <span class="string">"client auth"</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">cat &gt; ca-csr.json &lt;&lt; EOF</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"CN"</span>: <span class="string">"kubernetes"</span>,</span><br><span class="line">    <span class="string">"key"</span>: &#123;</span><br><span class="line">        <span class="string">"algo"</span>: <span class="string">"rsa"</span>,</span><br><span class="line">        <span class="string">"size"</span>: 2048</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"names"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"C"</span>: <span class="string">"CN"</span>,</span><br><span class="line">            <span class="string">"L"</span>: <span class="string">"Beijing"</span>,</span><br><span class="line">            <span class="string">"ST"</span>: <span class="string">"Beijing"</span>,</span><br><span class="line">            <span class="string">"O"</span>: <span class="string">"k8s"</span>,</span><br><span class="line">            <span class="string">"OU"</span>: <span class="string">"System"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成 kube-apiserver 证书</span></span><br><span class="line">cfssl gencert -initca ca-csr.json | cfssljson -bare ca -</span><br><span class="line">ls *pem</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 【使用自签 CA 签发 kube-apiserver HTTPS 证书】</span></span><br><span class="line"><span class="comment"># 创建证书申请文件，注意自己添加可信任的ip</span></span><br><span class="line">cat &gt; server-csr.json &lt;&lt; EOF</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"CN"</span>: <span class="string">"kubernetes"</span>,</span><br><span class="line">    <span class="string">"hosts"</span>: [</span><br><span class="line">      <span class="string">"10.0.0.1"</span>,</span><br><span class="line">      <span class="string">"127.0.0.1"</span>,</span><br><span class="line">      <span class="string">"192.168.249.147"</span>,</span><br><span class="line">      <span class="string">"192.168.249.148"</span>,</span><br><span class="line">      <span class="string">"192.168.249.146"</span>,</span><br><span class="line">      <span class="string">"192.168.249.2"</span>,</span><br><span class="line">      <span class="string">"kubernetes"</span>,</span><br><span class="line">      <span class="string">"kubernetes.default"</span>,</span><br><span class="line">      <span class="string">"kubernetes.default.svc"</span>,</span><br><span class="line">      <span class="string">"kubernetes.default.svc.cluster"</span>,</span><br><span class="line">      <span class="string">"kubernetes.default.svc.cluster.local"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"key"</span>: &#123;</span><br><span class="line">        <span class="string">"algo"</span>: <span class="string">"rsa"</span>,</span><br><span class="line">        <span class="string">"size"</span>: 2048</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"names"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"C"</span>: <span class="string">"CN"</span>,</span><br><span class="line">            <span class="string">"L"</span>: <span class="string">"BeiJing"</span>,</span><br><span class="line">            <span class="string">"ST"</span>: <span class="string">"BeiJing"</span>,</span><br><span class="line">            <span class="string">"O"</span>: <span class="string">"k8s"</span>,</span><br><span class="line">            <span class="string">"OU"</span>: <span class="string">"System"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成 kube-apiserver https 证书</span></span><br><span class="line">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes server-csr.json | cfssljson -bare server</span><br><span class="line">ls server*pem</span><br></pre></td></tr></table></figure><p><strong>安装 kube-apiserver</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载二进制包</span></span><br><span class="line"><span class="comment"># 下载地址：https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG/CHANGELOG-1.20.md</span></span><br><span class="line"><span class="comment"># kubernetes-server-linux-amd64.tar.gz 包含了 master 和 node 的所有组件</span></span><br><span class="line"><span class="comment"># 这里提供几个下载地址，1.20.1启动需要额外参数</span></span><br><span class="line"><span class="comment"># wget https://storage.googleapis.com/kubernetes-release/release/v1.20.1/kubernetes-server-linux-amd64.tar.gz</span></span><br><span class="line">wget https://dl.k8s.io/v1.19.0/kubernetes-server-linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压二进制包</span></span><br><span class="line">mkdir -p /opt/kubernetes/&#123;bin,cfg,ssl,logs&#125;</span><br><span class="line">tar -zxvf kubernetes-server-linux-amd64.tar.gz</span><br><span class="line"><span class="built_in">cd</span> kubernetes/server/bin</span><br><span class="line">cp kube-apiserver kube-scheduler kube-controller-manager /opt/kubernetes/bin</span><br><span class="line">cp kubectl /usr/bin/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成 kube-apiserver 配置文件</span></span><br><span class="line">cat &gt; /opt/kubernetes/cfg/kube-apiserver.conf &lt;&lt; EOF</span><br><span class="line">KUBE_APISERVER_OPTS=<span class="string">"--logtostderr=false \\</span></span><br><span class="line"><span class="string">--v=2 \\</span></span><br><span class="line"><span class="string">--log-dir=/opt/kubernetes/logs \\</span></span><br><span class="line"><span class="string">--etcd-servers=https://192.168.249.146:2379,https://192.168.249.147:2379,https://192.168.249.148:2379 \\</span></span><br><span class="line"><span class="string">--bind-address=192.168.249.146 \\</span></span><br><span class="line"><span class="string">--secure-port=6443 \\</span></span><br><span class="line"><span class="string">--advertise-address=192.168.249.146 \\</span></span><br><span class="line"><span class="string">--allow-privileged=true \\</span></span><br><span class="line"><span class="string">--service-cluster-ip-range=10.0.0.0/24 \\</span></span><br><span class="line"><span class="string">--enable-admission-plugins=NamespaceLifecycle,LimitRanger,ServiceAccount,ResourceQuota,NodeRestriction \\</span></span><br><span class="line"><span class="string">--authorization-mode=RBAC,Node \\</span></span><br><span class="line"><span class="string">--enable-bootstrap-token-auth=true \\</span></span><br><span class="line"><span class="string">--token-auth-file=/opt/kubernetes/cfg/token.csv \\</span></span><br><span class="line"><span class="string">--service-node-port-range=30000-32767 \\</span></span><br><span class="line"><span class="string">--kubelet-client-certificate=/opt/kubernetes/ssl/server.pem \\</span></span><br><span class="line"><span class="string">--kubelet-client-key=/opt/kubernetes/ssl/server-key.pem \\</span></span><br><span class="line"><span class="string">--tls-cert-file=/opt/kubernetes/ssl/server.pem  \\</span></span><br><span class="line"><span class="string">--tls-private-key-file=/opt/kubernetes/ssl/server-key.pem \\</span></span><br><span class="line"><span class="string">--client-ca-file=/opt/kubernetes/ssl/ca.pem \\</span></span><br><span class="line"><span class="string">--service-account-key-file=/opt/kubernetes/ssl/ca-key.pem \\</span></span><br><span class="line"><span class="string">--etcd-cafile=/opt/etcd/ssl/ca.pem \\</span></span><br><span class="line"><span class="string">--etcd-certfile=/opt/etcd/ssl/server.pem \\</span></span><br><span class="line"><span class="string">--etcd-keyfile=/opt/etcd/ssl/server-key.pem \\</span></span><br><span class="line"><span class="string">--audit-log-maxage=30 \\</span></span><br><span class="line"><span class="string">--audit-log-maxbackup=3 \\</span></span><br><span class="line"><span class="string">--audit-log-maxsize=100 \\</span></span><br><span class="line"><span class="string">--audit-log-path=/opt/kubernetes/logs/k8s-audit.log"</span></span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注：上面两个\\ 第一个是转义符，第二个是换行符，使用转义符是为了使用 EOF 保留换行符。</span></span><br><span class="line"><span class="comment"># –logtostderr：启用日志</span></span><br><span class="line"><span class="comment"># —v：日志等级</span></span><br><span class="line"><span class="comment"># –log-dir：日志目录</span></span><br><span class="line"><span class="comment"># –etcd-servers：etcd 集群地址</span></span><br><span class="line"><span class="comment"># –bind-address：监听地址</span></span><br><span class="line"><span class="comment"># –secure-port：https 安全端口</span></span><br><span class="line"><span class="comment"># –advertise-address：集群通告地址</span></span><br><span class="line"><span class="comment"># –allow-privileged：启用授权</span></span><br><span class="line"><span class="comment"># –service-cluster-ip-range：Service 虚拟 IP 地址段</span></span><br><span class="line"><span class="comment"># –enable-admission-plugins：准入控制模块</span></span><br><span class="line"><span class="comment"># –authorization-mode：认证授权，启用 RBAC 授权和节点自管理</span></span><br><span class="line"><span class="comment"># –enable-bootstrap-token-auth：启用 TLS bootstrap 机制</span></span><br><span class="line"><span class="comment"># –token-auth-file：bootstrap token 文件</span></span><br><span class="line"><span class="comment"># –service-node-port-range：Service nodeport 类型默认分配端口范围</span></span><br><span class="line"><span class="comment"># –kubelet-client-xxx：apiserver 访问 kubelet 客户端证书</span></span><br><span class="line"><span class="comment"># –tls-xxx-file：apiserver https 证书</span></span><br><span class="line"><span class="comment"># –etcd-xxxfile：连接 Etcd 集群证书</span></span><br><span class="line"><span class="comment"># –audit-log-xxx：审计日志</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把刚生成的证书拷贝到配置文件中的路径</span></span><br><span class="line">cp ~/TLS/k8s/ca*pem ~/TLS/k8s/server*pem /opt/kubernetes/ssl/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建上述文件配置文件中的 token 文件</span></span><br><span class="line"><span class="comment"># 格式：token，用户名，UID，用户组 token 也可自行生成替换【建议暂时不要替换，直接 copy 代码就完事了】</span></span><br><span class="line">head -c 16 /dev/urandom | od -An -t x | tr -d <span class="string">' '</span></span><br><span class="line">cat &gt; /opt/kubernetes/cfg/token.csv &lt;&lt; EOF</span><br><span class="line">c47ffb939f5ca36231d9e3121a252940,kubelet-bootstrap,10001,<span class="string">"system:node-bootstrapper"</span></span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># systemd 管理 apiserver</span></span><br><span class="line">cat &gt; /usr/lib/systemd/system/kube-apiserver.service &lt;&lt; EOF</span><br><span class="line">[Unit]</span><br><span class="line">Description=Kubernetes API Server</span><br><span class="line">Documentation=https://github.com/kubernetes/kubernetes</span><br><span class="line">[Service]</span><br><span class="line">EnvironmentFile=/opt/kubernetes/cfg/kube-apiserver.conf</span><br><span class="line">ExecStart=/opt/kubernetes/bin/kube-apiserver \<span class="variable">$KUBE_APISERVER_OPTS</span></span><br><span class="line">Restart=on-failure</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动并设置开机启动</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start kube-apiserver</span><br><span class="line">systemctl <span class="built_in">enable</span> kube-apiserver</span><br><span class="line">systemctl status kube-apiserver</span><br><span class="line"><span class="comment"># 报错查看一下日志</span></span><br><span class="line">cat /var/<span class="built_in">log</span>/messages|grep kube-apiserver|grep -i error</span><br><span class="line"></span><br><span class="line"><span class="comment"># 授权 kubelet-bootstrap 用户允许请求证书</span></span><br><span class="line">kubectl create clusterrolebinding kubelet-bootstrap \</span><br><span class="line">--clusterrole=system:node-bootstrapper \</span><br><span class="line">--user=kubelet-bootstrap</span><br></pre></td></tr></table></figure><p><strong>部署 kube-controller-manager</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /opt/kubernetes/cfg/kube-controller-manager.conf &lt;&lt; EOF</span><br><span class="line">KUBE_CONTROLLER_MANAGER_OPTS=<span class="string">"--logtostderr=false \\</span></span><br><span class="line"><span class="string">--v=2 \\</span></span><br><span class="line"><span class="string">--log-dir=/opt/kubernetes/logs \\</span></span><br><span class="line"><span class="string">--leader-elect=true \\</span></span><br><span class="line"><span class="string">--master=127.0.0.1:8080 \\</span></span><br><span class="line"><span class="string">--bind-address=127.0.0.1 \\</span></span><br><span class="line"><span class="string">--allocate-node-cidrs=true \\</span></span><br><span class="line"><span class="string">--cluster-cidr=10.244.0.0/16 \\</span></span><br><span class="line"><span class="string">--service-cluster-ip-range=10.0.0.0/24 \\</span></span><br><span class="line"><span class="string">--cluster-signing-cert-file=/opt/kubernetes/ssl/ca.pem \\</span></span><br><span class="line"><span class="string">--cluster-signing-key-file=/opt/kubernetes/ssl/ca-key.pem  \\</span></span><br><span class="line"><span class="string">--root-ca-file=/opt/kubernetes/ssl/ca.pem \\</span></span><br><span class="line"><span class="string">--service-account-private-key-file=/opt/kubernetes/ssl/ca-key.pem \\</span></span><br><span class="line"><span class="string">--experimental-cluster-signing-duration=87600h0m0s"</span></span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># –master：通过本地非安全本地端口 8080 连接 apiserver。</span></span><br><span class="line"><span class="comment"># –leader-elect：当该组件启动多个时，自动选举（HA）</span></span><br><span class="line"><span class="comment"># –cluster-signing-cert-file/–cluster-signing-key-file：自动为 kubelet 颁发证书的 CA，与 apiserver 保持一致</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># systemd 管理 controller-manager</span></span><br><span class="line">cat &gt; /usr/lib/systemd/system/kube-controller-manager.service &lt;&lt; EOF</span><br><span class="line">[Unit]</span><br><span class="line">Description=Kubernetes Controller Manager</span><br><span class="line">Documentation=https://github.com/kubernetes/kubernetes</span><br><span class="line">[Service]</span><br><span class="line">EnvironmentFile=/opt/kubernetes/cfg/kube-controller-manager.conf</span><br><span class="line">ExecStart=/opt/kubernetes/bin/kube-controller-manager \<span class="variable">$KUBE_CONTROLLER_MANAGER_OPTS</span></span><br><span class="line">Restart=on-failure</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动并设置开机启动</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start kube-controller-manager</span><br><span class="line">systemctl <span class="built_in">enable</span> kube-controller-manager</span><br><span class="line">systemctl status kube-controller-manager</span><br></pre></td></tr></table></figure><p><strong>部署 kube-scheduler</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /opt/kubernetes/cfg/kube-scheduler.conf &lt;&lt; EOF</span><br><span class="line">KUBE_SCHEDULER_OPTS=<span class="string">"--logtostderr=false \</span></span><br><span class="line"><span class="string">--v=2 \</span></span><br><span class="line"><span class="string">--log-dir=/opt/kubernetes/logs \</span></span><br><span class="line"><span class="string">--leader-elect \</span></span><br><span class="line"><span class="string">--master=127.0.0.1:8080 \</span></span><br><span class="line"><span class="string">--bind-address=127.0.0.1"</span></span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line"><span class="comment"># –master：通过本地非安全本地端口 8080 连接 apiserver。</span></span><br><span class="line"><span class="comment"># –leader-elect：当该组件启动多个时，自动选举（HA）</span></span><br><span class="line"></span><br><span class="line">cat &gt; /usr/lib/systemd/system/kube-scheduler.service &lt;&lt; EOF</span><br><span class="line">[Unit]</span><br><span class="line">Description=Kubernetes Scheduler</span><br><span class="line">Documentation=https://github.com/kubernetes/kubernetes</span><br><span class="line">[Service]</span><br><span class="line">EnvironmentFile=/opt/kubernetes/cfg/kube-scheduler.conf</span><br><span class="line">ExecStart=/opt/kubernetes/bin/kube-scheduler \<span class="variable">$KUBE_SCHEDULER_OPTS</span></span><br><span class="line">Restart=on-failure</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动并设置开机启动</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start kube-scheduler</span><br><span class="line">systemctl <span class="built_in">enable</span> kube-scheduler</span><br><span class="line">systemctl status kube-scheduler</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#======================查看集群状态====================</span></span><br><span class="line"><span class="comment"># 所有组件都已经启动成功，通过 kubectl 工具查看当前集群组件状态</span></span><br><span class="line">kubectl get cs</span><br></pre></td></tr></table></figure><h3 id="3-5-部署node组件">3.5 部署node组件</h3><ul><li>kubelet</li><li>kube-proxy</li></ul><p><strong>安装 kubelet</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##### k8snode1 节点上操作,注意修改集群的名字，不要重复(这里的m1) #####</span></span><br><span class="line">mkdir -p /opt/kubernetes/&#123;bin,cfg,ssl,logs&#125;</span><br><span class="line"></span><br><span class="line">cat &gt; /opt/kubernetes/cfg/kubelet.conf &lt;&lt; EOF</span><br><span class="line">KUBELET_OPTS=<span class="string">"--logtostderr=false \\</span></span><br><span class="line"><span class="string">--v=2 \\</span></span><br><span class="line"><span class="string">--log-dir=/opt/kubernetes/logs \\</span></span><br><span class="line"><span class="string">--hostname-override=m1 \\</span></span><br><span class="line"><span class="string">--network-plugin=cni \\</span></span><br><span class="line"><span class="string">--kubeconfig=/opt/kubernetes/cfg/kubelet.kubeconfig \\</span></span><br><span class="line"><span class="string">--experimental-bootstrap-kubeconfig=/opt/kubernetes/cfg/bootstrap.kubeconfig \\</span></span><br><span class="line"><span class="string">--config=/opt/kubernetes/cfg/kubelet-config.yml \\</span></span><br><span class="line"><span class="string">--cert-dir=/opt/kubernetes/ssl \\</span></span><br><span class="line"><span class="string">--pod-infra-container-image=lizhenliang/pause-amd64:3.0"</span></span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># –hostname-override：显示名称，集群中唯一</span></span><br><span class="line"><span class="comment"># –network-plugin：启用 CNI</span></span><br><span class="line"><span class="comment"># –kubeconfig：空路径，会自动生成，后面用于连接 apiserver</span></span><br><span class="line"><span class="comment"># –bootstrap-kubeconfig：首次启动向 apiserver 申请证书</span></span><br><span class="line"><span class="comment"># –config：配置参数文件</span></span><br><span class="line"><span class="comment"># –cert-dir：kubelet 证书生成目录</span></span><br><span class="line"><span class="comment"># –pod-infra-container-image：管理 Pod 网络容器的镜像</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cat &gt; /opt/kubernetes/cfg/kubelet-config.yml &lt;&lt; EOF</span><br><span class="line">kind: KubeletConfiguration</span><br><span class="line">apiVersion: kubelet.config.k8s.io/v1beta1</span><br><span class="line">address: 0.0.0.0</span><br><span class="line">port: 10250</span><br><span class="line">readOnlyPort: 10255</span><br><span class="line">cgroupDriver: cgroupfs</span><br><span class="line">clusterDNS:</span><br><span class="line">- 10.0.0.2</span><br><span class="line">clusterDomain: cluster.local </span><br><span class="line">failSwapOn: <span class="literal">false</span></span><br><span class="line">authentication:</span><br><span class="line">  anonymous:</span><br><span class="line">    enabled: <span class="literal">false</span></span><br><span class="line">  webhook:</span><br><span class="line">    cacheTTL: 2m0s</span><br><span class="line">    enabled: <span class="literal">true</span></span><br><span class="line">  x509:</span><br><span class="line">    clientCAFile: /opt/kubernetes/ssl/ca.pem </span><br><span class="line">authorization:</span><br><span class="line">  mode: Webhook</span><br><span class="line">  webhook:</span><br><span class="line">    cacheAuthorizedTTL: 5m0s</span><br><span class="line">    cacheUnauthorizedTTL: 30s</span><br><span class="line">evictionHard:</span><br><span class="line">  imagefs.available: 15%</span><br><span class="line">  memory.available: 100Mi</span><br><span class="line">  nodefs.available: 10%</span><br><span class="line">  nodefs.inodesFree: 5%</span><br><span class="line">maxOpenFiles: 1000000</span><br><span class="line">maxPods: 110</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 k8smaster 节点的 bin 文件和证书拷贝到 k8snode1 和 k8snode2 节点上【k8smaster 节点操作】</span></span><br><span class="line"><span class="built_in">cd</span> ~/kubernetes/server/bin</span><br><span class="line"></span><br><span class="line"><span class="comment">##### 转发到 k8snode1 #####</span></span><br><span class="line">scp -r &#123;kubelet,kube-proxy&#125; root@k8snode1:/opt/kubernetes/bin/</span><br><span class="line">scp -r /usr/bin/kubectl root@k8snode1:/usr/bin/</span><br><span class="line">scp -r /opt/kubernetes/ssl root@k8snode1:/opt/kubernetes</span><br><span class="line"></span><br><span class="line"><span class="comment">##### 转发到 k8snode2 #####</span></span><br><span class="line">scp -r &#123;kubelet,kube-proxy&#125; root@k8snode2:/opt/kubernetes/bin/</span><br><span class="line">scp -r /usr/bin/kubectl root@k8snode2:/usr/bin/</span><br><span class="line">scp -r /opt/kubernetes/ssl root@k8snode2:/opt/kubernetes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成 bootstrap.kubeconfig 文件</span></span><br><span class="line"><span class="comment"># apiserver IP:PORT</span></span><br><span class="line">KUBE_APISERVER=<span class="string">"https://192.168.249.146:6443"</span> </span><br><span class="line"><span class="comment"># 与 token.csv 里保持一致</span></span><br><span class="line">TOKEN=<span class="string">"c47ffb939f5ca36231d9e3121a252940"</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成 kubelet bootstrap kubeconfig 配置文件</span></span><br><span class="line">kubectl config <span class="built_in">set</span>-cluster kubernetes \</span><br><span class="line">  --certificate-authority=/opt/kubernetes/ssl/ca.pem \</span><br><span class="line">  --embed-certs=<span class="literal">true</span> \</span><br><span class="line">  --server=<span class="variable">$&#123;KUBE_APISERVER&#125;</span> \</span><br><span class="line">  --kubeconfig=bootstrap.kubeconfig</span><br><span class="line">kubectl config <span class="built_in">set</span>-credentials <span class="string">"kubelet-bootstrap"</span> \</span><br><span class="line">  --token=<span class="variable">$&#123;TOKEN&#125;</span> \</span><br><span class="line">  --kubeconfig=bootstrap.kubeconfig</span><br><span class="line">kubectl config <span class="built_in">set</span>-context default \</span><br><span class="line">  --cluster=kubernetes \</span><br><span class="line">  --user=<span class="string">"kubelet-bootstrap"</span> \</span><br><span class="line">  --kubeconfig=bootstrap.kubeconfig</span><br><span class="line">kubectl config use-context default --kubeconfig=bootstrap.kubeconfig</span><br><span class="line"></span><br><span class="line">mv bootstrap.kubeconfig /opt/kubernetes/cfg</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># systemd 管理 kubelet</span></span><br><span class="line">cat &gt; /usr/lib/systemd/system/kubelet.service &lt;&lt; EOF</span><br><span class="line">[Unit]</span><br><span class="line">Description=Kubernetes Kubelet</span><br><span class="line">After=docker.service</span><br><span class="line">[Service]</span><br><span class="line">EnvironmentFile=/opt/kubernetes/cfg/kubelet.conf</span><br><span class="line">ExecStart=/opt/kubernetes/bin/kubelet \<span class="variable">$KUBELET_OPTS</span></span><br><span class="line">Restart=on-failure</span><br><span class="line">LimitNOFILE=65536</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动并设置开机启动</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start kubelet</span><br><span class="line">systemctl <span class="built_in">enable</span> kubelet</span><br><span class="line">systemctl status kubelet</span><br><span class="line"></span><br><span class="line"><span class="comment"># 批准 kubelet 证书申请并加入集群【k8smaster 节点操作】</span></span><br><span class="line"><span class="comment"># 查看 kubelet 证书请求</span></span><br><span class="line">kubectl get csr</span><br><span class="line"><span class="comment">###    输出结果</span></span><br><span class="line"><span class="comment">###    NAME                                                   AGE    SIGNERNAME                                    REQUESTOR           CONDITION</span></span><br><span class="line"><span class="comment">###    node-csr-uCEGPOIiDdlLODKts8J658HrFq9CZ--K6M4G7bjhk8A   6m3s   kubernetes.io/kube-apiserver-client-kubelet   kubelet-bootstrap   Pending</span></span><br><span class="line"><span class="comment"># 批准申请</span></span><br><span class="line">kubectl certificate approve node-csr-uCEGPOIiDdlLODKts8J658HrFq9CZ--K6M4G7bjhk8A</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看节点,由于网络插件还没有部署，节点会没有准备就绪 NotReady</span></span><br><span class="line">kubectl get node</span><br></pre></td></tr></table></figure><p><strong>部署 kube-proxy</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以下在node1和node2创建</span></span><br><span class="line">cat &gt; /opt/kubernetes/cfg/kube-proxy.conf &lt;&lt; EOF</span><br><span class="line">KUBE_PROXY_OPTS=<span class="string">"--logtostderr=false \\</span></span><br><span class="line"><span class="string">--v=2 \\</span></span><br><span class="line"><span class="string">--log-dir=/opt/kubernetes/logs \\</span></span><br><span class="line"><span class="string">--config=/opt/kubernetes/cfg/kube-proxy-config.yml"</span></span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">cat &gt; /opt/kubernetes/cfg/kube-proxy-config.yml &lt;&lt; EOF</span><br><span class="line">kind: KubeProxyConfiguration</span><br><span class="line">apiVersion: kubeproxy.config.k8s.io/v1alpha1</span><br><span class="line">bindAddress: 0.0.0.0</span><br><span class="line">metricsBindAddress: 0.0.0.0:10249</span><br><span class="line">clientConnection:</span><br><span class="line">  kubeconfig: /opt/kubernetes/cfg/kube-proxy.kubeconfig</span><br><span class="line">hostnameOverride: m1</span><br><span class="line">clusterCIDR: 10.0.0.0/24</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment">#=================回到master结点</span></span><br><span class="line"><span class="comment"># 切换工作目录</span></span><br><span class="line"><span class="built_in">cd</span> ~/TLS/k8s</span><br><span class="line"><span class="comment"># 创建证书请求文件</span></span><br><span class="line">cat &gt; kube-proxy-csr.json &lt;&lt; EOF</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"CN"</span>: <span class="string">"system:kube-proxy"</span>,</span><br><span class="line">  <span class="string">"hosts"</span>: [],</span><br><span class="line">  <span class="string">"key"</span>: &#123;</span><br><span class="line">    <span class="string">"algo"</span>: <span class="string">"rsa"</span>,</span><br><span class="line">    <span class="string">"size"</span>: 2048</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"names"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"C"</span>: <span class="string">"CN"</span>,</span><br><span class="line">      <span class="string">"L"</span>: <span class="string">"BeiJing"</span>,</span><br><span class="line">      <span class="string">"ST"</span>: <span class="string">"BeiJing"</span>,</span><br><span class="line">      <span class="string">"O"</span>: <span class="string">"k8s"</span>,</span><br><span class="line">      <span class="string">"OU"</span>: <span class="string">"System"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成证书</span></span><br><span class="line">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes kube-proxy-csr.json | cfssljson -bare kube-proxy</span><br><span class="line"><span class="comment"># 生成 kubeconfig 文件</span></span><br><span class="line">KUBE_APISERVER=<span class="string">"https://192.168.249.146:6443"</span></span><br><span class="line"></span><br><span class="line">kubectl config <span class="built_in">set</span>-cluster kubernetes \</span><br><span class="line">  --certificate-authority=/opt/kubernetes/ssl/ca.pem \</span><br><span class="line">  --embed-certs=<span class="literal">true</span> \</span><br><span class="line">  --server=<span class="variable">$&#123;KUBE_APISERVER&#125;</span> \</span><br><span class="line">  --kubeconfig=kube-proxy.kubeconfig</span><br><span class="line">kubectl config <span class="built_in">set</span>-credentials kube-proxy \</span><br><span class="line">  --client-certificate=./kube-proxy.pem \</span><br><span class="line">  --client-key=./kube-proxy-key.pem \</span><br><span class="line">  --embed-certs=<span class="literal">true</span> \</span><br><span class="line">  --kubeconfig=kube-proxy.kubeconfig</span><br><span class="line">kubectl config <span class="built_in">set</span>-context default \</span><br><span class="line">  --cluster=kubernetes \</span><br><span class="line">  --user=kube-proxy \</span><br><span class="line">  --kubeconfig=kube-proxy.kubeconfig</span><br><span class="line">kubectl config use-context default --kubeconfig=kube-proxy.kubeconfig</span><br><span class="line"></span><br><span class="line"><span class="comment">##### 转发到 k8snode1 #####</span></span><br><span class="line">scp -r kube-proxy.kubeconfig root@k8snode1:/opt/kubernetes/cfg/</span><br><span class="line"><span class="comment">##### 转发到 k8snode2 #####</span></span><br><span class="line">scp -r kube-proxy.kubeconfig root@k8snode2:/opt/kubernetes/cfg/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#======================回到node1和node2============</span></span><br><span class="line">cat &gt; /usr/lib/systemd/system/kube-proxy.service &lt;&lt; EOF</span><br><span class="line">[Unit]</span><br><span class="line">Description=Kubernetes Proxy</span><br><span class="line">After=network.target</span><br><span class="line">[Service]</span><br><span class="line">EnvironmentFile=/opt/kubernetes/cfg/kube-proxy.conf</span><br><span class="line">ExecStart=/opt/kubernetes/bin/kube-proxy \<span class="variable">$KUBE_PROXY_OPTS</span></span><br><span class="line">Restart=on-failure</span><br><span class="line">LimitNOFILE=65536</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start kube-proxy</span><br><span class="line">systemctl <span class="built_in">enable</span> kube-proxy</span><br><span class="line">systemctl status kube-proxy</span><br></pre></td></tr></table></figure><h3 id="3-6-部署-CNI-网络插件">3.6 部署 CNI 网络插件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># node结点操作，下载 CNI 网络插件</span></span><br><span class="line">wget https://github.com/containernetworking/plugins/releases/download/v0.8.6/cni-plugins-linux-amd64-v0.8.6.tgz</span><br><span class="line"><span class="comment"># 安装插件</span></span><br><span class="line">mkdir -p /opt/cni/bin</span><br><span class="line">tar -zxvf cni-plugins-linux-amd64-v0.8.6.tgz -C /opt/cni/bin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># k8smaster 节点操作，国内可以直接下载百度云文件</span></span><br><span class="line"><span class="comment">#链接：https://pan.baidu.com/s/1UaTBQ7GD2Smuty_MyxI1PA?pwd=g47k </span></span><br><span class="line">wget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span><br><span class="line">kubectl apply -f kube-flannel.yml</span><br></pre></td></tr></table></figure><h3 id="3-7-测试-kubernetes-集群">3.7 测试 kubernetes 集群</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载 nginx 【会联网拉取 nginx 镜像】</span></span><br><span class="line">kubectl create deployment nginx --image=nginx</span><br><span class="line"><span class="comment"># 查看状态</span></span><br><span class="line">kubectl get pod</span><br><span class="line"><span class="comment"># 暴露端口</span></span><br><span class="line">kubectl expose deployment nginx --port=80 --<span class="built_in">type</span>=NodePort</span><br><span class="line"><span class="comment"># 查看一下对外的端口</span></span><br><span class="line">kubectl get pod,svc</span><br><span class="line"><span class="comment"># 我们到我们的宿主机浏览器上，访问如下地址,两个node的ip都可以访问</span></span><br><span class="line">http://192.168.249.148:30899/</span><br></pre></td></tr></table></figure><h2 id="4、两种方式搭建集群的对比">4、两种方式搭建集群的对比</h2><h3 id="4-1-Kubeadm-方式搭建-K8S-集群">4.1 Kubeadm 方式搭建 K8S 集群</h3><ul><li>安装虚拟机，在虚拟机安装 Linux 操作系统【3 台虚拟机】</li><li>对操作系统初始化操作</li><li>所有节点安装 Docker、kubeadm、kubelet、kubectl【包含 master 和 node 节点】<ul><li>安装 Docker、使用 yum，不指定版本默认安装最新的 Docker 版本</li><li>修改 Docker 仓库地址，yum 源地址，改为阿里云地址</li><li>安装 kubeadm，kubelet 和 kubectl<ul><li>k8s 已经发布最新的 1.19 版本，可以指定版本安装，不指定安装最新版本</li><li><code>yum install -y kubelet kubeadm kubectl</code></li></ul></li></ul></li><li>在 master 节点执行初始化命令操作<ul><li><code>kubeadm init</code></li><li>默认拉取镜像地址 <a href="http://K8s.gcr.io" target="_blank" rel="noopener" title="K8s.gcr.io">K8s.gcr.io</a> 国内地址，需要使用国内地址</li></ul></li><li>安装网络插件 (CNI)<ul><li><code>kubectl apply -f kube-flannel.yml</code></li></ul></li><li>在所有的 node 节点上，使用 join 命令，把 node 添加到 master 节点上</li><li>测试 kubernetes 集群</li></ul><h3 id="4-2-二进制方式搭建-K8S-集群">4.2 二进制方式搭建 K8S 集群</h3><ul><li>安装虚拟机和操作系统，对操作系统进行初始化操作</li><li>生成 cfssl 自签证书<ul><li><code>ca-key.pem</code>、<code>ca.pem</code></li><li><code>server-key.pem</code>、<code>server.pem</code></li></ul></li><li>部署 Etcd 集群<ul><li>部署的本质，就是把 etcd 集群交给 systemd 管理</li><li>把生成的证书复制过来，启动，设置开机启动</li></ul></li><li>安装 Docker</li><li>部署 master 组件，主要包含以下组件<ul><li>apiserver</li><li>controller-manager</li><li>scheduler</li><li>交给 systemd 管理，并设置开机启动</li><li>如果要安装最新的 1.19 版本，下载二进制文件进行安装</li></ul></li><li>部署 node 组件<ul><li>kubelet</li><li>kube-proxy【需要批准 kubelet 证书申请加入集群】</li><li>交给 systemd 管理组件- 组件启动，设置开机启动</li></ul></li><li>批准 kubelet 证书申请 并加入集群</li><li>部署 CNI 网络插件</li><li>测试 Kubernets 集群【安装 nginx 测试】</li></ul><h2 id="5、可视化安装">5、可视化安装</h2><h3 id="5-1-Kuboard-v3-kubernetes-推荐">5.1 Kuboard v3 - kubernetes(推荐)</h3><blockquote><p>参考：<a href="https://kuboard.cn/install/v3/install-in-k8s.html" target="_blank" rel="noopener" title="安装 Kuboard v3 - kubernetes">安装 Kuboard v3 - kubernetes</a></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 Kuboard</span></span><br><span class="line">kubectl apply -f https://addons.kuboard.cn/kuboard/kuboard-v3.yaml</span><br><span class="line"><span class="comment"># 也可以使用下面的指令，唯一的区别是，该指令使用华为云的镜像仓库替代 docker hub 分发 Kuboard 所需要的镜像</span></span><br><span class="line"><span class="comment"># kubectl apply -f https://addons.kuboard.cn/kuboard/kuboard-v3-swr.yaml</span></span><br><span class="line"><span class="comment"># 如果想要定制 Kuboard 的启动参数，请将该 YAML 文件下载到本地，并修改其中的 ConfigMap</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看运行状态</span></span><br><span class="line">watch kubectl get pods -n kuboard</span><br><span class="line">kubectl get svc -A</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在浏览器中打开链接 http://your-node-ip-address:30080</span></span><br><span class="line"><span class="comment"># 输入初始用户名和密码，并登录</span></span><br><span class="line"><span class="comment"># 用户名： admin</span></span><br><span class="line"><span class="comment"># 密码： Kuboard123</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行 Kuboard v3 的卸载</span></span><br><span class="line">kubectl delete -f https://addons.kuboard.cn/kuboard/kuboard-v3.yaml</span><br><span class="line"><span class="comment"># 清理遗留数据,在 master 节点以及带有 k8s.kuboard.cn/role=etcd 标签的节点上执行</span></span><br><span class="line">rm -rf /usr/share/kuboard</span><br></pre></td></tr></table></figure><p>docker的安装方式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://hub.docker.com/r/eipwork/kuboard/tags 可以查看最新版本号</span></span><br><span class="line">sudo docker run -d \</span><br><span class="line">  --restart=unless-stopped \</span><br><span class="line">  --name=kuboard \</span><br><span class="line">  -p 80:80/tcp \</span><br><span class="line">  -p 10081:10081/udp \</span><br><span class="line">  -p 10081:10081/tcp \</span><br><span class="line">  -e KUBOARD_ENDPOINT=<span class="string">"http://192.168.249.139:80"</span> \</span><br><span class="line">  -e KUBOARD_AGENT_SERVER_UDP_PORT=<span class="string">"10081"</span> \</span><br><span class="line">  -e KUBOARD_AGENT_SERVER_TCP_PORT=<span class="string">"10081"</span> \</span><br><span class="line">  -v /root/kuboard-data:/data \</span><br><span class="line">  eipwork/kuboard:v3.3.0.3</span><br></pre></td></tr></table></figure><p>在浏览器输入 <code>192.168.249.139</code> 即可访问 Kuboard 的界面，登录方式：用户名：admin/密 码：Kuboard123</p><h3 id="5-2-Kubernetes-Dashboard">5.2 Kubernetes Dashboard</h3><blockquote><p>参考：<a href="https://kuboard.cn/install/install-k8s-dashboard.html" target="_blank" rel="noopener" title="Kubernetes Dashboard安装">Kubernetes Dashboard安装</a>/<a href="https://kubernetes.io/zh-cn/docs/tasks/access-application-cluster/web-ui-dashboard/" target="_blank" rel="noopener" title="部署和访问 Kubernetes 仪表板（Dashboard）">部署和访问 Kubernetes 仪表板（Dashboard）</a></p></blockquote><p>Kubernetes Dashboard 是 Kubernetes 的官方 Web UI。使用 Kubernetes Dashboard可以</p><ul><li>向 Kubernetes 集群部署容器化应用</li><li>诊断容器化应用的问题</li><li>管理集群的资源</li><li>查看集群上所运行的应用程序</li><li>创建、修改Kubernetes 上的资源（例如 Deployment、Job、DaemonSet等）</li><li>展示集群上发生的错误</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 Kubernetes Dashboard</span></span><br><span class="line">kubectl apply -f https://kuboard.cn/install-script/k8s-dashboard/v2.0.0-beta5.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># Kubernetes Dashboard 当前，只支持使用 Bearer Token登录</span></span><br><span class="line"><span class="comment"># 创建 ServiceAccount 和 ClusterRoleBinding</span></span><br><span class="line">kubectl apply -f https://kuboard.cn/install-script/k8s-dashboard/auth.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取Bearer Token</span></span><br><span class="line">kubectl -n kubernetes-dashboard describe secret $(kubectl -n kubernetes-dashboard get secret | grep admin-user | awk <span class="string">'&#123;print $1&#125;'</span>)</span><br><span class="line"><span class="comment"># 执行代理命令</span></span><br><span class="line">kubectl proxy</span><br><span class="line"><span class="comment"># 如需要使用 nodePort 或 Ingress 的方式访问 Kubernetes Dashboard 请配置正确的 https 证书，或者使用 Firefox 浏览器，并忽略 HTTPS 校验错误。</span></span><br><span class="line"><span class="comment"># 访问路径，将上一个步骤中获得的 Token 输入到登录界面中，点击 Sign in 按钮，完成登录</span></span><br><span class="line">http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/</span><br></pre></td></tr></table></figure><p>另一种方法，kubernetes官方提供的可视化界面<a href="https://github.com/kubernetes/dashboard" target="_blank" rel="noopener" title="https://github.com/kubernetes/dashboard">https://github.com/kubernetes/dashboard</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先自己下载下来</span></span><br><span class="line">kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.3.1/aio/deploy/recommended.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># type: ClusterIP 改为 type: NodePort</span></span><br><span class="line">kubectl edit svc kubernetes-dashboard -n kubernetes-dashboard</span><br><span class="line"><span class="comment"># 然后再次更新运行</span></span><br><span class="line"><span class="comment"># 访问： https://集群任意IP:端口      https://139.198.165.238:32759</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建访问账号</span></span><br><span class="line"><span class="comment"># 文件见下面</span></span><br><span class="line">kubectl apply -f dash.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取访问令牌</span></span><br><span class="line">kubectl -n kubernetes-dashboard get secret $(kubectl -n kubernetes-dashboard get sa/admin-user -o jsonpath=<span class="string">"&#123;.secrets[0].name&#125;"</span>) -o go-template=<span class="string">"&#123;&#123;.data.token | base64decode&#125;&#125;"</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建访问账号，准备一个yaml文件； vi dash.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">admin-user</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">admin-user</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cluster-admin</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">admin-user</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kubernetes-dashboard</span></span><br></pre></td></tr></table></figure><h3 id="5-3-k8slens-IDE-推荐">5.3 k8slens IDE(推荐)</h3><blockquote><p>官网：<a href="https://k8slens.dev/" target="_blank" rel="noopener" title="https://k8slens.dev/">https://k8slens.dev/</a></p></blockquote><h1>三、Kubernetes 核心概念(基础)</h1><h2 id="1、集群命令行工具-kubectl">1、集群命令行工具 kubectl</h2><h3 id="1-1-kubectl-概述">1.1 kubectl 概述</h3><p>kubectl 是 Kubernetes 集群的命令行工具，通过 kubectl 能够对集群本身进行管理，并能够在集群上进行容器化应用的安装和部署</p><h3 id="1-2-kubectl-命令格式">1.2 kubectl 命令格式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">kubectl [<span class="built_in">command</span>] [<span class="built_in">type</span>] [name] [flags]</span><br><span class="line"><span class="comment"># command：指定要对资源执行的操作，例如 create、get、describe、delete</span></span><br><span class="line"><span class="comment"># type：指定资源类型，资源类型是大小写敏感的，开发者能够以单数 、复数 和 缩略的形式</span></span><br><span class="line">kubectl get pod pod1</span><br><span class="line">kubectl get pods pod1</span><br><span class="line">kubectl get po pod1</span><br><span class="line"><span class="comment"># name：指定资源的名称，名称也是大小写敏感的，如果省略名称，则会显示所有的资源</span></span><br><span class="line"><span class="comment"># flags：指定可选的参数，例如，可用 -s 或者 -server 参数指定 Kubernetes API server 的地址和端口</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取 kubectl 的命令</span></span><br><span class="line">kubectl --<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取某个命令的介绍和使用</span></span><br><span class="line">kubectl get --<span class="built_in">help</span></span><br><span class="line">kubectl create --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><p>举例常用命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 部署应用</span></span><br><span class="line">kubectl apply -f app.yaml</span><br><span class="line"><span class="comment"># 查看 deployment</span></span><br><span class="line">kubectl get deployment</span><br><span class="line"><span class="comment"># 查看 pod</span></span><br><span class="line">kubectl get pod -o wide</span><br><span class="line"><span class="comment"># 查看 pod 详情</span></span><br><span class="line">kubectl describe pod pod-name</span><br><span class="line"><span class="comment"># 查看 log</span></span><br><span class="line">kubectl logs pod-name [-f]</span><br><span class="line"><span class="comment"># 进入 Pod 容器终端， -c container-name 可以指定进入哪个容器。</span></span><br><span class="line">kubectl <span class="built_in">exec</span> -it pod-name -- bash</span><br><span class="line"><span class="comment"># 伸缩扩展副本</span></span><br><span class="line">kubectl scale deployment <span class="built_in">test</span>-k8s --replicas=5</span><br><span class="line"><span class="comment"># 把集群内端口映射到节点</span></span><br><span class="line">kubectl port-forward pod-name 8090:8080</span><br><span class="line"><span class="comment"># 查看历史</span></span><br><span class="line">kubectl rollout <span class="built_in">history</span> deployment <span class="built_in">test</span>-k8s</span><br><span class="line"><span class="comment"># 回到上个版本</span></span><br><span class="line">kubectl rollout undo deployment <span class="built_in">test</span>-k8s</span><br><span class="line"><span class="comment"># 回到指定版本</span></span><br><span class="line">kubectl rollout undo deployment <span class="built_in">test</span>-k8s --to-revision=2</span><br><span class="line"><span class="comment"># 删除部署</span></span><br><span class="line">kubectl delete deployment <span class="built_in">test</span>-k8s</span><br><span class="line"></span><br><span class="line"><span class="comment"># =============更多命令============</span></span><br><span class="line"><span class="comment"># 查看命名空间</span></span><br><span class="line">kubectl get ns</span><br><span class="line"><span class="comment"># 查看全部</span></span><br><span class="line">kubectl get all</span><br><span class="line"><span class="comment"># 重新部署</span></span><br><span class="line">kubectl rollout restart deployment <span class="built_in">test</span>-k8s</span><br><span class="line"><span class="comment"># 命令修改镜像，--record 表示把这个命令记录到操作历史中</span></span><br><span class="line">kubectl <span class="built_in">set</span> image deployment <span class="built_in">test</span>-k8s <span class="built_in">test</span>-k8s=ccr.ccs.tencentyun.com/k8s-tutorial/<span class="built_in">test</span>-k8s:v2-with-error --record</span><br><span class="line"><span class="comment"># 暂停运行，暂停后，对 deployment 的修改不会立刻生效，恢复后才应用设置</span></span><br><span class="line">kubectl rollout pause deployment <span class="built_in">test</span>-k8s</span><br><span class="line"><span class="comment"># 恢复</span></span><br><span class="line">kubectl rollout resume deployment <span class="built_in">test</span>-k8s</span><br><span class="line"><span class="comment"># 输出到文件</span></span><br><span class="line">kubectl get deployment <span class="built_in">test</span>-k8s -o yaml &gt;&gt; app2.yaml</span><br><span class="line"><span class="comment"># 删除全部资源</span></span><br><span class="line">kubectl delete all --all</span><br></pre></td></tr></table></figure><h3 id="1-3-kubectl-基础命令">1.3 kubectl 基础命令</h3><table><thead><tr><th>命令</th><th>介绍</th></tr></thead><tbody><tr><td>create</td><td>通过文件名或标准输入创建资源</td></tr><tr><td>expose</td><td>将一个资源公开为一个新的 Service</td></tr><tr><td>run</td><td>在集群中运行一个特定的镜像</td></tr><tr><td>set</td><td>在对象上设置特定的功能</td></tr><tr><td>get</td><td>显示一个或多个资源</td></tr><tr><td>explain</td><td>文档参考资料</td></tr><tr><td>edit</td><td>使用默认的编辑器编辑一个资源</td></tr><tr><td>delete</td><td>通过文件名，标准输入，资源名称或标签来删除资源</td></tr></tbody></table><h3 id="1-4-kubectl-部署命令">1.4 kubectl 部署命令</h3><table><thead><tr><th>命令</th><th>介绍</th></tr></thead><tbody><tr><td>rollout</td><td>管理资源的发布</td></tr><tr><td>rolling-update</td><td>对给定的复制控制器滚动更新</td></tr><tr><td>scale</td><td>扩容或缩容 Pod 数量，Deployment、ReplicaSet、RC 或 Job</td></tr><tr><td>autoscale</td><td>创建一个自动选择扩容或缩容并设置 Pod 数量</td></tr></tbody></table><h3 id="1-5-kubectl-集群管理命令">1.5 kubectl 集群管理命令</h3><table><thead><tr><th>命令</th><th>介绍</th></tr></thead><tbody><tr><td>certificate</td><td>修改证书资源</td></tr><tr><td>cluster-info</td><td>显示集群信息</td></tr><tr><td>top</td><td>显示资源 (CPU/M)</td></tr><tr><td>cordon</td><td>标记节点不可调度</td></tr><tr><td>uncordon</td><td>标记节点可被调度</td></tr><tr><td>drain</td><td>驱逐节点上的应用，准备下线维护</td></tr><tr><td>taint</td><td>修改节点 taint 标记</td></tr></tbody></table><h3 id="1-6-kubectl-故障和调试命令">1.6 kubectl 故障和调试命令</h3><table><thead><tr><th>命令</th><th>介绍</th></tr></thead><tbody><tr><td>describe</td><td>显示特定资源或资源组的详细信息</td></tr><tr><td>logs</td><td>在一个 Pod 中打印一个容器日志，如果 Pod 只有一个容器，容器名称是可选的</td></tr><tr><td>attach</td><td>附加到一个运行的容器</td></tr><tr><td>exec</td><td>执行命令到容器</td></tr><tr><td>port-forward</td><td>转发一个或多个</td></tr><tr><td>proxy</td><td>运行一个 proxy 到 Kubernetes API Server</td></tr><tr><td>cp</td><td>拷贝文件或目录到容器中</td></tr><tr><td>auth</td><td>检查授权</td></tr></tbody></table><h3 id="1-7-kubectl-其它命令">1.7 kubectl 其它命令</h3><table><thead><tr><th>命令</th><th>介绍</th></tr></thead><tbody><tr><td>apply</td><td>通过文件名或标准输入对资源应用配置</td></tr><tr><td>patch</td><td>使用补丁修改、更新资源的字段</td></tr><tr><td>replace</td><td>通过文件名或标准输入替换一个资源</td></tr><tr><td>convert</td><td>不同的 API 版本之间转换配置文件</td></tr><tr><td>label</td><td>更新资源上的标签</td></tr><tr><td>annotate</td><td>更新资源上的注释</td></tr><tr><td>completion</td><td>用于实现 kubectl 工具自动补全</td></tr><tr><td>api-versions</td><td>打印受支持的 API 版本</td></tr><tr><td>config</td><td>修改 kubeconfig 文件（用于访问 API，比如配置认证信息）</td></tr><tr><td>help</td><td>所有命令帮助</td></tr><tr><td>plugin</td><td>运行一个命令行插件</td></tr><tr><td>version</td><td>打印客户端和服务版本信息</td></tr></tbody></table><h2 id="2、YAML-文件详解">2、YAML 文件详解</h2><blockquote><p>参考：<a href="https://www.runoob.com/w3cnote/yaml-intro.html" target="_blank" rel="noopener" title="YAML 入门教程">YAML 入门教程</a></p></blockquote><h3 id="2-1-YAML-概述">2.1 YAML 概述</h3><ul><li>YAML 文件 : 就是资源清单文件，用于资源编排</li><li>YAML : 仍是一种标记语言。为了强调这种语言以数据做为中心，而不是以标记语言为重点</li><li>YAML : 是一个可读性高，用来表达数据序列的格式</li></ul><h3 id="2-2-基础语法">2.2 基础语法</h3><ul><li>使用空格做为缩进</li><li>缩进的空格数目不重要，只要相同层级的元素左侧对齐即可</li><li>低版本缩进时不允许使用 Tab 键，只允许使用空格</li><li>使用#标识注释，从这个字符一直到行尾，都会被解释器忽略</li><li>使用 — 表示新的 yaml 文件开始</li></ul><h3 id="2-3-YAML-数据结构">2.3 YAML 数据结构</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对象类型：对象的一组键值对，使用冒号结构表示</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">Tom</span></span><br><span class="line"><span class="attr">age:</span> <span class="number">18</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># yaml 也允许另一种写法，将所有键值对写成一个行内对象</span></span><br><span class="line"><span class="attr">hash:</span> <span class="string">&#123;name:</span> <span class="string">Tom,</span> <span class="attr">age:</span> <span class="number">18</span><span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数组类型：一组连词线开头的行，构成一个数组</span></span><br><span class="line"><span class="string">People</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Tom</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Jack</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数组也可以采用行内表示法</span></span><br><span class="line"><span class="attr">People:</span> <span class="string">[Tom,</span> <span class="string">Jack]</span></span><br></pre></td></tr></table></figure><h3 id="2-4-组成部分">2.4 组成部分</h3><p>主要分为了两部分，一个是<strong>控制器的定义</strong>和<strong>被控制的对象</strong>。在一个 YAML 文件的控制器定义中，有很多属性名称</p><table><thead><tr><th>属性名称</th><th>介绍</th></tr></thead><tbody><tr><td>apiVersion</td><td>API 版本</td></tr><tr><td>kind</td><td>资源类型</td></tr><tr><td>metadata</td><td>资源元数据</td></tr><tr><td>spec</td><td>资源规格</td></tr><tr><td>replicas</td><td>副本数量</td></tr><tr><td>selector</td><td>标签选择器</td></tr><tr><td>template</td><td>Pod 模板</td></tr><tr><td>metadata</td><td>Pod 元数据</td></tr><tr><td>spec</td><td>Pod 规格</td></tr><tr><td>containers</td><td>容器配置</td></tr></tbody></table><h3 id="2-5-快速编写">2.5 快速编写</h3><p>一般来说，我们很少自己手写 YAML 文件，因为这里面涉及到了很多内容，我们一般都会借助工具来创建</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 尝试运行，并不会真正的创建镜像</span></span><br><span class="line">kubectl create deployment web --image=nginx -o yaml --dry-run</span><br><span class="line"><span class="comment"># 我们可以输出到一个文件中</span></span><br><span class="line">kubectl create deployment web --image=nginx -o yaml --dry-run &gt; hello.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以首先查看一个目前已经部署的镜像</span></span><br><span class="line">kubectl get deploy</span><br><span class="line"><span class="comment"># 导出 nginx 的配置</span></span><br><span class="line">kubectl get deploy nginx -o=yaml --<span class="built_in">export</span> &gt; nginx.yaml</span><br></pre></td></tr></table></figure><h2 id="3、Pod">3、Pod</h2><blockquote><p>参考：<a href="https://kubernetes.io/zh-cn/docs/reference/kubernetes-api/workload-resources/pod-v1/" target="_blank" rel="noopener" title="https://kubernetes.io/zh-cn/docs/reference/kubernetes-api/workload-resources/pod-v1/">https://kubernetes.io/zh-cn/docs/reference/kubernetes-api/workload-resources/pod-v1/</a></p></blockquote><h3 id="3-1-Pod概述">3.1 Pod概述</h3><p><strong>基本概念</strong></p><ul><li>最小部署的单元</li><li>Pod 里面是由一个或多个容器组成【一组容器的集合】</li><li>一个 pod 中的容器是共享网络命名空间</li><li>Pod 是短暂的</li><li>每个 Pod 包含一个或多个紧密相关的用户业务容器</li></ul><p><strong>Pod 存在的意义</strong></p><ul><li>创建容器使用 docker，一个 docker 对应一个容器，一个容器运行一个应用进程</li><li>Pod 是多进程设计，运用多个应用程序，也就是一个 Pod 里面有多个容器，而一个容器里面运行一个应用程序</li><li>Pod 的存在是为了亲密性应用<ul><li>两个应用之间进行交互</li><li>网络之间的调用【通过 127.0.0.1 或 socket】</li><li>两个应用之间需要频繁调用</li></ul></li></ul><h3 id="3-2-Pod-实现机制">3.2 Pod 实现机制</h3><p>Pod 主要有以下两大机制：<strong>共享网络</strong> 和 <strong>共享存储</strong></p><ul><li><strong>共享网络</strong>【容器通过 <strong>namespace</strong> 和 <strong>group</strong> 进行隔离】，Pod 中容器通信 过程：<ul><li>同一个 namespace 下</li><li>在 Pod 中创建一个根容器： <code>pause 容器</code></li><li>在 Pod 中创建业务容器 【nginx，redis 等】【创建时会添加到 <code>info 容器</code> 中】</li><li>在 <code>info 容器</code> 中会独立出 ip 地址，mac 地址，port 等信息，然后实现网络的共享</li></ul></li><li><strong>共享存储</strong>【Pod 持久化数据，专门存储到某个地方中，使用 Volumn 数据卷进行共享存储】</li></ul><h3 id="3-3-Pod-镜像拉取策略">3.3 Pod 镜像拉取策略</h3><p>拉取策略就是 <code>imagePullPolicy</code>，有以下几个值</p><ul><li><code>IfNotPresent</code>：默认值，镜像在宿主机上不存在才拉取</li><li><code>Always</code>：每次创建 Pod 都会重新拉取一次镜像</li><li><code>Never</code>：Pod 永远不会主动拉取这个镜像</li></ul><h3 id="3-4-Pod-资源限制">3.4 Pod 资源限制</h3><blockquote><p>Pod 在进行调度的时候，可以对调度的资源进行限制，例如我们限制 Pod 调度是使用的资源是 2C4G，那么在调度对应的 node 节点时，只会占用对应的资源，对于不满足资源的节点，将不会进行调度。</p></blockquote><p>这里分了两个部分：</p><ul><li><code>request</code>：表示调度所需的资源</li><li><code>limits</code>：表示最大所占用的资源</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sepc:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">db</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">memory:</span> <span class="string">"64Mi"</span></span><br><span class="line">      <span class="attr">cpu:</span> <span class="string">"250m"</span></span><br><span class="line">    <span class="attr">limits:</span></span><br><span class="line">      <span class="attr">memory:</span> <span class="string">"128Mi"</span></span><br><span class="line">      <span class="attr">cpu:</span> <span class="string">"500m"</span></span><br></pre></td></tr></table></figure><h3 id="3-5-Pod-重启机制">3.5 Pod 重启机制</h3><blockquote><p>因为 Pod 中包含了很多个容器，假设某个容器出现问题了，那么就会触发 Pod 重启机制</p></blockquote><p>restartPolicy重启策略主要分为以下三种：</p><ul><li><code>Always</code>：当容器终止退出后，总是重启容器，默认策略 【nginx 等，需要不断提供服务】</li><li><code>OnFailure</code>：当容器异常退出（退出状态码非 0）时，才重启容器。</li><li><code>Never</code>：当容器终止退出，从不重启容器 【批量任务】</li></ul><h3 id="3-6-Pod-健康检查">3.6 Pod 健康检查</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过容器检查</span></span><br><span class="line">kubectl get pod</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过应用检查，因为有的时候，程序可能出现了 Java 堆内存溢出，程序还在运行，但是不能对外提供服务了，这个时候就不能通过容器检查来判断服务是否可用了。需要通过应用检查</span></span><br><span class="line"><span class="comment"># 存活检查，如果检查失败，将杀死容器，根据 Pod 的 restartPolicy【重启策略】来操作</span></span><br><span class="line">livenessProbe</span><br><span class="line"></span><br><span class="line"><span class="comment"># 就绪检查，如果检查失败，Kubernetes 会把 Pod 从 Service endpoints 中剔除</span></span><br><span class="line">readinessProbe</span><br></pre></td></tr></table></figure><p>Probe 支持以下三种检查方式</p><ul><li><code>http Get</code>：发送 HTTP 请求，返回 200 - 400 范围状态码为成功</li><li><code>exec</code>：执行 Shell 命令返回状态码是 0 为成功</li><li><code>tcpSocket</code>：发起 TCP Socket 建立成功</li></ul><h3 id="3-7-Pod-调度策略">3.7 Pod 调度策略</h3><ul><li>首先创建一个 pod，然后创建一个 API Server 和 Etcd【把创建出来的信息存储在 etcd 中】</li><li>然后创建 Scheduler，监控 API Server 是否有新的 Pod，如果有的话，会通过调度算法，把 pod 调度某个 node 上</li><li>在 node 节点，会通过 <code>kubelet -- apiserver</code> 读取 etcd 拿到分配在当前 node 节点上的 pod，然后通过 docker 创建容器</li></ul><p><strong>Pod资源限制对Pod的调度会有影响，节点选择器标签影响Pod调度</strong>，如果不满足就不会在该结点运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给我们的节点新增标签</span></span><br><span class="line">kubectl label node m1 env_role=prod</span><br><span class="line">kubectl get nodes m1 --show-labels</span><br><span class="line"><span class="comment"># nodeSelector结点选择器会选择对应Pod</span></span><br></pre></td></tr></table></figure><p><strong>节点亲和性</strong> <strong>nodeAffinity</strong> (比选择器更强)和 之前nodeSelector 基本一样的，根据节点上标签约束来决定Pod调度到哪些节点上</p><ul><li>硬亲和性：约束条件必须满足</li><li>软亲和性：尝试满足，不保证</li></ul><p><img src="https://img-blog.csdnimg.cn/2048a529fea84935ab05d77fb2a7e3c0.png#pic_center" alt="在这里插入图片描述"></p><p>支持常用操作符：in、NotIn、Exists、Gt、Lt、DoesNotExists</p><p>反亲和性：就是和亲和性刚刚相反，如 NotIn、DoesNotExists等</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>                          <span class="comment"># api版本</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span>                               <span class="comment"># 组件类型</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-mysql-pod</span></span><br><span class="line">  <span class="attr">labels:</span>                               <span class="comment"># 标签</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-mysql</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="comment"># 结点选择器</span></span><br><span class="line">  <span class="comment">#nodeSelector:</span></span><br><span class="line">    <span class="comment">#env_role: prod</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span>                         <span class="comment"># 名称</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span>                        <span class="comment"># image地址</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mysql</span>                         </span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql</span>                        </span><br><span class="line">    <span class="attr">env:</span>                                <span class="comment"># 环境变量</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MYSQL_ROOT_PASSWORD</span></span><br><span class="line">      <span class="attr">value:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span> <span class="comment">#镜像拉取策略</span></span><br><span class="line">    <span class="comment"># 资源限制策略</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">requests:</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">"64Mi"</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">"250m"</span></span><br><span class="line">        <span class="comment"># 重启机制</span></span><br><span class="line">    <span class="attr">restartPolicy:</span> <span class="string">Never</span></span><br><span class="line">    <span class="comment"># Pod健康检查</span></span><br><span class="line">    <span class="attr">livenessProbe:</span></span><br><span class="line">      <span class="attr">exec:</span></span><br><span class="line">        <span class="attr">command:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">cat</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/tmp/healthy</span></span><br><span class="line">      <span class="attr">initialDelaySeconds:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">periodSeconds:</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><h3 id="3-8-污点和污点容忍">3.8 污点和污点容忍</h3><blockquote><p>nodeSelector 和 NodeAffinity，都是Prod调度到某些节点上，属于Pod的属性，是在调度的时候实现的。<strong>Taint 污点：节点不做普通分配调度，是节点属性</strong>；污点容忍就是某个节点可能被调度，也可能不被调度</p></blockquote><p><strong>使用场景</strong></p><ul><li>专用节点【限制ip】</li><li>配置特定硬件的节点【固态硬盘】</li><li>基于Taint驱逐【在node1不放，在node2放】</li></ul><p><strong>污点值：</strong></p><ul><li>NoSchedule：一定不被调度</li><li>PreferNoSchedule：尽量不被调度【也有被调度的几率】</li><li>NoExecute：不会调度，并且还会驱逐Node已有Pod</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看节点污点</span></span><br><span class="line">kubectl describe node k8smaster | grep Taint</span><br><span class="line"><span class="comment"># 为节点添加污点</span></span><br><span class="line">kubectl taint node [node] key=value:污点的三个值</span><br><span class="line">kubectl taint node k8snode1 env_role=yes:NoSchedule</span><br><span class="line"><span class="comment"># 删除污点</span></span><br><span class="line">kubectl taint node k8snode1 env_role:NoSchedule-</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#==============演示=============================</span></span><br><span class="line"><span class="comment"># 我们现在创建多个Pod，查看最后分配到Node上的情况</span></span><br><span class="line">kubectl create deployment web --image=nginx</span><br><span class="line">kubectl get pods -o wide</span><br><span class="line"><span class="comment"># 所以节点都被分配到了 node1 和 node2节点上</span></span><br><span class="line">kubectl scale deployment web --replicas=5</span><br><span class="line">kubectl delete deployment web</span><br><span class="line"><span class="comment"># 给 node1节点打上污点</span></span><br><span class="line">kubectl taint node k8snode1 env_role=yes:NoSchedule</span><br><span class="line"><span class="comment"># 然后我们查看污点是否成功添加</span></span><br><span class="line">kubectl describe node k8snode1 | grep Taint</span><br><span class="line"><span class="comment"># 创建nginx pod</span></span><br><span class="line">kubectl create deployment web --image=nginx</span><br><span class="line"><span class="comment"># 复制五次</span></span><br><span class="line">kubectl scale deployment web --replicas=5</span><br><span class="line"><span class="comment"># 然后我们在进行查看</span></span><br><span class="line">kubectl get pods -o wide</span><br><span class="line"><span class="comment"># 现在所有的pod都被分配到了 k8snode2上，因为刚刚我们给node1节点设置了污点</span></span><br><span class="line"><span class="comment"># 删除刚刚添加的污点</span></span><br><span class="line">kubectl taint node k8snode1 env_role:NoSchedule-</span><br></pre></td></tr></table></figure><h2 id="4、Controller之Deployment">4、Controller之Deployment</h2><h3 id="4-1-Controller-简介">4.1 Controller 简介</h3><p>Controller 是集群上管理和运行容器的对象</p><ul><li>Controller 是实际存在的</li><li>Pod 是虚拟机的</li></ul><p>Pod 是通过 Controller 实现应用的运维，比如弹性收缩，滚动升级。Pod 和 Controller 之间是通过 label 标签建立关系，同时 Controller 又被称为控制器工作负载。</p><ul><li>Controller【控制器】【工作负载】<code>selector: app:nginx</code></li><li>Pod【容器】<code>labels: app:nginx</code></li></ul><p><img src="https://img-blog.csdnimg.cn/012ee75bf2674d65af6685eb12d4e0e8.png#pic_center" alt="在这里插入图片描述"></p><h3 id="4-2-Deployment控制器应用">4.2 Deployment控制器应用</h3><ul><li>Deployment控制器可以部署无状态应用</li><li>管理Pod和ReplicaSet</li><li>部署，滚动升级等功能</li><li>应用场景：web服务，微服务</li></ul><p>Deployment表示用户对K8S集群的一次更新操作。Deployment是一个比RS( Replica Set, RS) 应用模型更广的 API 对象，可以是创建一个新的服务，更新一个新的服务，也可以是滚动升级一个服务。滚动升级一个服务，实际是创建一个新的RS，然后逐渐将新 RS 中副本数增加到理想状态，将旧RS中的副本数减少到0的复合操作。这样一个复合操作用一个RS是不好描述的，所以用一个更通用的Deployment来描述。以K8S的发展方向，未来对所有长期伺服型的业务的管理，都会通过Deployment来管理</p><h3 id="4-3-Deployment-部署应用">4.3 Deployment 部署应用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 Deploment 部署应用，代码如下：【缺点：代码不好复用】</span></span><br><span class="line">kubectrl create deployment web --image=nginx</span><br><span class="line"><span class="comment"># 使用 YAML 文件进行配置：【快速编写 YAML 文件】</span></span><br><span class="line">kubectl create deployment web --image=nginx -o yaml --dry-run &gt; nginx.yaml</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># nginx.yaml 文件【selector 和 label 就是我们 Pod 和 Controller 之间建立关系的桥梁】</span></span><br><span class="line"><span class="comment"># 使用nginx.yaml文件创建镜像</span></span><br><span class="line">kubectl apply -f nginx.yaml</span><br><span class="line"><span class="comment"># 对外暴露端口</span></span><br><span class="line">kubectl expose deployment web --port=80 --<span class="built_in">type</span>=NodePort --target-port=80 --name=web1</span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line"><span class="comment"># --port：就是我们内部的端口号</span></span><br><span class="line"><span class="comment"># --target-port：就是暴露外面访问的端口号</span></span><br><span class="line"><span class="comment"># --name：名称</span></span><br><span class="line"><span class="comment"># --type：类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 同理，导出配置文件</span></span><br><span class="line">kubectl expose deployment web --port=80 --<span class="built_in">type</span>=NodePort --target-port=80 --name=web1 -o yaml &gt; web1.yaml</span><br><span class="line"><span class="comment"># 查看端口，然后就可以访问了</span></span><br><span class="line">kubectl get pods,svc</span><br></pre></td></tr></table></figure><p>举例</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span>    <span class="comment">#指定api版本标签】</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span>       </span><br><span class="line"><span class="comment">#定义资源的类型/角色】，deployment为副本控制器，此处资源类型可以是Deployment、Job、Ingress、Service等</span></span><br><span class="line"><span class="attr">metadata :</span>          <span class="comment">#定义资源的元数据信息，比如资源的名称、namespace、标签等信息</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span> <span class="comment">#定义资源的名称，在同一个namespace空间中必须是唯一的</span></span><br><span class="line">  <span class="attr">labels:</span>    <span class="comment">#定义资源标签(Pod的标签)</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span>  <span class="comment">#定义deployment资源需要的参数属性，诸如是否在容器失败时重新启动容器的属性</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span>       <span class="comment">#定义副本数量</span></span><br><span class="line">  <span class="attr">selector:</span>         <span class="comment">#定义标签选择器</span></span><br><span class="line">    <span class="attr">matchLabels :</span>   <span class="comment">#定义匹配标签</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span>    <span class="comment">#匹配上面的标签，需与上面的标签定义的app保持一致</span></span><br><span class="line">  <span class="attr">template:</span>         <span class="comment">#【定义业务模板】，如果有多个副本，所有副本的属性会按照模板的相关配置进行匹配</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span>       <span class="comment">#定义容器属性</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span>   <span class="comment">#定义一个容器名，一个- name:定义一个容器</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.15.4</span>   <span class="comment">#定义容器使用的镜像以及版本</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span> <span class="comment">#镜像拉取策略</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span>   <span class="comment">#定义容器的对外的端口</span></span><br></pre></td></tr></table></figure><h3 id="4-4-升级回滚和弹性收缩">4.4 升级回滚和弹性收缩</h3><ul><li>升级： 假设从版本为 1.14 升级到 1.15 ，这就叫应用的升级【升级可以保证服务不中断】</li><li>回滚：从版本 1.15 变成 1.14，这就叫应用的回滚</li><li>弹性伸缩：我们根据不同的业务场景，来改变 Pod 的数量对外提供服务，这就是弹性伸缩</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 应用升级</span></span><br><span class="line">kubectl <span class="built_in">set</span> image deployment nginx nginx=nginx:1.15</span><br><span class="line"><span class="comment"># 我们在下载 1.15 版本，容器就处于 ContainerCreating 状态，然后下载完成后，就用 1.15 版本去替换 1.14 版本了，这么做的好处就是：升级可以保证服务不中断</span></span><br><span class="line">kubectl rollout status deployment nginx</span><br><span class="line">kubectl rollout <span class="built_in">history</span> deployment nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 回滚到上一版本</span></span><br><span class="line">kubectl rollout undo deployment nginx</span><br><span class="line"><span class="comment"># 回滚到指定版本</span></span><br><span class="line">kubectl rollout undo deployment nginx --to-revision=2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过命令创建多个副本</span></span><br><span class="line">kubectl scale deployment nginx --replicas=10</span><br><span class="line"><span class="comment"># 查看</span></span><br><span class="line">kubectl get pod</span><br></pre></td></tr></table></figure><h2 id="5、Service">5、Service</h2><blockquote><p>文档参考：<a href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#headless-services" target="_blank" rel="noopener" title="https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#headless-services">https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#headless-services</a></p></blockquote><h3 id="5-1-service概述">5.1 service概述</h3><p>前面我们了解到 Deployment 只是保证了支撑服务的微服务Pod的数量，但是<strong>没有解决如何访问这些服务的问题</strong>。一个Pod只是一个运行服务的实例，随时可能在一个节点上停止，在另一个节点以一个新的IP启动一个新的Pod，因此不能以确定的IP和端口号提供服务。</p><p>要稳定地提供服务<strong>需要服务发现和负载均衡能力</strong>。服务发现完成的工作，是针对客户端访问的服务，找到对应的后端服务实例。在K8S集群中，客户端需要访问的服务就是Service对象。<strong>每个Service会对应一个集群内部有效的虚拟IP，集群内部通过虚拟IP访问一个服务</strong>。在K8S集群中，<strong>微服务的负载均衡是由kube-proxy实现的</strong>。kube-proxy是k8s集群内部的负载均衡器。它是一个分布式代理服务器，在K8S的每个节点上都有一个；这一设计体现了它的伸缩性优势，需要访问服务的节点越多，提供负载均衡能力的kube-proxy就越多，高可用节点也随之增多。与之相比，我们平时在服务器端使用反向代理作负载均衡，还要进一步解决反向代理的高可用问题。</p><h3 id="5-2-Service存在的意义">5.2 Service存在的意义</h3><ul><li><p><strong>防止Pod失联【服务发现】</strong></p><p>因为Pod每次创建都对应一个IP地址，而这个IP地址是短暂的，每次随着Pod的更新都会变化，假设当我们的前端页面有多个Pod时候，同时后端也多个Pod，这个时候，他们之间的相互访问，就需要通过注册中心，拿到Pod的IP地址，然后去访问对应的Pod</p></li><li><p><strong>定义Pod访问策略【负载均衡】</strong></p><p>页面前端的Pod访问到后端的Pod，中间会通过Service一层，而Service在这里还能做负载均衡，负载均衡的策略有很多种实现策略，例如：</p><ul><li>随机</li><li>轮询</li><li>响应比</li></ul></li></ul><h3 id="5-3-Pod和Service的关系">5.3 Pod和Service的关系</h3><p>这里Pod 和 Service 之间还是根据 label 和 selector 建立关联的 【和Controller一样】，我们在访问service的时候，其实也是需要有一个ip地址，这个ip肯定不是pod的ip地址，而是 虚拟IP <code>vip</code></p><h3 id="5-4-Service常用类型">5.4 Service常用类型</h3><ul><li>ClusterIp：集群内部访问</li><li>NodePort：对外访问应用使用</li><li>LoadBalancer：对外访问应用使用，公有云</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">kubectl expose deployment nginx --port=80 --target-port=80 --dry-run -o yaml &gt; service.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改完命令后，我们使用创建一个pod</span></span><br><span class="line">kubectl apply -f service.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以对外暴露端口，这样是随机的</span></span><br><span class="line">kubectl expose deployment web --port=80 --<span class="built_in">type</span>=NodePort --target-port=80 --name=nginx</span><br><span class="line"></span><br><span class="line">kubectl get service</span><br><span class="line">kubectl get svc</span><br><span class="line"><span class="comment"># 查看服务详情，可以发现 Endpoints 是各个 Pod 的 IP，也就是他会把流量转发到这些节点</span></span><br><span class="line">kubectl describe svc <span class="built_in">test</span>-k8s</span><br><span class="line"><span class="comment"># 服务的默认类型是ClusterIP，只能在集群内部访问，我们可以进入到 Pod 里面访问</span></span><br><span class="line">kubectl <span class="built_in">exec</span> -it pod-name -- bash</span><br><span class="line">curl http://nginx:80</span><br><span class="line"><span class="comment"># 如果要在集群外部访问，可以通过端口转发实现（只适合临时测试用）</span></span><br><span class="line">kubectl port-forward service/nginx 8080:80</span><br><span class="line">curl http://localhost:8080</span><br></pre></td></tr></table></figure><p>如果我们没有做设置的话，默认使用的是第一种方式 ClusterIp，也就是只能在集群内部使用，我们<strong>可以添加一个type字段，用来设置我们的service类型</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">web</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">    <span class="comment">#nodePort: 31000   # 指定暴露节点端口，范围固定 30000 ~ 32767</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line"><span class="attr">status:</span></span><br><span class="line">  <span class="attr">loadBalancer:</span> <span class="string">&#123;&#125;</span></span><br></pre></td></tr></table></figure><p>运行后能够看到，已经成功修改为 NodePort类型了，最后剩下的一种方式就是LoadBalanced：对外访问应用使用公有云，node一般是在内网进行部署，而外网一般是不能访问到的，那么如何访问的呢？</p><ul><li>找到一台可以通过外网访问机器，安装nginx，反向代理</li><li>手动把可以访问的节点添加到nginx中</li></ul><p>如果我们使用LoadBalancer，就会有负载均衡的控制器，类似于nginx的功能，就不需要自己添加到nginx上</p><h2 id="6、Controller之Statefulset">6、Controller之Statefulset</h2><h3 id="6-1-Statefulset概述">6.1 Statefulset概述</h3><p><strong>Statefulset主要是用来部署有状态应用</strong>。对于StatefulSet中的Pod，每个Pod挂载自己独立的存储，如果一个Pod出现故障，从其他节点启动一个同样名字的Pod，要挂载上原来Pod的存储继续以它的状态提供服务。</p><p>前面我们部署的应用，都是不需要存储数据，不需要记住状态的，可以随意扩充副本，每个副本都是一样的，可替代的。  而像数据库、Redis 这类有状态的，则不能随意扩充副本。StatefulSet 会固定每个 Pod 的名字，具有以下<strong>特性</strong></p><ul><li>Service 的 <code>CLUSTER-IP</code> 是空的，Pod 名字也是固定的。</li><li>Pod 创建和销毁是有序的，创建是顺序的，销毁是逆序的。</li><li>Pod 重建不会改变名字，除了IP，所以不要用IP直连</li></ul><h3 id="6-2-无状态和有状态容器">6.2 无状态和有状态容器</h3><p><strong>无状态应用</strong>，我们原来使用 deployment，部署的都是无状态的应用</p><ul><li>认为Pod都是一样的</li><li>没有顺序要求</li><li>不考虑应用在哪个node上运行</li><li>能够进行随意伸缩和扩展</li></ul><p><strong>有状态应用</strong>，上述的因素都需要考虑到</p><ul><li>每个Pod独立的，保持Pod启动顺序和唯一性</li><li>唯一的网络标识符，持久存储</li><li>有序，比如mysql中的主从</li></ul><p>适合StatefulSet的业务包括数据库服务MySQL 和 PostgreSQL，集群化管理服务Zookeeper、etcd等有状态服务。<strong>StatefulSet的另一种典型应用场景是作为一种比普通容器更稳定可靠的模拟虚拟机的机制</strong>。传统的虚拟机正是一种有状态的宠物，运维人员需要不断地维护它，容器刚开始流行时，我们用容器来模拟虚拟机使用，所有状态都保存在容器里，而这已被证明是非常不安全、不可靠的。</p><p>使用StatefulSet，Pod仍然可以通过漂移到不同节点提供高可用，而存储也可以通过外挂的存储来提供 高可靠性，StatefulSet做的只是将确定的Pod与确定的存储关联起来保证状态的连续性</p><h3 id="6-3-部署有状态应用">6.3 部署有状态应用</h3><p><strong>无头service， ClusterIp：none</strong>。这里就需要使用 StatefulSet部署有状态应用</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="string">None</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StatefulSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-statefulset</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">serviceName:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.14-alpine</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>然后通过查看pod，能否发现每个pod都有唯一的名称；然后我们在查看service，发现是无头的service</p><p>这里有状态的约定，肯定不是简简单单通过名称来进行约定，而是更加复杂的操作</p><ul><li>deployment：是有身份的，有唯一标识</li><li>statefulset：根据主机名 + 按照一定规则生成域名</li></ul><p>每个pod有唯一的主机名，并且有唯一的域名</p><ul><li>格式：主机名称.service名称.名称空间.svc.cluster.local</li><li>举例：nginx-statefulset-0.default.svc.cluster.local</li></ul><h2 id="7、Controller之其他应用">7、Controller之其他应用</h2><h3 id="7-1-DaemonSet">7.1 DaemonSet</h3><p>DaemonSet 即后台支撑型服务，主要是用来部署守护进程</p><p>长期伺服型和批处理型的核心在业务应用，可能有些节点运行多个同类业务的Pod，有些节点上又没有这类的Pod运行；而后台支撑型服务的核心关注点在K8S集群中的节点(物理机或虚拟机)，要保证每个节点上都有一个此类Pod运行。节点可能是所有集群节点，也可能是通过 nodeSelector选定的一些特定节点。典型的后台支撑型服务包括：存储、日志和监控等。在每个节点上支撑K8S集群运行的服务。</p><p>守护进程在我们每个节点上，运行的是同一个pod，新加入的节点也同样运行在同一个pod里面</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ds-test</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">filebeat</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">filebeat</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">filebeat</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">logs</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">        <span class="comment"># #容器内挂载点</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">varlog</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/tmp/log</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">varlog</span></span><br><span class="line">        <span class="attr">hostPath:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/var/log</span>   <span class="comment">#宿主机挂载点</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f daemon.yaml</span><br><span class="line">kubectl get pod -owide</span><br><span class="line">kubectl <span class="built_in">exec</span> -it ds-test-cbk6v bash</span><br></pre></td></tr></table></figure><h3 id="7-2-Job和CronJob">7.2 Job和CronJob</h3><ul><li>一次性任务：一次性执行完就结束</li><li>定时任务：周期性执行</li></ul><p>Job是K8S中用来控制批处理型任务的API对象。批处理业务与长期伺服业务的主要区别就是批处理业务的运行有头有尾，而长期伺服业务在用户不停止的情况下永远运行。Job管理的Pod根据用户的设置把任务成功完成就自动退出了。成功完成的标志根据不同的 spec.completions 策略而不同：单Pod型任务有一个Pod成功就标志完成；定数成功行任务保证有N个任务全部成功；工作队列性任务根据应用确定的全局成功而标志成功。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># job的yaml文件</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Job</span></span><br><span class="line"><span class="attr">metadata:</span> </span><br><span class="line">  <span class="attr">name:</span> <span class="string">pi</span></span><br><span class="line"><span class="attr">spec:</span> </span><br><span class="line">  <span class="attr">template:</span> </span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">pi</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">perl</span></span><br><span class="line">        <span class="attr">command:</span> <span class="string">["perl",</span> <span class="string">"-Mbignum=bpi"</span><span class="string">,</span> <span class="string">"-wle"</span><span class="string">,</span> <span class="string">"print bpi(2000)"</span><span class="string">]</span></span><br><span class="line">      <span class="attr">restartPolicy:</span> <span class="string">Never</span></span><br><span class="line">  <span class="comment"># 失败后尝试次数</span></span><br><span class="line">  <span class="attr">backoffLimit:</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># CronJob的yaml文件</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">CronJob</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">hello</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">schedule:</span> <span class="string">"*/1 * * * *"</span></span><br><span class="line">  <span class="attr">jobTemplate:</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">template:</span></span><br><span class="line">        <span class="attr">spec:</span></span><br><span class="line">          <span class="attr">containers:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">hello</span></span><br><span class="line">            <span class="attr">image:</span> <span class="string">registry.cn-beijing.aliyuncs.com/google_registry/busybox:1.24</span></span><br><span class="line">            <span class="attr">args:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">/bin/sh</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">-c</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">date;</span> <span class="string">echo</span> <span class="string">Hello</span> <span class="string">from</span> <span class="string">the</span> <span class="string">Kubernetes</span> <span class="string">cluster</span></span><br><span class="line">          <span class="attr">restartPolicy:</span> <span class="string">OnFailure</span></span><br></pre></td></tr></table></figure><p>命令操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 能够看到目前已经存在的Job</span></span><br><span class="line">kubectl get <span class="built_in">jobs</span></span><br><span class="line"><span class="comment"># 我们可以通过查看日志，查看到一次性任务的结果</span></span><br><span class="line">kubectl logs pi-qpqff</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看定时任务，每隔一次会创建一个</span></span><br><span class="line">kubectl get cronjobs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除svc 和 statefulset</span></span><br><span class="line">kubectl delete svc web</span><br><span class="line">kubectl delete statefulset --all</span><br><span class="line">kubectl delete cronjobs hello</span><br></pre></td></tr></table></figure><h3 id="7-3-Replication-Controller">7.3 Replication Controller</h3><p>Replication Controller 简称 <strong>RC</strong>，是K8S中的复制控制器。RC是K8S集群中最早的保证Pod高可用的API对象。通过监控运行中的Pod来保证集群中运行指定数目的Pod副本。指定的数目可以是多个也可以是1个；少于指定数目，RC就会启动新的Pod副本；多于指定数目，RC就会杀死多余的Pod副本。即使在指定数目为1的情况下，通过RC运行Pod也比直接运行Pod更明智，因为RC也可以发挥它高可用的能力，保证永远有一个Pod在运行。RC是K8S中较早期的技术概念，只适用于长期伺服型的业务类型，比如控制Pod提供高可用的Web服务。</p><p>Replica Set 检查 RS，也就是副本集。RS是新一代的RC，提供同样高可用能力，区别主要在于RS后来居上，能够支持更多种类的匹配模式。副本集对象一般不单独使用，而是作为Deployment的理想状态参数来使用</p><h1>四、Kubernetes 核心概念(进阶)</h1><h2 id="1、Kubernetes配置管理">1、Kubernetes配置管理</h2><h3 id="1-1-Secret">1.1 Secret</h3><blockquote><p>参考文档：<a href="https://kubernetes.io/zh-cn/docs/concepts/configuration/secret/" target="_blank" rel="noopener" title="https://kubernetes.io/zh-cn/docs/concepts/configuration/secret/">https://kubernetes.io/zh-cn/docs/concepts/configuration/secret/</a></p></blockquote><p>Secret的主要作用就是加密数据，然后存在etcd里面，让Pod容器以挂载Volume方式进行访问，一般场景的是对某个字符串进行base64编码 进行加密</p><ul><li>场景：用户名 和 密码进行加密</li></ul><p>密码文件举例</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">data:</span> </span><br><span class="line"><span class="comment"># 下面就是定义的值密码了【其实我们设置的是redhat1和redhat2，在文件中就显示为被加密过的值了,用了base64</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">YWRtaW4=</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">YWRtaW4=</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="string">"2022-08-30T03:13:56Z"</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mysecret</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">Opaque</span></span><br></pre></td></tr></table></figure><p><strong>变量形式挂载到Pod</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -n <span class="string">'admin'</span> | base64</span><br><span class="line"><span class="comment"># 密码文件见下面</span></span><br><span class="line">kubectl create -f secret.yaml</span><br><span class="line">kubectl apply -f secret-val.yaml</span><br><span class="line">kubectl get pods</span><br><span class="line">kubectl get secret</span><br><span class="line">kubectl <span class="built_in">exec</span> -it mypod bash</span><br><span class="line"><span class="comment"># 输出用户</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$SECRET_USERNAME</span></span><br><span class="line"><span class="comment"># 输出密码</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$SECRET_PASSWORD</span></span><br><span class="line"><span class="comment"># 要删除这个Pod，就可以使用这个命令</span></span><br><span class="line">kubectl delete -f secret-val.yaml</span><br></pre></td></tr></table></figure><p>然后可以将密码文件挂载到pod，注意名字和key要和密码文件一一对应</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mypod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">env:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">SECRET_USERNAME</span></span><br><span class="line">      <span class="attr">valueFrom:</span></span><br><span class="line">        <span class="attr">secretKeyRef:</span> </span><br><span class="line">          <span class="attr">name:</span> <span class="string">mysecret</span></span><br><span class="line">          <span class="attr">key:</span> <span class="string">username</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">SECRET_PASSWORD</span></span><br><span class="line">      <span class="attr">valueFrom:</span></span><br><span class="line">        <span class="attr">secretKeyRef:</span> </span><br><span class="line">          <span class="attr">name:</span> <span class="string">mysecret</span></span><br><span class="line">          <span class="attr">key:</span> <span class="string">password</span></span><br></pre></td></tr></table></figure><p><strong>数据卷形式挂载</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据配置创建容器</span></span><br><span class="line">kubectl apply -f secret-val.yaml</span><br><span class="line"><span class="comment"># 进入容器</span></span><br><span class="line">kubectl <span class="built_in">exec</span> -it mypod bash</span><br><span class="line"><span class="comment"># 查看，会发现username文件和password文件</span></span><br><span class="line">ls /etc/foo</span><br></pre></td></tr></table></figure><p>修改secret-val.yaml文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mypod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">foo</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">"/etc/foo"</span></span><br><span class="line">      <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">foo</span></span><br><span class="line">    <span class="attr">secret:</span></span><br><span class="line">      <span class="attr">secretName:</span> <span class="string">mysecret</span></span><br></pre></td></tr></table></figure><p>举例docker密钥的保存</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##命令格式</span></span><br><span class="line"><span class="string">kubectl</span> <span class="string">create</span> <span class="string">secret</span> <span class="string">docker-registry</span> <span class="string">regcred</span> <span class="string">\</span></span><br><span class="line">  <span class="string">--docker-server=&lt;你的镜像仓库服务器&gt;</span> <span class="string">\</span></span><br><span class="line">  <span class="string">--docker-username=&lt;你的用户名&gt;</span> <span class="string">\</span></span><br><span class="line">  <span class="string">--docker-password=&lt;你的密码&gt;</span> <span class="string">\</span></span><br><span class="line">  <span class="string">--docker-email=&lt;你的邮箱地址&gt;</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="string">---</span></span><br><span class="line">  <span class="comment"># 编写pod，这样就可以拉取私密镜像仓库了</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">private-nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">private-nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">shawn/guignginx:v1.0</span></span><br><span class="line">  <span class="attr">imagePullSecrets:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">shawn-docker</span></span><br></pre></td></tr></table></figure><h3 id="1-2-ConfigMap">1.2 ConfigMap</h3><blockquote><p>参考文档：<a href="https://kubernetes.io/zh/docs/concepts/configuration/configmap/" target="_blank" rel="noopener" title="https://kubernetes.io/zh/docs/concepts/configuration/configmap/">https://kubernetes.io/zh/docs/concepts/configuration/configmap/</a></p></blockquote><p>ConfigMap作用是存储不加密的数据到etcd中，让Pod以变量或数据卷Volume挂载到容器中；应用场景：配置文件</p><p>首先我们需要创建一个配置文件 redis.properties</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis.port&#x3D;127.0.0.1</span><br><span class="line">redis.port&#x3D;6379</span><br><span class="line">redis.password&#x3D;123456</span><br></pre></td></tr></table></figure><p>我们使用命令创建configmap</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl create configmap redis-config --from-file=redis.properties</span><br><span class="line"><span class="comment"># 然后查看详细信息</span></span><br><span class="line">kubectl get configmap</span><br><span class="line">kubectl describe cm redis-config</span><br></pre></td></tr></table></figure><p><strong>Volume数据卷形式挂载</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mypod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">["/bin/sh","-c","cat</span> <span class="string">/etc/config/redis.properties"]</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config-volume</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/etc/config</span></span><br><span class="line">      </span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config-volume</span></span><br><span class="line">    <span class="attr">configMap:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">redis-config</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">Never</span></span><br></pre></td></tr></table></figure><p>以redis举例，可以抽取应用配置，并且可以自动更新；修改了CM，Pod里面的配置文件会跟着变，但要用需要重启redis</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">data:</span>    <span class="comment">#data是所有真正的数据，key：默认是文件名   value：配置文件的内容</span></span><br><span class="line">  <span class="attr">redis.conf:</span> <span class="string">|</span></span><br><span class="line">    <span class="string">appendonly</span> <span class="literal">yes</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">redis-conf</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">  </span><br><span class="line"> <span class="string">----</span></span><br><span class="line"><span class="comment"># 创建配置，redis保存到k8s的etcd；</span></span><br><span class="line"><span class="string">kubectl</span> <span class="string">create</span> <span class="string">cm</span> <span class="string">redis-conf</span> <span class="string">--from-file=redis.conf</span></span><br><span class="line"></span><br><span class="line"><span class="string">----</span></span><br><span class="line"><span class="comment"># 创建pod</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">command:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis-server</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"/redis-master/redis.conf"</span>  <span class="comment">#指的是redis容器内部的位置</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/data</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">data</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/redis-master</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">config</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">data</span></span><br><span class="line">      <span class="attr">emptyDir:</span> <span class="string">&#123;&#125;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config</span></span><br><span class="line">      <span class="attr">configMap:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">redis-conf</span></span><br><span class="line">        <span class="attr">items:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">redis.conf</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">redis.conf</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># 检查默认配置</span></span><br><span class="line"><span class="string">kubectl</span> <span class="string">exec</span> <span class="string">-it</span> <span class="string">redis</span> <span class="string">--</span> <span class="string">redis-cli</span></span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">CONFIG</span> <span class="string">GET</span> <span class="string">appendonly</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">CONFIG</span> <span class="string">GET</span> <span class="string">requirepass</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查配置是否更新</span></span><br><span class="line"><span class="string">kubectl</span> <span class="string">exec</span> <span class="string">-it</span> <span class="string">redis</span> <span class="string">--</span> <span class="string">redis-cli</span></span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">CONFIG</span> <span class="string">GET</span> <span class="string">maxmemory</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">CONFIG</span> <span class="string">GET</span> <span class="string">maxmemory-policy</span></span><br></pre></td></tr></table></figure><p><strong>以变量的形式挂载Pod</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">myconfig</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">special.level:</span> <span class="string">info</span></span><br><span class="line">  <span class="attr">special.type:</span> <span class="string">hello</span></span><br></pre></td></tr></table></figure><p>命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建pod</span></span><br><span class="line">kubectl apply -f myconfig.yaml</span><br><span class="line"><span class="comment"># 获取</span></span><br><span class="line">kubectl get cm</span><br><span class="line">kubectl logs mypod</span><br></pre></td></tr></table></figure><p>然后创建可以挂载的Pod</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mypod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">["/bin/sh","-c","echo</span> <span class="string">$(LEVEL)</span> <span class="string">$(TYPE)"]</span></span><br><span class="line">    <span class="attr">env:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">LEVEL</span></span><br><span class="line">      <span class="attr">valueFrom:</span></span><br><span class="line">        <span class="attr">configMapKeyRef:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">myconfig</span></span><br><span class="line">          <span class="attr">key:</span> <span class="string">special.level</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">TYPE</span></span><br><span class="line">      <span class="attr">valueFrom:</span></span><br><span class="line">        <span class="attr">configMapKeyRef:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">myconfig</span></span><br><span class="line">          <span class="attr">key:</span> <span class="string">special.type</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">Never</span></span><br></pre></td></tr></table></figure><h2 id="2、Kubernetes集群安全机制">2、Kubernetes集群安全机制</h2><h3 id="2-1-概述">2.1 概述</h3><p>当我们访问K8S集群时，需要经过三个步骤完成具体操作</p><ul><li>认证</li><li>鉴权【授权】</li><li>准入控制</li></ul><p>进行访问的时候，<strong>都需要经过 apiserver， apiserver做统一协调</strong>，比如门卫</p><ul><li>访问过程中，需要证书、token、或者用户名和密码</li><li>如果访问pod需要serviceAccount</li></ul><p><strong>认证</strong></p><p>对外不暴露8080端口，只能内部访问，对外使用的端口6443，客户端身份认证常用方式</p><ul><li>https证书认证，基于ca证书</li><li>http token认证，通过token来识别用户</li><li>http基本认证，用户名 + 密码认证</li></ul><p><strong>鉴权</strong></p><p>基于RBAC进行鉴权操作；基于角色访问控制</p><p><strong>准入控制</strong></p><p>就是准入控制器的列表，如果列表有请求内容就通过，没有的话 就拒绝</p><h3 id="2-2-RBAC介绍">2.2 RBAC介绍</h3><p>基于角色的访问控制，为某个角色设置访问内容，然后用户分配该角色后，就拥有该角色的访问权限</p><p><img src="https://img-blog.csdnimg.cn/afaaa16b72914272aae9bb3cbf522f1b.png#pic_center" alt="在这里插入图片描述"></p><p>k8s中有默认的几个角色</p><ul><li>role：特定命名空间访问权限</li><li>ClusterRole：所有命名空间的访问权限</li></ul><p>角色绑定</p><ul><li>roleBinding：角色绑定到主体</li><li>ClusterRoleBinding：集群角色绑定到主体</li></ul><p>主体</p><ul><li>user：用户</li><li>group：用户组</li><li>serviceAccount：服务账号</li></ul><h3 id="2-3-RBAC实现鉴权">2.3 RBAC实现鉴权</h3><p>首先创建角色， rbac-role.yaml进行创建，这个角色只对pod 有 get、list权限</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">pod-reader</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">roledemo</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> <span class="string">[""]</span> <span class="comment"># ""indicates the core API group</span></span><br><span class="line">  <span class="attr">resources:</span> <span class="string">["pods"]</span></span><br><span class="line">  <span class="attr">verbs:</span> <span class="string">["get","watch","list"]</span></span><br></pre></td></tr></table></figure><p>相关命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看已经存在的命名空间</span></span><br><span class="line">kubectl get namespace</span><br><span class="line"><span class="comment"># 创建一个自己的命名空间 roledemo</span></span><br><span class="line">kubectl create ns roledemo</span><br><span class="line"><span class="comment"># 默认是在default空间下</span></span><br><span class="line">kubectl run nginx --image=nginx -n roledemo</span><br><span class="line"><span class="comment"># 查看</span></span><br><span class="line">kubectl get pod -n roledemo</span><br><span class="line"><span class="comment"># 创建</span></span><br><span class="line">kubectl apply -f rbac-role.yaml</span><br><span class="line"><span class="comment"># 查看角色</span></span><br><span class="line">kubectl get role -n roledemo</span><br></pre></td></tr></table></figure><p>然后进行<strong>创建角色绑定</strong>，通过 role-rolebinding.yaml 的方式，来创建我们的角色绑定</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">RoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">read-pods</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">roledemo</span>  </span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">shawn</span></span><br><span class="line">     <span class="attr">kind:</span> <span class="string">User</span></span><br><span class="line">     <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">     <span class="attr">name:</span> <span class="string">pod-reader</span> <span class="comment"># 这里的名称必须与你想要绑定的 Role 或 ClusterRole 名称一致</span></span><br><span class="line">     <span class="attr">kind:</span> <span class="string">Role</span> <span class="comment">#这里必须是Role或者ClusterRole</span></span><br><span class="line">     <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></table></figure><p>执行相关命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建角色绑定</span></span><br><span class="line">kubectl apply -f rbac-rolebinding.yaml</span><br><span class="line"><span class="comment"># 查看角色绑定</span></span><br><span class="line">kubectl get role, rolebinding -n roledemo</span><br><span class="line"><span class="comment"># http://docs.kubernetes.org.cn/494.html</span></span><br><span class="line"><span class="comment"># 在集群范围将cluster-admin ClusterRole授予用户user1，user2和group1</span></span><br><span class="line">kubectl create clusterrolebinding cluster-admin --clusterrole=cluster-admin --user=user1 --user=user2 --group=group1</span><br></pre></td></tr></table></figure><h2 id="3、核心技术Ingress">3、核心技术Ingress</h2><blockquote><p>官网地址：<a href="https://kubernetes.github.io/ingress-nginx/" target="_blank" rel="noopener" title="https://kubernetes.github.io/ingress-nginx/">https://kubernetes.github.io/ingress-nginx/</a></p></blockquote><h3 id="3-1-前言概述">3.1 前言概述</h3><p>原来我们需要将端口号对外暴露，通过 ip + 端口号就可以进行访问，是使用Service中的NodePort来实现</p><ul><li>在每个节点上都会启动端口</li><li>在访问的时候通过任何节点，通过ip + 端口号就能实现访问</li></ul><p>但是NodePort还存在一些缺陷</p><ul><li>因为端口不能重复，所以每个端口只能使用一次，一个端口对应一个应用</li><li>实际访问中都是用域名，根据不同域名跳转到不同端口服务中</li></ul><h3 id="3-2-Ingress和Pod关系">3.2 Ingress和Pod关系</h3><p>pod 和 ingress 是通过service进行关联的，而ingress作为统一入口，由service关联一组pod中</p><ul><li>首先service就是关联我们的pod</li><li>然后ingress作为入口，首先需要到service，然后发现一组pod</li><li>发现pod后，就可以做负载均衡等操作</li></ul><p>在实际的访问中，我们都是需要维护很多域名，<a href="http://a.com" target="_blank" rel="noopener">a.com</a> 和 b.com然后不同的域名对应的不同的Service，然后service管理不同的pod(ingress不是内置的组件，需要我们单独的安装)，相当于Nginx</p><p><img src="https://img-blog.csdnimg.cn/b412fc190bd144fdb4d9f81e1f6968ed.png#pic_center" alt="在这里插入图片描述"></p><h3 id="3-3-创建Ingress规则">3.3 创建Ingress规则</h3><blockquote><p>参考：<a href="https://blog.csdn.net/weixin_41831919/article/details/118463892" target="_blank" rel="noopener" title="ingress-controller部署">ingress-controller部署</a><br>github：<a href="https://github.com/kubernetes/ingress-nginx" target="_blank" rel="noopener" title="https://github.com/kubernetes/ingress-nginx">https://github.com/kubernetes/ingress-nginx</a></p></blockquote><ul><li>部署ingress Controller【需要下载官方的】</li><li>创建ingress规则【对哪个Pod、名称空间配置规则】</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个nginx应用，然后对外暴露端口，创建pod</span></span><br><span class="line">kubectl create deployment web --image=nginx</span><br><span class="line"><span class="comment"># 查看</span></span><br><span class="line">kubectl get pods</span><br><span class="line"><span class="comment"># 对外暴露端口</span></span><br><span class="line">kubectl expose deployment web --port=80 --target-port=80 --<span class="built_in">type</span>=NodePort</span><br><span class="line">kubectl get svc</span><br><span class="line"><span class="comment"># 额外下载,这个有版本匹配要求</span></span><br><span class="line"><span class="comment"># wget https://raw.githubusercontent.com/kubernetes/ingress-nginx/nginx-0.30.0/deploy/static/mandatory.yaml -O nginx-ingress-controller.yaml</span></span><br><span class="line"><span class="comment"># 可以在spec.template.spec添加 hostNetwork: true，改成ture是为了让后面访问到，不然就是使用service的"type: NodePort"方式暴露的</span></span><br><span class="line"><span class="comment"># 使用"hostNetwork: true"配置网络，pod中运行的应用程序可以直接看到宿主主机的网络接口，宿主机所在的局域网上所有网络接口都可以访问到该应用程序及端口</span></span><br><span class="line"></span><br><span class="line">kubectl apply -f ingress-controller.yaml</span><br><span class="line"><span class="comment"># 查看一下</span></span><br><span class="line">kubectl get pod -n ingress-nginx</span><br><span class="line">kubectl get pod,svc -n ingress-nginx</span><br><span class="line"><span class="comment"># 然后可以测试访问一下端口</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建ingress规则文件ingress.yaml，如下，然后运行</span></span><br><span class="line">kubectl apply -f ingress.yaml</span><br><span class="line"><span class="comment"># 最后通过下面命令，查看是否成功部署 ingress</span></span><br><span class="line">kubectl get pods -n ingress-nginx</span><br></pre></td></tr></table></figure><p>现在还只能在集群内部访问，需要暴露service，<code>vimservice-nodeport.yaml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ingress-nginx</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">ingress-nginx</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/name:</span> <span class="string">ingress-nginx</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/part-of:</span> <span class="string">ingress-nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="comment"># HTTP</span></span><br><span class="line">      <span class="attr">nodePort:</span> <span class="number">32080</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">https</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">443</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">443</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">     <span class="comment"># HTTPS</span></span><br><span class="line">      <span class="attr">nodePort:</span> <span class="number">32443</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/name:</span> <span class="string">ingress-nginx</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/part-of:</span> <span class="string">ingress-nginx</span></span><br></pre></td></tr></table></figure><p>ingress.yaml规则文件，注意不同版本间的写法有差异</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ingress-host-bar</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="comment"># 这是访问的域名</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">shawn.com</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">      <span class="comment"># 路径，可以分割，把请求会转给下面的服务，下面的服务一定要能处理这个路径，不能处理就是404</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">nginx</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>在windows 的 hosts文件，添加域名访问规则【因为我们没有域名解析，所以只能这样做】,最后通过<code>域名:32080</code>就能访问</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xx.xx.xx.xx shawn.com</span><br></pre></td></tr></table></figure><h3 id="3-4-其他高级配置">3.4 其他高级配置</h3><p>其他高级选项和nginx类似，可以通过高级注解选择，参考：<a href="https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations/" target="_blank" rel="noopener" title="nginx-ingress注解官网">nginx-ingress注解官网</a></p><p><strong>路径重写</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">nginx.ingress.kubernetes.io/rewrite-target:</span> <span class="string">/$2</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ingress-rewrite-bar</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="comment"># 这是访问的域名</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">"rewrite.shawn.com"</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">        <span class="comment"># 重写路径，去除nginx</span></span><br><span class="line">        <span class="comment"># 把请求会转给下面的服务，下面的服务一定要能处理这个路径，不能处理就是404</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/something(/|$)(.*)</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">nginx</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>流量限制</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ingress-limit-rate</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">nginx.ingress.kubernetes.io/limit-rps:</span> <span class="string">"1"</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="comment"># 这是访问的域名</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">"limit.shawn.com"</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">pathType:</span> <span class="string">Exact</span></span><br><span class="line">        <span class="comment"># 重写路径，去除nginx</span></span><br><span class="line">        <span class="comment"># 把请求会转给下面的服务，下面的服务一定要能处理这个路径，不能处理就是404</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">"/"</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">nginx</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><h2 id="4、Kubernetes核心技术Helm">4、Kubernetes核心技术Helm</h2><blockquote><p>Helm官网：<a href="https://helm.sh/zh/" target="_blank" rel="noopener" title="https://helm.sh/zh/">https://helm.sh/zh/</a><br>包搜索：<a href="https://artifacthub.io/" target="_blank" rel="noopener" title="https://artifacthub.io/">https://artifacthub.io/</a></p></blockquote><h3 id="4-1-Helm概述">4.1 Helm概述</h3><p>Helm是一个Kubernetes的包管理工具，就像Linux下的包管理器，如yum/apt等，可以很方便的将之前打包好的yaml文件部署到kubernetes上。<strong>Helm就是一个包管理工具【类似于npm】</strong>。Helm有三个重要概念</p><ul><li>helm：一个命令行客户端工具，主要用于Kubernetes应用chart的创建、打包、发布和管理</li><li>Chart：应用描述，一系列用于描述k8s资源相关文件的集合</li><li>Release：基于Chart的部署实体，一个chart被Helm运行后将会生成对应的release，将在K8S中创建出真实的运行资源对象。也就是应用级别的版本管理</li><li>Repository：用于发布和存储Chart的仓库</li></ul><p><strong>V3版本变化</strong></p><ul><li>架构变化<ul><li>最明显的变化是Tiller的删除</li><li>V3版本删除Tiller</li><li>relesase可以在不同命名空间重用</li></ul></li></ul><h3 id="4-2-helm下载与配置">4.2 helm下载与配置</h3><blockquote><p>安装文档：<a href="https://helm.sh/zh/docs/intro/install/" target="_blank" rel="noopener" title="https://helm.sh/zh/docs/intro/install/">https://helm.sh/zh/docs/intro/install/</a></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 脚本安装，不过可能会失败</span></span><br><span class="line">curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash</span><br><span class="line"><span class="comment"># 手动进行安装</span></span><br><span class="line">wget https://get.helm.sh/helm-v3.10.1-linux-amd64.tar.gz</span><br><span class="line">tar -zxvf helm-v3.10.1-linux-amd64.tar.gz</span><br><span class="line">sudo mv linux-amd64/helm /usr/<span class="built_in">local</span>/bin/helm</span><br><span class="line">helm --<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置微软源</span></span><br><span class="line">helm repo add stable http://mirror.azure.cn/kubernetes/charts</span><br><span class="line"><span class="comment"># 配置阿里源</span></span><br><span class="line">helm repo add aliyun https://kubernetes.oss-cn-hangzhou.aliyuncs.com/charts</span><br><span class="line"><span class="comment"># 配置google源</span></span><br><span class="line">helm repo add google https://kubernetes-charts.storage.googleapis.com/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新</span></span><br><span class="line">helm repo update</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看全部</span></span><br><span class="line">helm repo list</span><br><span class="line"><span class="comment"># 查看某个</span></span><br><span class="line">helm search repo stable</span><br><span class="line"><span class="comment"># 删除我们添加的源</span></span><br><span class="line">helm repo remove stable</span><br></pre></td></tr></table></figure><h3 id="4-3-使用helm快速部署应用">4.3 使用helm快速部署应用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 搜索 weave仓库</span></span><br><span class="line">helm search repo weave</span><br><span class="line"><span class="comment"># 搜索完成后，使用命令进行安装</span></span><br><span class="line">helm install ui aliyun/weave-scope</span><br><span class="line"><span class="comment"># 来下载yaml文件【如果】</span></span><br><span class="line">kubectl apply -f weave-scope.yaml</span><br><span class="line"><span class="comment"># 查看</span></span><br><span class="line">helm list</span><br><span class="line">helm install ui stable/weave-scope</span><br><span class="line"><span class="comment"># 查询状态</span></span><br><span class="line">helm status ui</span><br><span class="line"><span class="comment"># 我们通过查看 svc状态，发现没有对象暴露端口</span></span><br><span class="line"><span class="comment"># 需要修改service的yaml文件，添加NodePort</span></span><br><span class="line">kubectl edit svc ui-weave-scope</span><br></pre></td></tr></table></figure><h3 id="4-4-自定义Chart">4.4 自定义Chart</h3><p>目录格式</p><ul><li>templates：编写yaml文件存放到这个目录</li><li>values.yaml：存放的是全局的yaml文件</li><li>chart.yaml：当前chart属性配置信息</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用命令，自己创建Chart</span></span><br><span class="line">helm create mychart</span><br><span class="line"><span class="comment"># 在templates文件夹创建两个文件</span></span><br><span class="line"><span class="comment"># 导出deployment.yaml</span></span><br><span class="line">kubectl create deployment web1 --image=nginx --dry-run -o yaml &gt; deployment.yaml</span><br><span class="line"><span class="comment"># 导出service.yaml 【可能需要创建 deployment，不然会报错】</span></span><br><span class="line">kubectl expose deployment web1 --port=80 --target-port=80 --<span class="built_in">type</span>=NodePort --dry-run -o yaml &gt; service.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行命令创建,在mychart/外层目录执行</span></span><br><span class="line">helm install web1 mychart</span><br><span class="line"><span class="comment"># 当我们修改了mychart中的东西后，就可以进行升级操作</span></span><br><span class="line">helm upgrade web1 mychart</span><br></pre></td></tr></table></figure><h3 id="4-5-chart模板使用">4.5 chart模板使用</h3><blockquote><p>通过传递参数，动态渲染模板，yaml内容动态从传入参数生成</p></blockquote><p>刚刚我们创建mychart的时候，看到有values.yaml文件，这个文件就是一些全局的变量，然后在templates中能取到变量的值，下面我们可以利用这个，来完成动态模板</p><ul><li>在values.yaml定义变量和值</li><li>具体yaml文件，获取定义变量值</li><li>yaml文件中大题有几个地方不同<ul><li>image</li><li>tag</li><li>label</li><li>port</li><li>replicas</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在values.yaml定义变量和值</span></span><br><span class="line">replicas: 3</span><br><span class="line">image: nginx</span><br><span class="line">tag: 1.16</span><br><span class="line">label: nginx</span><br><span class="line">port: 80</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取变量和值</span></span><br><span class="line"><span class="comment"># 我们通过表达式形式 使用全局变量 &#123;&#123;.Values.变量名称&#125;&#125; 例如： &#123;&#123;.Release.Name&#125;&#125;</span></span><br><span class="line"><span class="comment"># 然后修改模板文件</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成文件查看一下</span></span><br><span class="line">helm install --dry-run web2 mychart</span><br><span class="line"><span class="comment"># 正式执行</span></span><br><span class="line">helm install web2 mychart</span><br></pre></td></tr></table></figure><p>修改模板文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># deployment.yaml文件</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">&#123;&#123;.Release.Name&#125;&#125;-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="string">&#123;&#123;.Values.replicas&#125;&#125;</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">&#123;&#123;.Values.label&#125;&#125;</span></span><br><span class="line">  <span class="attr">strategy:</span> <span class="string">&#123;&#125;</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">&#123;&#123;.Values.label&#125;&#125;</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">&#123;&#123;.Values.image&#125;&#125;</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">resources:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="attr">status:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">----</span></span><br><span class="line"><span class="comment"># service.yaml文件</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">&#123;&#123;.Release.Name&#125;&#125;-svc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="string">&#123;&#123;.Values.port&#125;&#125;</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">&#123;&#123;.Values.label&#125;&#125;</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line"><span class="attr">status:</span></span><br><span class="line">  <span class="attr">loadBalancer:</span> <span class="string">&#123;&#125;</span></span><br></pre></td></tr></table></figure><h2 id="5、命名空间">5、命名空间</h2><blockquote><p>如果一个集群中部署了多个应用，所有应用都在一起，就不太好管理，也可以导致名字冲突等。我们可以使用 namespace 把应用划分到不同的命名空间，跟代码里的 namespace 是一个概念，只是为了划分空间</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建命名空间</span></span><br><span class="line">kubectl create namespace testapp</span><br><span class="line"><span class="comment"># 部署应用到指定的命名空间</span></span><br><span class="line">kubectl apply -f app.yml --namespace testapp</span><br><span class="line"><span class="comment"># 查询</span></span><br><span class="line">kubectl get pod --namespace kube-system</span><br><span class="line"><span class="comment"># 查询命名空间</span></span><br><span class="line">kubectl get ns</span><br></pre></td></tr></table></figure><p>可以用 <a href="https://github.com/ahmetb/kubectx" target="_blank" rel="noopener" title="kubens">kubens</a> 快速切换 namespace，首先进行下载安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/ahmetb/kubectx/releases/download/v0.9.4/kubens_v0.9.4_linux_x86_64.tar.gz</span><br><span class="line">tar -zxvf kubens_v0.9.4_linux_x86_64.tar.gz</span><br><span class="line">sudo mv kubens /usr/<span class="built_in">local</span>/bin/kubens</span><br><span class="line"><span class="comment"># 查看所有命名空间</span></span><br><span class="line">kubens</span><br><span class="line"><span class="comment"># 切换命名空间</span></span><br><span class="line">kubens kube-system</span><br><span class="line"><span class="comment"># 回到上个命名空间</span></span><br><span class="line">kubens -</span><br><span class="line"><span class="comment"># 切换集群</span></span><br><span class="line"><span class="comment"># kubectx minikube</span></span><br></pre></td></tr></table></figure><h2 id="6、Kubernetes持久化存储">6、Kubernetes持久化存储</h2><h3 id="6-1-概述">6.1 概述</h3><p>之前我们有提到数据卷：<code>emptydir</code> ，是本地存储，pod重启，数据就不存在了，需要对数据持久化存储，对于数据持久化存储【pod重启，数据还存在】，有两种方式</p><ul><li>nfs：网络存储【通过一台服务器来存储】</li><li>PV和PVC</li></ul><h3 id="6-2-nfs网络存储">6.2 nfs网络存储</h3><p>持久化服务器上操作，所有结点都需要安装nfs-utils</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 找一台新的服务器nfs服务端，安装nfs,设置挂载路径,使用命令安装nfs</span></span><br><span class="line">yum install -y nfs-utils</span><br><span class="line"><span class="comment"># 首先创建存放数据的目录</span></span><br><span class="line">mkdir -p /data/nfs</span><br><span class="line"><span class="comment"># 设置挂载路径</span></span><br><span class="line"><span class="comment"># 打开文件</span></span><br><span class="line">vim /etc/exports</span><br><span class="line"><span class="comment"># 添加如下内容</span></span><br><span class="line"><span class="comment"># /data/nfs *(rw,no_root_squash)</span></span><br><span class="line"><span class="comment"># 或者执行</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"/data/nfs/ *(insecure,rw,sync,no_root_squash)"</span> &gt; /etc/exports</span><br><span class="line"><span class="comment"># 执行完成后，即部署完我们的持久化服务器</span></span><br><span class="line"></span><br><span class="line">systemctl <span class="built_in">enable</span> rpcbind --now</span><br><span class="line">systemctl <span class="built_in">enable</span> nfs-server --now</span><br><span class="line"><span class="comment">#配置生效</span></span><br><span class="line">exportfs -r</span><br></pre></td></tr></table></figure><p>从节点上操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 然后需要在k8s集群node节点上安装nfs，这里需要在 node1 和 node2节点上安装</span></span><br><span class="line">yum install -y nfs-utils</span><br><span class="line"><span class="comment"># 执行完成后，会自动帮我们挂载上</span></span><br><span class="line"></span><br><span class="line">showmount -e 192.168.249.139</span><br><span class="line"><span class="comment">#执行以下命令挂载 nfs 服务器上的共享目录到本机路径 /root/nfsmount</span></span><br><span class="line">mkdir -p /data/nfs</span><br><span class="line"></span><br><span class="line">mount -t nfs 192.168.249.139:/data/nfs /data/nfs</span><br><span class="line"><span class="comment"># 写入一个测试文件，这样两个机器就联通了</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"hello nfs server"</span> &gt; /data/nfs/test.txt</span><br></pre></td></tr></table></figure><p>K8s集群部署应用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 最后我们在k8s集群上部署应用，使用nfs持久化存储</span></span><br><span class="line"><span class="comment"># 创建一个pv文件</span></span><br><span class="line">mkdir pv</span><br><span class="line"><span class="comment"># 进入</span></span><br><span class="line"><span class="built_in">cd</span> pv</span><br></pre></td></tr></table></figure><p>创建nfs-nginx.yaml文件，注意修改ip</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-dep1</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">wwwroot</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/usr/share/nginx/html</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">wwwroot</span></span><br><span class="line">          <span class="attr">nfs:</span></span><br><span class="line">            <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.249</span><span class="number">.139</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/data/nfs</span></span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f nfs-nginx.yaml</span><br><span class="line">kubectl describe pod nginx-dep1</span><br><span class="line"><span class="comment"># 进入pod中查看</span></span><br><span class="line">kubectl <span class="built_in">exec</span> -it nginx-dep1-77f6bcbd45-q9rfz --  bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在/data/nfs创建文件，容器内部会出现，成功挂载</span></span><br><span class="line">ls /usr/share/nginx/html/</span><br><span class="line">kubectl expose deployment nginx-depl --port=80 --target-port=80 --<span class="built_in">type</span>=NodePort</span><br></pre></td></tr></table></figure><h3 id="6-3-PV和PVC">6.3 PV和PVC</h3><ul><li>PV：持久化存储，对存储的资源进行抽象，对外提供可以调用的地方【生产者】</li><li>PVC：用于调用，不需要关心内部实现细节【消费者】</li></ul><p>PV 和 PVC 使得 K8S 集群具备了存储的逻辑抽象能力。使得在配置Pod的逻辑里可以忽略对实际后台存储 技术的配置，而把这项配置的工作交给PV的配置者，即集群的管理者。存储的PV和PVC的这种关系，跟 计算的Node和Pod的关系是非常类似的；PV和Node是资源的提供者，根据集群的基础设施变化而变 化，由K8s集群管理员配置；而PVC和Pod是资源的使用者，根据业务服务的需求变化而变化，由K8s集 群的使用者即服务的管理员来配置。</p><p><strong>实现流程</strong></p><ul><li>PVC绑定PV</li><li>定义PVC</li><li>定义PV【数据卷定义，指定数据存储服务器的ip、路径、容量和匹配模式】</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pvc.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-dep1</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">wwwroot</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/usr/share/nginx/html</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">wwwroot</span></span><br><span class="line">        <span class="attr">persistentVolumeClaim:</span></span><br><span class="line">          <span class="attr">claimName:</span> <span class="string">my-pvc</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-pvc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">3Gi</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">nfs</span>    </span><br><span class="line">      </span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># pv.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-pv01</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">5Gi</span></span><br><span class="line">  <span class="comment"># 相当于分组</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">nfs</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">nfs:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/data/nfs/01</span></span><br><span class="line">    <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.249</span><span class="number">.139</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># pv.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-pv02</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">10M</span></span><br><span class="line">  <span class="comment"># 相当于分组</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">nfs</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">nfs:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/data/nfs/02</span></span><br><span class="line">    <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.249</span><span class="number">.139</span></span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 然后就可以创建pod了</span></span><br><span class="line">kubectl apply -f pv.yaml</span><br><span class="line">kubectl apply -f pvc.yaml</span><br><span class="line"><span class="comment"># 然后我们就可以通过下面命令，查看我们的 pv 和 pvc之间的绑定关系</span></span><br><span class="line">kubectl get pv,pvc</span><br><span class="line"></span><br><span class="line">kubect <span class="built_in">exec</span> -it nginx-dep1 -- bash</span><br><span class="line"><span class="comment"># 然后查看 /usr/share/nginx.html</span></span><br></pre></td></tr></table></figure><p>如果删除了pvc，会发现pv状态是处于Released的，需要进入特定的pv配置文件，删除<strong>claimRef</strong>下的内容即可</p><h1>五、搭建集群监控平台系统</h1><h2 id="1、监控指标">1、监控指标</h2><p>一个好的监控系统主要监控以下内容：</p><ul><li>集群监控<ul><li>节点资源利用率</li><li>节点数</li><li>运行 Pods</li></ul></li><li>Pod 监控<ul><li>容器指标</li><li>应用程序【程序占用多少 CPU、内存】</li></ul></li></ul><p>2、监控平台<br>台</p><ul><li>prometheus【监控】<ul><li>定时搜索被监控服务的状态</li><li>开源</li><li>监控、报警、数据库</li><li>以 HTTP 协议周期性抓取被监控组件状态</li><li>不需要复杂的集成过程，使用 http 接口接入即可</li></ul></li><li>Grafana【展示】<ul><li>开源的数据分析和可视化工具</li><li>支持多种数据源</li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/5e40e1055af74cc981983ee62715fc02.png#pic_center" alt="在这里插入图片描述"></p><h2 id="3、部署-Pormetheus">3、部署 Pormetheus</h2><h3 id="3-1-创建守护进程Pod">3.1 创建守护进程Pod</h3><p>首先需要部署一个守护进程，然后创建yaml文件<code>vim node-exporter.yaml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">node-exporter</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">node-exporter</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">k8s-app:</span> <span class="string">node-exporter</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">k8s-app:</span> <span class="string">node-exporter</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">prom/node-exporter</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">node-exporter</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">9100</span></span><br><span class="line">          <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">node-exporter</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">node-exporter</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">9100</span></span><br><span class="line">    <span class="attr">nodePort:</span> <span class="number">31672</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">node-exporter</span></span><br></pre></td></tr></table></figure><p>然后通过yaml的方式部署prometheus：</p><ul><li>configmap：定义一个configmap：存储一些配置文件【不加密】</li><li>prometheus.deploy.yaml：部署一个deployment【包括端口号，资源限制】</li><li>prometheus.svc.yaml：对外暴露的端口</li><li>rbac-setup.yaml：分配一些角色的权限</li></ul><h3 id="3-2-rbac创建">3.2 rbac创建</h3><p><code>vim rbac-setup.yaml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">prometheus</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> <span class="string">[""]</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">nodes</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">nodes/proxy</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">services</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">endpoints</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">pods</span></span><br><span class="line">  <span class="attr">verbs:</span> <span class="string">["get",</span> <span class="string">"list"</span><span class="string">,</span> <span class="string">"watch"</span><span class="string">]</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">extensions</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ingresses</span></span><br><span class="line">  <span class="attr">verbs:</span> <span class="string">["get",</span> <span class="string">"list"</span><span class="string">,</span> <span class="string">"watch"</span><span class="string">]</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">nonResourceURLs:</span> <span class="string">["/metrics"]</span></span><br><span class="line">  <span class="attr">verbs:</span> <span class="string">["get"]</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">prometheus</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">prometheus</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">prometheus</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">prometheus</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br></pre></td></tr></table></figure><h3 id="3-3-ConfigMap">3.3 ConfigMap</h3><p><code>vim configmap.yaml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">prometheus-config</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">prometheus.yml:</span> <span class="string">|</span></span><br><span class="line">    <span class="attr">global:</span></span><br><span class="line">      <span class="attr">scrape_interval:</span>     <span class="string">15s</span></span><br><span class="line">      <span class="attr">evaluation_interval:</span> <span class="string">15s</span></span><br><span class="line">    <span class="attr">scrape_configs:</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">'kubernetes-apiservers'</span></span><br><span class="line">      <span class="attr">kubernetes_sd_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">role:</span> <span class="string">endpoints</span></span><br><span class="line">      <span class="attr">scheme:</span> <span class="string">https</span></span><br><span class="line">      <span class="attr">tls_config:</span></span><br><span class="line">        <span class="attr">ca_file:</span> <span class="string">/var/run/secrets/kubernetes.io/serviceaccount/ca.crt</span></span><br><span class="line">      <span class="attr">bearer_token_file:</span> <span class="string">/var/run/secrets/kubernetes.io/serviceaccount/token</span></span><br><span class="line">      <span class="attr">relabel_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">source_labels:</span> <span class="string">[__meta_kubernetes_namespace,</span> <span class="string">__meta_kubernetes_service_name,</span> <span class="string">__meta_kubernetes_endpoint_port_name]</span></span><br><span class="line">        <span class="attr">action:</span> <span class="string">keep</span></span><br><span class="line">        <span class="attr">regex:</span> <span class="string">default;kubernetes;https</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">'kubernetes-nodes'</span></span><br><span class="line">      <span class="attr">kubernetes_sd_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">role:</span> <span class="string">node</span></span><br><span class="line">      <span class="attr">scheme:</span> <span class="string">https</span></span><br><span class="line">      <span class="attr">tls_config:</span></span><br><span class="line">        <span class="attr">ca_file:</span> <span class="string">/var/run/secrets/kubernetes.io/serviceaccount/ca.crt</span></span><br><span class="line">      <span class="attr">bearer_token_file:</span> <span class="string">/var/run/secrets/kubernetes.io/serviceaccount/token</span></span><br><span class="line">      <span class="attr">relabel_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">action:</span> <span class="string">labelmap</span></span><br><span class="line">        <span class="attr">regex:</span> <span class="string">__meta_kubernetes_node_label_(.+)</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">target_label:</span> <span class="string">__address__</span></span><br><span class="line">        <span class="attr">replacement:</span> <span class="string">kubernetes.default.svc:443</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">source_labels:</span> <span class="string">[__meta_kubernetes_node_name]</span></span><br><span class="line">        <span class="attr">regex:</span> <span class="string">(.+)</span></span><br><span class="line">        <span class="attr">target_label:</span> <span class="string">__metrics_path__</span></span><br><span class="line">        <span class="attr">replacement:</span> <span class="string">/api/v1/nodes/$&#123;1&#125;/proxy/metrics</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">'kubernetes-cadvisor'</span></span><br><span class="line">      <span class="attr">kubernetes_sd_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">role:</span> <span class="string">node</span></span><br><span class="line">      <span class="attr">scheme:</span> <span class="string">https</span></span><br><span class="line">      <span class="attr">tls_config:</span></span><br><span class="line">        <span class="attr">ca_file:</span> <span class="string">/var/run/secrets/kubernetes.io/serviceaccount/ca.crt</span></span><br><span class="line">      <span class="attr">bearer_token_file:</span> <span class="string">/var/run/secrets/kubernetes.io/serviceaccount/token</span></span><br><span class="line">      <span class="attr">relabel_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">action:</span> <span class="string">labelmap</span></span><br><span class="line">        <span class="attr">regex:</span> <span class="string">__meta_kubernetes_node_label_(.+)</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">target_label:</span> <span class="string">__address__</span></span><br><span class="line">        <span class="attr">replacement:</span> <span class="string">kubernetes.default.svc:443</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">source_labels:</span> <span class="string">[__meta_kubernetes_node_name]</span></span><br><span class="line">        <span class="attr">regex:</span> <span class="string">(.+)</span></span><br><span class="line">        <span class="attr">target_label:</span> <span class="string">__metrics_path__</span></span><br><span class="line">        <span class="attr">replacement:</span> <span class="string">/api/v1/nodes/$&#123;1&#125;/proxy/metrics/cadvisor</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">'kubernetes-service-endpoints'</span></span><br><span class="line">      <span class="attr">kubernetes_sd_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">role:</span> <span class="string">endpoints</span></span><br><span class="line">      <span class="attr">relabel_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">source_labels:</span> <span class="string">[__meta_kubernetes_service_annotation_prometheus_io_scrape]</span></span><br><span class="line">        <span class="attr">action:</span> <span class="string">keep</span></span><br><span class="line">        <span class="attr">regex:</span> <span class="literal">true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">source_labels:</span> <span class="string">[__meta_kubernetes_service_annotation_prometheus_io_scheme]</span></span><br><span class="line">        <span class="attr">action:</span> <span class="string">replace</span></span><br><span class="line">        <span class="attr">target_label:</span> <span class="string">__scheme__</span></span><br><span class="line">        <span class="attr">regex:</span> <span class="string">(https?)</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">source_labels:</span> <span class="string">[__meta_kubernetes_service_annotation_prometheus_io_path]</span></span><br><span class="line">        <span class="attr">action:</span> <span class="string">replace</span></span><br><span class="line">        <span class="attr">target_label:</span> <span class="string">__metrics_path__</span></span><br><span class="line">        <span class="attr">regex:</span> <span class="string">(.+)</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">source_labels:</span> <span class="string">[__address__,</span> <span class="string">__meta_kubernetes_service_annotation_prometheus_io_port]</span></span><br><span class="line">        <span class="attr">action:</span> <span class="string">replace</span></span><br><span class="line">        <span class="attr">target_label:</span> <span class="string">__address__</span></span><br><span class="line">        <span class="attr">regex:</span> <span class="string">([^:]+)(?::\d+)?;(\d+)</span></span><br><span class="line">        <span class="attr">replacement:</span> <span class="string">$1:$2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">action:</span> <span class="string">labelmap</span></span><br><span class="line">        <span class="attr">regex:</span> <span class="string">__meta_kubernetes_service_label_(.+)</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">source_labels:</span> <span class="string">[__meta_kubernetes_namespace]</span></span><br><span class="line">        <span class="attr">action:</span> <span class="string">replace</span></span><br><span class="line">        <span class="attr">target_label:</span> <span class="string">kubernetes_namespace</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">source_labels:</span> <span class="string">[__meta_kubernetes_service_name]</span></span><br><span class="line">        <span class="attr">action:</span> <span class="string">replace</span></span><br><span class="line">        <span class="attr">target_label:</span> <span class="string">kubernetes_name</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">'kubernetes-services'</span></span><br><span class="line">      <span class="attr">kubernetes_sd_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">role:</span> <span class="string">service</span></span><br><span class="line">      <span class="attr">metrics_path:</span> <span class="string">/probe</span></span><br><span class="line">      <span class="attr">params:</span></span><br><span class="line">        <span class="attr">module:</span> <span class="string">[http_2xx]</span></span><br><span class="line">      <span class="attr">relabel_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">source_labels:</span> <span class="string">[__meta_kubernetes_service_annotation_prometheus_io_probe]</span></span><br><span class="line">        <span class="attr">action:</span> <span class="string">keep</span></span><br><span class="line">        <span class="attr">regex:</span> <span class="literal">true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">source_labels:</span> <span class="string">[__address__]</span></span><br><span class="line">        <span class="attr">target_label:</span> <span class="string">__param_target</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">target_label:</span> <span class="string">__address__</span></span><br><span class="line">        <span class="attr">replacement:</span> <span class="string">blackbox-exporter.example.com:9115</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">source_labels:</span> <span class="string">[__param_target]</span></span><br><span class="line">        <span class="attr">target_label:</span> <span class="string">instance</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">action:</span> <span class="string">labelmap</span></span><br><span class="line">        <span class="attr">regex:</span> <span class="string">__meta_kubernetes_service_label_(.+)</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">source_labels:</span> <span class="string">[__meta_kubernetes_namespace]</span></span><br><span class="line">        <span class="attr">target_label:</span> <span class="string">kubernetes_namespace</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">source_labels:</span> <span class="string">[__meta_kubernetes_service_name]</span></span><br><span class="line">        <span class="attr">target_label:</span> <span class="string">kubernetes_name</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">'kubernetes-ingresses'</span></span><br><span class="line">      <span class="attr">kubernetes_sd_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">role:</span> <span class="string">ingress</span></span><br><span class="line">      <span class="attr">relabel_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">source_labels:</span> <span class="string">[__meta_kubernetes_ingress_annotation_prometheus_io_probe]</span></span><br><span class="line">        <span class="attr">action:</span> <span class="string">keep</span></span><br><span class="line">        <span class="attr">regex:</span> <span class="literal">true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">source_labels:</span> <span class="string">[__meta_kubernetes_ingress_scheme,__address__,__meta_kubernetes_ingress_path]</span></span><br><span class="line">        <span class="attr">regex:</span> <span class="string">(.+);(.+);(.+)</span></span><br><span class="line">        <span class="attr">replacement:</span> <span class="string">$&#123;1&#125;://$&#123;2&#125;$&#123;3&#125;</span></span><br><span class="line">        <span class="attr">target_label:</span> <span class="string">__param_target</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">target_label:</span> <span class="string">__address__</span></span><br><span class="line">        <span class="attr">replacement:</span> <span class="string">blackbox-exporter.example.com:9115</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">source_labels:</span> <span class="string">[__param_target]</span></span><br><span class="line">        <span class="attr">target_label:</span> <span class="string">instance</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">action:</span> <span class="string">labelmap</span></span><br><span class="line">        <span class="attr">regex:</span> <span class="string">__meta_kubernetes_ingress_label_(.+)</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">source_labels:</span> <span class="string">[__meta_kubernetes_namespace]</span></span><br><span class="line">        <span class="attr">target_label:</span> <span class="string">kubernetes_namespace</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">source_labels:</span> <span class="string">[__meta_kubernetes_ingress_name]</span></span><br><span class="line">        <span class="attr">target_label:</span> <span class="string">kubernetes_name</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">'kubernetes-pods'</span></span><br><span class="line">      <span class="attr">kubernetes_sd_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">role:</span> <span class="string">pod</span></span><br><span class="line">      <span class="attr">relabel_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">source_labels:</span> <span class="string">[__meta_kubernetes_pod_annotation_prometheus_io_scrape]</span></span><br><span class="line">        <span class="attr">action:</span> <span class="string">keep</span></span><br><span class="line">        <span class="attr">regex:</span> <span class="literal">true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">source_labels:</span> <span class="string">[__meta_kubernetes_pod_annotation_prometheus_io_path]</span></span><br><span class="line">        <span class="attr">action:</span> <span class="string">replace</span></span><br><span class="line">        <span class="attr">target_label:</span> <span class="string">__metrics_path__</span></span><br><span class="line">        <span class="attr">regex:</span> <span class="string">(.+)</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">source_labels:</span> <span class="string">[__address__,</span> <span class="string">__meta_kubernetes_pod_annotation_prometheus_io_port]</span></span><br><span class="line">        <span class="attr">action:</span> <span class="string">replace</span></span><br><span class="line">        <span class="attr">regex:</span> <span class="string">([^:]+)(?::\d+)?;(\d+)</span></span><br><span class="line">        <span class="attr">replacement:</span> <span class="string">$1:$2</span></span><br><span class="line">        <span class="attr">target_label:</span> <span class="string">__address__</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">action:</span> <span class="string">labelmap</span></span><br><span class="line">        <span class="attr">regex:</span> <span class="string">__meta_kubernetes_pod_label_(.+)</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">source_labels:</span> <span class="string">[__meta_kubernetes_namespace]</span></span><br><span class="line">        <span class="attr">action:</span> <span class="string">replace</span></span><br><span class="line">        <span class="attr">target_label:</span> <span class="string">kubernetes_namespace</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">source_labels:</span> <span class="string">[__meta_kubernetes_pod_name]</span></span><br><span class="line">        <span class="attr">action:</span> <span class="string">replace</span></span><br><span class="line">        <span class="attr">target_label:</span> <span class="string">kubernetes_pod_name</span></span><br></pre></td></tr></table></figure><h3 id="3-4-Deployment">3.4 Deployment</h3><p><code>vim prometheus.deploy.yaml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">prometheus-deployment</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">prometheus</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">prometheus</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">prometheus</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">prom/prometheus:v2.0.0</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">prometheus</span></span><br><span class="line">        <span class="attr">command:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">"/bin/prometheus"</span></span><br><span class="line">        <span class="attr">args:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">"--config.file=/etc/prometheus/prometheus.yml"</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">"--storage.tsdb.path=/prometheus"</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">"--storage.tsdb.retention=24h"</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">9090</span></span><br><span class="line">          <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">"/prometheus"</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">data</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">"/etc/prometheus"</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">config-volume</span></span><br><span class="line">        <span class="attr">resources:</span></span><br><span class="line">          <span class="attr">requests:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">100m</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">100Mi</span></span><br><span class="line">          <span class="attr">limits:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">500m</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">2500Mi</span></span><br><span class="line">      <span class="attr">serviceAccountName:</span> <span class="string">prometheus</span>    </span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">data</span></span><br><span class="line">        <span class="attr">emptyDir:</span> <span class="string">&#123;&#125;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config-volume</span></span><br><span class="line">        <span class="attr">configMap:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">prometheus-config</span></span><br></pre></td></tr></table></figure><h3 id="3-5-Service">3.5 Service</h3><p><code>vim prometheus.svc.yaml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">prometheus</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">prometheus</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">9090</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">9090</span></span><br><span class="line">    <span class="attr">nodePort:</span> <span class="number">30003</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">prometheus</span></span><br></pre></td></tr></table></figure><h3 id="3-6-创建与部署">3.6 创建与部署</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f node-exporter.yaml</span><br><span class="line">kubectl create -f rbac-setup.yaml</span><br><span class="line">kubectl create -f configmap.yaml</span><br><span class="line">kubectl create -f prometheus.deploy.yaml</span><br><span class="line">kubectl create -f prometheus.svc.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看</span></span><br><span class="line">kubectl get pod,svc -n kube-system | grep prometheus</span><br><span class="line"><span class="comment"># 浏览器访问：[ip:port] 192.168.249.139:30003</span></span><br></pre></td></tr></table></figure><h2 id="4、部署-Grafana">4、部署 Grafana</h2><h3 id="4-1-Deployment">4.1 Deployment</h3><p><code>vim grafana-deploy.yaml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">grafana-core</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">grafana</span></span><br><span class="line">    <span class="attr">component:</span> <span class="string">core</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">grafana</span></span><br><span class="line">      <span class="attr">component:</span> <span class="string">core</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">grafana</span></span><br><span class="line">        <span class="attr">component:</span> <span class="string">core</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">grafana/grafana:4.2.0</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">grafana-core</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">        <span class="comment"># env:</span></span><br><span class="line">        <span class="attr">resources:</span></span><br><span class="line">          <span class="comment"># keep request = limit to keep this container in guaranteed class</span></span><br><span class="line">          <span class="attr">limits:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">100m</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">100Mi</span></span><br><span class="line">          <span class="attr">requests:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">100m</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">100Mi</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="comment"># The following env variables set up basic auth twith the default admin user and admin password.</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">GF_AUTH_BASIC_ENABLED</span></span><br><span class="line">            <span class="attr">value:</span> <span class="string">"true"</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">GF_AUTH_ANONYMOUS_ENABLED</span></span><br><span class="line">            <span class="attr">value:</span> <span class="string">"false"</span></span><br><span class="line">          <span class="comment"># - name: GF_AUTH_ANONYMOUS_ORG_ROLE</span></span><br><span class="line">          <span class="comment">#   value: Admin</span></span><br><span class="line">          <span class="comment"># does not really work, because of template variables in exported dashboards:</span></span><br><span class="line">          <span class="comment"># - name: GF_DASHBOARDS_JSON_ENABLED</span></span><br><span class="line">          <span class="comment">#   value: "true"</span></span><br><span class="line">        <span class="attr">readinessProbe:</span></span><br><span class="line">          <span class="attr">httpGet:</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/login</span></span><br><span class="line">            <span class="attr">port:</span> <span class="number">3000</span></span><br><span class="line">          <span class="comment"># initialDelaySeconds: 30</span></span><br><span class="line">          <span class="comment"># timeoutSeconds: 1</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">grafana-persistent-storage</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/var</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">grafana-persistent-storage</span></span><br><span class="line">        <span class="attr">emptyDir:</span> <span class="string">&#123;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="4-2-Service">4.2 Service</h3><p><code>vim grafana-svc.yaml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">grafana</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">grafana</span></span><br><span class="line">    <span class="attr">component:</span> <span class="string">core</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">3000</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">grafana</span></span><br><span class="line">    <span class="attr">component:</span> <span class="string">core</span></span><br></pre></td></tr></table></figure><h3 id="4-3-Runing">4.3 Runing</h3><p><code>vim grafana-ing.yaml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">   <span class="attr">name:</span> <span class="string">grafana</span></span><br><span class="line">   <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">   <span class="attr">rules:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">k8s.grafana</span></span><br><span class="line">     <span class="attr">http:</span></span><br><span class="line">       <span class="attr">paths:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">         <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">grafana</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">3000</span></span><br></pre></td></tr></table></figure><h3 id="4-4-创建与部署">4.4 创建与部署</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f grafana-deploy.yaml</span><br><span class="line">kubectl create -f grafana-svc.yaml</span><br><span class="line">kubectl create -f grafana-ing.yaml</span><br><span class="line"></span><br><span class="line">kubectl get pod,svc -n kube-system | grep grafana</span><br><span class="line"></span><br><span class="line">kubectl get pod,svc -A</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意url要填写集群内部的ip</span></span><br><span class="line"><span class="comment">#  浏览器访问：[ip:port] http://192.168.60.151:32389/</span></span><br><span class="line"><span class="comment">#  用户名/密码：admin/admin</span></span><br><span class="line"><span class="comment"># 注意ip是集群ip，然后选择Dashboard，选择import选择315模板(二进制搭建不知道为什么会失败，kubeadm搭建正常)</span></span><br><span class="line"><span class="comment"># 可以自行下载导入模板</span></span><br><span class="line"><span class="comment"># https://grafana.com/grafana/dashboards/?search=315</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/5b850e667d3b49c7ad960220fe86a0c4.png#pic_center" alt="在这里插入图片描述"></p><h1>六、搭建高可用 Kubernetes 集群</h1><h2 id="1、高可用集群架构">1、高可用集群架构</h2><blockquote><p>之前我们搭建的集群，只有一个 master 节点，当 master 节点宕机的时候，通过 node 节点将无法继续访问，而 master 主要是管理作用，所以整个集群将无法提供服务</p></blockquote><ul><li>在 node 节点和 master 节点之间，需要一个 LoadBalancer 组件<ul><li>【作用 1】负载</li><li>【作用 2】检查 master 节点的状态</li></ul></li><li>对外需要一个统一的 VIP<ul><li>【作用 1】虚拟 ip 对外进行访问</li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/7a0dd3c272ae46319b05c14f54405060.png#pic_center" alt="在这里插入图片描述"></p><h2 id="2、高可用集群环境准备">2、高可用集群环境准备</h2><blockquote><p>我们采用 2 个 master 节点，一个 node 节点来搭建高可用集群</p></blockquote><h3 id="2-1-安装步骤-v2">2.1 安装步骤</h3><p>使用二进制包方式搭建 Kubernetes 集群主要分为以下几步：</p><ol><li>【<strong>环境准备</strong>】准备四台虚拟机，并安装操作系统 CentOS 7.x</li><li>【<strong>系统初始化</strong>】对四个刚安装好的操作系统进行初始化操作</li><li>【<strong>安装 docker、kubectl、kubeadm、kubectl</strong>】对四个节点进行安装</li><li>【<strong>配置高可用 VIP</strong>】对 master 节点安装<code>keepalived</code>和<code>haproxy</code></li><li>【<strong>部署 master 组件</strong>】在 master 节点上安装<code>kube-apiserver</code>、<code>kube-controller-manager</code>、<code>kube-scheduler</code></li><li>【<strong>安装网络插件</strong>】配置 CNI 网络插件，用于节点之间的连通</li><li>【<strong>测试集群</strong>】通过拉取一个 nginx 进行测试，能否进行外网测试</li></ol><h3 id="2-2-安装要求">2.2 安装要求</h3><ul><li>一台或多台机器，操作系统 CentOS7.x-86_x64</li><li>硬件配置：2GB 或更多 RAM，2 个 CPU 或更多 CPU，硬盘 30GB 或更多【注意】【master 需要两核】</li><li>可以访问外网，需要拉取镜像，如果服务器不能上网，需要提前下载镜像并导入节点</li><li>禁止 swap 分区</li></ul><h3 id="2-3-准备环境">2.3 准备环境</h3><table><thead><tr><th>角色</th><th>IP</th><th>配置</th><th>步骤</th></tr></thead><tbody><tr><td>k8sLoadBalancer(这台可以不用)</td><td>192.168.249.139</td><td>2CPU 1G</td><td><code>init</code> <code>docker</code> <code>kubectl</code> <code>kubeadm</code> <code>kubectl</code></td></tr><tr><td>k8smaster1</td><td>192.168.249.146</td><td>2CPU 2G</td><td><code>init</code> <code>docker</code> <code>kubectl</code> <code>kubeadm</code> <code>kubectl</code> <code>keepalived</code> <code>haproxy</code></td></tr><tr><td>k8smaster2</td><td>192.168.249.147</td><td>2CPU 2G</td><td><code>init</code> <code>docker</code> <code>kubectl</code> <code>kubeadm</code> <code>kubectl</code> <code>keepalived</code> <code>haproxy</code></td></tr><tr><td>k8snode1</td><td>192.168.249.148</td><td>2CPU 2G</td><td><code>init</code> <code>docker</code> <code>kubectl</code> <code>kubeadm</code> <code>kubectl</code></td></tr></tbody></table><h2 id="3、高可用集群搭建">3、高可用集群搭建</h2><h3 id="3-1-系统初始化">3.1 系统初始化</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 所有结点都需要</span></span><br><span class="line"><span class="comment"># 关闭防火墙</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line"><span class="comment"># 禁用 firewalld 服务</span></span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭 selinux</span></span><br><span class="line"><span class="comment"># 临时关闭【立即生效】告警，不启用，Permissive，查看使用 getenforce 命令</span></span><br><span class="line">setenforce 0  </span><br><span class="line"><span class="comment"># 永久关闭【重启生效】</span></span><br><span class="line">sed -i <span class="string">'s/SELINUX=enforcing/\SELINUX=disabled/'</span> /etc/selinux/config  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭 swap</span></span><br><span class="line"><span class="comment"># 临时关闭【立即生效】查看使用 free 命令</span></span><br><span class="line">swapoff -a </span><br><span class="line"><span class="comment"># 永久关闭【重启生效】</span></span><br><span class="line">sed -ri <span class="string">'s/.*swap.*/#&amp;/'</span> /etc/fstab</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在主机名静态查询表中添加 4 台主机</span></span><br><span class="line">cat &gt;&gt; /etc/hosts &lt;&lt; EOF</span><br><span class="line">192.168.249.139 k8sLoadBalancer</span><br><span class="line">192.168.249.146 k8smaster1</span><br><span class="line">192.168.249.147 k8smaster2</span><br><span class="line">192.168.249.148 k8snode1</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将桥接的 IPv4 流量传递到 iptables 的链【3 个节点上都执行】</span></span><br><span class="line">cat &gt; /etc/sysctl.d/k8s.conf &lt;&lt; EOF</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生效</span></span><br><span class="line">sysctl --system  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 时间同步</span></span><br><span class="line">yum install ntpdate -y</span><br><span class="line">ntpdate time.windows.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据规划设置主机名【k8sLoadBalancer 节点上操作】</span></span><br><span class="line">hostnamectl <span class="built_in">set</span>-hostname k8sLoadBalancer</span><br><span class="line"><span class="comment"># 根据规划设置主机名【k8smaster1 节点上操作】</span></span><br><span class="line">hostnamectl <span class="built_in">set</span>-hostname k8smaster1</span><br><span class="line"><span class="comment"># 根据规划设置主机名【k8smaster2 节点上操作】</span></span><br><span class="line">hostnamectl <span class="built_in">set</span>-hostname k8smaster2</span><br><span class="line"><span class="comment"># 根据规划设置主机名【k8snode1 节点操作】</span></span><br><span class="line">hostnamectl <span class="built_in">set</span>-hostname k8snode1</span><br></pre></td></tr></table></figure><h3 id="3-2-安装-docker、kubelet、kubeadm、kubectl">3.2 安装 docker、kubelet、kubeadm、kubectl</h3><blockquote><p>所有节点安装 docker/kubelet/kubeadm/kubectl，Kubernetes 默认 CRI（容器运行时）为 docker，因此先安装 docker</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 所有结点都需要</span></span><br><span class="line"><span class="comment"># =========================docker安装=================</span></span><br><span class="line"><span class="comment"># 首先配置一下 docker 的阿里 yum 源</span></span><br><span class="line">cat &gt;/etc/yum.repos.d/docker.repo&lt;&lt;EOF</span><br><span class="line">[docker-ce-edge]</span><br><span class="line">name=Docker CE Edge - \<span class="variable">$basearch</span></span><br><span class="line">baseurl=https://mirrors.aliyun.com/docker-ce/linux/centos/7/\<span class="variable">$basearch</span>/edge</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=https://mirrors.aliyun.com/docker-ce/linux/centos/gpg</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># yum 安装</span></span><br><span class="line">yum -y install docker-ce</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 docker 版本</span></span><br><span class="line">docker --version  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置 docker 的镜像源【阿里云】</span></span><br><span class="line">cat &gt; /etc/docker/daemon.json &lt;&lt; EOF</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"registry-mirrors"</span>: [<span class="string">"https://b9pmyelo.mirror.aliyuncs.com"</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">systemctl start docker</span><br><span class="line">systemctl <span class="built_in">enable</span> docker</span><br><span class="line">systemctl status docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更改后记得重载一下</span></span><br><span class="line">systemctl reload-daemon</span><br><span class="line">systemctl restart docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># ====================安装 kubeadm，kubelet 和 kubectl==============</span></span><br><span class="line"><span class="comment"># 配置 kubernetes 阿里云 yum 源</span></span><br><span class="line">cat &gt; /etc/yum.repos.d/kubernetes.repo &lt;&lt; EOF</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># yum 方式安装，由于版本更新频繁，这里指定版本号部署</span></span><br><span class="line"><span class="comment"># 查看版本</span></span><br><span class="line">yum list kubeadm --showduplicates</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 kubelet、kubeadm、kubectl，同时指定版本</span></span><br><span class="line">yum install -y kubelet-1.18.0 kubeadm-1.18.0 kubectl-1.18.0</span><br><span class="line"><span class="comment"># 设置开机启动【这里先不启动】</span></span><br><span class="line">systemctl <span class="built_in">enable</span> kubelet</span><br></pre></td></tr></table></figure><h3 id="3-3-配置高可用-VIP【haproxy-keepalived】">3.3 配置高可用 VIP【haproxy+keepalived】</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 【k8smaster1 + k8smaster2 上操作】</span></span><br><span class="line"><span class="comment"># 安装 haproxy + keepalived</span></span><br><span class="line"><span class="comment"># 我们需要在所有的 master 节点【k8smaster1 和 k8smaster2】上部署 haproxy + keepAlive</span></span><br><span class="line">yum install -y haproxy keepalived</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置 haproxy</span></span><br><span class="line"><span class="comment"># 所有master节点的haproxy配置相同，haproxy 的配置文件是/etc/haproxy/haproxy.cfg</span></span><br><span class="line"><span class="comment"># 配置中声明了后端代理的两个 master 节点服务器，指定了 haproxy 运行的端口为 16443 等，因此 16443 端口为集群的入口</span></span><br><span class="line"><span class="comment"># 注意下面ip的更改</span></span><br><span class="line">cat &gt; /etc/haproxy/haproxy.cfg &lt;&lt; EOF</span><br><span class="line"><span class="comment">#---------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Global settings</span></span><br><span class="line"><span class="comment">#---------------------------------------------------------------------</span></span><br><span class="line">global</span><br><span class="line">    <span class="comment"># to have these messages end up in /var/log/haproxy.log you will</span></span><br><span class="line">    <span class="comment"># need to:</span></span><br><span class="line">    <span class="comment"># 1) configure syslog to accept network log events.  This is done</span></span><br><span class="line">    <span class="comment">#    by adding the '-r' option to the SYSLOGD_OPTIONS in</span></span><br><span class="line">    <span class="comment">#    /etc/sysconfig/syslog</span></span><br><span class="line">    <span class="comment"># 2) configure local2 events to go to the /var/log/haproxy.log</span></span><br><span class="line">    <span class="comment">#   file. A line like the following can be added to</span></span><br><span class="line">    <span class="comment">#   /etc/sysconfig/syslog</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#    local2.*                       /var/log/haproxy.log</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="built_in">log</span>         127.0.0.1 local2</span><br><span class="line">    </span><br><span class="line">    chroot      /var/lib/haproxy</span><br><span class="line">    pidfile     /var/run/haproxy.pid</span><br><span class="line">    maxconn     4000</span><br><span class="line">    user        haproxy</span><br><span class="line">    group       haproxy</span><br><span class="line">    daemon </span><br><span class="line">       </span><br><span class="line">    <span class="comment"># turn on stats unix socket</span></span><br><span class="line">    stats socket /var/lib/haproxy/stats</span><br><span class="line"><span class="comment">#---------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># common defaults that all the 'listen' and 'backend' sections will</span></span><br><span class="line"><span class="comment"># use if not designated in their block</span></span><br><span class="line"><span class="comment">#---------------------------------------------------------------------  </span></span><br><span class="line">defaults</span><br><span class="line">    mode                    http</span><br><span class="line">    <span class="built_in">log</span>                     global</span><br><span class="line">    option                  httplog</span><br><span class="line">    option                  dontlognull</span><br><span class="line">    option http-server-close</span><br><span class="line">    option forwardfor       except 127.0.0.0/8</span><br><span class="line">    option                  redispatch</span><br><span class="line">    retries                 3</span><br><span class="line">    timeout http-request    10s</span><br><span class="line">    timeout queue           1m</span><br><span class="line">    timeout connect         10s</span><br><span class="line">    timeout client          1m</span><br><span class="line">    timeout server          1m</span><br><span class="line">    timeout http-keep-alive 10s</span><br><span class="line">    timeout check           10s</span><br><span class="line">    maxconn                 3000</span><br><span class="line"><span class="comment">#---------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># kubernetes apiserver frontend which proxys to the backends</span></span><br><span class="line"><span class="comment">#--------------------------------------------------------------------- </span></span><br><span class="line">frontend kubernetes-apiserver</span><br><span class="line">    mode                 tcp</span><br><span class="line">    <span class="built_in">bind</span>                 *:16443</span><br><span class="line">    option               tcplog</span><br><span class="line">    default_backend      kubernetes-apiserver    </span><br><span class="line"><span class="comment">#---------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># round robin balancing between the various backends</span></span><br><span class="line"><span class="comment">#---------------------------------------------------------------------</span></span><br><span class="line">backend kubernetes-apiserver</span><br><span class="line">    mode        tcp</span><br><span class="line">    balance     roundrobin</span><br><span class="line">    server      k8smaster1   192.168.249.146:6443 check</span><br><span class="line">    server      k8smaster2   192.168.249.147:6443 check</span><br><span class="line"><span class="comment">#---------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># collection haproxy statistics message</span></span><br><span class="line"><span class="comment">#---------------------------------------------------------------------</span></span><br><span class="line">listen stats</span><br><span class="line">    <span class="built_in">bind</span>                 *:10080</span><br><span class="line">    stats auth           admin:awesomePassword</span><br><span class="line">    stats refresh        5s</span><br><span class="line">    stats realm          HAProxy\ Statistics</span><br><span class="line">    stats uri            /admin?stats</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>配置 keepalived，<strong>keepalived中使用track_script机制来配置脚本进行探测kubernetes的master节点是否宕机</strong>，并以此切换节点实现高可用，配置文件所在的位置<code>/etc/keepalived/keepalived.cfg</code></p><p>需要注意几点（前两点记得修改）：</p><ul><li><code>mcast_src_ip</code>：配置多播源地址，此地址是当前主机的 ip 地址。</li><li><code>priority</code>：<code>keepalived</code>根据此项参数的大小仲裁<code>master</code>节点。我们这里让 master 节点为<code>kubernetes</code>提供服务，其他两个节点暂时为备用节点。因此<code>k8smaster1</code>节点设置为<code>100</code>，<code>k8smaster2</code>节点设置为<code>99</code>。</li><li><code>state</code>：我们将<code>k8smaster1</code>节点的<code>state</code>字段设置为<code>MASTER</code>，其他节点字段修改为<code>BACKUP</code>。</li><li>上面的集群检查功能是关闭的，等到集群建立完成后再开启。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># k8smaster1节点的keepalived配置文件，虚拟ip是vip地址</span></span><br><span class="line">cat &gt; /etc/keepalived/keepalived.conf &lt;&lt;EOF </span><br><span class="line">! Configuration File <span class="keyword">for</span> keepalived</span><br><span class="line"></span><br><span class="line">global_defs &#123;</span><br><span class="line">   router_id k8s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_script check_haproxy &#123;</span><br><span class="line">    script <span class="string">"killall -0 haproxy"</span></span><br><span class="line">    interval 3</span><br><span class="line">    weight -2</span><br><span class="line">    fall 10</span><br><span class="line">    rise 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state MASTER </span><br><span class="line">    interface ens33 </span><br><span class="line">    mcast_src_ip 192.168.249.146</span><br><span class="line">    virtual_router_id 51</span><br><span class="line">    priority 100</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass ceb1b3ec013d66163d6ab</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.249.139</span><br><span class="line">    &#125;</span><br><span class="line">    track_script &#123;</span><br><span class="line">        check_haproxy</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置 k8smaster2 节点，注意换</span></span><br><span class="line">cat &gt; /etc/keepalived/keepalived.conf &lt;&lt;EOF </span><br><span class="line">! Configuration File <span class="keyword">for</span> keepalived</span><br><span class="line"></span><br><span class="line">global_defs &#123;</span><br><span class="line">   router_id k8s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_script check_haproxy &#123;</span><br><span class="line">    script <span class="string">"killall -0 haproxy"</span></span><br><span class="line">    interval 3</span><br><span class="line">    weight -2</span><br><span class="line">    fall 10</span><br><span class="line">    rise 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state BACKUP </span><br><span class="line">    interface ens33 </span><br><span class="line">    mcast_src_ip 192.168.249.147</span><br><span class="line">    virtual_router_id 51</span><br><span class="line">    priority 99</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass ceb1b3ec013d66163d6ab</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.249.139</span><br><span class="line">    &#125;</span><br><span class="line">    track_script &#123;</span><br><span class="line">        check_haproxy</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>启动和检查 【k8smaster1 和 k8smaster2 均要启动】</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动 haproxy</span></span><br><span class="line">systemctl start haproxy</span><br><span class="line">systemctl <span class="built_in">enable</span> haproxy</span><br><span class="line">systemctl status haproxy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 keepalived</span></span><br><span class="line">systemctl start keepalived.service</span><br><span class="line">systemctl <span class="built_in">enable</span> keepalived.service</span><br><span class="line">systemctl status keepalived.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动后查看 master 网卡信息</span></span><br><span class="line">ip a s ens33</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查是否可以 ping 通</span></span><br><span class="line">ping 192.168.249.139</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果出错</span></span><br><span class="line"><span class="comment"># 初始化一下！！！并重新启动！！！</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line">setenforce 0  </span><br><span class="line">swapoff -a</span><br></pre></td></tr></table></figure><h3 id="3-4-部署-Kubernetes-Master-组件">3.4 部署 Kubernetes Master 组件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先在master1结点操作</span></span><br><span class="line"><span class="comment"># 导出初始化配置文件，然后修改配置，再进行初始化</span></span><br><span class="line">kubeadm config <span class="built_in">print</span> init-defaults &gt; kubeadm-init.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里直接写入配置，并初始化</span></span><br><span class="line">cat &gt; kubeadm-init.yaml &lt;&lt; EOF</span><br><span class="line">apiVersion: kubeadm.k8s.io/v1beta2</span><br><span class="line">bootstrapTokens:</span><br><span class="line">- groups:</span><br><span class="line">  - system:bootstrappers:kubeadm:default-node-token</span><br><span class="line">  token: abcdef.0123456789abcdef</span><br><span class="line">  ttl: 24h0m0s</span><br><span class="line">  usages:</span><br><span class="line">  - signing</span><br><span class="line">  - authentication</span><br><span class="line">kind: InitConfiguration</span><br><span class="line">localAPIEndpoint:</span><br><span class="line">  advertiseAddress: 192.168.249.139 <span class="comment"># k8sLoadBalancer ip</span></span><br><span class="line">  bindPort: 6443</span><br><span class="line">nodeRegistration:</span><br><span class="line">  criSocket: /var/run/dockershim.sock</span><br><span class="line">  name: k8sloadbalancer</span><br><span class="line">  taints:</span><br><span class="line">  - effect: NoSchedule</span><br><span class="line">    key: node-role.kubernetes.io/master</span><br><span class="line">---</span><br><span class="line">apiServer: <span class="comment"># 添加两行配置</span></span><br><span class="line">  certSANs:</span><br><span class="line">  - <span class="string">"192.168.249.139"</span> <span class="comment"># k8sLoadBalancer ip 即 VIP 的地址</span></span><br><span class="line">  timeoutForControlPlane: 4m0s</span><br><span class="line">apiVersion: kubeadm.k8s.io/v1beta2</span><br><span class="line">certificatesDir: /etc/kubernetes/pki</span><br><span class="line">clusterName: kubernetes</span><br><span class="line">controllerManager: &#123;&#125;</span><br><span class="line">dns:</span><br><span class="line">  <span class="built_in">type</span>: CoreDNS</span><br><span class="line">etcd:</span><br><span class="line">  <span class="built_in">local</span>:</span><br><span class="line">    dataDir: /var/lib/etcd</span><br><span class="line">imageRepository: registry.cn-hangzhou.aliyuncs.com/google_containers   <span class="comment"># 阿里云的镜像站点</span></span><br><span class="line">controlPlaneEndpoint: <span class="string">"192.168.249.139:16443"</span>  <span class="comment"># VIP 的地址和端口</span></span><br><span class="line">kind: ClusterConfiguration</span><br><span class="line">kubernetesVersion: v1.18.0</span><br><span class="line">networking:</span><br><span class="line">  dnsDomain: cluster.local</span><br><span class="line">  serviceSubnet: 10.96.0.0/12</span><br><span class="line">  podSubnet: 10.244.0.0/16        <span class="comment"># 添加 pod 网段</span></span><br><span class="line">scheduler: &#123;&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接 kubeadm init 初始化，中间会拉取镜像，速度较慢，分为两步来做</span></span><br><span class="line"><span class="comment"># （1）提前拉取镜像</span></span><br><span class="line">kubeadm config images pull --config kubeadm-init.yaml</span><br><span class="line"><span class="comment"># （2）初始化</span></span><br><span class="line">kubeadm init --config kubeadm-init.yaml --upload-certs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行下方命令</span></span><br><span class="line">mkdir -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) <span class="variable">$HOME</span>/.kube/config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看节点</span></span><br><span class="line">kubectl get nodes</span><br><span class="line"><span class="comment"># 查看 pod</span></span><br><span class="line">kubectl get pods -n kube-system</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照k8smaster1提示信息，将k8smaster2加入集群</span></span><br><span class="line">kubeadm join 192.168.249.139:16443 --token abcdef.0123456789abcdef \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:b828e96d32b7c4adef8f6cd34392c5c519e133d57dc51e82d61c64e95add41c8 \</span><br><span class="line">    --control-plane --certificate-key b52333ccc3d38d166e9aab487412ea8f2bf26430efa45306a3d803d16793bf19</span><br><span class="line"><span class="comment"># 查看集群状态</span></span><br><span class="line">kubectl get cs</span><br><span class="line"><span class="comment"># 查看 pod</span></span><br><span class="line">kubectl get pods -n kube-system</span><br><span class="line"><span class="comment"># 默认 token 有效期为 24 小时，当过期之后，该 token 就不可用了。这时就需要重新创建 token</span></span><br><span class="line">kubeadm token create --<span class="built_in">print</span>-join-command</span><br><span class="line"><span class="comment"># 按照k8smaster1提示信息，将k8snode1加入集群</span></span><br><span class="line">kubeadm join 192.168.249.139:16443 --token abcdef.0123456789abcdef \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:d0ad912a5ac6e5c5a1471f5931bee86bf4b077b5c377cca008ec86e280492ba8</span><br></pre></td></tr></table></figure><h3 id="3-5-安装集群网络">3.5 安装集群网络</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载 yaml 文件</span></span><br><span class="line">wget -c https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span><br><span class="line"><span class="comment"># 安装 flannel 网络</span></span><br><span class="line">kubectl apply -f kube-flannel.yml</span><br><span class="line"><span class="comment"># 这里可能会出错，拉取镜像出错，如果出错需要手动将出错的镜像导入，并将其tag为指定标签，详情见上面集群安装</span></span><br><span class="line"><span class="comment"># 或者将docker.io/rancher/mirrored-flannelcni-flannel:v0.20.1(两个地方)替换成registry.cn-hangzhou.aliyuncs.com/shawn222/flannel:v0.20.1</span></span><br><span class="line"><span class="comment"># 查看状态 【kube-system 是 k8s 中的最小单元】</span></span><br><span class="line"><span class="comment"># 检查</span></span><br><span class="line">kubectl get pods -n kube-system</span><br><span class="line">watch kubectl get pods -A</span><br></pre></td></tr></table></figure><h3 id="3-6-测试-kubernetes-集群">3.6 测试 kubernetes 集群</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 nginx deployment</span></span><br><span class="line">kubectl create deployment nginx --image=nginx</span><br><span class="line"><span class="comment"># 暴露端口</span></span><br><span class="line">kubectl expose deployment nginx --port=80 --<span class="built_in">type</span>=NodePort</span><br><span class="line"><span class="comment"># 查看状态</span></span><br><span class="line">kubectl get pod,svc</span><br><span class="line"></span><br><span class="line"><span class="comment">## [ip:port] 通过任何一个节点，都能够访问我们的 nginx 页面</span></span><br><span class="line"><span class="comment"># 浏览器访问：</span></span><br><span class="line"><span class="comment"># http://192.168.249.139:30965/</span></span><br><span class="line"><span class="comment"># http://192.168.249.146:30965/</span></span><br><span class="line"><span class="comment"># http://192.168.249.147:30965/</span></span><br><span class="line"><span class="comment"># http://192.168.249.148:30965/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意如果要进行容灾演练，需要3台以上主节点</span></span><br><span class="line"><span class="comment"># 手把手从零搭建 k8s 集群系列（三）高可用（灾备）切换</span></span><br></pre></td></tr></table></figure><h1>七、在集群环境中部署项目</h1><h2 id="1、容器交付流程">1、容器交付流程</h2><ul><li>开发代码阶段<ul><li>编写代码</li><li>编写 Dockerfile【打镜像做准备】</li></ul></li><li>持续交付/集成<ul><li>代码编译打包</li><li>制作镜像</li><li>上传镜像仓库</li></ul></li><li>应用部署<ul><li>环境准备</li><li>Pod</li><li>Service</li><li>Ingress</li></ul></li><li>运维<ul><li>监控</li><li>故障排查</li><li>应用升级</li></ul></li></ul><h2 id="2、k8s-部署-java-项目流程">2、k8s 部署 java 项目流程</h2><ul><li>制作镜像【Dockerfile】</li><li>上传到镜像仓库【Dockerhub、阿里云、网易】</li><li>控制器部署镜像【Deployment】</li><li>对外暴露应用【Service、Ingress】</li><li>运维【监控、升级】</li></ul><h2 id="3、k8s-部署-Java-项目">3、k8s 部署 Java 项目</h2><h3 id="3-1-制作镜像">3.1 制作镜像</h3><p>这里已经制作好了一个 jar 包，名字为demojenkins.jar，然后上传并编写<code>vim Dockerfile</code></p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">8</span>-jdk-alpine</span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> /tmp</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> ./demojenkins.jar demojenkins.jar</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"java"</span>,<span class="string">"-jar"</span>,<span class="string">"/demojenkins.jar"</span>, <span class="string">"&amp;"</span>]</span></span><br></pre></td></tr></table></figure><p>打包与测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker build -t java-demo-01:latest .</span><br><span class="line">docker run -d -p 8111:8111 java-demo-01:latest -t </span><br><span class="line"><span class="comment"># 打开浏览器进行访问</span></span><br><span class="line"><span class="comment"># http://192.168.249.139:8111/user</span></span><br></pre></td></tr></table></figure><h3 id="3-2-上传镜像仓库">3.2 上传镜像仓库</h3><p>镜像仓库可以选择云服务等，这里选择本地仓库地址进行测试，可以参考：<a href="https://blog.csdn.net/lemon_TT/article/details/125981712" target="_blank" rel="noopener" title="docker学习笔记">docker学习笔记</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 搭建私人仓库</span></span><br><span class="line">mkdir -p /data/myregistry</span><br><span class="line">docker pull registry:latest</span><br><span class="line">docker run -d -p 5000:5000 --name my_registry --restart=always -v /data/myregistry:/var/lib/registry registry:latest</span><br><span class="line"></span><br><span class="line"><span class="comment">## 更改 docker 配置文件（在需要连接到私有仓库的机器上全部都执行一遍）</span></span><br><span class="line"><span class="comment">## 在 k8smaster k8snode1 k8snode2 上均执行一遍</span></span><br><span class="line"><span class="comment"># 注意修改自己的ip</span></span><br><span class="line">cat &gt; /etc/docker/daemon.json &lt;&lt; EOF</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"registry-mirrors"</span>: [<span class="string">"https://b9pmyelo.mirror.aliyuncs.com"</span>],</span><br><span class="line">  <span class="string">"insecure-registries"</span>: [<span class="string">"192.168.249.139:5000"</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"><span class="comment">## 重启 docker，重启 registry（如果停止了的话）</span></span><br><span class="line">systemctl restart docker  <span class="comment"># 3 台机器上执行</span></span><br><span class="line">docker start my_registry  <span class="comment"># 主节点上执行（因为私人仓库在主节点上）</span></span><br><span class="line"><span class="comment"># 访问：ip:5000/v2/_catalog查看本地仓库镜像</span></span><br><span class="line"><span class="comment">#http://192.168.249.139:5000/v2/_catalog</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker tag java-demo-01 192.168.249.139:5000/<span class="built_in">test</span>/java-demo-01:v1</span><br><span class="line">docker push 192.168.249.139:5000/<span class="built_in">test</span>/java-demo-01:v1</span><br><span class="line"><span class="comment"># 可以在其他结点进行拉取测试</span></span><br><span class="line">docker pull 192.168.249.139:5000/<span class="built_in">test</span>/java-demo-01:v1</span><br><span class="line"></span><br><span class="line"><span class="comment"># ip可以用域名等代替，该方法使用云服务也一样的道理</span></span><br></pre></td></tr></table></figure><h3 id="3-3-部署项目">3.3 部署项目</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果时私有仓库注意添加docker源</span></span><br><span class="line">kubectl create deployment java01 --image=192.168.249.139:5000/<span class="built_in">test</span>/java-demo-01:v1 --dry-run -o yaml &gt; java01.yaml</span><br><span class="line">kubectl apply -f java01.yaml</span><br><span class="line">kubectl get pod -o wide</span><br><span class="line"><span class="comment"># 暴露端口</span></span><br><span class="line">kubectl expose deployment java01 --port=8111 --target-port=8111 --<span class="built_in">type</span>=NodePort</span><br><span class="line"><span class="comment"># 扩容</span></span><br><span class="line">kubectl scale deployment javademo1 --replicas=3</span><br><span class="line"></span><br><span class="line"><span class="comment">## 查看暴露的端口</span></span><br><span class="line">kubectl get svc</span><br></pre></td></tr></table></figure><hr><p>参考：</p><p><a href="https://www.bilibili.com/video/BV1GT4y1A756" target="_blank" rel="noopener" title="https://www.bilibili.com/video/BV1GT4y1A756">https://www.bilibili.com/video/BV1GT4y1A756</a></p><p><a href="https://gitee.com/moxi159753/LearningNotes/tree/master/K8S" target="_blank" rel="noopener" title="https://gitee.com/moxi159753/LearningNotes/tree/master/K8S">https://gitee.com/moxi159753/LearningNotes/tree/master/K8S</a></p><p><a href="https://www.kubernetes.org.cn/k8s" target="_blank" rel="noopener" title="https://www.kubernetes.org.cn/k8s">https://www.kubernetes.org.cn/k8s</a></p>]]></content>
    
    
    <summary type="html">&lt;h1&gt;一、Kubernetes 概述和架构&lt;/h1&gt;
&lt;h2 id=&quot;1、kubernetes-基本介绍&quot;&gt;1、kubernetes 基本介绍&lt;/h2&gt;
&lt;p&gt;kubernetes，简称K8s，是用8 代替8 个字符&amp;quot;ubernete&amp;quot;而成的缩写。是一个开源的，用于管理云平台中多个主机上的容器化的应用，Kubernetes 的目标是让部署容器化的应用简单并且高效（powerful）,Kubernetes 提供了应用部署，规划，更新，维护的一种机制。&lt;/p&gt;
&lt;p&gt;传统的应用部署方式是通过插件或脚本来安装应用。这样做的缺点是应用的运行、配置、管理、所有生存周期将与当前操作系统绑定，这样做并不利于应用的升级更新/回滚等操作，当然也可以通过创建虚拟机的方式来实现某些功能，但是虚拟机非常重，并不利于可移植性。新的方式是通过部署容器方式实现，每个容器之间互相隔离，每个容器有自己的文件系统，容器之间进程不会相互影响，能区分计算资源。相对于虚拟机，容器能快速部署，由于容器与底层设施、机器文件系统解耦的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;K8s是谷歌在2014年发布的容器化集群管理系统&lt;/li&gt;
&lt;li&gt;使用k8s进行容器化应用部署&lt;/li&gt;
&lt;li&gt;使用k8s利于应用扩展&lt;/li&gt;
&lt;li&gt;k8s目标实施让部署容器化应用更加简洁和高效&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.shawn22.xyz/categories/Linux/"/>
    
    
    <category term="K8S" scheme="https://www.shawn22.xyz/tags/K8S/"/>
    
  </entry>
  
  <entry>
    <title>k8s快速入门</title>
    <link href="https://www.shawn22.xyz/posts/407f91da.html"/>
    <id>https://www.shawn22.xyz/posts/407f91da.html</id>
    <published>2023-03-05T16:15:24.000Z</published>
    <updated>2023-03-05T16:37:02.079Z</updated>
    
    <content type="html"><![CDATA[<h1>一、Kubernetes（K8S）简介</h1><h2 id="1、概念">1、概念</h2><blockquote><p>官网：<a href="https://kubernetes.io/zh-cn/docs/home/" target="_blank" rel="noopener" title="https://kubernetes.io/zh-cn/docs/home/">https://kubernetes.io/zh-cn/docs/home/</a></p></blockquote><h3 id="1-1-Kubernetes-K8S-是什么">1.1 Kubernetes (K8S) 是什么</h3><p>它是一个为 <strong>容器化</strong> 应用提供集群部署和管理的开源工具，由 Google 开发。K8S 是负责自动化运维管理多个跨机器 Docker 程序的集群</p><h3 id="1-2-核心特性">1.2 核心特性</h3><ul><li>服务发现与负载均衡：无需修改你的应用程序即可使用陌生的服务发现机制</li><li>存储编排：自动挂载所选存储系统，包括本地存储</li><li>Secret和配置管理：部署更新Secrets和应用程序的配置时不必重新构建容器镜像，且不必将软件堆栈配置中的秘密信息暴露出来</li><li>批量执行：除了服务之外，Kubernetes还可以管理你的批处理和CI工作负载，在期望时替换掉失效的容器</li><li>水平扩缩：使用一个简单的命令、一个UI或基于CPU使用情况自动对应用程序进行扩缩</li><li>自动化上线和回滚：Kubernetes会分步骤地将针对应用或其配置的更改上线，同时监视应用程序运行状况以确保你不会同时终止所有实例</li><li>自动装箱：根据资源需求和其他约束自动放置容器，同时避免影响可用性</li><li>自我修复：重新启动失败的容器，在节点死亡时替换并重新调度容器，杀死不响应用户定义的健康检查的容器</li></ul><a id="more"></a><h3 id="1-3-部署方案">1.3 部署方案</h3><p><strong>传统部署方式</strong></p><p>应用直接在物理机上部署，机器资源分配不好控制，出现Bug时，可能机器的大部分资源被某个应用占用，导致其他应用无法正常运行，无法做到应用隔离</p><p><strong>虚拟机部署</strong></p><p>在单个物理机上运行多个虚拟机，每个虚拟机都是完整独立的系统，性能损耗大</p><p><strong>容器部署</strong></p><p>所有容器共享主机的系统，轻量级的虚拟机，性能损耗小，资源隔离，CPU和内存可按需分配；例如k8s可以轻松管理百万千万台机器的集群，可以为你提供集中式的管理集群机器和应用，不停机的灰度更新，确保高可用、高性能、高扩展</p><h2 id="2、Kubernetes-集群架构">2、Kubernetes 集群架构</h2><h3 id="2-1-架构">2.1 架构</h3><p><img src="https://img-blog.csdnimg.cn/a85b4181772445daae892f246473f6f9.png#pic_center" alt="在这里插入图片描述"></p><ul><li><p>master</p><p>主节点，控制平台，不需要很高性能，不跑任务，通常一个就行了，也可以开多个主节点来提高集群可用度。</p></li><li><p>worker</p><p>工作节点，可以是虚拟机或物理计算机，任务都在这里跑，机器性能需要好点；通常都有很多个，可以不断加机器扩大集群；每个工作节点由主节点管理</p></li></ul><h3 id="2-2-重要概念-Pod">2.2 重要概念 Pod</h3><p>K8S 调度、管理的最小单位，一个 Pod 可以包含一个或多个容器，每个 Pod 有自己的虚拟IP。一个工作节点可以有多个 pod，主节点会考量负载自动调度 pod 到哪个节点运行</p><p><img src="https://img-blog.csdnimg.cn/b27389316e9d4552a7eaa70b3c96b74b.png#pic_center" alt="在这里插入图片描述"></p><h3 id="2-3-Kubernetes-组件">2.3 Kubernetes 组件</h3><ul><li><code>kube-apiserver</code> <strong>K8S 的请求入口服务</strong>。API Server 负责接收 K8S 所有请求（来自 UI 界面或者 CLI 命令行工具），然后，API Server 根据用户的具体请求，去通知其他组件干活</li><li><code>etcd</code> <strong>K8S 的存储服务</strong>。etcd 存储了 K8S 的关键配置和用户配置，K8S 中仅 API Server 才具备读写权限，其他组件必须通过 API Server 的接口才能读写数据</li><li><code>kube-scheduler</code> <strong>K8S 所有 Worker Node 的调度器</strong>。当用户要部署服务时，Scheduler 会选择最合适的 Worker Node（服务器）来部署</li><li><code>controller Manager</code> <strong>K8S 所有 Worker Node 的监控器</strong>。Controller Manager 有很多具体的Controller， Node Controller、Service Controller、Volume Controller 等。Controller 负责监控和调整在Worker Node 上部署的服务的状态，比如用户要求 A 服务部署 2 个副本，那么当其中一个服务挂了的时候，Controller 会马上调整，让 Scheduler 再选择一个 Worker Node 重新部署服务</li><li><code>cloud-controller</code> 与云服务商交互</li><li><code>Kubelet</code> <strong>Worker Node 的监视器，以及与 Master Node 的通讯器</strong>。Kubelet 是 Master Node 安插在Worker Node 上的&quot;眼线&quot;，它会定期向 Master Node 汇报自己 Node 上运行的服务的状态，并接受来自Master Node 的指示采取调整措施。负责控制所有容器的启动停止，保证节点工作正常。</li><li><code>Kube-Proxy</code> <strong>K8S 的网络代理</strong>。Kube-Proxy 负责 Node 在 K8S 的网络通讯、以及对外部网络流量的负载均衡</li><li><code>Container Runtime</code>** Worker Node 的运行环境**。即安装了容器化所需的软件环境确保容器化程序能够跑起来，比如 Docker Engine运行环境</li></ul><p><img src="https://img-blog.csdnimg.cn/7b0aeb0696a044199762d593f8f6d55d.png#pic_center" alt="在这里插入图片描述"></p><h1>二、Kubernetes集群安装</h1><blockquote><p>默认已经提前安装好Docker，docker安装可以参考：<a href="https://blog.csdn.net/lemon_TT/article/details/125981712" target="_blank" rel="noopener" title="docker学习笔记">docker学习笔记</a></p></blockquote><h2 id="1、安装方式介绍">1、安装方式介绍</h2><ul><li><p><strong>minikube</strong>  </p><p>只是一个 K8S 集群模拟器，只有一个节点的集群，只为测试用，master 和 worker 都在一起</p></li><li><p><strong>直接用云平台 Kubernetes</strong> (阿里/腾讯)</p><p>可视化搭建，只需简单几步就可以创建好一个集群。  </p><p>优点：安装简单，生态齐全，负载均衡器、存储等都给你配套好，简单操作就搞定</p></li><li><p><strong>裸机安装（Bare Metal）</strong>  </p><p>至少需要两台机器（主节点、工作节点个一台），需要自己安装 Kubernetes 组件，配置会稍微麻烦点。  </p><p>可以到各云厂商按时租用服务器，费用低，用完就销毁。  </p><p>缺点：配置麻烦，缺少生态支持，例如负载均衡器、云存储。</p></li></ul><h2 id="2、minikubute安装">2、minikubute安装</h2><blockquote><p>官网安装：<a href="https://minikube.sigs.k8s.io/docs/start/" target="_blank" rel="noopener" title="https://minikube.sigs.k8s.io/docs/start/">https://minikube.sigs.k8s.io/docs/start/</a><br><a href="https://developer.aliyun.com/article/886463" target="_blank" rel="noopener" title="Minikube：搭建部署单机 Kubernetes">Minikube：搭建部署单机 Kubernetes</a></p></blockquote><p>minikube安装非常简单，支持各种平台，建议直接裸机(个人虚拟机安装一直有问题)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动集群，据说不加版本会报错(我还是启动不了)</span></span><br><span class="line">minikube start --kubernetes-version=v1.23.0</span><br><span class="line"><span class="comment"># 查看节点。kubectl 是一个用来跟 K8S 集群进行交互的命令行工具</span></span><br><span class="line">kubectl get node</span><br><span class="line"><span class="comment"># 停止集群</span></span><br><span class="line">minikube stop</span><br><span class="line"><span class="comment"># 清空集群</span></span><br><span class="line">minikube delete --all</span><br><span class="line"><span class="comment"># 安装集群可视化 Web UI 控制台</span></span><br><span class="line">minikube dashboard</span><br></pre></td></tr></table></figure><p>minikube和云平台不多赘述，例如腾讯云的<a href="https://cloud.tencent.com/product/eks" target="_blank" rel="noopener" title="弹性容器服务 EKS">弹性容器服务 EKS</a>，这里主要讲述逻辑集群的安装</p><h2 id="3、裸机搭建（Bare-Metal）">3、裸机搭建（Bare Metal）</h2><blockquote><p>k8s集群搭建参考：<a href="https://k8s.easydoc.net/docs/dRiQjyTY/28366845/6GiNOzyZ/nd7yOvdY#nav_3" target="_blank" rel="noopener" title="https://k8s.easydoc.net/docs/dRiQjyTY/28366845/6GiNOzyZ/nd7yOvdY#nav_3">https://k8s.easydoc.net/docs/dRiQjyTY/28366845/6GiNOzyZ/nd7yOvdY#nav_3</a></p></blockquote><h3 id="3-1-概念介绍">3.1 概念介绍</h3><p><strong>主节点需要组件</strong></p><ul><li>docker（也可以是其他容器运行时）</li><li>kubectl 集群命令行交互工具</li><li>kubeadm 集群初始化工具</li></ul><p>**工作节点需要组件 **<a href="https://kubernetes.io/zh/docs/concepts/overview/components/#node-components" target="_blank" rel="noopener" title="文档"><strong>文档</strong></a></p><ul><li>docker（也可以是其他容器运行时）</li><li>kubelet 管理 Pod 和容器，确保他们健康稳定运行</li><li>kube-proxy 网络代理，负责网络相关的工作</li></ul><h3 id="3-2-集群安装">3.2 集群安装</h3><p>这里我基于centos7创建了三台虚拟机(2核4G，网络使用nat)，以下是所有节点的配置，权限不够的话使用sudo提升权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每个节点分别设置对应主机名</span></span><br><span class="line">hostnamectl <span class="built_in">set</span>-hostname master</span><br><span class="line">hostnamectl <span class="built_in">set</span>-hostname node1</span><br><span class="line">hostnamectl <span class="built_in">set</span>-hostname node2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 所有节点都修改 hosts</span></span><br><span class="line">vim /etc/hosts</span><br><span class="line">192.168.249.241 node1</span><br><span class="line">192.168.249.242 node2</span><br><span class="line">192.168.249.240 master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 所有节点关闭 SELinux</span></span><br><span class="line"><span class="comment"># 临时关闭</span></span><br><span class="line">setenforce 0</span><br><span class="line"><span class="comment"># 永久关闭</span></span><br><span class="line">sed -i --follow-symlinks <span class="string">'s/SELINUX=enforcing/SELINUX=disabled/g'</span> /etc/sysconfig/selinux</span><br><span class="line"><span class="comment"># 查看selinux状态</span></span><br><span class="line">getenforce</span><br><span class="line"></span><br><span class="line"><span class="comment"># k8s不需要swap分区，如果安装Linux系统时创建了swap分区，那么就需要禁用swap</span></span><br><span class="line"><span class="comment"># 临时关闭swap分区</span></span><br><span class="line">swapoff -a</span><br><span class="line"><span class="comment"># 修改配置文件永久关闭swap分区 ，或者vim /etc/fstab 删除或注释掉带有swap的行</span></span><br><span class="line">sed -ri <span class="string">'s/.*swap.*/#&amp;/'</span> /etc/fstab</span><br><span class="line"></span><br><span class="line"><span class="comment"># 所有节点确保防火墙关闭，确保网络通信</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置时间同步</span></span><br><span class="line">sudo yum install ntpdate -y</span><br><span class="line">sudo ntpdate time.windows.com</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加 k8s 安装源</span></span><br><span class="line">cat &lt;&lt;EOF &gt; kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br><span class="line">mv kubernetes.repo /etc/yum.repos.d/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加 Docker 安装源</span></span><br><span class="line">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装所需组件（所有节点）</span></span><br><span class="line">yum install -y kubelet-1.22.4 kubectl-1.22.4 kubeadm-1.22.4 docker-ce</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 kubelet、docker，并设置开机启动</span></span><br><span class="line">systemctl <span class="built_in">enable</span> kubelet</span><br><span class="line">systemctl start kubelet</span><br><span class="line">systemctl <span class="built_in">enable</span> docker</span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改 docker 配置</span></span><br><span class="line"><span class="comment"># kubernetes 官方推荐 docker 等使用 systemd 作为 cgroupdriver，否则 kubelet 启动不了</span></span><br><span class="line">cat &lt;&lt;EOF &gt; daemon.json</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"exec-opts"</span>: [<span class="string">"native.cgroupdriver=systemd"</span>],</span><br><span class="line">  <span class="string">"registry-mirrors"</span>: [<span class="string">"https://ud6340vz.mirror.aliyuncs.com"</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">mv daemon.json /etc/docker/</span><br><span class="line"><span class="comment"># 重启生效</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><p>在主节点master初始化集群，<a href="https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm-init/" target="_blank" rel="noopener" title="init的文档">init的文档</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化集群控制台 Control plane</span></span><br><span class="line"><span class="comment"># 失败了可以用 sudo kubeadm reset 重置</span></span><br><span class="line"><span class="comment"># 这里记得加上子网分配，教程不加也可以，可以试试</span></span><br><span class="line">sudo kubeadm init --image-repository=registry.aliyuncs.com/google_containers --pod-network-cidr 10.244.0.0/16</span><br><span class="line"><span class="comment">#sudo kubeadm init --apiserver-advertise-address=192.168.249.139 --image-repository registry.aliyuncs.com/google_containers --kubernetes-version v1.18.0 --service-cidr=10.96.0.0/12 --pod-network-cidr=10.244.0.0/16</span></span><br><span class="line"><span class="comment"># 记得把 kubeadm join xxx 保存起来</span></span><br><span class="line"><span class="comment"># 忘记了重新获取：kubeadm token create --print-join-command</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制授权文件，以便 kubectl 可以有权限访问集群</span></span><br><span class="line"><span class="comment"># 如果你其他节点需要访问集群，需要从主节点复制这个文件过去其他节点</span></span><br><span class="line"><span class="comment"># 如果是普通用户</span></span><br><span class="line">mkdir -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) <span class="variable">$HOME</span>/.kube/config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果是root用户</span></span><br><span class="line"><span class="built_in">export</span> KUBECONFIG=/etc/kubernetes/admin.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在其他机器上创建 ~/.kube/config 文件也能通过 kubectl 访问到集群</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果node节点添加进集群失败，可以删除节点重新添加</span></span><br><span class="line"><span class="comment"># 要删除 ­node1 这个节点，首先在 master 节点上依次执行以下两个命令</span></span><br><span class="line">kubectl drain node1 --delete-local-data --force --ignore-daemonsets</span><br><span class="line">kubectl delete node node1</span><br><span class="line"><span class="comment"># 执行后通过 kubectl get node 命令可以看到 node1 已被成功删除，接着在 k8s­node1 这个 Node 节点上执行如下命令，这样该节点即完全从 k8s 集群中脱离开来，之后就可以重新执行命令添加到集群</span></span><br><span class="line">kubeadm reset</span><br></pre></td></tr></table></figure><p>然后把工作节点加入集群（只在工作节点跑）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo kubeadm join 192.168.249.140:6443 --token 5f20z7.9rbjijmnkhpz0sj2 \</span><br><span class="line">        --discovery-token-ca-cert-hash sha256:b6b6b1d84ca8a0711667d654e8a676c0e17703715c5b16074896eecedbf8ca01</span><br></pre></td></tr></table></figure><p>最后安装网络插件，否则 node 是 NotReady 状态（主节点跑）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看状态</span></span><br><span class="line">kubectl get nodes</span><br><span class="line"><span class="comment"># 网络插件，用来结点通信的，</span></span><br><span class="line"><span class="comment"># 很有可能国内网络访问不到这个资源，你可以网上找找国内的源安装 flannel</span></span><br><span class="line">kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span><br><span class="line"><span class="comment"># 这里一个方法是进入该网站手动讲内容复制下来，把内容保存到linux中命名kube-flannel.yml</span></span><br><span class="line">https://github.com/flannel-io/flannel/blob/master/Documentation/kube-flannel.yml</span><br><span class="line"><span class="comment"># 执行</span></span><br><span class="line">kubectl apply -f kube-flannel.yml</span><br></pre></td></tr></table></figure><h3 id="3-3-踩坑之路">3.3 踩坑之路</h3><p>首先了解一下基本的命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看所有的详细信息</span></span><br><span class="line">kubectl get pod -A -owide</span><br><span class="line"><span class="comment"># 查看某一个容器详细运行状态，-n后跟的是命名空间，排查错误用</span></span><br><span class="line">kubectl describe pod kube-flannel-ds-wclwt -n kube-flannel</span><br><span class="line"><span class="comment"># 查看日志</span></span><br><span class="line">kubectl logs -f --tail 200 -n kube-flannel kube-flannel-ds-5bmpl</span><br></pre></td></tr></table></figure><p><strong>问题一</strong></p><p>手动导入网络插件后通过查看日志发现镜像无法拉取，于是手动拉取导入，然后用tag打上与yml文件中的镜像一模一样的名字，这里我每个结点都是这样操作（按理说会自动同步过去其他结点，但是每个结点都报错了，所以我手动下载了；当然换个国内源也可以）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载地址</span></span><br><span class="line">https://github.com/flannel-io/flannel</span><br><span class="line"><span class="comment"># 比如yml中写的是docker.io/rancher/mirrored-flannelcni-flannel:v0.20.0，首先下载对应的包</span></span><br><span class="line">docker load &lt; flanneld-v0.20.0-amd64.docker</span><br><span class="line"><span class="comment"># 查看一下</span></span><br><span class="line">sudo docker images</span><br><span class="line"><span class="comment"># 找到对应的镜像打上对应标签</span></span><br><span class="line">sudo docker tag quay.io/coreos/flannel:v0.20.0-amd64 docker.io/rancher/mirrored-flannelcni-flannel:v0.20.0</span><br></pre></td></tr></table></figure><p><strong>问题二</strong></p><p>手动下载后，查看describe日志发现能成功拉去镜像，但是容器无法启动，查看logs日志发现说没有分配子网podCIDR，通过kubeadm init初始化master节点时，flannel网络插件需要确保初始化命令配置了podCIDR如下启动参数，<strong>–pod-network-cidr=172.18.0.0/16</strong></p><blockquote><p>参考：<a href="https://www.hyhblog.cn/2021/02/21/k8s-flannel-pod-cidr-not-assigned/" target="_blank" rel="noopener" title="k8s集群flannel部署错误异常排查：pod cidr not assigned">k8s集群flannel部署错误异常排查：pod cidr not assigned</a></p></blockquote><p><strong>问题三</strong></p><p>如果你运行 <code>kubectl describe pod/pod-name</code> 发现 Events 中有下面这个错误<code>networkPlugin cni failed to set up pod &quot;test-k8s-68bb74d654-mc6b9_default&quot; network: open /run/flannel/subnet.env: no such file or directory</code>那么在每个节点创建文件<code>/run/flannel/subnet.env</code>写入以下内容，配置后等待一会就好了（用来配置每个结点的子网信息）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FLANNEL_NETWORK=10.244.0.0/16</span><br><span class="line">FLANNEL_SUBNET=10.244.0.1/24</span><br><span class="line">FLANNEL_MTU=1450</span><br><span class="line">FLANNEL_IPMASQ=<span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="4、快速体验">4、快速体验</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一次deployment部署</span></span><br><span class="line">kubectl create deployment nginx --image=nginx</span><br><span class="line">kubectl get deployment</span><br><span class="line">kubectl get pod</span><br><span class="line"><span class="comment"># 创建service（端口映射）</span></span><br><span class="line">kubectl expose deployment nginx --port=80 --<span class="built_in">type</span>=NodePort</span><br><span class="line"></span><br><span class="line">kubectl get pod,svc -o wide</span><br><span class="line"><span class="comment"># 访问Nginx地址： http://任意节点的ip:图中Nginx的对外映射端口，http://192.168.249.240:30433</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除pod和service(端口映射)</span></span><br><span class="line">kubectl delete deployment nginx</span><br><span class="line">kubectl delete svc/nginx</span><br></pre></td></tr></table></figure><h2 id="5、可视化安装">5、可视化安装</h2><h3 id="5-1-Kuboard-v2-kubernetes-推荐">5.1 Kuboard v2 - kubernetes(推荐)</h3><blockquote><p>参考：<a href="https://kuboard.cn/install/install-dashboard.html" target="_blank" rel="noopener" title="安装 Kuboard v2">安装 Kuboard v2</a></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 Kuboard</span></span><br><span class="line">kubectl apply -f https://kuboard.cn/install-script/kuboard.yaml</span><br><span class="line">kubectl apply -f https://addons.kuboard.cn/metrics-server/0.3.7/metrics-server.yaml</span><br><span class="line"><span class="comment"># 查看运行状态</span></span><br><span class="line">kubectl get pods -l k8s.kuboard.cn/name=kuboard -n kube-system</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取管理员token</span></span><br><span class="line"><span class="built_in">echo</span> $(kubectl -n kube-system get secret $(kubectl -n kube-system get secret | grep ^kuboard-user | awk <span class="string">'&#123;print $1&#125;'</span>) -o go-template=<span class="string">'&#123;&#123;.data.token&#125;&#125;'</span> | base64 -d)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Kuboard Service 使用了 NodePort 的方式暴露服务，NodePort 为 32567；您可以按如下方式访问 Kuboard。</span></span><br><span class="line"><span class="comment"># http://任意一个Worker节点的IP地址:32567/</span></span><br></pre></td></tr></table></figure><h3 id="5-2-Kubernetes-Dashboard">5.2 Kubernetes Dashboard</h3><blockquote><p>参考：<a href="https://kuboard.cn/install/install-k8s-dashboard.html" target="_blank" rel="noopener" title="Kubernetes Dashboard安装">Kubernetes Dashboard安装</a>/<a href="https://kubernetes.io/zh-cn/docs/tasks/access-application-cluster/web-ui-dashboard/" target="_blank" rel="noopener" title="部署和访问 Kubernetes 仪表板（Dashboard）">部署和访问 Kubernetes 仪表板（Dashboard）</a></p></blockquote><p>Kubernetes Dashboard 是 Kubernetes 的官方 Web UI。使用 Kubernetes Dashboard可以</p><ul><li>向 Kubernetes 集群部署容器化应用</li><li>诊断容器化应用的问题</li><li>管理集群的资源</li><li>查看集群上所运行的应用程序</li><li>创建、修改Kubernetes 上的资源（例如 Deployment、Job、DaemonSet等）</li><li>展示集群上发生的错误</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 Kubernetes Dashboard</span></span><br><span class="line">kubectl apply -f https://kuboard.cn/install-script/k8s-dashboard/v2.0.0-beta5.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># Kubernetes Dashboard 当前，只支持使用 Bearer Token登录</span></span><br><span class="line"><span class="comment"># 创建 ServiceAccount 和 ClusterRoleBinding</span></span><br><span class="line">kubectl apply -f https://kuboard.cn/install-script/k8s-dashboard/auth.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取Bearer Token</span></span><br><span class="line">kubectl -n kubernetes-dashboard describe secret $(kubectl -n kubernetes-dashboard get secret | grep admin-user | awk <span class="string">'&#123;print $1&#125;'</span>)</span><br><span class="line"><span class="comment"># 执行代理命令</span></span><br><span class="line">kubectl proxy</span><br><span class="line"><span class="comment"># 如需要使用 nodePort 或 Ingress 的方式访问 Kubernetes Dashboard 请配置正确的 https 证书，或者使用 Firefox 浏览器，并忽略 HTTPS 校验错误。</span></span><br><span class="line"><span class="comment"># 访问路径，将上一个步骤中获得的 Token 输入到登录界面中，点击 Sign in 按钮，完成登录</span></span><br><span class="line">http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/</span><br></pre></td></tr></table></figure><h1>三、集群服务部署</h1><h2 id="1、部署应用Demo">1、部署应用Demo</h2><p>部署一个 nodejs web 应用，源码地址：<a href="https://github.com/gzyunke/test-k8s" target="_blank" rel="noopener" title="Github">Github</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看pod状态</span></span><br><span class="line">kubectl get pod -owide</span><br><span class="line"><span class="comment"># 运行一个pod</span></span><br><span class="line">kubectl run testapp --image=ccr.ccs.tencentyun.com/k8s-tutorial/<span class="built_in">test</span>-k8s:v1</span><br><span class="line"><span class="comment"># 通过yaml创建k8sPod</span></span><br><span class="line">kubectl apply -f pod.yaml</span><br><span class="line">kubectl apply -f deployment.yaml</span><br></pre></td></tr></table></figure><p>创建pod.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">test-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="comment"># 定义容器，可以多个</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test-k8s</span> <span class="comment"># 容器名字</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">ccr.ccs.tencentyun.com/k8s-tutorial/test-k8s:v1</span> <span class="comment"># 镜像</span></span><br></pre></td></tr></table></figure><p>创建deployment.yaml文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="comment"># 定义资源的类型/角色，deployment为副本控制器，此处资源类型可以是Deployment、Job、Ingress、Service等</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="comment"># 定义资源的名称，在同一个namespace空间中必须是唯一的</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">test-k8s</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="comment"># 用来查找关联的 Pod，所有标签都匹配才行</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">test-k8s</span></span><br><span class="line">  <span class="comment"># 定义 Pod 相关数据</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">test-k8s</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="comment"># 定义容器，可以多个</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test-k8s</span> <span class="comment"># 容器名字</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">ccr.ccs.tencentyun.com/k8s-tutorial/test-k8s:v1</span> <span class="comment"># 镜像</span></span><br></pre></td></tr></table></figure><p>命令行弹性伸缩，k8s会自动根据结点情况部署</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 命令行弹性扩容，也可以在yaml中进行编写</span></span><br><span class="line">kubectl scale deployment <span class="built_in">test</span>-k8s --replicas=3</span><br><span class="line"><span class="comment"># 修改镜像</span></span><br><span class="line">kubectl <span class="built_in">set</span> image deployment <span class="built_in">test</span>-k8s <span class="built_in">test</span>-k8s=ccr.ccs.tencentyun.com/k8s-tutorial/<span class="built_in">test</span>-k8s:v2-with-error</span><br><span class="line"><span class="comment"># 把集群内端口某个pod映射到节点</span></span><br><span class="line">kubectl port-forward <span class="built_in">test</span>-k8s-5699487f75-bg82t 8090:8080</span><br><span class="line"><span class="comment"># 在master结点测试访问，这只是其中一个容器的，外网不能进行访问</span></span><br><span class="line">curl localhost:8090</span><br></pre></td></tr></table></figure><h2 id="2、常用命令详情">2、常用命令详情</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 部署应用</span></span><br><span class="line">kubectl apply -f app.yaml</span><br><span class="line"><span class="comment"># 查看 deployment</span></span><br><span class="line">kubectl get deployment</span><br><span class="line"><span class="comment"># 查看 pod</span></span><br><span class="line">kubectl get pod -o wide</span><br><span class="line"><span class="comment"># 查看 pod 详情</span></span><br><span class="line">kubectl describe pod pod-name</span><br><span class="line"><span class="comment"># 查看 log</span></span><br><span class="line">kubectl logs pod-name [-f]</span><br><span class="line"><span class="comment"># 进入 Pod 容器终端， -c container-name 可以指定进入哪个容器。</span></span><br><span class="line">kubectl <span class="built_in">exec</span> -it pod-name -- bash</span><br><span class="line"><span class="comment"># 伸缩扩展副本</span></span><br><span class="line">kubectl scale deployment <span class="built_in">test</span>-k8s --replicas=5</span><br><span class="line"><span class="comment"># 把集群内端口映射到节点</span></span><br><span class="line">kubectl port-forward pod-name 8090:8080</span><br><span class="line"><span class="comment"># 查看历史</span></span><br><span class="line">kubectl rollout <span class="built_in">history</span> deployment <span class="built_in">test</span>-k8s</span><br><span class="line"><span class="comment"># 回到上个版本</span></span><br><span class="line">kubectl rollout undo deployment <span class="built_in">test</span>-k8s</span><br><span class="line"><span class="comment"># 回到指定版本</span></span><br><span class="line">kubectl rollout undo deployment <span class="built_in">test</span>-k8s --to-revision=2</span><br><span class="line"><span class="comment"># 删除部署</span></span><br><span class="line">kubectl delete deployment <span class="built_in">test</span>-k8s</span><br><span class="line"></span><br><span class="line"><span class="comment"># =============更多命令============</span></span><br><span class="line"><span class="comment"># 查看全部</span></span><br><span class="line">kubectl get all</span><br><span class="line"><span class="comment"># 重新部署</span></span><br><span class="line">kubectl rollout restart deployment <span class="built_in">test</span>-k8s</span><br><span class="line"><span class="comment"># 命令修改镜像，--record 表示把这个命令记录到操作历史中</span></span><br><span class="line">kubectl <span class="built_in">set</span> image deployment <span class="built_in">test</span>-k8s <span class="built_in">test</span>-k8s=ccr.ccs.tencentyun.com/k8s-tutorial/<span class="built_in">test</span>-k8s:v2-with-error --record</span><br><span class="line"><span class="comment"># 暂停运行，暂停后，对 deployment 的修改不会立刻生效，恢复后才应用设置</span></span><br><span class="line">kubectl rollout pause deployment <span class="built_in">test</span>-k8s</span><br><span class="line"><span class="comment"># 恢复</span></span><br><span class="line">kubectl rollout resume deployment <span class="built_in">test</span>-k8s</span><br><span class="line"><span class="comment"># 输出到文件</span></span><br><span class="line">kubectl get deployment <span class="built_in">test</span>-k8s -o yaml &gt;&gt; app2.yaml</span><br><span class="line"><span class="comment"># 删除全部资源</span></span><br><span class="line">kubectl delete all --all</span><br></pre></td></tr></table></figure><h2 id="3、概念">3、概念</h2><blockquote><p>更多官网关于 <a href="https://kubernetes.io/zh/docs/concepts/workloads/controllers/deployment/" target="_blank" rel="noopener" title="Deployment">Deployment</a> 的介绍，将 Pod 指定到某个节点运行：<a href="https://kubernetes.io/zh/docs/concepts/scheduling-eviction/assign-pod-node/#nodeselector" target="_blank" rel="noopener" title="nodeselector">nodeselector</a>，限定 CPU、内存总量：<a href="https://kubernetes.io/zh/docs/concepts/policy/resource-quotas/#%E8%AE%A1%E7%AE%97%E8%B5%84%E6%BA%90%E9%85%8D%E9%A2%9D" target="_blank" rel="noopener" title="文档">文档</a></p></blockquote><h3 id="3-1-工作负载分类">3.1 工作负载分类</h3><blockquote><p><a href="https://kubernetes.io/zh/docs/concepts/workloads/" target="_blank" rel="noopener" title="https://kubernetes.io/zh/docs/concepts/workloads/">https://kubernetes.io/zh/docs/concepts/workloads/</a></p></blockquote><ul><li><p>Deployment  </p><p>适合无状态应用，所有pod等价，可替代</p></li><li><p>StatefulSet  </p><p>有状态的应用，适合数据库这种类型。</p></li><li><p>DaemonSet  </p><p>在每个节点上跑一个 Pod，可以用来做节点监控、节点日志收集等</p></li><li><p>Job &amp; CronJob  </p><p>Job 用来表达的是一次性的任务，而 CronJob 会根据其时间规划反复运行。</p></li></ul><h3 id="3-2-存在问题">3.2 存在问题</h3><ul><li>每次只能访问一个 pod，没有负载均衡自动转发到不同 pod</li><li>访问还需要端口转发</li><li>Pod 重创后 IP 变了，名字也变了</li></ul><h1>四、Service</h1><h2 id="1、概念-v2">1、概念</h2><blockquote><p><a href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#headless-services" target="_blank" rel="noopener" title="https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#headless-services">https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#headless-services</a></p></blockquote><ul><li>Service 通过 label 关联对应的 Pod</li><li>Servcie 生命周期不跟 Pod 绑定，不会因为 Pod 重创改变 IP</li><li>提供了负载均衡功能，自动转发流量到不同 Pod</li><li>可对集群外部提供访问端口</li><li>集群内部可通过服务名字访问</li></ul><p><img src="https://img-blog.csdnimg.cn/c8391a23d64c46199b53ad1dbee0bd33.png#pic_center" alt="在这里插入图片描述"></p><h2 id="2、Service简单Demo">2、Service简单Demo</h2><p>首先创建service.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">test-k8s</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="comment"># 要和pod对应</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">test-k8s</span></span><br><span class="line">  <span class="comment"># 服务默认是这个</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">8080</span>        <span class="comment"># 本 Service 的端口</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8080</span>  <span class="comment"># 容器端口</span></span><br></pre></td></tr></table></figure><p>然后进行访问测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建service</span></span><br><span class="line">kubectl apply -f service.yaml</span><br><span class="line"><span class="comment"># 查看服务</span></span><br><span class="line">kubectl get service</span><br><span class="line">kubectl get svc</span><br><span class="line"><span class="comment"># 查看服务详情，可以发现 Endpoints 是各个 Pod 的 IP，也就是他会把流量转发到这些节点</span></span><br><span class="line">kubectl describe svc <span class="built_in">test</span>-k8s</span><br><span class="line"><span class="comment"># 服务的默认类型是ClusterIP，只能在集群内部访问，我们可以进入到 Pod 里面访问</span></span><br><span class="line">kubectl <span class="built_in">exec</span> -it pod-name -- bash</span><br><span class="line">curl http://<span class="built_in">test</span>-k8s:8080</span><br><span class="line"><span class="comment"># 如果要在集群外部访问，可以通过端口转发实现（只适合临时测试用）</span></span><br><span class="line">kubectl port-forward service/<span class="built_in">test</span>-k8s 8888:8080</span><br><span class="line">curl http://localhost:8080</span><br></pre></td></tr></table></figure><h2 id="3、对外暴露服务-重要">3、对外暴露服务(重要)</h2><p>上面我们是通过端口转发的方式可以在外面访问到集群里的服务，如果想要直接把集群服务暴露出来，我们可以使用<code>NodePort</code> 和 <code>Loadbalancer</code> 类型的 Service</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">test-k8s</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">test-k8s</span></span><br><span class="line">  <span class="comment"># 默认 ClusterIP 集群内可访问，NodePort 节点可访问，LoadBalancer 负载均衡模式（需要负载均衡器才可用）</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">8080</span>        <span class="comment"># 本 Service 的端口</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8080</span>  <span class="comment"># 容器端口</span></span><br><span class="line">      <span class="attr">nodePort:</span> <span class="number">31000</span>   <span class="comment"># 节点端口，范围固定 30000 ~ 32767</span></span><br></pre></td></tr></table></figure><p>应用配置 <code>kubectl apply -f service.yaml</code>；在节点上，我们可以 <code>curl http://localhost:31000</code> 或者<code>curl http://[你的物理ip]:31000</code>访问到应用并且是有负载均衡的，网页的信息可以看到被转发到了不同的 Pod(可能有缓存)</p><p><code>Loadbalancer</code> 也可以对外提供服务，这需要一个负载均衡器的支持，因为它需要生成一个新的 IP 对外服务，否则状态就一直是 pendding，这个很少用了，后面我们会讲更高端的 Ingress 来代替它。</p><h2 id="4、多端口">4、多端口</h2><blockquote><p><a href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#multi-port-services" target="_blank" rel="noopener" title="https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#multi-port-services">https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#multi-port-services</a></p></blockquote><p>多端口时必须配置 name</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">test-k8s</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">test-k8s</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">8080</span>        <span class="comment"># 本 Service 的端口</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">test-k8s</span>    <span class="comment"># 必须配置</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8080</span>  <span class="comment"># 容器端口</span></span><br><span class="line">      <span class="attr">nodePort:</span> <span class="number">31000</span>   <span class="comment"># 节点端口，范围固定 30000 ~ 32767</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">8090</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">test-other</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8090</span></span><br><span class="line">      <span class="attr">nodePort:</span> <span class="number">32000</span></span><br></pre></td></tr></table></figure><h2 id="5、总结">5、总结</h2><ul><li><p><strong>ClusterIP</strong></p><p>默认的，仅在集群内可用</p></li><li><p><strong>NodePort</strong></p><p>暴露端口到节点，提供了集群外部访问的入口，<strong>端口范围固定 30000 ~ 32767</strong></p></li><li><p><strong>LoadBalancer</strong></p><p>需要负载均衡器（通常都需要云服务商提供，裸机可以安装 <a href="https://metallb.universe.tf/" target="_blank" rel="noopener" title="METALLB">METALLB</a> 测试）会额外生成一个 IP 对外服务K8S 支持的负载均衡器：<a href="https://kubernetes.io/zh/docs/concepts/services-networking/service/#internal-load-balancer" target="_blank" rel="noopener" title="负载均衡器">负载均衡器</a></p></li><li><p><strong>Headless</strong></p><p>适合数据库，clusterIp 设置为 None 就变成 Headless 了，不会再分配 IP，后面会再讲到具体用法</p></li></ul><h1>五、StatefulSet</h1><h2 id="1、StatefulSet介绍">1、StatefulSet介绍</h2><h3 id="1-1-概念">1.1 概念</h3><p>StatefulSet 是用来管理有状态的应用，例如数据库。  前面我们部署的应用，都是不需要存储数据，不需要记住状态的，可以随意扩充副本，每个副本都是一样的，可替代的。  而像数据库、Redis 这类有状态的，则不能随意扩充副本。<strong>StatefulSet 会固定每个 Pod 的名字</strong></p><h3 id="1-2-特性">1.2 特性</h3><ul><li>Service 的 <code>CLUSTER-IP</code> 是空的，Pod 名字也是固定的。</li><li>Pod 创建和销毁是有序的，创建是顺序的，销毁是逆序的。</li><li>Pod 重建不会改变名字，除了IP，所以不要用IP直连</li></ul><h2 id="2、部署-StatefulSet-类型的-Mongodb">2、部署 StatefulSet 类型的 Mongodb</h2><p>创建statefulset和service</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StatefulSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mongodb</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">serviceName:</span> <span class="string">mongodb</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">mongodb</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">mongodb</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mongo</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">mongo:4.4</span></span><br><span class="line">          <span class="comment">#IfNotPresent 仅本地没有镜像时才远程拉，Always 永远都是从远程拉，Never 永远只用本地镜像，本地没有则报错</span></span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mongodb</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">mongodb</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br><span class="line">  <span class="comment"># HeadLess</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="string">None</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">27017</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">27017</span></span><br></pre></td></tr></table></figure><p>操作，<a href="http://xn--test-k8sccr-qx9qe5hn8f556o1se334kwlhmtr.ccs.tencentyun.com/k8s-tutorial/test-k8s:v3-mongo" target="_blank" rel="noopener">这里的test-k8s镜像使用了ccr.ccs.tencentyun.com/k8s-tutorial/test-k8s:v3-mongo</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 扩容</span></span><br><span class="line">kubectl scale --replicas=5 statefulset mongodb</span><br><span class="line"><span class="comment"># 查看状态信息</span></span><br><span class="line">kubectl get endpoints mongodb -o yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问时，如果直接使用 Service 名字连接，会随机转发请求</span></span><br><span class="line"><span class="comment"># 要连接指定 Pod，可以这样pod-name.service-name</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行一个临时 Pod 连接数据测试下</span></span><br><span class="line">kubectl run mongodb-client --rm --tty -i --restart=<span class="string">'Never'</span> --image docker.io/bitnami/mongodb:4.4.10-debian-10-r20 --<span class="built_in">command</span> -- bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问某一个mongodb</span></span><br><span class="line">mongo --host mongodb-0.mongodb</span><br><span class="line"></span><br><span class="line">show dbs</span><br><span class="line">use <span class="built_in">test</span></span><br><span class="line">db.users.save(&#123;<span class="string">'_id'</span>:<span class="string">'shawn'</span>,<span class="string">'name'</span>:<span class="string">'shawn22'</span>&#125;)</span><br><span class="line">db.users.find()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看集权状态</span></span><br><span class="line">kubectl get all</span><br></pre></td></tr></table></figure><h1>六、数据持久化</h1><h2 id="1、概念-v3">1、概念</h2><p>kubernetes 集群不会为你处理数据的存储，我们可以为数据库挂载一个磁盘来确保数据的安全。可以选择云存储、本地磁盘、NFS。</p><ul><li>本地磁盘：可以挂载某个节点上的目录，但是这需要限定 pod 在这个节点上运行</li><li>云存储：不限定节点，不受集群影响，安全稳定；需要云服务商提供，裸机集群是没有的。</li><li>NFS：不限定节点，不受集群影响</li></ul><h2 id="2、hostPath-挂载示例">2、hostPath 挂载示例</h2><blockquote><p>文档：<a href="https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#hostpath" target="_blank" rel="noopener" title="https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#hostpath">https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#hostpath</a></p></blockquote><p>把节点上的一个目录挂载到 Pod，但是已经不推荐使用了，该方法配置方式简单，需要手动指定 Pod 跑在某个固定的节点。仅供单节点测试使用；不适用于多节点集群</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StatefulSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mongodb</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">mongodb</span></span><br><span class="line">  <span class="attr">serviceName:</span> <span class="string">mongodb</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">mongodb</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mongo</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">mongo:4.4</span></span><br><span class="line">          <span class="comment"># IfNotPresent 仅本地没有镜像时才远程拉，Always 永远都是从远程拉，Never 永远只用本地镜像，本地没有则报错</span></span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">          <span class="attr">volumeMounts:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/data/db</span> <span class="comment"># 容器里面的挂载路径</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">mongo-data</span>    <span class="comment"># 卷名字，必须跟下面定义的名字一致</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mongo-data</span>              <span class="comment"># 卷名字</span></span><br><span class="line">          <span class="attr">hostPath:</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/data/mongo-data</span>      <span class="comment"># 节点上的路径</span></span><br><span class="line">            <span class="attr">type:</span> <span class="string">DirectoryOrCreate</span>     <span class="comment"># 指向一个目录，不存在时自动创建</span></span><br></pre></td></tr></table></figure><p>创建好数据后重启<code>kubectl rollout restart statefulset mongodb</code>，发现数据还在，同时进入结点，可以发现数据保存在<code>/data/db</code>，而进入该结点的宿主机，发现数据映射在<code>/data/mongo-data</code></p><h2 id="3、高级抽象挂载">3、高级抽象挂载</h2><h3 id="3-1-概述">3.1 概述</h3><p><img src="https://img-blog.csdnimg.cn/fad029fc6f494c6ba1b07b095da05e70.png#pic_center" alt="在这里插入图片描述"></p><ul><li>更好的分工，运维人员负责提供好存储，开发人员不需要关注磁盘细节，只需要写一个申请单。</li><li>方便云服务商提供不同类型的，配置细节不需要开发者关注，只需要一个申请单。</li><li><a href="https://kubernetes.io/zh/docs/concepts/storage/dynamic-provisioning/" target="_blank" rel="noopener" title="动态创建">动态创建</a>，开发人员写好申请单后，供应商可以根据需求自动创建所需存储卷。</li></ul><h3 id="3-2-各个层级表述">3.2 各个层级表述</h3><p><strong>Storage Class (SC)</strong></p><p>将存储卷划分为不同的种类，例如：SSD，普通磁盘，本地磁盘，按需使用。<a href="https://kubernetes.io/zh/docs/concepts/storage/storage-classes/" target="_blank" rel="noopener" title="文档">文档</a></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">storage.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StorageClass</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">slow</span></span><br><span class="line"><span class="attr">provisioner:</span> <span class="string">kubernetes.io/aws-ebs</span></span><br><span class="line"><span class="attr">parameters:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">io1</span></span><br><span class="line">  <span class="attr">iopsPerGB:</span> <span class="string">"10"</span></span><br><span class="line">  <span class="attr">fsType:</span> <span class="string">ext4</span></span><br></pre></td></tr></table></figure><p><strong>Persistent Volume (PV)</strong></p><p>描述卷的具体信息，例如磁盘大小，<a href="https://kubernetes.io/zh/docs/concepts/storage/persistent-volumes/#access-modes" target="_blank" rel="noopener" title="访问模式">访问模式</a>。<a href="https://kubernetes.io/zh/docs/concepts/storage/persistent-volumes/" target="_blank" rel="noopener" title="文档">文档</a>，<a href="https://kubernetes.io/zh/docs/concepts/storage/persistent-volumes/#types-of-persistent-volumes" target="_blank" rel="noopener" title="类型">类型</a>，<a href="https://kubernetes.io/zh/docs/concepts/storage/volumes/#local" target="_blank" rel="noopener" title="Local 示例">Local 示例</a></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mongodata</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">2Gi</span></span><br><span class="line">  <span class="attr">volumeMode:</span> <span class="string">Filesystem</span>  <span class="comment"># Filesystem（文件系统） Block（块）</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span>       <span class="comment"># 卷可以被一个节点以读写方式挂载</span></span><br><span class="line">  <span class="attr">persistentVolumeReclaimPolicy:</span> <span class="string">Delete</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">local-storage</span></span><br><span class="line">  <span class="attr">local:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/root/data</span></span><br><span class="line">  <span class="attr">nodeAffinity:</span></span><br><span class="line">    <span class="attr">required:</span></span><br><span class="line">      <span class="comment"># 通过 hostname 限定在某个节点创建存储卷</span></span><br><span class="line">      <span class="attr">nodeSelectorTerms:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">matchExpressions:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">kubernetes.io/hostname</span></span><br><span class="line">              <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">              <span class="attr">values:</span></span><br><span class="line">                <span class="bullet">-</span> <span class="string">node2</span></span><br></pre></td></tr></table></figure><p><strong>Persistent Volume Claim (PVC)</strong></p><p>对存储需求的一个申明，可以理解为一个申请单，系统根据这个申请单去找一个合适的 PV<br>还可以根据 PVC 自动创建 PV。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mongodata</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span> <span class="string">["ReadWriteOnce"]</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">"local-storage"</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">2Gi</span></span><br></pre></td></tr></table></figure><h3 id="3-3-本地测试">3.3 本地测试</h3><p>网络云服务商封装了底层，只需要提交pvc申请即可成功，这里我用本地进行模拟，写到了一起，实际可以自行分开</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StatefulSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mongodb</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">mongodb</span></span><br><span class="line">  <span class="attr">serviceName:</span> <span class="string">mongodb</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">mongodb</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mongo</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">mongo:4.4</span></span><br><span class="line">          <span class="comment"># IfNotPresent 仅本地没有镜像时才远程拉，Always 永远都是从远程拉，Never 永远只用本地镜像，本地没有则报错</span></span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">          <span class="attr">volumeMounts:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/data/db</span> <span class="comment"># 容器里面的挂载路径</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">mongo-data</span>    <span class="comment"># 卷名字，必须跟下面定义的名字一致</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mongo-data</span>              <span class="comment"># 卷名字</span></span><br><span class="line">          <span class="attr">persistentVolumeClaim:</span></span><br><span class="line">              <span class="attr">claimName:</span> <span class="string">mongodata</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mongodb</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="string">None</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">27017</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">27017</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">mongodb</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">storage.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StorageClass</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">local-storage</span></span><br><span class="line"><span class="attr">provisioner:</span> <span class="string">kubernetes.io/no-provisioner</span></span><br><span class="line"><span class="attr">volumeBindingMode:</span> <span class="string">WaitForFirstConsumer</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mongodata</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">2Gi</span></span><br><span class="line">  <span class="attr">volumeMode:</span> <span class="string">Filesystem</span>  <span class="comment"># Filesystem（文件系统） Block（块）</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="comment"># 卷可以被一个节点以读写方式挂载</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span>       </span><br><span class="line">  <span class="attr">persistentVolumeReclaimPolicy:</span> <span class="string">Delete</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">local-storage</span></span><br><span class="line">  <span class="attr">local:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/root/data</span></span><br><span class="line">  <span class="attr">nodeAffinity:</span></span><br><span class="line">    <span class="attr">required:</span></span><br><span class="line">      <span class="comment"># 通过 hostname 限定在某个节点创建存储卷</span></span><br><span class="line">      <span class="attr">nodeSelectorTerms:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">matchExpressions:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">kubernetes.io/hostname</span></span><br><span class="line">              <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">              <span class="attr">values:</span></span><br><span class="line">                <span class="bullet">-</span> <span class="string">node2</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mongodata</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span> <span class="string">["ReadWriteOnce"]</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">"local-storage"</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">2Gi</span></span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 运行</span></span><br><span class="line">kubectl apply -f storage.yaml</span><br><span class="line"><span class="comment"># 查看各个层信息</span></span><br><span class="line">kubectl get pv</span><br><span class="line">kubectl get sc</span><br><span class="line">kubectl get pvc</span><br><span class="line">kubectl get pod -owide</span><br><span class="line"><span class="comment"># 需要进入node2结点去创建一下data路径，可能会报错，后面mongo的数据库就挂在到了node2的/data下面</span></span><br></pre></td></tr></table></figure><h1>七、ConfigMap &amp; Secret</h1><h2 id="1、概述">1、概述</h2><blockquote><p>参考文档：<a href="https://kubernetes.io/zh/docs/concepts/configuration/configmap/" target="_blank" rel="noopener" title="https://kubernetes.io/zh/docs/concepts/configuration/configmap/">https://kubernetes.io/zh/docs/concepts/configuration/configmap/</a></p></blockquote><p>数据库连接地址，这种可能根据部署环境变化的，我们不应该写死在代码里。Kubernetes 为我们提供了 ConfigMap，可以方便的配置一些变量</p><h2 id="2、ConfigMap">2、ConfigMap</h2><p>创建configmap.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mongo-config</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">mongoHost:</span> <span class="string">mongodb-0.mongodb</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 应用</span></span><br><span class="line">kubectl apply -f configmap.yaml</span><br><span class="line"><span class="comment"># 查看</span></span><br><span class="line">kubectl get configmap mongo-config -o yaml</span><br><span class="line">kubectl get configmap</span><br></pre></td></tr></table></figure><h2 id="3、Secret">3、Secret</h2><p>一些重要数据，例如密码、TOKEN，我们可以放到 secret 中。<a href="https://kubernetes.io/zh/docs/concepts/configuration/secret/" target="_blank" rel="noopener" title="文档">文档</a>，<a href="https://kubernetes.io/zh/docs/concepts/configuration/secret/#tls-secret" target="_blank" rel="noopener" title="配置证书">配置证书</a>。<strong>注意，数据要进行 Base64 编码</strong>。<a href="https://tools.fun/base64.html" target="_blank" rel="noopener" title="Base64 工具">Base64 工具</a></p><p>创建secret.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mongo-secret</span></span><br><span class="line"><span class="comment"># Opaque 用户定义的任意数据，更多类型介绍 https://kubernetes.io/zh/docs/concepts/configuration/secret/#secret-types</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">Opaque</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="comment"># 数据要 base64。https://tools.fun/base64.html</span></span><br><span class="line">  <span class="attr">mongo-username:</span> <span class="string">bW9uZ291c2Vy</span></span><br><span class="line">  <span class="attr">mongo-password:</span> <span class="string">bW9uZ29wYXNz</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 应用</span></span><br><span class="line">kubectl apply -f secret.yaml</span><br><span class="line"><span class="comment"># 查看</span></span><br><span class="line">kubectl get secret mongo-secret -o yaml</span><br><span class="line">kubectl get secret</span><br></pre></td></tr></table></figure><h2 id="4、Demo使用">4、Demo使用</h2><p>作为环境变量使用</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StatefulSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mongodb</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">mongodb</span></span><br><span class="line">  <span class="attr">serviceName:</span> <span class="string">mongodb</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">mongodb</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mongo</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">mongo:4.4</span></span><br><span class="line">          <span class="comment"># IfNotPresent 仅本地没有镜像时才远程拉，Always 永远都是从远程拉，Never 永远只用本地镜像，本地没有则报错</span></span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">          <span class="attr">env:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MONGO_INITDB_ROOT_USERNAME</span></span><br><span class="line">            <span class="attr">valueFrom:</span></span><br><span class="line">              <span class="attr">secretKeyRef:</span></span><br><span class="line">                <span class="attr">name:</span> <span class="string">mongo-secret</span></span><br><span class="line">                <span class="attr">key:</span> <span class="string">mongo-username</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MONGO_INITDB_ROOT_PASSWORD</span></span><br><span class="line">            <span class="attr">valueFrom:</span></span><br><span class="line">              <span class="attr">secretKeyRef:</span></span><br><span class="line">                <span class="attr">name:</span> <span class="string">mongo-secret</span></span><br><span class="line">                <span class="attr">key:</span> <span class="string">mongo-password</span></span><br><span class="line">          <span class="comment"># Secret 的所有数据定义为容器的环境变量，Secret 中的键名称为 Pod 中的环境变量名称</span></span><br><span class="line">          <span class="comment"># envFrom:</span></span><br><span class="line">          <span class="comment"># - secretRef:</span></span><br><span class="line">          <span class="comment">#     name: mongo-secret</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mongodb</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">mongodb</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br><span class="line">  <span class="comment"># HeadLess</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="string">None</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">27017</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">27017</span></span><br></pre></td></tr></table></figure><p>挂载为文件（更适合证书文件）挂载后，会在容器中对应路径生成文件，一个 key 一个文件，内容就是 value，<a href="https://kubernetes.io/zh/docs/concepts/configuration/secret/#using-secrets-as-files-from-a-pod" target="_blank" rel="noopener" title="文档">文档</a></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mypod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mypod</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">foo</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">"/etc/foo"</span></span><br><span class="line">      <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">foo</span></span><br><span class="line">    <span class="attr">secret:</span></span><br><span class="line">      <span class="attr">secretName:</span> <span class="string">mysecret</span></span><br></pre></td></tr></table></figure><p>进行测试（<a href="http://xn--test-k8sccr-bo5rx54qupkn10dve7f.ccs.tencentyun.com/k8s-tutorial/test-k8s:v4-configmap%EF%BC%89" target="_blank" rel="noopener">test-k8s的镜像更换ccr.ccs.tencentyun.com/k8s-tutorial/test-k8s:v4-configmap）</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl run mongodb-client --rm --tty -i --restart=<span class="string">'Never'</span> --image docker.io/bitnami/mongodb:4.4.10-debian-10-r20 --<span class="built_in">command</span> -- bash</span><br><span class="line">mongo --host mongodb-0.mongodb -u mongouser -p mongopass</span><br><span class="line">show dbs</span><br><span class="line"><span class="comment"># 外部访问需要端口转发</span></span><br></pre></td></tr></table></figure><h1>八、Helm &amp; 命名空间</h1><h2 id="1、简介">1、简介</h2><blockquote><p>Helm官网：<a href="https://helm.sh/zh/" target="_blank" rel="noopener" title="https://helm.sh/zh/">https://helm.sh/zh/</a><br>包搜索：<a href="https://artifacthub.io/" target="_blank" rel="noopener" title="https://artifacthub.io/">https://artifacthub.io/</a></p></blockquote><p><code>Helm</code>类似 npm，pip，docker hub， 可以理解为是一个软件库，可以方便快速的为我们的集群安装一些第三方软件。使用 Helm 我们可以非常方便的就搭建出来 MongoDB / MySQL 副本集群，YAML 文件别人都给我们写好了，直接使用</p><h2 id="2、Helm安装">2、Helm安装</h2><blockquote><p>安装文档：<a href="https://helm.sh/zh/docs/intro/install/" target="_blank" rel="noopener" title="https://helm.sh/zh/docs/intro/install/">https://helm.sh/zh/docs/intro/install/</a></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 脚本安装，不过可能会失败</span></span><br><span class="line">curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash</span><br><span class="line"><span class="comment"># 手动进行安装</span></span><br><span class="line">wget https://get.helm.sh/helm-v3.10.1-linux-amd64.tar.gz</span><br><span class="line">tar -zxvf helm-v3.10.1-linux-amd64.tar.gz</span><br><span class="line">sudo mv linux-amd64/helm /usr/<span class="built_in">local</span>/bin/helm</span><br><span class="line">helm --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><h2 id="3、安装MongoDb">3、安装MongoDb</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">helm repo add bitnami https://charts.bitnami.com/bitnami</span><br><span class="line">helm install my-mongo bitnami/mongodb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定密码和架构</span></span><br><span class="line">helm install my-mongo bitnami/mongodb --<span class="built_in">set</span> architecture=<span class="string">"replicaset"</span>,auth.rootPassword=<span class="string">"mongopass"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除</span></span><br><span class="line">helm ls</span><br><span class="line">helm delete my-mongo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看密码</span></span><br><span class="line">kubectl get secret my-mongo-mongodb -o json</span><br><span class="line">kubectl get secret my-mongo-mongodb -o yaml &gt; secret.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 临时运行一个包含 mongo client 的 debian 系统</span></span><br><span class="line">kubectl run mongodb-client --rm --tty -i --restart=<span class="string">'Never'</span> --image docker.io/bitnami/mongodb:4.4.10-debian-10-r20 --<span class="built_in">command</span> -- bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进去 mongodb</span></span><br><span class="line">mongo --host <span class="string">"my-mongo-mongodb"</span> -u root -p mongopass</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以转发集群里的端口到宿主机访问 mongodb</span></span><br><span class="line">kubectl port-forward svc/my-mongo-mongodb 27017:27018</span><br></pre></td></tr></table></figure><h2 id="4、命名空间">4、命名空间</h2><blockquote><p>如果一个集群中部署了多个应用，所有应用都在一起，就不太好管理，也可以导致名字冲突等。我们可以使用 namespace 把应用划分到不同的命名空间，跟代码里的 namespace 是一个概念，只是为了划分空间</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建命名空间</span></span><br><span class="line">kubectl create namespace testapp</span><br><span class="line"><span class="comment"># 部署应用到指定的命名空间</span></span><br><span class="line">kubectl apply -f app.yml --namespace testapp</span><br><span class="line"><span class="comment"># 查询</span></span><br><span class="line">kubectl get pod --namespace kube-system</span><br><span class="line"><span class="comment"># 查询命名空间</span></span><br><span class="line">kubectl get ns</span><br></pre></td></tr></table></figure><p>可以用 <a href="https://github.com/ahmetb/kubectx" target="_blank" rel="noopener" title="kubens">kubens</a> 快速切换 namespace，首先进行下载安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/ahmetb/kubectx/releases/download/v0.9.4/kubens_v0.9.4_linux_x86_64.tar.gz</span><br><span class="line">tar -zxvf kubens_v0.9.4_linux_x86_64.tar.gz</span><br><span class="line">sudo mv kubens /usr/<span class="built_in">local</span>/bin/kubens</span><br><span class="line"><span class="comment"># 查看所有命名空间</span></span><br><span class="line">kubens</span><br><span class="line"><span class="comment"># 切换命名空间</span></span><br><span class="line">kubens kube-system</span><br><span class="line"><span class="comment"># 回到上个命名空间</span></span><br><span class="line">kubens -</span><br><span class="line"><span class="comment"># 切换集群</span></span><br><span class="line"><span class="comment"># kubectx minikube</span></span><br></pre></td></tr></table></figure><h1>九、Ingress</h1><h2 id="1、介绍">1、介绍</h2><blockquote><p>Ingress 为外部访问集群提供了一个 <strong>统一</strong> 入口，避免了对外暴露集群端口；功能类似 Nginx，可以根据域名、路径把请求转发到不同的 Service。可以配置 https</p></blockquote><p>**跟 LoadBalancer 有什么区别？**LoadBalancer 需要对外暴露端口，不安全；无法根据域名、路径转发流量到不同 Service，多个 Service 则需要开多个 LoadBalancer；功能单一，无法配置 https</p><p><img src="https://img-blog.csdnimg.cn/ed0a4b92be0645e2b9af94cbafa43273.png#pic_center" alt="在这里插入图片描述"></p><h2 id="2、使用">2、使用</h2><blockquote><p>文档：<a href="https://kubernetes.io/zh/docs/concepts/services-networking/ingress/" target="_blank" rel="noopener" title="Ingress">Ingress</a></p></blockquote><p>要使用 Ingress，需要一个负载均衡器 + Ingress Controller如果是裸机（bare metal) 搭建的集群，你需要自己安装一个负载均衡插件，可以安装 <a href="https://metallb.universe.tf/" target="_blank" rel="noopener" title="METALLB">METALLB</a>如果是云服务商，会自动给你配置，否则你的外部 IP 会是 &quot;pending&quot;状态，无法使用。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">simple-example</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ingressClassName:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">tools.fun</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/easydoc</span></span><br><span class="line">        <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">service:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">service1</span></span><br><span class="line">            <span class="attr">port:</span></span><br><span class="line">              <span class="attr">number:</span> <span class="number">4200</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/svnbucket</span></span><br><span class="line">        <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">service:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">service2</span></span><br><span class="line">            <span class="attr">port:</span></span><br><span class="line">              <span class="attr">number:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure><hr><p>参考文档：</p><p><a href="https://www.bilibili.com/video/BV1Tg411P7EB" target="_blank" rel="noopener" title="https://www.bilibili.com/video/BV1Tg411P7EB">https://www.bilibili.com/video/BV1Tg411P7EB</a></p><p><a href="https://k8s.easydoc.net/docs/dRiQjyTY/28366845/6GiNOzyZ/9EX8Cp45" target="_blank" rel="noopener" title="https://k8s.easydoc.net/docs/dRiQjyTY/28366845/6GiNOzyZ/9EX8Cp45">https://k8s.easydoc.net/docs/dRiQjyTY/28366845/6GiNOzyZ/9EX8Cp45</a></p><p><a href="https://kuboard.cn/install/install-k8s.html" target="_blank" rel="noopener" title="https://kuboard.cn/install/install-k8s.html">https://kuboard.cn/install/install-k8s.html</a></p>]]></content>
    
    
    <summary type="html">&lt;h1&gt;一、Kubernetes（K8S）简介&lt;/h1&gt;
&lt;h2 id=&quot;1、概念&quot;&gt;1、概念&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;官网：&lt;a href=&quot;https://kubernetes.io/zh-cn/docs/home/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; title=&quot;https://kubernetes.io/zh-cn/docs/home/&quot;&gt;https://kubernetes.io/zh-cn/docs/home/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1-1-Kubernetes-K8S-是什么&quot;&gt;1.1 Kubernetes (K8S) 是什么&lt;/h3&gt;
&lt;p&gt;它是一个为 &lt;strong&gt;容器化&lt;/strong&gt; 应用提供集群部署和管理的开源工具，由 Google 开发。K8S 是负责自动化运维管理多个跨机器 Docker 程序的集群&lt;/p&gt;
&lt;h3 id=&quot;1-2-核心特性&quot;&gt;1.2 核心特性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;服务发现与负载均衡：无需修改你的应用程序即可使用陌生的服务发现机制&lt;/li&gt;
&lt;li&gt;存储编排：自动挂载所选存储系统，包括本地存储&lt;/li&gt;
&lt;li&gt;Secret和配置管理：部署更新Secrets和应用程序的配置时不必重新构建容器镜像，且不必将软件堆栈配置中的秘密信息暴露出来&lt;/li&gt;
&lt;li&gt;批量执行：除了服务之外，Kubernetes还可以管理你的批处理和CI工作负载，在期望时替换掉失效的容器&lt;/li&gt;
&lt;li&gt;水平扩缩：使用一个简单的命令、一个UI或基于CPU使用情况自动对应用程序进行扩缩&lt;/li&gt;
&lt;li&gt;自动化上线和回滚：Kubernetes会分步骤地将针对应用或其配置的更改上线，同时监视应用程序运行状况以确保你不会同时终止所有实例&lt;/li&gt;
&lt;li&gt;自动装箱：根据资源需求和其他约束自动放置容器，同时避免影响可用性&lt;/li&gt;
&lt;li&gt;自我修复：重新启动失败的容器，在节点死亡时替换并重新调度容器，杀死不响应用户定义的健康检查的容器&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.shawn22.xyz/categories/Linux/"/>
    
    
    <category term="K8S" scheme="https://www.shawn22.xyz/tags/K8S/"/>
    
  </entry>
  
  <entry>
    <title>Java验证码</title>
    <link href="https://www.shawn22.xyz/posts/34dda368.html"/>
    <id>https://www.shawn22.xyz/posts/34dda368.html</id>
    <published>2023-03-05T16:13:36.000Z</published>
    <updated>2023-03-05T16:37:34.506Z</updated>
    
    <content type="html"><![CDATA[<h1>一、验证码概述</h1><blockquote><p><strong>验证码</strong>（CAPTCHA）是“Completely Automated Public Turing test to tell Computers and Humans Apart”（全自动区分计算机和人类的图灵测试）的缩写，是一种区分用户是计算机还是人的公共全自动程序</p></blockquote><p><strong>验证码的作用：</strong></p><ul><li><strong>防止刷票、论坛灌水、刷页</strong></li><li><strong>防止黑客恶意破解密码，盗取用户数据</strong></li></ul><p>验证码通常使用一些线条和一些不规则的字符组成，主要作用是为了防止一些黑客把密码数据化盗取。有效防止某个黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登录尝试，实际上使用验证码是现在很多网站通行的方式（比如招商银行的网上个人银行，百度社区），我们利用比较简易的方式实现了这个功能。虽然登录麻烦一点，但是对网友的密码安全来说这个功能还是很有必要，也很重要</p><ul><li><strong>防止恶意注册、登录</strong></li></ul><p>验证码一般是防止批量注册的，人眼看起来都费劲，何况是机器。几乎所有正规的论坛都要求注册时输入验证码，这是为了防止乱发垃圾广告的人用注册机来恶意注册</p><a id="more"></a><h1>二、Java原生验证码</h1><p>创建好需要保存的Bean类，保存好结果和过期时间等，最后直接把这个类放在session中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckCode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证码字符</span></span><br><span class="line">    <span class="keyword">private</span> String code;</span><br><span class="line">    <span class="comment">// 过期时间</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime expireTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> code 验证码字符</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expireTime 过期时间，单位秒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CheckCode</span><span class="params">(String code, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.expireTime = LocalDateTime.now().plusSeconds(expireTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CheckCode</span><span class="params">(String code)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 默认验证码 60 秒后过期</span></span><br><span class="line">        <span class="keyword">this</span>(code, <span class="number">60</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否过期</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isExpired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.expireTime.isBefore(LocalDateTime.now());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1、随机数字验证码">1、随机数字验证码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 验证码图片边框宽度</span></span><br><span class="line"><span class="keyword">int</span> WIDTH = <span class="number">120</span>;</span><br><span class="line"><span class="comment">// 验证码图片边框高度</span></span><br><span class="line"><span class="keyword">int</span> HEIGHT = <span class="number">45</span>;</span><br><span class="line"><span class="comment">// 验证码有效时间 60s</span></span><br><span class="line"><span class="keyword">int</span> expireIn = <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通验证码</span></span><br><span class="line"><span class="keyword">int</span> length = <span class="number">4</span>; <span class="comment">// 验证码位数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 普通验证码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createNumberImageCode</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置响应报头信息</span></span><br><span class="line">    response.setHeader(<span class="string">"Pragma"</span>, <span class="string">"No-cache"</span>);</span><br><span class="line">    response.setHeader(<span class="string">"Cache-Control"</span>, <span class="string">"no-cache"</span>);</span><br><span class="line">    response.setDateHeader(<span class="string">"Expires"</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 设置响应的MIME类型</span></span><br><span class="line">    response.setContentType(<span class="string">"image/jpeg"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    BufferedImage image = <span class="keyword">new</span> BufferedImage(WIDTH, HEIGHT, BufferedImage.TYPE_INT_RGB);</span><br><span class="line"></span><br><span class="line">    Graphics g = image.getGraphics();</span><br><span class="line"></span><br><span class="line">    Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    g.setColor(getRandColor(<span class="number">185</span>, <span class="number">250</span>));</span><br><span class="line">    g.fillRect(<span class="number">0</span>, <span class="number">0</span>, WIDTH, HEIGHT);</span><br><span class="line">    g.setFont(<span class="keyword">new</span> Font(<span class="string">"Times New Roman"</span>, Font.ITALIC, <span class="number">35</span>));</span><br><span class="line">    g.setColor(getRandColor(<span class="number">160</span>, <span class="number">200</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">155</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> x = random.nextInt(WIDTH);</span><br><span class="line">        <span class="keyword">int</span> y = random.nextInt(HEIGHT);</span><br><span class="line">        <span class="keyword">int</span> xl = random.nextInt(<span class="number">12</span>);</span><br><span class="line">        <span class="keyword">int</span> yl = random.nextInt(<span class="number">12</span>);</span><br><span class="line">        g.drawLine(x, y, x + xl, y + yl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    StringBuilder sRand = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line"></span><br><span class="line">        String rand = String.valueOf(random.nextInt(<span class="number">10</span>));</span><br><span class="line">        sRand.append(rand);</span><br><span class="line">        g.setColor(<span class="keyword">new</span> Color(<span class="number">20</span> + random.nextInt(<span class="number">110</span>), <span class="number">20</span> + random.nextInt(<span class="number">110</span>), <span class="number">20</span> + random.nextInt(<span class="number">110</span>)));</span><br><span class="line">        g.drawString(rand, <span class="number">25</span> * i + <span class="number">12</span>, <span class="number">32</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    g.dispose();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 放入session缓存，默认60s过期</span></span><br><span class="line">    CheckCode checkCode = <span class="keyword">new</span> CheckCode(sRand.toString(),expireIn);</span><br><span class="line">    HttpSession se = request.getSession();</span><br><span class="line">    se.setAttribute(Constants.KAPTCHA_SESSION_KEY, checkCode);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        OutputStream os = response.getOutputStream();</span><br><span class="line">        <span class="comment">// 输出图像到页面</span></span><br><span class="line">        ImageIO.write(image, <span class="string">"JPEG"</span>, os);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Color <span class="title">getRandColor</span><span class="params">(<span class="keyword">int</span> fc, <span class="keyword">int</span> bc)</span> </span>&#123;</span><br><span class="line">    Random random = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">if</span> (fc &gt; <span class="number">255</span>) &#123;</span><br><span class="line">        fc = <span class="number">255</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bc &gt; <span class="number">255</span>) &#123;</span><br><span class="line">        bc = <span class="number">255</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> r = fc + random.nextInt(bc - fc);</span><br><span class="line">    <span class="keyword">int</span> g = fc + random.nextInt(bc - fc);</span><br><span class="line">    <span class="keyword">int</span> b = fc + random.nextInt(bc - fc);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Color(r, g, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、随机数字和字母验证码">2、随机数字和字母验证码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 验证码图片边框宽度</span></span><br><span class="line"><span class="keyword">int</span> WIDTH = <span class="number">120</span>;</span><br><span class="line"><span class="comment">// 验证码图片边框高度</span></span><br><span class="line"><span class="keyword">int</span> HEIGHT = <span class="number">45</span>;</span><br><span class="line"><span class="comment">// 验证码有效时间 60s</span></span><br><span class="line"><span class="keyword">int</span> expireIn = <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通验证码</span></span><br><span class="line"><span class="keyword">int</span> length = <span class="number">4</span>; <span class="comment">// 验证码位数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createNumberAndLetterImageCode</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  HttpServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置响应报头信息</span></span><br><span class="line">    response.setHeader(<span class="string">"Pragma"</span>, <span class="string">"No-cache"</span>);</span><br><span class="line">    response.setHeader(<span class="string">"Cache-Control"</span>, <span class="string">"no-cache"</span>);</span><br><span class="line">    response.setDateHeader(<span class="string">"Expires"</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 设置响应的MIME类型</span></span><br><span class="line">    response.setContentType(<span class="string">"image/jpeg"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//画板</span></span><br><span class="line">    BufferedImage image = <span class="keyword">new</span> BufferedImage(WIDTH,HEIGHT,BufferedImage.TYPE_INT_RGB);</span><br><span class="line">    <span class="comment">//画笔</span></span><br><span class="line">    Graphics g = image.getGraphics();</span><br><span class="line">    <span class="comment">//字体</span></span><br><span class="line">    Font font = <span class="keyword">new</span> Font(<span class="string">"微软雅黑"</span>, Font.BOLD,<span class="number">35</span>);</span><br><span class="line">    <span class="comment">//设置字体</span></span><br><span class="line">    g.setFont(font);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//引入背景图片</span></span><br><span class="line">    g.fillRect(<span class="number">0</span>, <span class="number">0</span>, WIDTH, HEIGHT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//随机数</span></span><br><span class="line">    Random random = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="comment">//要随机的字符串</span></span><br><span class="line">    String template = <span class="string">"123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"</span>;</span><br><span class="line">    StringBuilder s = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">char</span> tempNum;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">        <span class="comment">//获取随机出的字符</span></span><br><span class="line">        <span class="keyword">int</span> tempIndex = random.nextInt(template.length()-<span class="number">1</span>);</span><br><span class="line">        tempNum = template.charAt(tempIndex);</span><br><span class="line">        <span class="comment">//拼成字符串</span></span><br><span class="line">        s.append(tempNum);</span><br><span class="line">        <span class="comment">//设置颜色</span></span><br><span class="line">        Color color = <span class="keyword">new</span> Color(<span class="number">20</span>+random.nextInt(<span class="number">110</span>),<span class="number">20</span>+random.nextInt(<span class="number">110</span>),random.nextInt(<span class="number">110</span>));</span><br><span class="line">        g.setColor(color);</span><br><span class="line">        <span class="comment">//字母写入图片</span></span><br><span class="line">        g.drawString(String.valueOf(tempNum),<span class="number">25</span> * i + <span class="number">12</span>, <span class="number">32</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 放入session缓存，默认60s过期</span></span><br><span class="line">    CheckCode checkCode = <span class="keyword">new</span> CheckCode(sRand.toString(),expireIn);</span><br><span class="line">    HttpSession se = request.getSession();</span><br><span class="line">    se.setAttribute(Constants.KAPTCHA_SESSION_KEY, checkCode);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取流发送给前台</span></span><br><span class="line">    ServletOutputStream ots = response.getOutputStream();</span><br><span class="line">    ImageIO.write(image,<span class="string">"JPEG"</span>,ots);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、运算验证码">3、运算验证码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 公共部分</span></span><br><span class="line"><span class="comment">// 验证码图片边框宽度</span></span><br><span class="line"><span class="keyword">int</span> WIDTH = <span class="number">120</span>;</span><br><span class="line"><span class="comment">// 验证码图片边框高度</span></span><br><span class="line"><span class="keyword">int</span> HEIGHT = <span class="number">45</span>;</span><br><span class="line"><span class="comment">// 验证码有效时间 60s</span></span><br><span class="line"><span class="keyword">int</span> expireIn = <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运算验证码</span></span><br><span class="line"><span class="comment">// 验证码字体高度</span></span><br><span class="line"><span class="keyword">int</span> FONT_HEIGHT = HEIGHT - <span class="number">12</span>;</span><br><span class="line"><span class="comment">// 验证码干扰线条数</span></span><br><span class="line"><span class="keyword">int</span> INTERFERENCE_LINE = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成运算验证码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createSpecialImageCode</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                         HttpServletResponse response)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置响应报头信息</span></span><br><span class="line">    response.setHeader(<span class="string">"Pragma"</span>, <span class="string">"No-cache"</span>);</span><br><span class="line">    response.setHeader(<span class="string">"Cache-Control"</span>, <span class="string">"no-cache"</span>);</span><br><span class="line">    response.setDateHeader(<span class="string">"Expires"</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 设置响应的MIME类型</span></span><br><span class="line">    response.setContentType(<span class="string">"image/jpeg"</span>);</span><br><span class="line"></span><br><span class="line">    BufferedImage image = <span class="keyword">new</span> BufferedImage(WIDTH, HEIGHT,</span><br><span class="line">            BufferedImage.TYPE_INT_RGB);</span><br><span class="line">    Font mFont = <span class="keyword">new</span> Font(<span class="string">"Arial"</span>, Font.PLAIN, <span class="number">18</span>);</span><br><span class="line">    Graphics g = image.getGraphics();</span><br><span class="line">    Random rd = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="comment">// 设置背景颜色</span></span><br><span class="line">    g.setColor(<span class="keyword">new</span> Color(rd.nextInt(<span class="number">55</span>) + <span class="number">200</span>, rd.nextInt(<span class="number">55</span>) + <span class="number">200</span>, rd</span><br><span class="line">            .nextInt(<span class="number">55</span>) + <span class="number">200</span>));</span><br><span class="line">    g.fillRect(<span class="number">0</span>, <span class="number">0</span>, WIDTH, HEIGHT);</span><br><span class="line">    <span class="comment">// 设置字体</span></span><br><span class="line">    g.setFont(mFont);</span><br><span class="line">    <span class="comment">// 画边框</span></span><br><span class="line">    g.setColor(Color.black);</span><br><span class="line">    g.drawRect(<span class="number">0</span>, <span class="number">0</span>, WIDTH - <span class="number">1</span>, HEIGHT - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 验证码字符串</span></span><br><span class="line">    String text = getText();</span><br><span class="line">    <span class="comment">// 运算表达式</span></span><br><span class="line">    String operationExpression = text.substring(<span class="number">0</span>, text.lastIndexOf(<span class="string">"@"</span>) - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 计算结果</span></span><br><span class="line">    String result = text.substring(text.lastIndexOf(<span class="string">"@"</span>) + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 放入session缓存，默认60s过期</span></span><br><span class="line">    CheckCode checkCode = <span class="keyword">new</span> CheckCode(result,expireIn);</span><br><span class="line">    HttpSession se = request.getSession();</span><br><span class="line"></span><br><span class="line">    se.setAttribute(Constants.KAPTCHA_SESSION_KEY, checkCode);</span><br><span class="line"></span><br><span class="line">    g.setColor(<span class="keyword">new</span> Color(rd.nextInt(<span class="number">200</span>), rd.nextInt(<span class="number">200</span>), rd</span><br><span class="line">            .nextInt(<span class="number">200</span>)));</span><br><span class="line">    <span class="comment">// 根据画笔颜色绘制字符</span></span><br><span class="line">    g.drawString(operationExpression, <span class="number">5</span>, FONT_HEIGHT);</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> gg = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 绘制干扰线</span></span><br><span class="line">    <span class="keyword">int</span> x1, y1, x2, y2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; INTERFERENCE_LINE; i++) &#123;</span><br><span class="line">        <span class="comment">// 随机生成rgb颜色值，并设置画笔颜色</span></span><br><span class="line">        r = rd.nextInt(<span class="number">255</span>);</span><br><span class="line">        gg = rd.nextInt(<span class="number">255</span>);</span><br><span class="line">        b = rd.nextInt(<span class="number">255</span>);</span><br><span class="line">        g.setColor(<span class="keyword">new</span> Color(r, gg, b));</span><br><span class="line">        x1 = rd.nextInt(WIDTH);</span><br><span class="line">        y1 = rd.nextInt(HEIGHT);</span><br><span class="line">        x2 = rd.nextInt(WIDTH);</span><br><span class="line">        y2 = rd.nextInt(HEIGHT);</span><br><span class="line">        <span class="comment">// 绘制线条</span></span><br><span class="line">        g.drawLine(x1, y1, x2, y2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放图形资源</span></span><br><span class="line">    g.dispose();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        OutputStream os = response.getOutputStream();</span><br><span class="line">        <span class="comment">// 输出图像到页面</span></span><br><span class="line">        ImageIO.write(image, <span class="string">"JPEG"</span>, os);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取运算验证码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getText</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Random random = <span class="keyword">new</span> Random(System.currentTimeMillis());</span><br><span class="line">    StringBuilder result = <span class="keyword">new</span> StringBuilder(); <span class="comment">// 运算验证码结果</span></span><br><span class="line">    <span class="keyword">int</span> x = random.nextInt(<span class="number">51</span>);</span><br><span class="line">    <span class="keyword">int</span> y = random.nextInt(<span class="number">51</span>);</span><br><span class="line">    <span class="keyword">int</span> operationalRules = random.nextInt(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">switch</span> (operationalRules) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            result = add(x, y);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            result = subtract(x, y);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            result = multiply(x, y);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            result = divide(x, y);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            result = add(x, y);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result.toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 加法运算</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span>  StringBuilder <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    StringBuilder result = <span class="keyword">new</span> StringBuilder(); <span class="comment">// 运算验证码结果</span></span><br><span class="line">    result.append(x);</span><br><span class="line">    result.append(<span class="string">" + "</span>);</span><br><span class="line">    result.append(y);</span><br><span class="line">    result.append(<span class="string">" = ?@"</span>);</span><br><span class="line">    result.append(x + y);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 减法运算</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span>  StringBuilder <span class="title">subtract</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    StringBuilder result = <span class="keyword">new</span> StringBuilder(); <span class="comment">// 运算验证码结果</span></span><br><span class="line">    <span class="keyword">int</span> max = Math.max(x, y);</span><br><span class="line">    <span class="keyword">int</span> min = Math.min(x, y);</span><br><span class="line">    result.append(max);</span><br><span class="line">    result.append(<span class="string">" - "</span>);</span><br><span class="line">    result.append(min);</span><br><span class="line">    result.append(<span class="string">" = ?@"</span>);</span><br><span class="line">    result.append(max - min);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 乘法运算</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span>  StringBuilder <span class="title">multiply</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    StringBuilder result = <span class="keyword">new</span> StringBuilder(); <span class="comment">// 运算验证码结果</span></span><br><span class="line">    <span class="keyword">int</span> value = x * y;</span><br><span class="line">    result.append(x);</span><br><span class="line">    result.append(value &gt; <span class="number">100</span> ? <span class="string">" + "</span> : <span class="string">" * "</span>);</span><br><span class="line">    result.append(y);</span><br><span class="line">    result.append(<span class="string">" = ?@"</span>);</span><br><span class="line">    result.append(value &gt; <span class="number">100</span> ? x + y : x * y);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 除法运算</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span>  StringBuilder <span class="title">divide</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    StringBuilder result = <span class="keyword">new</span> StringBuilder(); <span class="comment">// 运算验证码结果</span></span><br><span class="line">    <span class="keyword">int</span> max = Math.max(x, y);</span><br><span class="line">    <span class="keyword">int</span> min = Math.min(x, y);</span><br><span class="line">    <span class="keyword">if</span> (min == <span class="number">0</span>) &#123;</span><br><span class="line">        multiply(max, min);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (max % min == <span class="number">0</span>) &#123;</span><br><span class="line">        result.append(max);</span><br><span class="line">        result.append(<span class="string">" / "</span>);</span><br><span class="line">        result.append(min);</span><br><span class="line">        result.append(<span class="string">" = ?@"</span>);</span><br><span class="line">        result.append(max / min);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result.append(max);</span><br><span class="line">        result.append(<span class="string">" % "</span>);</span><br><span class="line">        result.append(min);</span><br><span class="line">        result.append(<span class="string">" = ?@"</span>);</span><br><span class="line">        result.append(max % min);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>三、引入三方验证码</h1><blockquote><p>三方验证码有很多，这里我就只举例一个</p></blockquote><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--验证码--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.whvcse<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>easy-captcha<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>编写代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CodeCheck</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置请求头输入为图片类型</span></span><br><span class="line">    response.setContentType(<span class="string">"image/jpg"</span>);</span><br><span class="line">    <span class="comment">// 设置不用缓存，防止验证码不刷新</span></span><br><span class="line">    response.setHeader(<span class="string">"Pargam"</span>,<span class="string">"No-cache"</span>);</span><br><span class="line">    response.setHeader(<span class="string">"Cache-Control"</span>,<span class="string">"no-cache"</span>);</span><br><span class="line">    <span class="comment">// 设置过期时间，永不失效</span></span><br><span class="line">    response.setDateHeader(<span class="string">"Expires"</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 算术类型（长，宽，几个数的运算）</span></span><br><span class="line">    ArithmeticCaptcha captcha = <span class="keyword">new</span> ArithmeticCaptcha(<span class="number">130</span>, <span class="number">48</span>);</span><br><span class="line">    captcha.setLen(<span class="number">3</span>);  <span class="comment">// 几位数运算，默认是两位</span></span><br><span class="line">    System.out.println(captcha.getArithmeticString()); <span class="comment">// 获取运算公式 5x0+5=?</span></span><br><span class="line">    System.out.println(captcha.text()); <span class="comment">// 获取验证码结果</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 图片英语字母数字类型</span></span><br><span class="line">    <span class="comment">//SpecCaptcha captcha = new SpecCaptcha(130, 48);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 英语字母数字gif类型的</span></span><br><span class="line">    <span class="comment">//GifCaptcha captcha = new GifCaptcha(130, 48,4);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中文类型的</span></span><br><span class="line">    <span class="comment">//ChineseCaptcha captcha = new ChineseCaptcha(130, 48,3);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中文gif类型</span></span><br><span class="line">    <span class="comment">//ChineseGifCaptcha captcha = new ChineseGifCaptcha(130, 48,4);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出验证码</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        captcha.out(response.getOutputStream());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1&gt;一、验证码概述&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;验证码&lt;/strong&gt;（CAPTCHA）是“Completely Automated Public Turing test to tell Computers and Humans Apart”（全自动区分计算机和人类的图灵测试）的缩写，是一种区分用户是计算机还是人的公共全自动程序&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;验证码的作用：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;防止刷票、论坛灌水、刷页&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;防止黑客恶意破解密码，盗取用户数据&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;验证码通常使用一些线条和一些不规则的字符组成，主要作用是为了防止一些黑客把密码数据化盗取。有效防止某个黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登录尝试，实际上使用验证码是现在很多网站通行的方式（比如招商银行的网上个人银行，百度社区），我们利用比较简易的方式实现了这个功能。虽然登录麻烦一点，但是对网友的密码安全来说这个功能还是很有必要，也很重要&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;防止恶意注册、登录&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;验证码一般是防止批量注册的，人眼看起来都费劲，何况是机器。几乎所有正规的论坛都要求注册时输入验证码，这是为了防止乱发垃圾广告的人用注册机来恶意注册&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://www.shawn22.xyz/categories/Java/"/>
    
    
    <category term="Java基础" scheme="https://www.shawn22.xyz/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch7学习笔记(尚硅谷)</title>
    <link href="https://www.shawn22.xyz/posts/83d7c18a.html"/>
    <id>https://www.shawn22.xyz/posts/83d7c18a.html</id>
    <published>2023-03-05T16:13:06.000Z</published>
    <updated>2023-03-05T16:38:27.673Z</updated>
    
    <content type="html"><![CDATA[<h1>一、ElasticSearch概述</h1><h2 id="1、ElasticSearch是什么">1、ElasticSearch是什么</h2><p>Elasticsearch是一个<strong>实时的分布式搜索和分析引擎</strong>。它可以帮助你用前所未有的速度去处理大规模数据。它可以用于<strong>全文搜索，结构化搜索以及分析</strong>，当然你也可以将这三者进行组合。</p><p>Elasticsearch是一个建<strong>立在全文搜索引擎 Apache Lucene™ 基础</strong>上的搜索引擎，可以说Lucene是当今最先进，最高效的全功能开源搜索引擎框架。但是Lucene只是一个框架，要充分利用它的功能，需要使用JAVA，并且在程序中集成Lucene。当然Elasticsearch并不仅仅是Lucene这么简单，它不但包括了全文搜索功能，还可以进行以下工作:</p><ul><li>分布式实时文件存储，并将每一个字段都编入索引，使其可以被搜索。</li><li>实时分析的分布式搜索引擎。</li><li>可以扩展到上百台服务器，处理PB级别的结构化或非结构化数据。</li></ul><a id="more"></a><h2 id="2、全文搜索引擎">2、全文搜索引擎</h2><p>Google，百度类的网站搜索，它们都是根据网页中的关键字生成索引，我们在搜索的时候输入关键字，它们会将该关键字即索引匹配到的所有网页返回；还有常见的项目中应用日志的搜索等等。对于这些非结构化的数据文本，关系型数据库搜索不是能很好的支持。</p><p>一般传统数据库，全文检索都实现的很鸡肋，因为一般也没人用数据库存文本字段。进行全文检索需要扫描整个表，如果数据量大的话即使对 SQL 的语法优化，也收效甚微。建立了索引，但是维护起来也很麻烦，对于 insert 和 update 操作都会重新构建索引。</p><p>基于以上原因可以分析得出，在一些生产环境中，使用常规的搜索方式，性能是非常差的：</p><ul><li>搜索的数据对象是大量的非结构化的文本数据</li><li>文件记录量达到数十万或数百万个甚至更多</li><li>支持大量基于交互式文本的查询</li><li>需求非常灵活的全文搜索查询</li><li>对高度相关的搜索结果的有特殊需求，但是没有可用的关系数据库可以满足</li><li>对不同记录类型、非文本数据操作或安全事务处理的需求相对较少的情况。为了解决结构化数据搜索和非结构化数据搜索性能问题，我们就需要专业，健壮，强大的全文搜索引擎 </li></ul><p>这里说到的全文搜索引擎指的是目前广泛应用的主流搜索引擎。它的工作原理是<strong>计算机索引程序通过扫描文章中的每一个词，对每一个词建立一个索引，指明该词在文章中出现的次数和位置，当用户查询时，检索程序就根据事先建立的索引进行查找，并将查找的结果反馈给用户的检索方式</strong>这个过程类似于通过字典中的检索字表查字的过程</p><h2 id="3、ElasticSearch-和-Solr">3、ElasticSearch 和 Solr</h2><h3 id="3-1-概述">3.1 概述</h3><p><strong>Lucene</strong>是apache软件基金会Jakarta项目组的一个子项目，提供了一个简单却强大的应用程序式接口，能够做全文索引和搜寻。在Java开发环境里Lucene是一个成熟的免费开源工具。就其本身而言，Lucene是当前提供全文搜索功能类库的核心工具包，而真正使用它还需要一个完善服务框架搭建起来进行应用。</p><p>目前市面上流行的搜索引擎软件，主流的就两款：<strong>Elasticsearch</strong>和<strong>Solr</strong>,这两款都是基于Lucene搭建的，可以独立部署启动的搜索引擎服务软件。由于内核相同，所以两者除了服务器安装、部署、管理、集群外，对于数据的操作 修改、添加、保存、查询等等都十分相似。</p><p>在使用过程中，一般都会将Elastics search和Solr这两个软件对比，然后进行选型。这两个搜索引擎都是流行的，先进的的开源搜索引擎，它们都是围绕核心底层搜索库-Lucene构建的－但它们又是不同的。像所有东西并样，每个都有其优点和缺点：</p><ul><li>当单纯的对已有数据进行搜索时，Solr更快</li><li>当实时建立索引时, Solr会产生io阻塞，查询性能较差, Elasticsearch具有明显的优势</li><li>随着数据量的增加，Solr的搜索效率会变得更低，而Elasticsearch却没有明显的变化</li></ul><p>综上所述，Solr的架构不适合实时搜索的应用</p><h3 id="3-2-比较总结">3.2 比较总结</h3><ul><li>Solr 利用 Zookeeper 进行分布式管理，而 Elasticsearch 自身带有分布式协调管理功能</li><li>Solr 支持更多格式的数据，而 Elasticsearch 仅支持json文件格式</li><li>Solr 官方提供的功能更多，而 Elasticsearch 本身更注重于核心功能，高级功能多有第三方插件提供</li><li>Solr 在传统的搜索应用中表现好于 Elasticsearch，但在处理实时搜索应用时效率明显低于 Elasticsearch</li></ul><p>Solr 是传统搜索应用的有力解决方案，但 Elasticsearch 更适用于新兴的实时搜索应用。</p><p><strong>对于两者的使用</strong></p><ul><li>由于易于使用， Elasticsearch 在新开发者中更受欢迎。一个下载和一个命令就可以启动一切</li><li>如果除了搜索文本之外还需要它来处理分析查询， Elasticsearch 是更好的选择</li><li>如果需要分布式索引，则需要选择 Elasticsearch 。对于需要良好可伸缩性和以及性能分布式环境， Elasticsearch 是更好的选择</li><li>lasticsearch 在开源日志管理用例中占据主导地位，许多组织在 Elasticsearch 中索引它们的日志以使其可搜索</li><li>如果你喜欢监控和指标，那么请使用Elastics search，因为相对于Solr， Elasticsearch 暴露了更多的关键指标</li></ul><h1>二、Elasticsearch入门</h1><h2 id="1、Elasticsearch安装">1、Elasticsearch安装</h2><h3 id="1-1-下载使用">1.1 下载使用</h3><blockquote><p>官网地址：<a href="https://www.elastic.co/cn/" target="_blank" rel="noopener" title="https://www.elastic.co/cn/">https://www.elastic.co/cn/</a><br>Elasticsearch 7.8.0下载界面：<a href="https://www.elastic.co/cn/downloads/past-releases/elasticsearch-7-8-0" target="_blank" rel="noopener" title="https://www.elastic.co/cn/downloads/past-releases/elasticsearch-7-8-0">https://www.elastic.co/cn/downloads/past-releases/elasticsearch-7-8-0</a></p></blockquote><p>Windows 版的 Elasticsearch 压缩包，解压即安装完毕，解压后的 Elasticsearch 的目录结构如下 ：</p><table><thead><tr><th><strong>目录</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>bin</td><td>可执行脚本目录</td></tr><tr><td>config</td><td>配置目录</td></tr><tr><td>jdk</td><td>内置 JDK 目录</td></tr><tr><td>lib</td><td>类库</td></tr><tr><td>logs</td><td>日志目录</td></tr><tr><td>modules</td><td>模块目录</td></tr><tr><td>plugins</td><td>插件目录</td></tr></tbody></table><p>解压后，进入 bin 文件目录，点击 elasticsearch.bat 文件启动 ES 服务 。注意： 9300 端口为 Elasticsearch 集群间组件的通信端口， 9200 端口为浏览器访问的 http协议 RESTful 端口。打开浏览器，输入地址： <a href="http://localhost:9200" target="_blank" rel="noopener" title="http://localhost:9200">http://localhost:9200</a>，测试返回结果</p><p>因为ES使用的是RESTful &amp; JSON传输数据，所以需要一个发送http请求的客户端，推荐Postman或者Apifox</p><h3 id="1-2-数据格式">1.2 数据格式</h3><p>Elassitiesearch 是面向文档型数据库，一条数据在这里就是一个文档。为了方便大家理解，我们将 Elastlesearch 里存储文档数据和关系型数据库MySQL存储数据的概念进行一个类比</p><p><img src="https://img-blog.csdnimg.cn/883a3574848c414ea692a447a609057d.png#pic_center" alt="在这里插入图片描述"></p><p>ES 里的 Index 可以看做一个库，而 Types 相当于表， Documents 则相当于表的行。这里 Types 的概念已经被逐渐弱化， Elasticsearch 6.X 中，一个 index 下已经只能包含一个type， Elasticsearch 7.X 中, Type 的概念已经被删除了。</p><p>ES还包括了倒排索引，这个极大方便了数据的搜索</p><p>正排索引（传统）</p><table><thead><tr><th><strong>id</strong></th><th><strong>content</strong></th></tr></thead><tbody><tr><td>1001</td><td>my name is zhang san</td></tr><tr><td>1002</td><td>my name is li si</td></tr></tbody></table><p>倒排索引</p><table><thead><tr><th><strong>keyword</strong></th><th><strong>id</strong></th></tr></thead><tbody><tr><td>name</td><td>1001, 1002</td></tr><tr><td>zhang</td><td>1001</td></tr></tbody></table><h2 id="2、索引操作">2、索引操作</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对比关系型数据块，创建索引就等同于创建数据库，需要发送put请求</span></span><br><span class="line">http://127.0.0.1:9200/shopping</span><br><span class="line"><span class="comment"># 查看单个索引信息，发送get</span></span><br><span class="line">http://127.0.0.1:9200/shopping</span><br><span class="line"><span class="comment"># 查看所有索引信息,发送get</span></span><br><span class="line">http://127.0.0.1:9200/_cat/indices?v</span><br><span class="line"><span class="comment"># 删除索引信息,向 ES 服务器发 DELETE 请求</span></span><br><span class="line">http://127.0.0.1:9200/shopping</span><br></pre></td></tr></table></figure><h2 id="3、文档操作（了解）">3、文档操作（了解）</h2><h3 id="3-1-创建文档">3.1 创建文档</h3><p>假设索引已经创建好了，接下来我们来创建文档，并添加数据。这里的文档可以类比为关系型数据库中的表数据，添加的数据格式为 JSON 格式，向 ES 服务器发 **POST **请求 ： <code>http://127.0.0.1:9200/shopping/_doc</code>（注意，此处发送请求的方式必须为 POST，不能是 PUT，否则会发生错误）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"title"</span>:<span class="string">"小米手机"</span>,</span><br><span class="line">    <span class="string">"category"</span>:<span class="string">"小米"</span>,</span><br><span class="line">    <span class="string">"images"</span>:<span class="string">"http://www.xxx.com/xm.jpg"</span>,</span><br><span class="line">    <span class="string">"price"</span>:3999.00</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的数据创建后，由于没有指定数据唯一性标识（ID），默认情况下， ES 服务器会随机生成一个。如果想要自定义唯一性标识，需要在创建时指定： <code>http://127.0.0.1:9200/shopping/_doc/1001</code></p><p>此处需要注意：如果增加数据时明确数据主键，那么请求方式也可以为 <strong>PUT</strong>，其中路径**_doc**可以改为_create也没有问题(符合幂等性)</p><h3 id="3-2-文档查询">3.2 文档查询</h3><ul><li><strong>根据主键查询</strong>：向 ES 服务器发 GET请求 ： <code>http://127.0.0.1:9200/shopping/_doc/1001</code></li><li><strong>查询所有信息</strong>：向 ES 服务器发 GET请求 ： <code>http://127.0.0.1:9200/shopping/_search</code></li></ul><h3 id="3-3-文档修改">3.3 文档修改</h3><ul><li><p><strong>全量修改</strong>：和新增文档一样，输入相同的 URL 地址请求，如果请求体变化，会将原有的数据内容覆盖，向 ES 服务器发 PUT请求 ： <code>http://127.0.0.1:9200/shopping/_doc/1</code>。提示：全量更新，每次结果都是相同的，所以是幂等性的，使用PUT</p></li><li><p><strong>局部修改</strong>：向 ES 服务器发 POST请求 ： <code>http://127.0.0.1:9200/shopping/_update/1001</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"doc"</span>: &#123;</span><br><span class="line">    <span class="attr">"title"</span>:<span class="string">"华为手机"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-4-文档删除">3.4 文档删除</h3><p>向 ES 服务器发 DELETE 请求 ： <code>http://127.0.0.1:9200/shopping/_doc/1001</code></p><h3 id="3-5-文档条件查询-分页查询-查询排序">3.5 文档条件查询 &amp; 分页查询 &amp; 查询排序</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找category为小米的文档，向 ES 发GET请求 ： http://127.0.0.1:9200/shopping/_search?q=category:小米</span></span><br><span class="line"><span class="comment"># 上述不常用，一般使用带JSON请求体请求进行查询</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 向 ES 服务器发 GET请求 ： http://127.0.0.1:9200/shopping/_search，附带JSON体如下</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"query"</span>:&#123;</span><br><span class="line">    <span class="string">"match"</span>:&#123;</span><br><span class="line">      <span class="string">"category"</span>:<span class="string">"小米"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 带请求体方式的查找所有内容</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"query"</span>:&#123;</span><br><span class="line">    <span class="string">"match_all"</span>:&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询指定字段</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"query"</span>:&#123;</span><br><span class="line">    <span class="string">"match_all"</span>:&#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"_source"</span>:[<span class="string">"title"</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分页查询，提示：from=(n-1)*size，size:一页的数量</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"query"</span>:&#123;</span><br><span class="line">    <span class="string">"match_all"</span>:&#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"from"</span>:0,</span><br><span class="line">  <span class="string">"size"</span>:2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询排序</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"query"</span>:&#123;</span><br><span class="line">    <span class="string">"match_all"</span>:&#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"sort"</span>:&#123;</span><br><span class="line">    <span class="string">"price"</span>:&#123;</span><br><span class="line">      <span class="string">"order"</span>:<span class="string">"desc"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-6-文档多条件查询-范围查询">3.6 文档多条件查询 &amp; 范围查询</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 向 ES 服务器发 GET请求 ： http://127.0.0.1:9200/shopping/_search，附带JSON体</span></span><br><span class="line"><span class="comment"># bool表示条件的意思，must表示都要满足</span></span><br><span class="line"><span class="comment"># 多条件查询</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"query"</span>:&#123;</span><br><span class="line">    <span class="string">"bool"</span>:&#123;</span><br><span class="line">      <span class="string">"must"</span>:[&#123;</span><br><span class="line">        <span class="string">"match"</span>:&#123;</span><br><span class="line">          <span class="string">"category"</span>:<span class="string">"小米"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,&#123;</span><br><span class="line">        <span class="string">"match"</span>:&#123;</span><br><span class="line">          <span class="string">"price"</span>:3999.00</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 或者的条件查询(should)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"query"</span>:&#123;</span><br><span class="line">    <span class="string">"bool"</span>:&#123;</span><br><span class="line">      <span class="string">"should"</span>:[&#123;</span><br><span class="line">        <span class="string">"match"</span>:&#123;</span><br><span class="line">          <span class="string">"category"</span>:<span class="string">"小米"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,&#123;</span><br><span class="line">        <span class="string">"match"</span>:&#123;</span><br><span class="line">          <span class="string">"category"</span>:<span class="string">"华为"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加上价格大于5000的条件</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"query"</span>:&#123;</span><br><span class="line">    <span class="string">"bool"</span>:&#123;</span><br><span class="line">      <span class="string">"must"</span>:[&#123;</span><br><span class="line">        <span class="string">"match"</span>:&#123;</span><br><span class="line">          <span class="string">"category"</span>:<span class="string">"小米"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,&#123;</span><br><span class="line">        <span class="string">"match"</span>:&#123;</span><br><span class="line">          <span class="string">"price"</span>:3999.00</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;],</span><br><span class="line">        <span class="string">"filter"</span>:&#123;</span><br><span class="line">            <span class="string">"range"</span>:&#123;</span><br><span class="line">                <span class="string">"price"</span>:&#123;</span><br><span class="line">                    <span class="string">"gt"</span>:5000</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-7-文档全文检索-完全匹配-高亮查询">3.7 文档全文检索 &amp; 完全匹配 &amp; 高亮查询</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 向 ES 服务器发 GET请求 ： http://127.0.0.1:9200/shopping/_search，附带JSON体</span></span><br><span class="line"><span class="comment"># 全文检索,这功能像搜索引擎那样，如查询品牌输入"小华",返回结果品牌带有小、华两个字的数据</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"query"</span>:&#123;</span><br><span class="line">    <span class="string">"match"</span>:&#123;</span><br><span class="line">      <span class="string">"category"</span> : <span class="string">"小华"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 完全匹配</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"query"</span>:&#123;</span><br><span class="line">    <span class="string">"match_phrase"</span>:&#123;</span><br><span class="line">      <span class="string">"category"</span> : <span class="string">"为"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 高亮查询</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"query"</span>:&#123;</span><br><span class="line">    <span class="string">"match_phrase"</span>:&#123;</span><br><span class="line">      <span class="string">"category"</span> : <span class="string">"为"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">    <span class="string">"highlight"</span>:&#123;</span><br><span class="line">        <span class="string">"fields"</span>:&#123;</span><br><span class="line">            <span class="string">"category"</span>:&#123;&#125;//&lt;----高亮category 字段</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-8-文档聚合查询">3.8 文档聚合查询</h3><p>聚合允许使用者对 es 文档进行统计分析，类似与关系型数据库中的 group by，当然还有很多其他的聚合，例如取最大值max、平均值avg等等</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按price字段进行分组</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"aggs"</span>:&#123;//聚合操作</span><br><span class="line">    <span class="string">"price_group"</span>:&#123;//名称，随意起名</span><br><span class="line">      <span class="string">"terms"</span>:&#123;//分组</span><br><span class="line">        <span class="string">"field"</span>:<span class="string">"price"</span>//分组字段</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 上面返回结果会附带原始数据的。若不想要不附带原始数据的结果</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"aggs"</span>:&#123;</span><br><span class="line">    <span class="string">"price_group"</span>:&#123;</span><br><span class="line">      <span class="string">"terms"</span>:&#123;//分组</span><br><span class="line">        <span class="string">"field"</span>:<span class="string">"price"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">    <span class="string">"size"</span>:0//不要附带原始数据</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对所有手机价格求平均值</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"aggs"</span>:&#123;</span><br><span class="line">    <span class="string">"price_avg"</span>:&#123;//名称，随意起名</span><br><span class="line">      <span class="string">"avg"</span>:&#123;//求平均</span><br><span class="line">        <span class="string">"field"</span>:<span class="string">"price"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">    <span class="string">"size"</span>:0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-9-文档映射关系">3.9 文档映射关系</h3><p>在之前的查询有的字段可以分词查询，有的不可以，我们该如何界定和控制呢？创建数据库表需要设置字段名称，类型，长度，约束等；索引库也一样，需要知道这个类型下有哪些字段，每个字段有哪些约束信息，这就叫做映射(mapping)</p><p>先创建一个索引：<code>PUT http://127.0.0.1:9200/user</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建映射</span></span><br><span class="line"><span class="comment"># 向 ES 服务器发 PUT请求 ： http://127.0.0.1:9200/user/_mapping，附带JSON体</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"properties"</span>: &#123;</span><br><span class="line">        <span class="string">"name"</span>:&#123;</span><br><span class="line">          <span class="string">"type"</span>: <span class="string">"text"</span>,//可以分词</span><br><span class="line">          <span class="string">"index"</span>: <span class="literal">true</span> //可以索引查询</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"sex"</span>:&#123;</span><br><span class="line">          <span class="string">"type"</span>: <span class="string">"keyword"</span>,//关键字不可以分词</span><br><span class="line">          <span class="string">"index"</span>: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"tel"</span>:&#123;</span><br><span class="line">          <span class="string">"type"</span>: <span class="string">"keyword"</span>,</span><br><span class="line">          <span class="string">"index"</span>: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 查询映射</span></span><br><span class="line">http://127.0.0.1:9200/user/_mapping</span><br><span class="line"><span class="comment"># 增加数据</span></span><br><span class="line">http://127.0.0.1:9200/user/_create/1001</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>:<span class="string">"小米"</span>,</span><br><span class="line">  <span class="string">"sex"</span>:<span class="string">"男的"</span>,</span><br><span class="line">  <span class="string">"tel"</span>:<span class="string">"1111"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找name含有”小“数据,http://127.0.0.1:9200/user/_search</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"query"</span>:&#123;</span><br><span class="line">    <span class="string">"match"</span>:&#123;</span><br><span class="line">      <span class="string">"name"</span>:<span class="string">"小"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果验证，查询name为&quot;小&quot;的时候可以查出来，查询sex为&quot;男&quot;查不出来数据，这是因为name type 设置为&quot;text&quot;可以分词查询，sex没有，电话index设置为false</p><h2 id="4、JavaAPI">4、JavaAPI</h2><h3 id="4-1-环境准备">4.1 环境准备</h3><p>新建工程，引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- elasticsearch 的客户端 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch-rest-high-level-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">&lt;!-- elasticsearch 依赖 2.x 的 log4j --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- junit 单元测试 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.24<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>ESTest_Client</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ESTest_Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建客户端</span></span><br><span class="line">        RestHighLevelClient client = <span class="keyword">new</span> RestHighLevelClient(RestClient.builder(<span class="keyword">new</span> HttpHost(<span class="string">"localhost"</span>, <span class="number">9200</span>, <span class="string">"http"</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭客户端连接</span></span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-索引-创建">4.2 索引-创建</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ESTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建索引</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ESTest_Client_create</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建客户端</span></span><br><span class="line">        RestHighLevelClient client = <span class="keyword">new</span> RestHighLevelClient(RestClient.builder(<span class="keyword">new</span> HttpHost(<span class="string">"localhost"</span>, <span class="number">9200</span>, <span class="string">"http"</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建索引</span></span><br><span class="line">        CreateIndexRequest index = <span class="keyword">new</span> CreateIndexRequest(<span class="string">"user"</span>);</span><br><span class="line">        CreateIndexResponse createIndexResponse =</span><br><span class="line">                client.indices().create(index, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//响应状态</span></span><br><span class="line">        <span class="keyword">boolean</span> acknowledged = createIndexResponse.isAcknowledged();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"创建索引"</span>+acknowledged);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭客户端连接</span></span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-索引查询-删除">4.3 索引查询 &amp; 删除</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//索引查询</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ESTest_Client_search</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//创建客户端</span></span><br><span class="line">    RestHighLevelClient client = <span class="keyword">new</span> RestHighLevelClient(RestClient.builder(<span class="keyword">new</span> HttpHost(<span class="string">"localhost"</span>, <span class="number">9200</span>, <span class="string">"http"</span>)));</span><br><span class="line"></span><br><span class="line">    GetIndexRequest request = <span class="keyword">new</span> GetIndexRequest(<span class="string">"user"</span>);</span><br><span class="line"></span><br><span class="line">    GetIndexResponse response = client.indices().get(request, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//相应状态</span></span><br><span class="line">    System.out.println(response.getAliases());</span><br><span class="line">    System.out.println(response.getMappings());</span><br><span class="line">    System.out.println(response.getSettings());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭客户端连接</span></span><br><span class="line">    client.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除索引</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ESTest_Client_delete</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//创建客户端</span></span><br><span class="line">    RestHighLevelClient client = <span class="keyword">new</span> RestHighLevelClient(RestClient.builder(<span class="keyword">new</span> HttpHost(<span class="string">"localhost"</span>, <span class="number">9200</span>, <span class="string">"http"</span>)));</span><br><span class="line"></span><br><span class="line">    DeleteIndexRequest request = <span class="keyword">new</span> DeleteIndexRequest(<span class="string">"user"</span>);</span><br><span class="line"></span><br><span class="line">    AcknowledgedResponse response = client.indices().delete(request, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//相应状态</span></span><br><span class="line">    System.out.println(response.isAcknowledged());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭客户端连接</span></span><br><span class="line">    client.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-文档新增-修改">4.4 文档新增 &amp; 修改</h3><p>首先创建数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  String name;</span><br><span class="line">    <span class="keyword">private</span>  Integer age;</span><br><span class="line">    <span class="keyword">private</span>  String sex;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新增和修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入文档</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ESTest_Client_insert</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//创建客户端</span></span><br><span class="line">    RestHighLevelClient client = <span class="keyword">new</span> RestHighLevelClient(RestClient.builder(<span class="keyword">new</span> HttpHost(<span class="string">"localhost"</span>, <span class="number">9200</span>, <span class="string">"http"</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入数据</span></span><br><span class="line">    IndexRequest request = <span class="keyword">new</span> IndexRequest();</span><br><span class="line">    request.index(<span class="string">"user"</span>).id(<span class="string">"1001"</span>);</span><br><span class="line"></span><br><span class="line">    User user =  <span class="keyword">new</span> User(<span class="string">"张三"</span>,<span class="number">30</span>,<span class="string">"男"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//像ES插入数据必须将数据转化为JSON格式</span></span><br><span class="line">    ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">    String userJson = mapper.writeValueAsString(user);</span><br><span class="line">    request.source(userJson, XContentType.JSON);</span><br><span class="line"></span><br><span class="line">    IndexResponse response = client.index(request, RequestOptions.DEFAULT);</span><br><span class="line">    System.out.println(response.getResult());</span><br><span class="line">    <span class="comment">// 关闭客户端连接</span></span><br><span class="line">    client.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//修改文档</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ESTest_Client_update</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//创建客户端</span></span><br><span class="line">    RestHighLevelClient client = <span class="keyword">new</span> RestHighLevelClient(RestClient.builder(<span class="keyword">new</span> HttpHost(<span class="string">"localhost"</span>, <span class="number">9200</span>, <span class="string">"http"</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入数据</span></span><br><span class="line">    UpdateRequest request = <span class="keyword">new</span> UpdateRequest();</span><br><span class="line">    request.index(<span class="string">"user"</span>).id(<span class="string">"1001"</span>);</span><br><span class="line">    request.doc(XContentType.JSON,<span class="string">"sex"</span>,<span class="string">"女"</span>);</span><br><span class="line"></span><br><span class="line">    UpdateResponse response = client.update(request, RequestOptions.DEFAULT);</span><br><span class="line">    System.out.println(response.getResult());</span><br><span class="line">    <span class="comment">// 关闭客户端连接</span></span><br><span class="line">    client.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询文档数据</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ESTest_Client_get</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//创建客户端</span></span><br><span class="line">    RestHighLevelClient client = <span class="keyword">new</span> RestHighLevelClient(RestClient.builder(<span class="keyword">new</span> HttpHost(<span class="string">"localhost"</span>, <span class="number">9200</span>, <span class="string">"http"</span>)));</span><br><span class="line"></span><br><span class="line">    GetRequest getRequest = <span class="keyword">new</span> GetRequest();</span><br><span class="line">    getRequest.index(<span class="string">"user"</span>).id(<span class="string">"1001"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入数据</span></span><br><span class="line">    GetResponse response = client.get(getRequest, RequestOptions.DEFAULT);</span><br><span class="line">    System.out.println(response.getSourceAsString());</span><br><span class="line">    <span class="comment">// 关闭客户端连接</span></span><br><span class="line">    client.close();</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">//删除文档数据</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ESTest_Client_delete_document</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//创建客户端</span></span><br><span class="line">    RestHighLevelClient client = <span class="keyword">new</span> RestHighLevelClient(RestClient.builder(<span class="keyword">new</span> HttpHost(<span class="string">"localhost"</span>, <span class="number">9200</span>, <span class="string">"http"</span>)));</span><br><span class="line"></span><br><span class="line">    DeleteRequest deleteRequest = <span class="keyword">new</span> DeleteRequest();</span><br><span class="line">    deleteRequest.index(<span class="string">"user"</span>).id(<span class="string">"1001"</span>);</span><br><span class="line"></span><br><span class="line">    DeleteResponse response = client.delete(deleteRequest, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 关闭客户端连接</span></span><br><span class="line">    client.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5-文档-批量查询-批量删除">4.5 文档-批量查询 &amp; 批量删除</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//批量新增数据</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ESTest_Client_insert_batch_document</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//创建客户端</span></span><br><span class="line">    RestHighLevelClient client = <span class="keyword">new</span> RestHighLevelClient(RestClient.builder(<span class="keyword">new</span> HttpHost(<span class="string">"localhost"</span>, <span class="number">9200</span>, <span class="string">"http"</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//批量插入数据</span></span><br><span class="line">    BulkRequest bulkRequest = <span class="keyword">new</span> BulkRequest();</span><br><span class="line"></span><br><span class="line">    bulkRequest.add(<span class="keyword">new</span> IndexRequest().index(<span class="string">"user"</span>).id(<span class="string">"1001"</span>).source(XContentType.JSON,<span class="string">"name"</span>,<span class="string">"zhangsan"</span>));</span><br><span class="line">    bulkRequest.add(<span class="keyword">new</span> IndexRequest().index(<span class="string">"user"</span>).id(<span class="string">"1002"</span>).source(XContentType.JSON,<span class="string">"name"</span>,<span class="string">"lisi"</span>));</span><br><span class="line">    bulkRequest.add(<span class="keyword">new</span> IndexRequest().index(<span class="string">"user"</span>).id(<span class="string">"1003"</span>).source(XContentType.JSON,<span class="string">"name"</span>,<span class="string">"wangwu"</span>));</span><br><span class="line"></span><br><span class="line">    BulkResponse response = client.bulk(bulkRequest, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">    System.out.println(response.getTook());</span><br><span class="line">    System.out.println(response.getItems());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭客户端连接</span></span><br><span class="line">    client.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//批量删除数据</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ESTest_Client_delete_batch_document</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//创建客户端</span></span><br><span class="line">    RestHighLevelClient client = <span class="keyword">new</span> RestHighLevelClient(RestClient.builder(<span class="keyword">new</span> HttpHost(<span class="string">"localhost"</span>, <span class="number">9200</span>, <span class="string">"http"</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//批量删除数据</span></span><br><span class="line">    BulkRequest bulkRequest = <span class="keyword">new</span> BulkRequest();</span><br><span class="line"></span><br><span class="line">    bulkRequest.add(<span class="keyword">new</span> DeleteRequest().index(<span class="string">"user"</span>).id(<span class="string">"1001"</span>));</span><br><span class="line">    bulkRequest.add(<span class="keyword">new</span> DeleteRequest().index(<span class="string">"user"</span>).id(<span class="string">"1002"</span>));</span><br><span class="line">    bulkRequest.add(<span class="keyword">new</span> DeleteRequest().index(<span class="string">"user"</span>).id(<span class="string">"1003"</span>));</span><br><span class="line"></span><br><span class="line">    BulkResponse response = client.bulk(bulkRequest, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">    System.out.println(response.getTook());</span><br><span class="line">    System.out.println(response.getItems());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭客户端连接</span></span><br><span class="line">    client.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-6-文档-高级查询-全量">4.6 文档-高级查询-全量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全量查询</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ESTest_Client_query_document</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//创建客户端</span></span><br><span class="line">    RestHighLevelClient client = <span class="keyword">new</span> RestHighLevelClient(RestClient.builder(<span class="keyword">new</span> HttpHost(<span class="string">"localhost"</span>, <span class="number">9200</span>, <span class="string">"http"</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.查询索引中全部的数据</span></span><br><span class="line">    SearchRequest request = <span class="keyword">new</span> SearchRequest();</span><br><span class="line">    request.indices(<span class="string">"user"</span>);</span><br><span class="line">    request.source(<span class="keyword">new</span> SearchSourceBuilder().query(QueryBuilders.matchAllQuery()));</span><br><span class="line"></span><br><span class="line">    SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    SearchHits hits = response.getHits();</span><br><span class="line"></span><br><span class="line">    System.out.println(hits.getTotalHits());</span><br><span class="line">    System.out.println(response.getTook());</span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">        System.out.println(hit.getSourceAsString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭客户端连接</span></span><br><span class="line">    client.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-7-文档-高级查询-termQuery查询、分页查询、排序查询、过滤字段">4.7 文档-高级查询-termQuery查询、分页查询、排序查询、过滤字段</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//条件查询</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ESTest_Client_query_document2</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//创建客户端</span></span><br><span class="line">    RestHighLevelClient client = <span class="keyword">new</span> RestHighLevelClient(RestClient.builder(<span class="keyword">new</span> HttpHost(<span class="string">"localhost"</span>, <span class="number">9200</span>, <span class="string">"http"</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.查询索引中全部的数据</span></span><br><span class="line">    SearchRequest request = <span class="keyword">new</span> SearchRequest();</span><br><span class="line">    request.indices(<span class="string">"user"</span>);</span><br><span class="line">    <span class="comment">//termQuery 查询</span></span><br><span class="line">    <span class="comment">//request.source(new SearchSourceBuilder().query(QueryBuilders.termQuery("sex","男")));</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    SearchSourceBuilder builder = <span class="keyword">new</span> SearchSourceBuilder().query(QueryBuilders.matchAllQuery());</span><br><span class="line">    <span class="comment">//分页查询</span></span><br><span class="line">    <span class="comment">//(当前页码-1)*页数</span></span><br><span class="line">    <span class="comment">//builder.from(0);</span></span><br><span class="line">    <span class="comment">//builder.size(2);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//排序查询</span></span><br><span class="line">    <span class="comment">//builder.sort("age", SortOrder.DESC);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//过滤字段</span></span><br><span class="line">    String[] excludes = &#123;<span class="string">"age"</span>&#125;;</span><br><span class="line">    String[] includes = &#123;<span class="string">"name"</span>,<span class="string">"age"</span>&#125;;</span><br><span class="line">    builder.fetchSource(includes,excludes);</span><br><span class="line"></span><br><span class="line">    request.source(builder);</span><br><span class="line">    SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    SearchHits hits = response.getHits();</span><br><span class="line"></span><br><span class="line">    System.out.println(hits.getTotalHits());</span><br><span class="line">    System.out.println(response.getTook());</span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">        System.out.println(hit.getSourceAsString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭客户端连接</span></span><br><span class="line">    client.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-8-文档-高级查询-组合查询-and、or、范围查询">4.8 文档-高级查询-组合查询 and、or、范围查询</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//组合查询</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ESTest_Client_compose_query_document2</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//创建客户端</span></span><br><span class="line">    RestHighLevelClient client = <span class="keyword">new</span> RestHighLevelClient(RestClient.builder(<span class="keyword">new</span> HttpHost(<span class="string">"localhost"</span>, <span class="number">9200</span>, <span class="string">"http"</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.查询索引中全部的数据</span></span><br><span class="line">    SearchRequest request = <span class="keyword">new</span> SearchRequest();</span><br><span class="line">    request.indices(<span class="string">"user"</span>);</span><br><span class="line">    SearchSourceBuilder builder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//        and or 查询</span></span><br><span class="line">    <span class="comment">//BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery();</span></span><br><span class="line"><span class="comment">//        and 的关系</span></span><br><span class="line">    <span class="comment">//boolQueryBuilder.must(QueryBuilders.matchQuery("age",30));</span></span><br><span class="line">   <span class="comment">// boolQueryBuilder.must(QueryBuilders.matchQuery("sex","男"));</span></span><br><span class="line"><span class="comment">//        或者的关系</span></span><br><span class="line">    <span class="comment">//boolQueryBuilder.should(QueryBuilders.matchQuery("age",30));</span></span><br><span class="line">    <span class="comment">//boolQueryBuilder.should(QueryBuilders.matchQuery("age",40));</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//范围查询</span></span><br><span class="line">    RangeQueryBuilder rangeQuery = QueryBuilders.rangeQuery(<span class="string">"age"</span>);</span><br><span class="line"></span><br><span class="line">    rangeQuery.gte(<span class="number">30</span>); <span class="comment">// 大于等于</span></span><br><span class="line">    rangeQuery.lte(<span class="number">40</span>); <span class="comment">// 小于等于</span></span><br><span class="line"></span><br><span class="line">    builder.query(rangeQuery);</span><br><span class="line">    request.source(builder);</span><br><span class="line"></span><br><span class="line">    SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    SearchHits hits = response.getHits();</span><br><span class="line">    System.out.println(hits.getTotalHits());</span><br><span class="line">    System.out.println(response.getTook());</span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">        System.out.println(hit.getSourceAsString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭客户端连接</span></span><br><span class="line">    client.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-9-文档-高级查询-模糊、高亮查询">4.9 文档-高级查询-模糊、高亮查询</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模糊查询</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ESTest_Client_like_query_document2</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//创建客户端</span></span><br><span class="line">    RestHighLevelClient client = <span class="keyword">new</span> RestHighLevelClient(RestClient.builder(<span class="keyword">new</span> HttpHost(<span class="string">"localhost"</span>, <span class="number">9200</span>, <span class="string">"http"</span>)));</span><br><span class="line"></span><br><span class="line">    SearchRequest request = <span class="keyword">new</span> SearchRequest();</span><br><span class="line">    request.indices(<span class="string">"user"</span>);</span><br><span class="line">    SearchSourceBuilder builder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模糊查询 Fuzziness.ONE 差一个字符也能查出来</span></span><br><span class="line">   <span class="comment">// builder.query(QueryBuilders.fuzzyQuery("name","wangwu").fuzziness(Fuzziness.ONE));</span></span><br><span class="line">    <span class="comment">//request.source(builder);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//高亮显示</span></span><br><span class="line">    TermQueryBuilder termQueryBuilder = QueryBuilders.termQuery(<span class="string">"name"</span>, <span class="string">"zhangsan"</span>);</span><br><span class="line"></span><br><span class="line">    HighlightBuilder highlightBuilder = <span class="keyword">new</span> HighlightBuilder();</span><br><span class="line">    highlightBuilder.preTags(<span class="string">"&lt;font color='red'&gt;"</span>);</span><br><span class="line">    highlightBuilder.postTags(<span class="string">"&lt;/font&gt;"</span>);</span><br><span class="line">    highlightBuilder.field(<span class="string">"name"</span>);</span><br><span class="line"></span><br><span class="line">    builder.highlighter(highlightBuilder);</span><br><span class="line">    builder.query(termQueryBuilder);</span><br><span class="line"></span><br><span class="line">    request.source(builder);</span><br><span class="line">    SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    System.out.println(response.toString());</span><br><span class="line">    SearchHits hits = response.getHits();</span><br><span class="line">    System.out.println(hits.getTotalHits());</span><br><span class="line">    System.out.println(response.getTook());</span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">        System.out.println(hit.getSourceAsString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭客户端连接</span></span><br><span class="line">    client.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-10-文档-聚合查询">4.10 文档-聚合查询</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//聚合查询</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ESTest_Client_polymerization_query_document</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//创建客户端</span></span><br><span class="line">    RestHighLevelClient client = <span class="keyword">new</span> RestHighLevelClient(RestClient.builder(<span class="keyword">new</span> HttpHost(<span class="string">"localhost"</span>, <span class="number">9200</span>, <span class="string">"http"</span>)));</span><br><span class="line"></span><br><span class="line">    SearchRequest request = <span class="keyword">new</span> SearchRequest();</span><br><span class="line">    request.indices(<span class="string">"user"</span>);</span><br><span class="line">    SearchSourceBuilder builder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//最大值查询</span></span><br><span class="line">    <span class="comment">//AggregationBuilder aggregationBuilder = AggregationBuilders.max("maxAge").field("age");</span></span><br><span class="line">    <span class="comment">//builder.aggregation(aggregationBuilder);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//分组查询</span></span><br><span class="line">    AggregationBuilder aggregationBuilder = AggregationBuilders.terms(<span class="string">"ageGroup"</span>).field(<span class="string">"age"</span>);</span><br><span class="line">    builder.aggregation(aggregationBuilder);</span><br><span class="line"></span><br><span class="line">    request.source(builder);</span><br><span class="line">    SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    System.out.println(response.toString());</span><br><span class="line">    SearchHits hits = response.getHits();</span><br><span class="line">    System.out.println(hits.getTotalHits());</span><br><span class="line">    System.out.println(response.getTook());</span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">        System.out.println(hit.getSourceAsString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭客户端连接</span></span><br><span class="line">    client.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>三、ElasticSearch 环境</h1><h2 id="1、相关概念">1、相关概念</h2><h3 id="1-1-单机-集群">1.1 单机 &amp; 集群</h3><p>单台ElasticSearch 服务器提供服务，往往都有最大的负载能力，超过这个阈值，服务器性能就会大大降低甚至不可用，所以生产环境中，一般都是运行在指定服务器集群中。除了负载能力，单点服务器也存在其他问题：</p><ul><li>单台机器存储容量有限</li><li>单服务器容易出现单点故障，无法实现高可用</li><li>单服务的并发能力有限</li></ul><p>配置服务器集群时，集群中节点数量没有限制，大于等于 2 个节点就可以看做是集群了。一  般出于高性能及高可用方面来考虑集群中节点数量都是 3 个以上</p><h3 id="1-2-集群Cluster">1.2 集群Cluster</h3><p>一个集群就是由一个或多个服务器节点组织在一起，共同持有整个的数据，并一起提供索引和搜索功能。一个 Elasticsearch 集群有一个唯一的名字标识，这个名字默认就是&quot;elasticsearch&quot;。这个名字是重要的，因为一个节点只能通过指定某个集群的名字，来加入这个集群</p><h3 id="1-3-节点-Node">1.3 节点 Node</h3><p>集群中包含很多服务器， 一个节点就是其中的一个服务器。 作为集群的一部分，它存储数据，参与集群的索引和搜索功能。</p><p>一个节点也是由一个名字来标识的，默认情况下，这个名字是一个随机的漫威漫画角色的名字，这个名字会在启动的时候赋予节点。这个名字对于管理工作来说挺重要的，因为在这个管理过程中，你会去确定网络中的哪些服务器对应于 Elasticsearch 集群中的哪些节点。一个节点可以通过配置集群名称的方式来加入一个指定的集群。默认情况下，每个节点都会被安排加入到一个叫做**“elasticsearch”**的集群中，这意味着，如果你在你的网络中启动了若干个节点，并假定它们能够相互发现彼此，它们将会自动地形成并加入到一个叫做&quot;elasticsearch&quot;的集群中。</p><p>在一个集群里，只要你想，可以拥有任意多个节点。而且，如果当前你的网络中没有运行任何 Elasticsearch 节点，这时启动一个节点，会默认创建并加入一个叫做&quot;elasticsearch&quot;的集群。</p><h2 id="2、Windows集群">2、Windows集群</h2><p>创建elasticsearch-cluster文件夹，在内部复制三个elasticsearch服务(要全新的解压，分别命名node-1001/1002/1003)</p><p>修改集群文件目录中每个节点的<code>config/elasticsearch.yml</code> 配置文件 <strong>node-1001 节点</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ======================== Elasticsearch Configuration =========================</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># <span class="doctag">NOTE:</span> Elasticsearch comes with reasonable defaults for most settings.</span></span><br><span class="line"><span class="comment">#       Before you set out to tweak and tune the configuration, make sure you</span></span><br><span class="line"><span class="comment">#       understand what are you trying to accomplish and the consequences.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The primary way of configuring a node is via this file. This template lists</span></span><br><span class="line"><span class="comment"># the most important settings you may want to configure for a production cluster.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Please consult the documentation for further information on configuration options:</span></span><br><span class="line"><span class="comment"># https://www.elastic.co/guide/en/elasticsearch/reference/index.html</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ---------------------------------- Cluster -----------------------------------</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Use a descriptive name for your cluster:</span></span><br><span class="line"><span class="comment">#集群名称、节点之间要保持一致</span></span><br><span class="line"><span class="attr">cluster.name:</span> <span class="string">my-application</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ------------------------------------ Node ------------------------------------</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Use a descriptive name for the node:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#节点名称，集群内要唯一</span></span><br><span class="line"><span class="attr">node.name:</span> <span class="string">node-1001</span></span><br><span class="line"><span class="attr">node.master:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">node.data:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Add custom attributes to the node:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#node.attr.rack: r1</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ----------------------------------- Paths ------------------------------------</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Path to directory where to store the data (separate multiple locations by comma):</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#path.data: /path/to/data</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Path to log files:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#path.logs: /path/to/logs</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ----------------------------------- Memory -----------------------------------</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Lock the memory on startup:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#bootstrap.memory_lock: true</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Make sure that the heap size is set to about half the memory available</span></span><br><span class="line"><span class="comment"># on the system and that the owner of the process is allowed to use this</span></span><br><span class="line"><span class="comment"># limit.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Elasticsearch performs poorly when the system is swapping the memory.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ---------------------------------- Network -----------------------------------</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Set the bind address to a specific IP (IPv4 or IPv6):</span></span><br><span class="line"><span class="comment">#ip地址</span></span><br><span class="line"><span class="attr">network.host:</span> <span class="string">localhost</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Set a custom port for HTTP:</span></span><br><span class="line"><span class="comment">#http端口</span></span><br><span class="line"><span class="attr">http.port:</span> <span class="number">1001</span></span><br><span class="line"><span class="comment">#tcp 监听端口</span></span><br><span class="line"><span class="attr">transport.tcp.port:</span> <span class="number">9301</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># For more information, consult the network module documentation.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># --------------------------------- Discovery ----------------------------------</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Pass an initial list of hosts to perform discovery when this node is started:</span></span><br><span class="line"><span class="comment"># The default list of hosts is ["127.0.0.1", "[::1]"]</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#discovery.seed_hosts: ["host1", "host2"]</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Bootstrap the cluster using an initial set of master-eligible nodes:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#cluster.initial_master_nodes: ["node-1", "node-2"]</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># For more information, consult the discovery and cluster formation module documentation.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ---------------------------------- Gateway -----------------------------------</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Block initial recovery after a full cluster restart until N nodes are started:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#gateway.recover_after_nodes: 3</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># For more information, consult the gateway module documentation.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ---------------------------------- Various -----------------------------------</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Require explicit names when deleting indices:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#action.destructive_requires_name: true</span></span><br><span class="line"><span class="comment"># 跨域配置</span></span><br><span class="line"><span class="attr">http.cors.enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">http.cors.allow-origin:</span> <span class="string">"*"</span></span><br></pre></td></tr></table></figure><p><strong>node-1002 节点</strong>，自行增删</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#节点名称，集群内要唯一</span></span><br><span class="line"><span class="attr">node.name:</span> <span class="string">node-1002</span></span><br><span class="line"><span class="attr">node.master:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">node.data:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#ip地址</span></span><br><span class="line"><span class="attr">network.host:</span> <span class="string">localhost</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Set a custom port for HTTP:</span></span><br><span class="line"><span class="comment">#http端口</span></span><br><span class="line"><span class="attr">http.port:</span> <span class="number">1002</span></span><br><span class="line"><span class="comment">#tcp 监听端口</span></span><br><span class="line"><span class="attr">transport.tcp.port:</span> <span class="number">9302</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这是发现第一台的配置</span></span><br><span class="line"><span class="attr">discovery.seed_hosts:</span> <span class="string">["localhost:9301"]</span></span><br><span class="line"><span class="attr">discovery.zen.fd.ping_timeout:</span> <span class="string">1m</span></span><br><span class="line"><span class="attr">discovery.zen.fd.ping_retries:</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 跨域配置</span></span><br><span class="line"><span class="attr">http.cors.enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">http.cors.allow-origin:</span> <span class="string">"*"</span></span><br></pre></td></tr></table></figure><p><strong>node-1003 节点</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cluster.name:</span> <span class="string">my-application</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#节点名称，集群内要唯一</span></span><br><span class="line"><span class="attr">node.name:</span> <span class="string">node-1003</span></span><br><span class="line"><span class="attr">node.master:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">node.data:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#ip地址</span></span><br><span class="line"><span class="attr">network.host:</span> <span class="string">localhost</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Set a custom port for HTTP:</span></span><br><span class="line"><span class="comment">#http端口</span></span><br><span class="line"><span class="attr">http.port:</span> <span class="number">1003</span></span><br><span class="line"><span class="comment">#tcp 监听端口</span></span><br><span class="line"><span class="attr">transport.tcp.port:</span> <span class="number">9303</span></span><br><span class="line"></span><br><span class="line"><span class="attr">discovery.seed_hosts:</span> <span class="string">["localhost:9301","localhost:9302"]</span></span><br><span class="line"><span class="attr">discovery.zen.fd.ping_timeout:</span> <span class="string">1m</span></span><br><span class="line"><span class="attr">discovery.zen.fd.ping_retries:</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#action.destructive_requires_name: true</span></span><br><span class="line"><span class="comment"># 跨域配置</span></span><br><span class="line"><span class="attr">http.cors.enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">http.cors.allow-origin:</span> <span class="string">"*"</span></span><br></pre></td></tr></table></figure><p>最后启动前先删除每个节点中的data目录中所有内容（如果存在），然后分别双击执行<code>bin/elsaticsearch.bat</code>，启动节点服务器，会自动加入指定名称的集群，查询集群状态：<code>localhost:1001/_cluster/health</code></p><h2 id="3、Linux单机">3、Linux单机</h2><blockquote><p>Linux下载地址：<a href="https://www.elastic.co/cn/downloads/past-releases/elasticsearch-7-8-0" target="_blank" rel="noopener" title="https://www.elastic.co/cn/downloads/past-releases/elasticsearch-7-8-0">https://www.elastic.co/cn/downloads/past-releases/elasticsearch-7-8-0</a></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将下载的软件解压缩</span></span><br><span class="line"><span class="comment">#解压缩</span></span><br><span class="line">tar -axvf elasticsearch-7.8.0-linux-x86_64.tar.gz</span><br><span class="line"><span class="comment"># 改名称</span></span><br><span class="line">mv elasticsearch-7.8.0 es</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建用户,因为安全问题，Elasticsearch不允许root用户直接运行，所以创建新用户，在root用户中创建新用户</span></span><br><span class="line"><span class="comment">#新增es用户</span></span><br><span class="line">useradd es </span><br><span class="line"><span class="comment">#为es用户设置密码</span></span><br><span class="line">passwd es </span><br><span class="line"><span class="comment"># 如果错误了，可以删除再加</span></span><br><span class="line">userdel -r es </span><br><span class="line"><span class="comment">#文件夹所有者</span></span><br><span class="line">chown -R es:es /usr/<span class="built_in">local</span>/elasticsearch/single/es</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改配置文件</span></span><br><span class="line"><span class="comment"># 修改/usr/local/elasticsearch/single/es/config/elasticsearch.yml</span></span><br><span class="line"><span class="comment">#加入如下配置</span></span><br><span class="line">cluster.name: elasticsearch</span><br><span class="line">node.name: node-1</span><br><span class="line">network.host: 0.0.0.0</span><br><span class="line">cluster.initial_master_nodes: [<span class="string">"node-1"</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 由于es文件比较多，需要修改系统配置</span></span><br><span class="line"><span class="comment"># 修改 /etc/security/limits.conf</span></span><br><span class="line"><span class="comment"># 在文件末尾中增加下面内容，每个进程可以打开的文件数的限制</span></span><br><span class="line">es soft nofile 65536</span><br><span class="line">es hard nofile 65536</span><br><span class="line"><span class="comment"># 修改 /etc/security/limits.d/20-nproc.conf</span></span><br><span class="line"><span class="comment"># 在文件末尾中增加下面内容，每个进程可以打开的文件数的限制</span></span><br><span class="line">es soft nofile 65536</span><br><span class="line">es hard nofile 65536</span><br><span class="line"><span class="comment"># 操作系统级别对每个用户创建的进程数的限制</span></span><br><span class="line">* hard nproc 4096</span><br><span class="line"><span class="comment"># 注： * 地表linux 所有用户名称</span></span><br><span class="line"><span class="comment"># 修改/etc/sysctl.conf</span></span><br><span class="line"><span class="comment"># 在文件末尾中增加下面内容</span></span><br><span class="line"><span class="comment"># 一个进程可以拥有的 VMA(虚拟内存区域)的数量,默认值为 65536</span></span><br><span class="line">vm.max_map_count=655360</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新加载</span></span><br><span class="line">sysctl -p</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最后启动软件</span></span><br><span class="line"><span class="comment">#切换es用户</span></span><br><span class="line">su es</span><br><span class="line"><span class="comment">#启动ES</span></span><br><span class="line">bin/elasticsearch</span><br><span class="line"><span class="comment">#如果出现 Likely root cause: java.nio.file.AccessDeniedException: /usr/local/elasticsearch/single/es/config/elasticsearch.keystore错误</span></span><br><span class="line"><span class="comment"># 切换root用户  chown -R es:es /usr/local/elasticsearch/single/es</span></span><br></pre></td></tr></table></figure><h2 id="4、Linux集群">4、Linux集群</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#解压缩</span></span><br><span class="line">tar -axvf elasticsearch-7.8.0-linux-x86_64.tar.gz</span><br><span class="line"><span class="comment"># 改名称</span></span><br><span class="line">mv elasticsearch-7.8.0 es-cluster</span><br><span class="line"><span class="comment"># 最后将软件分发到其他节点(可以使用xsync)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 因为安全问题，Elasticsearch不允许root用户直接运行，所以创建新用户，在root用户中创建新用户</span></span><br><span class="line"><span class="comment">#新增es用户</span></span><br><span class="line">useradd es </span><br><span class="line"><span class="comment">#为es用户设置密码</span></span><br><span class="line">passwd es </span><br><span class="line"><span class="comment"># 如果错误了，可以删除再加</span></span><br><span class="line">userdel -r es </span><br><span class="line"><span class="comment">#文件夹所有者</span></span><br><span class="line">chown -R es:es /usr/<span class="built_in">local</span>/elasticsearch/single/es</span><br></pre></td></tr></table></figure><p>然后修改<code>/usr/local/elasticsearch/cluster/es-cluster/config/elasticsearch.yml</code> 文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加入如下配置</span></span><br><span class="line"><span class="comment">#集群名称</span></span><br><span class="line"><span class="attr">cluster.name:</span> <span class="string">cluster-es</span></span><br><span class="line"><span class="comment">#节点名称， 每个节点的名称不能重复</span></span><br><span class="line"><span class="attr">node.name:</span> <span class="string">node-1</span></span><br><span class="line"><span class="comment">#ip 地址， 每个节点的地址不能重复</span></span><br><span class="line"><span class="attr">network.host:</span> <span class="string">node01</span></span><br><span class="line"><span class="comment">#是不是有资格主节点</span></span><br><span class="line"><span class="attr">node.master:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">node.data:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">http.port:</span> <span class="number">9200</span></span><br><span class="line"><span class="comment"># head 插件需要这打开这两个配置</span></span><br><span class="line"><span class="attr">http.cors.allow-origin:</span> <span class="string">"*"</span></span><br><span class="line"><span class="attr">http.cors.enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">http.max_content_length:</span> <span class="string">200mb</span></span><br><span class="line"><span class="comment">#es7.x 之后新增的配置，初始化一个新的集群时需要此配置来选举 master</span></span><br><span class="line"><span class="attr">cluster.initial_master_nodes:</span> <span class="string">["node-1"]</span></span><br><span class="line"><span class="comment">#es7.x 之后新增的配置，节点发现</span></span><br><span class="line"><span class="attr">discovery.seed_hosts:</span> <span class="string">["node01:9300","node02:9300","node03:9300"]</span></span><br><span class="line"><span class="attr">gateway.recover_after_nodes:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">network.tcp.keep_alive:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">network.tcp.no_delay:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">transport.tcp.compress:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment">#集群内同时启动的数据任务个数，默认是 2 个</span></span><br><span class="line"><span class="attr">cluster.routing.allocation.cluster_concurrent_rebalance:</span> <span class="number">16</span></span><br><span class="line"><span class="comment">#添加或删除节点及负载均衡时并发恢复的线程个数，默认 4 个</span></span><br><span class="line"><span class="attr">cluster.routing.allocation.node_concurrent_recoveries:</span> <span class="number">16</span></span><br><span class="line"><span class="comment">#初始化数据恢复时，并发恢复线程的个数，默认 4 个</span></span><br><span class="line"><span class="attr">cluster.routing.allocation.node_initial_primaries_recoveries:</span> <span class="number">16</span></span><br></pre></td></tr></table></figure><p>然后系统的配置如同单机，最后启动软件，分别在不同节点上启动ES软件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/elasticsearch/cluster/es-cluster</span><br><span class="line"><span class="comment">#启动</span></span><br><span class="line">bin/slasticsearch</span><br><span class="line"><span class="comment">#后台启动</span></span><br><span class="line">bin/slasticsearch -d</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#  测试集群</span></span><br><span class="line">http://node01:9200/_cat/nodes</span><br></pre></td></tr></table></figure><h1>四、Elasticsearch进阶</h1><h2 id="1、核心概念">1、核心概念</h2><h3 id="1-1-索引（index）">1.1 索引（index）</h3><p>一个索引就是一个拥有几分相似特征的文档的集合。比如说，你可以有一个客户数据的索引，另一个产品目录的索引，还有一个订单数据的索引。一个索引由一个名字来标识（<strong>必须全部是小写字母</strong>），并且当我们要对这个索引中的文档进行索引、搜索、更新和删除（CRUD）的时候，都要使用到这个名字。在一个集群中，可以定义任意多的索引。</p><p>能搜索的数据必须索引，这样的好处是可以提高查询速度，比如：新华字典前面的目录就是索引的意思，目录可以提高查询速度。</p><p><strong>Elasticsearch 索引的精髓：一切设计都是为了提高搜索的性能。</strong></p><h3 id="1-2-类型-（type）">1.2 类型 （type）</h3><p>在一个索引中，你可以定义一种或多种类型。一个类型是你的索引的一个逻辑上的分类/分区，其语义完全由你来定。通常，会为具有一组共同字段的文档定义一个类型。不同的版本，类型发生了不同的变化。</p><table><thead><tr><th><strong>版本</strong></th><th><strong>Type</strong></th></tr></thead><tbody><tr><td>5.x</td><td>支持多种type</td></tr><tr><td>6.x</td><td>只能有一种type</td></tr><tr><td>7.x</td><td>默认不再支持自定义索引类型（默认类型为： _doc）</td></tr></tbody></table><h3 id="1-3-文档（Document）">1.3 文档（Document）</h3><p>一个文档是一个可被索引的基础信息单元，也就是一条数据</p><p>比如：你可以拥有某一个客户的文档，某一个产品的一个文档，当然，也可以拥有某个订单的一个文档。文档以 JSON（Javascript Object Notation）格式来表示，而 JSON 是一个到处存在的互联网数据交互格式。在一个<code> index/type</code> 里面，你可以存储任意多的文档。</p><h3 id="1-4-字段（Field）">1.4 字段（Field）</h3><p>相当于是数据表的字段，对文档数据根据不同属性进行的分类标识</p><h3 id="1-5-映射（Mapping）">1.5 映射（Mapping）</h3><p>mapping 是处理数据的方式和规则方面做一些限制，如：某个字段的数据类型、默认值、分析器、是否被索引等等。这些都是映射里面可以设置的，其它就是处理 ES 里面数据的一些使用规则设置也叫做映射，按着最优规则处理数据对性能提高很大，因此才需要建立映射，并且需要思考如何建立映射才能对性能更好。</p><h3 id="1-6-分片（Shards）">1.6 分片（Shards）</h3><p>一个索引可以存储超出单个节点硬件限制的大量数据。比如，一个具有 10 亿文档数据<br>的索引占据 1TB 的磁盘空间，而任一节点都可能没有这样大的磁盘空间。 或者单个节点处理搜索请求，响应太慢。为了解决这个问题，Elasticsearch 提供了将索引划分成多份的能力，每一份就称之为分片。当你创建一个索引的时候，你可以指定你想要的分片的数量。每个分片本身也是一个功能完善并且独立的“索引”，这个“索引”可以被放置到集群中的任何节点上。分片很重要，主要有两方面的原因：</p><ul><li>允许你水平分割 / 扩展你的内容容量</li><li>允许你在分片之上进行分布式的、并行的操作，进而提高性能/吞吐量</li></ul><p>至于一个分片怎样分布，它的文档怎样聚合和搜索请求，是完全由 Elasticsearch 管理的，对于作为用户的你来说，这些都是透明的，无需过分关心。被混淆的概念是，一个 Lucene 索引 我们在 Elasticsearch 称作 分片 。 一个Elasticsearch 索引 是分片的集合。 当 Elasticsearch 在索引中搜索的时候， 他发送查询到每一个属于索引的分片（Lucene 索引），然后合并每个分片的结果到一个全局的结果集。</p><h3 id="1-7-副本（Replicas）">1.7 副本（Replicas）</h3><p>在一个网络 / 云的环境里，失败随时都可能发生，在某个分片/节点不知怎么的就处于离线状态，或者由于任何原因消失了，这种情况下，有一个故障转移机制是非常有用并且是强烈推荐的。为此目的， Elasticsearch 允许你创建分片的一份或多份拷贝，这些拷贝叫做复制分片(副本)。</p><ul><li>在分片/节点失败的情况下，提供了高可用性。因为这个原因，注意到复制分片从不与原/主要（original/primary）分片置于同一节点上是非常重要的。</li><li>扩展你的搜索量/吞吐量，因为搜索可以在所有的副本上并行运行。</li></ul><p>总之，每个索引可以被分成多个分片。一个索引也可以被复制 0 次（意思是没有复制）或多次。一旦复制了，每个索引就有了主分片（作为复制源的原来的分片）和复制分片（主分片的拷贝）之别。</p><p>分片和复制的数量可以在索引创建的时候指定。在索引创建之后，你可以在任何时候动态地改变复制的数量，但是你事后不能改变分片的数量。默认情况下，Elasticsearch 中的每个索引被分片 1 个主分片和 1 个复制，这意味着，如果你的集群中至少有两个节点，你的索引将会有 1 个主分片和另外 1 个复制分片（1 个完全拷贝），这样的话每个索引总共就有 2 个分片， 我们需要根据索引需要确定分片个数。</p><h3 id="1-8-分配（Allocation）">1.8 分配（Allocation）</h3><p>将分片分配给某个节点的过程，包括分配主分片或者副本。如果是副本，还包含从主分片复制数据的过程。这个过程是由 master 节点完成的。</p><h2 id="2、系统架构">2、系统架构</h2><p><img src="https://img-blog.csdnimg.cn/e9fbab79383449dbaa96e73c95a0f8bb.png#pic_center" alt="在这里插入图片描述"></p><p>一个运行中的 Elasticsearch 实例称为一个节点，而集群是由一个或者多个拥有相同<br><code>cluster.name</code> 配置的节点组成， 它们共同承担数据和负载的压力。当有节点加入集群中或者从集群中移除节点时，集群将会重新平均分布所有的数据。</p><p>当一个节点被选举成为主节点时， 它将负责管理集群范围内的所有变更，例如增加、<br>删除索引，或者增加、删除节点等。 而主节点并不需要涉及到文档级别的变更和搜索等操作，所以当集群只拥有一个主节点的情况下，即使流量的增加它也不会成为瓶颈。 任何节点都可以成为主节点。我们的示例集群就只有一个节点，所以它同时也成为了主节点。</p><p>作为用户，我们可以将请求发送到集群中的任何节点 ，包括主节点。 每个节点都知道<br>任意文档所处的位置，并且能够将我们的请求直接转发到存储我们所需文档的节点。 无论我们将请求发送到哪个节点，它都能负责从各个包含我们所需文档的节点收集回数据，并将最终结果返回給客户端。 Elasticsearch 对这一切的管理都是透明的。</p><h2 id="3、分布式集群">3、分布式集群</h2><h3 id="3-1-单节点集群">3.1 单节点集群</h3><p>我们在包含一个空节点的集群内创建名为<strong>user的索引</strong>，为了掩饰目的，我们将分配3个主分片和一个副本（每个主分片拥有一个副本分片），集群现在是拥有一个索引的单节点集群。所有 3 个主分片都被分配在 node-1</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#PUT http://127.0.0.1:1001/users</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"settings"</span> : &#123;</span><br><span class="line">        <span class="string">"number_of_shards"</span> : 3,</span><br><span class="line">        <span class="string">"number_of_replicas"</span> : 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <a href="https://github.com/mobz/elasticsearch-head" target="_blank" rel="noopener" title="elasticsearch-head 插件">elasticsearch-head 插件</a>（一个Chrome插件）查看集群情况 </p><ul><li>集群健康值:yellow( 3 of 6 )：表示当前集群的全部主分片都正常运行，但是副本分片没有全部处在正常状态(当前集群是正常运行的，但存在丢失数据的风险。)</li><li>3 个主分片正常。3 个副本分片都是 Unassigned，它们都没有被分配到任何节点。 在同 一个节点上既保存原始数据又保存副本是没有意义的，因为一旦失去了那个节点，我们也将丢失该节点 上的所有副本数据</li></ul><h3 id="3-2-故障转移">3.2 故障转移</h3><p>当集群中只有一个节点在运行时，意味着会有一个单点故障问题——没有冗余。 幸运的是，我们只需再启动一个节点即可防止数据丢失。当你在同一台机器上启动了第二个节点时，只要它和第一个节点有同样的 <code>cluster.name </code>配置，它就会自动发现集群并加入到其中。但是在不同机器上启动节点的时候，为了加入到同一集群，你需要配置一个可连接到的单播主机列表。之所以配置为使用单播发现，以防止节点无意中加入集群。只有在同一台机器上运行的节点才会自动组成集群。</p><p>如果启动了第二个节点，集群将会拥有两个节点 : 所有主分片和副本分片都已被分配</p><p><img src="https://img-blog.csdnimg.cn/e7388d74ade44874ab7480cfc558d943.png#pic_center" alt="在这里插入图片描述"></p><h3 id="3-3-水平扩容">3.3 水平扩容</h3><p>怎样为我们的正在增长中的应用程序按需扩容呢？当启动了第三个节点，我们的集群将会拥有三个节点的集群 : **为了分散负载而对分片进行重新分配 **。</p><p><img src="https://img-blog.csdnimg.cn/a7daa52a14ce44b88ad581f34f98f7bb.png#pic_center" alt="在这里插入图片描述"></p><p>Node 1 和 Node 2 上各有一个分片被迁移到了新的 Node 3 节点，现在每个节点上都拥有 2 个分片， 而不是之前的 3 个。 这表示每个节点的硬件资源（CPU, RAM, I/O）将被更少的分片所共享，每个分片 的性能将会得到提升</p><p>分片是一个功能完整的搜索引擎，它拥有使用一个节点上的所有资源的能力。 我们这个拥有 6 个分 片（3 个主分片和 3 个副本分片）的索引可以最大扩容到 6 个节点，每个节点上存在一个分片，并且每个分片拥有所在节点的全部资源。</p><p><strong>但是如果我们想要扩容超过 6 个节点怎么办呢？</strong></p><p>主分片的数目在索引创建时就已经确定了下来。实际上，这个数目定义了这个索引能够存储 的最大数据量。（实际大小取决于你的数据、硬件和使用场景。） 但是，读操作——搜索和返回数据——可以同时被主分片 或 副本分片所处理，所以当你<strong>拥有越多的副本分片时，也将拥有越高的吞吐量</strong>。在运行中的集群上是可以动态调整副本分片数目的，我们可以按需伸缩集群。让我们把副本数从默认的 1 增加到 2。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#PUT http://127.0.0.1:1001/users/_settings</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"number_of_replicas"</span> : 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>users 索引现在拥有 9 个分片： 3 个主分片和 6 个副本分片。 这意味着我们可以将集群扩容到 9 个节点，每个节点上一个分片。相比原来 3 个节点时，集群搜索性能可以提升 3 倍。</p><h3 id="3-4-应对故障">3.4 应对故障</h3><p>虽然我们拥有所有的三个主分片，但是同时设置了每个主分片需要对应 2 份副本分片，而此时只存在一份副本分片。 所以集群不能为 green 的状态，不过我们不必过于担心：如果我们同样关闭了 Node 2 ，我们的程序 依然 可以保持在不丢任何数据的情况下运行，因为Node 3 为每一个分片都保留着一份副本。</p><p>如果想回复原来的样子，要确保Node-1的配置文件有如下配置：（让他找到集群）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">discovery.seed_hosts: [<span class="string">"localhost:9302"</span>, <span class="string">"localhost:9303"</span>]</span><br></pre></td></tr></table></figure><p>集群可以将缺失的副本分片再次进行分配，那么集群的状态也将恢复成之前的状态。 如果 Node 1 依然拥有着之前的分片，它将尝试去重用它们，同时仅从主分片复制发生了修改的数据文件。和之前的集群相比，只是 Master 节点切换了</p><h3 id="3-5-路由计算-分片控制">3.5 路由计算 &amp; 分片控制</h3><ul><li><strong>路由计算</strong></li></ul><p>当索引一个文档的时候，文档会被存储到一个主分片中。 Elasticsearch 如何知道一个文档应该存放到哪个分片中呢？当我们创建文档时，它如何决定这个文档应当被存储在分片 1 还是分片 2 中呢？首先这肯定不会是随机的，否则将来要获取文档的时候我们就不知道从何处寻找了。实际上，这个过程是根据下面这个公式决定的：<code>shard = hash(routing) % number_of_primary_shards</code></p><p><img src="https://img-blog.csdnimg.cn/c7e6513ac71448e0844520c73907887c.png#pic_center" alt="在这里插入图片描述"></p><p>所有的文档API ( get ,index ,delete ,bulk , update以及 mget ）都接受一个叫做routing 的路由参数，通过这个参数我们可以自定义文档到分片的映射。一个自定义的路由参数可以用来确保所有相关的文档—例如所有属于同一个用户的文档——都被存储到同一个分片中</p><ul><li><strong>分片控制</strong></li></ul><p>我们可以发送请求到集群中的任一节点。每个节点都有能力处理任意请求。每个节点都知道集群中任一文档位置，所以可以直接将请求转发到需要的节点上。在下面的例子中，如果将所有的请求发送到Node 1001，我们将其称为协调节点coordinating node</p><p><img src="https://img-blog.csdnimg.cn/e7174681b34242e9b9d3edbc54d600c8.png#pic_center" alt="在这里插入图片描述"></p><p><strong>当发送请求的时候， 为了扩展负载，更好的做法是轮询集群中所有的节点。</strong></p><h3 id="3-6-数据写流程">3.6 数据写流程</h3><p>新建、索引和删除请求都是写操作， 必须在主分片上面完成之后才能被复制到相关的副本分片</p><p><img src="https://img-blog.csdnimg.cn/7fd8ee4862154e94b61a28cb4079bba1.png#pic_center" alt="在这里插入图片描述"></p><p>在客户端收到成功响应时，文档变更已经在主分片和所有副本分片执行完成，变更是安全的。有一些可选的请求参数允许您影响这个过程，可能以数据安全为代价提升性能。这些选项很少使用，因为 Elasticsearch 已经很快，但是为了完整起见， 请参考下文：</p><p><strong>consistency</strong></p><ul><li>即一致性。在默认设置下，即使仅仅是在试图执行一个写操作之前，主分片都会要求必须要有规定数量quorum（或者换种说法，也即必须要有大多数）的分片副本处于活跃可用状态，才会去执行写操作（其中分片副本 可以是主分片或者副本分片）。这是为了避免在发生网络分区故障（network partition）的时候进行写操作，进而导致数据不一致。 规定数量即： int((primary + number_of_replicas) / 2 ) + 1</li><li>consistency 参数的值可以设为：<ul><li>one ：只要主分片状态 ok 就允许执行写操作</li><li>all：必须要主分片和所有副本分片的状态没问题才允许执行写操作</li><li>quorum：默认值为quorum , 即大多数的分片副本状态没问题就允许执行写操作</li></ul></li><li>注意，规定数量的计算公式中number_of_replicas指的是在索引设置中的设定副本分片数，而不是指当前处理活动状态的副本分片数。如果你的索引设置中指定了当前索引拥有3个副本分片，那规定数量的计算结果即：int((1 primary + 3 replicas) / 2) + 1 = 3，如果此时你只启动两个节点，那么处于活跃状态的分片副本数量就达不到规定数量，也因此您将无法索引和删除任何文档</li></ul><p><strong>timeout</strong></p><ul><li>如果没有足够的副本分片会发生什么？Elasticsearch 会等待，希望更多的分片出现。默认情况下，它最多等待 1 分钟。 如果你需要，你可以使用timeout参数使它更早终止：100是100 毫秒，30s是30秒。</li></ul><p>新索引默认有1个副本分片，这意味着为满足规定数量应该需要两个活动的分片副本。 但是，这些默认的设置会阻止我们在单一节点上做任何事情。为了避免这个问题，要求只有当number_of_replicas 大于1的时候，规定数量才会执行</p><h3 id="3-7-数据读流程">3.7 数据读流程</h3><p><img src="https://img-blog.csdnimg.cn/8b6ebb0429fb495eb264add065ffc175.png#pic_center" alt="在这里插入图片描述"></p><p>在处理读取请求时，协调结点在每次请求的时候都会通过轮询所有的副本分片来达到负载均衡。在文档被检索时，已经被索引的文档可能已经存在于主分片上但是还没有复制到副本分片。 在这种情况下，副本分片可能会报告文档不存在，但是主分片可能成功返回文档。 一旦索引请求成功返回给用户，文档在主分片和副本分片都是可用的。</p><h3 id="3-8-更新流程-批量操作流程">3.8 更新流程 &amp; 批量操作流程</h3><p><strong>更新流程</strong>（部分更新一个文档结合了先前说明的读取和写入流程：）</p><p><img src="https://img-blog.csdnimg.cn/bee2c7cc31dd4fe9a6328aee1d8197bb.png#pic_center" alt="在这里插入图片描述"></p><ul><li>客户端向Node 1发送更新请求</li><li>它将请求转发到主分片所在的Node 3 </li><li>Node 3从主分片检索文档，修改_source字段中的JSON，并且尝试重新索引主分片的文档。如果文档已经被另一个进程修改,它会重试步骤3 ,超过<code>retry_on_conflict</code>次后放弃</li><li>如果 Node 3成功地更新文档，它将新版本的文档并行转发到Node 1和 Node 2上的副本分片，重新建立索引。一旦所有副本分片都返回成功，Node 3向协调节点也返回成功，协调节点向客户端返回成功</li></ul><p><strong>批量操作流程</strong></p><p>**mget和 bulk API的模式类似于单文档模式。**区别在于协调节点知道每个文档存在于哪个分片中。它将整个多文档请求分解成每个分片的多文档请求，并且将这些请求并行转发到每个参与节点。协调节点一旦收到来自每个节点的应答，就将每个节点的响应收集整理成单个响应，返回给客户端。</p><p><img src="https://img-blog.csdnimg.cn/f6fcc343560d4722bb4d1d869f6777bd.png#pic_center" alt="在这里插入图片描述"></p><p>用单个 mget 请求取回多个文档所需的步骤顺序:</p><ul><li>客户端向 Node 1 发送 mget 请求。</li><li>Node 1为每个分片构建多文档获取请求，然后并行转发这些请求到托管在每个所需的主分片或者副本分片的节点上。一旦收到所有答复，Node 1 构建响应并将其返回给客户端。</li></ul><p>可以对docs数组中每个文档设置routing参数。bulk API， 允许在单个批量请求中执行多个创建、索引、删除和更新请求</p><p><img src="https://img-blog.csdnimg.cn/82cc4b59c9154ad7a07a73949d0025e1.png#pic_center" alt="在这里插入图片描述"></p><p>bulk API 按如下步骤顺序执行：</p><ul><li>客户端向Node 1 发送 bulk请求</li><li>Node 1为每个节点创建一个批量请求，并将这些请求并行转发到每个包含主分片的节点主机</li><li>主分片一个接一个按顺序执行每个操作。当每个操作成功时,主分片并行转发新文档（或删除）到副本分片，然后执行下一个操作。一旦所有的副本分片报告所有操作成功，该节点将向协调节点报告成功，协调节点将这些响应收集整理并返回给客户端。</li></ul><h2 id="4、分片原理">4、分片原理</h2><p>分片是Elasticsearch最小的工作单元。但是究竟什么是一个分片，它是如何工作的？传统的数据库每个字段存储单个值，但这对全文检索并不够。文本字段中的每个单词需要被搜索，对数据库意味着需要单个字段有索引多值的能力。最好的支持是一个字段多个值需求的数据结构是<strong>倒排索引</strong>。</p><h3 id="4-1-倒排索引">4.1 倒排索引</h3><blockquote><p>Elasticsearch使用一种称为倒排索引的结构，它适用于快速的全文搜索。见其名，知其意，有倒排索引，肯定会对应有正向索引。正向索引（forward index），反向索引（inverted index）更熟悉的名字是倒排索引。<strong>倒排索引（Inverted Index）也叫反向索引</strong>，有反向索引必有正向索引。通俗地来讲，正向索引是通过key找value，反向索引则是通过value找key</p></blockquote><ul><li><strong>Term（单词）</strong>：一段文本经过分析器分析以后就会输出一串单词，这一个一个的就叫做Term（直译为：单词）</li><li><strong>Term Dictionary（单词字典</strong>）：顾名思义，它里面维护的是Term，可以理解为Term的集合</li><li><strong>Term Index（单词索引</strong>）：为了更快的找到某个单词，我们为单词建立索引</li><li><strong>Posting List（倒排列表）</strong>：倒排列表记录了出现过某个单词的所有文档的文档列表及单词在该文档中出现的位置信息，每条记录称为一个倒排项(Posting)。根据倒排列表，即可获知哪些文档包含某个单词。（PS：实际的倒排列表中并不只是存了文档ID这么简单，还有一些其它的信息，比如：词频（Term出现的次数）、偏移量（offset）等，可以想象成是Python中的元组，或者Java中的对象）</li></ul><p><strong>索引是为了提高数据的查询速度，相当于给数据进行编号，在查找数据的时候就可以通过编号快速找到相应的数据</strong>。在倒排索引中，通过Term索引可以找到Term在Term Dictionary中的位置，进而找到Posting List，有了倒排列表就可以根据ID找到文档了</p><p><img src="https://img-blog.csdnimg.cn/607ec8f93214408fb0713413af6e8789.png#pic_center" alt="在这里插入图片描述"></p><h3 id="4-2-文档搜索">4.2 文档搜索</h3><p>早期的全文检索会为整个文档集合建立一个很大的倒排索引并将其写入到磁盘。 一旦新的索引就绪，旧的就会被其替换，这样最近的变化便可以被检索到。</p><ul><li>倒排索引被写入磁盘后是不可改变的：它永远不会修改。</li><li>不需要锁。如果你从来不更新索引，你就不需要担心多进程同时修改数据的问题。</li><li>一旦索引被读入内核的文件系统缓存，便会留在哪里，由于其不变性。只要文件系统缓存中还有足够的空间，那么大部分读请求会直接请求内存，而不会命中磁盘。这提供了很大的性能提升。</li><li>其它缓存(像filter缓存)，在索引的生命周期内始终有效。它们不需要在每次数据改变时被重建，因为数据不会变化。</li><li>写入单个大的倒排索引允许数据被压缩，减少磁盘IO和需要被缓存到内存的索引的使用量。</li></ul><p>当然，一个不变的索引也有不好的地方。主要事实是它是<strong>不可变</strong>的! 你不能修改它。如果你需要让一个新的文档可被搜索，你需要<strong>重建整个索引</strong>。这要么对一个索引所能包含的数据量造成了很大的限制，要么对索引可被更新的频率造成了很大的限制。</p><h3 id="4-3-动态更新索引">4.3 动态更新索引</h3><p>如何在保留不变性的前提下实现倒排索引的更新？答案是：用更多的索引。通过增加新的补充索引来反映新近的修改，而不是直接重写整个倒排索引。每一个倒排索引都会被轮流查询到,从最早的开始查询完后再对结果进行合并。</p><p>Elasticsearch基于Lucene，这个java库引入了<strong>按段搜索</strong>的概念。<strong>每一段本身都是一个倒排索引</strong>，但索引在 Lucene 中除表示所有段的集合外，还增加了提交点的概念—一个列出了所有已知段的文件。按段搜索会以如下流程执行：</p><ul><li>新文档被收集到内存索引缓存</li><li>不时地, 缓存被提交<ul><li>一个新的段，一个追加的倒排索引，被写入磁盘</li><li>一个新的包含新段名字的提交点被写入磁盘</li><li>磁盘进行同步，所有在文件系统缓存中等待的写入都刷新到磁盘，以确保它们被写入物理文件</li></ul></li><li>新的段被开启，让它包含的文档可见以被搜索</li><li>内存缓存被清空，等待接收新的文档</li></ul><p>当一个查询被触发，所有已知的段按顺序被查询。词项统计会对所有段的结果进行聚合，以保证每个词和每个文档的关联都被准确计算。这种方式可以用相对较低的成本将新文档添加到索引。<strong>段是不可改变的</strong>，所以既不能从把文档从旧的段中移除，也不能修改旧的段来进行反映文档的更新。取而代之的是，每个提交点会包含一个.del 文件，文件中会列出这些被删除文档的段信息。</p><p>当一个**文档被“删除”**时，它实际上只是在 .del 文件中被标记删除。一个被标记删除的文档仍然可以被查询匹配到，但它会在最终结果被返回前从结果集中移除。文档更新也是类似的操作方式:当一个文档被更新时，旧版本文档被标记删除，文档的新版本被索引到一个新的段中。可能两个版本的文档都会被一个查询匹配到，但被删除的那个旧版本文档在结果集返回前就已经被移除。</p><h3 id="4-4-文档刷新-文档刷写-文档合并">4.4 文档刷新 &amp; 文档刷写 &amp; 文档合并</h3><p><img src="https://img-blog.csdnimg.cn/5494e2f3794a480d9bdd63251b6c9345.png#pic_center" alt="在这里插入图片描述"></p><h4 id="近实时搜索">近实时搜索</h4><p>随着按段（per-segment）搜索的发展，一个新的文档从索引到可被搜索的延迟显著降低了。新文档在几分钟之内即可被检索，但这样还是不够快。磁盘在这里成为了瓶颈。提交（Commiting）<strong>一个新的段到磁盘需要一个fsync来确保段被物理性地写入磁盘</strong>，这样在断电的时候就不会丢失数据。但是fsync操作代价很大；如果每次索引一个文档都去执行一次的话会造成很大的性能问题。</p><p>我们需要的是一个更轻量的方式来使一个文档可被搜索，这意味着fsync要从整个过程中被移除。在Elasticsearch和磁盘之间是<strong>文件系统缓存</strong>。像之前描述的一样，在内存索引缓冲区中的文档会被写入到一个新的段中。但是这里新段会被先写入到文件系统缓存—这一步代价会比较低，稍后再被刷新到磁盘—这一步代价比较高。不过只要文件已经在缓存中，就可以像其它文件一样被打开和读取了</p><p><img src="https://img-blog.csdnimg.cn/05444e1f966a435ab03e8315aed257a5.png#pic_center" alt="在这里插入图片描述"></p><p>Lucene允许新段被写入和打开，使其包含的文档在未进行一次完整提交时便对搜索可见。这种方式比进行一次提交代价要小得多，并且在不影响性能的前提下可以被频繁地执行。在 Elasticsearch 中，写入和打开一个新段的轻量的过程叫做refresh。默认情况下每个分片会<strong>每秒自动刷新一次</strong>。这就是为什么我们说 Elasticsearch是近实时搜索：文档的变化并不是立即对搜索可见，但会在一秒之内变为可见。</p><p>这些行为可能会对新用户造成困惑：他们索引了一个文档然后尝试搜索它，但却没有搜到。这个问题的解决办法是用refresh API执行一次手动刷新：<strong>/usersl_refresh</strong>。尽管刷新是比提交轻量很多的操作，它还是会有性能开销。当写测试的时候，手动刷新很有用，但是不要在生产环境下每次索引一个文档都去手动刷新。相反，你的应用需要意识到Elasticsearch 的近实时的性质，并接受它的不足。并不是所有的情况都需要每秒刷新。可能你正在使用Elasticsearch索引大量的日志文件，你可能想优化索引速度而不是近实时搜索，可以通过设置<code>refresh_interval</code> ，降低每个索引的刷新频率</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"settings"</span>: &#123;</span><br><span class="line">      <span class="string">"refresh_interval"</span>: <span class="string">"30s"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># refresh_interval可以在既存索引上进行动态更新。</span></span><br><span class="line"><span class="comment"># 在生产环境中，当你正在建立一个大的新索引时，可以先关闭自动刷新，待开始使用该索引时，再把它们调回来。</span></span><br><span class="line"><span class="comment"># 关闭自动刷新</span></span><br><span class="line">PUT /users/_settings</span><br><span class="line">&#123; <span class="string">"refresh_interval"</span>: -1 &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每一秒刷新</span></span><br><span class="line">PUT /users/_settings</span><br><span class="line">&#123; <span class="string">"refresh_interval"</span>: <span class="string">"1s"</span> &#125;</span><br></pre></td></tr></table></figure><h4 id="持久化变更">持久化变更</h4><p>如果没有用fsync把数据从文件系统缓存刷（flush）到硬盘，我们不能保证数据在断电甚至是程序正常退出之后依然存在。为了保证Elasticsearch 的可靠性，需要确保数据变化被持久化到磁盘。在动态更新索引，我们说一次完整的提交会将段刷到磁盘，并写入一个包含所有段列表的提交点。Elasticsearch 在启动或重新打开一个索引的过程中使用这个提交点来判断哪些段隶属于当前分片。</p><p>即使<strong>通过每秒刷新(refresh）实现了近实时搜索</strong>，我们仍然需要经常进行完整提交来确保能从失败中恢复。但在两次提交之间发生变化的文档怎么办?我们也不希望丢失掉这些数据。Elasticsearch 增加了一个<strong>translog ，或者叫事务日志</strong>，在每一次对Elasticsearch进行操作时均进行了日志记录。整个流程如下:</p><ul><li><p>一个文档被索引之后，就会被添加到内存缓冲区，并且追加到了 translog</p><p><img src="https://img-blog.csdnimg.cn/e05d0542279149dfacf9950e47c5b3c8.png#pic_center" alt="在这里插入图片描述"></p></li><li><p>刷新（refresh）使分片每秒被刷新（refresh）一次</p><ul><li>这些在内存缓冲区的文档被写入到一个新的段中，且没有进行fsync操作</li><li>这个段被打开，使其可被搜索</li><li>内存缓冲区被清空<br><img src="https://img-blog.csdnimg.cn/56e2eb18879b41a7944adf83da53f341.png#pic_center" alt="在这里插入图片描述"></li></ul></li><li><p>这个进程继续工作，更多的文档被添加到内存缓冲区和追加到事务日志</p></li><li><p>每隔一段时间—例如translog变得越来越大，索引被刷新（flush）；一个新的translog被创建，并且一个全量提交被执行</p><ul><li>所有在内存缓冲区的文档都被写入一个新的段。</li><li>缓冲区被清空。</li><li>一个提交点被写入硬盘。</li><li>文件系统缓存通过fsync被刷新（flush） 。</li><li>老的translog被删除</li></ul></li></ul><p>translog 提供所有还没有被刷到磁盘的操作的一个持久化纪录。当Elasticsearch启动的时候，它会<strong>从磁盘中使用最后一个提交点去恢复己知的段，并且会重放translog 中所有在最后一次提交后发生的变更操作</strong>。translog 也被用来提供实时CRUD。当你试着通过ID查询、更新、删除一个文档，它会在尝试从相应的段中检索之前，首先检查 translog任何最近的变更。这意味着它总是能够实时地获取到文档的最新版本。</p><p><img src="https://img-blog.csdnimg.cn/f08c35ca0a004fb5879534ab32db320a.png#pic_center" alt="在这里插入图片描述"></p><h4 id="段合并">段合并</h4><p>由于自动刷新流程每秒会创建一个新的段，这样会导致短时间内的段数量暴增。而段数目太多会带来较大的麻烦。每一个段都会消耗文件句柄、内存和 cpu运行周期。更重要的是，每个搜索请求都必须轮流检查每个段；所以段越多，搜索也就越慢。</p><p>Elasticsearch通过在后台进行段合并来解决这个问题。小的段被合并到大的段，然后这些大的段再被合并到更大的段。<strong>段合并的时候会将那些旧的已删除文档从文件系统中清除。被删除的文档（或被更新文档的旧版本）不会被拷贝到新的大段中</strong>。启动段合并不需要你做任何事。进行索引和搜索时会自动进行。</p><ul><li><p>当索引的时候，刷新（refresh）操作会创建新的段并将段打开以供搜索使用</p></li><li><p>合并进程选择一小部分大小相似的段，并且在后台将它们合并到更大的段中。这并不会中断索引和搜索</p><p><img src="https://img-blog.csdnimg.cn/38f0b668fb2f4dd4af44b7c98a0cf650.png#pic_center" alt="在这里插入图片描述"></p></li><li><p>一旦合并结束，老的段被删除</p><ul><li>新的段被刷新(flush)到了磁盘</li><li>写入一个包含新段且排除旧的和较小的段的新提交点</li><li>新的段被打开用来搜索。老的段被删除</li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/af28e9ed86c74e63a4ecc5b2b3257d81.png#pic_center" alt="在这里插入图片描述"></p><p>合并大的段需要消耗大量的 I/O 和 CPU 资源，如果任其发展会影响搜索性能。 Elasticsearch在默认情况下会对合并流程进行资源限制，所以搜索仍然有足够的资源很好地执行</p><h3 id="4-5-文档分析">4.5 文档分析</h3><p>分析包含下面的过程：</p><ul><li>将一块文本分成适合于倒排索引的独立的词条</li><li>将这些词条统一化为标准格式以提高它们的“可搜索性”，或者recall</li></ul><p>分析器执行上面的工作。分析器实际上是将三个功能封装到了一个包里：</p><ul><li>字符过滤器：首先，字符串按顺序通过每个 字符过滤器 。他们的任务是在分词前整理字符串。一个字符过滤器可以用来去掉 HTML，或者将 &amp; 转化成 and。</li><li>分词器：其次，字符串被分词器分为单个的词条。一个简单的分词器遇到空格和标点的时候，可能会将文本拆分成词条。</li><li>Token 过滤器：最后，词条按顺序通过每个 token 过滤器 。这个过程可能会改变词条（例如，小写化Quick ），删除词条（例如， 像 a， and， the 等无用词），或者增加词条（例如，像jump和leap这种同义词）</li></ul><h4 id="内置分析器">内置分析器</h4><p>Elasticsearch还附带了可以直接使用的预包装的分析器。接下来我们会列出最重要的分析器。为了证明它们的差异，我们看看每个分析器会从下面的字符串得到哪些词条：<code>&quot;Set the shape to semi-transparent by calling set_trans(5)&quot;</code></p><ul><li>标准分析器</li></ul><p>标准分析器是Elasticsearch 默认使用的分析器。它是分析各种语言文本最常用的选择。它根据Unicode 联盟定义的单词边界划分文本。删除绝大部分标点。最后，将词条小写。它会产生：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>, the, shape, to, semi, transparent, by, calling, set_trans, 5</span><br></pre></td></tr></table></figure><ul><li>简单分析器</li></ul><p>简单分析器在任何不是字母的地方分隔文本，将词条小写</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>, the, shape, to, semi, transparent, by, calling, <span class="built_in">set</span>, trans</span><br></pre></td></tr></table></figure><ul><li>空格分析器</li></ul><p>空格分析器在空格的地方划分文本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set, the, shape, to, semi-transparent, by, calling, set_trans(5)</span><br></pre></td></tr></table></figure><ul><li>语言分析器</li></ul><p>特定语言分析器可用于很多语言。它们可以考虑指定语言的特点。例如，英语分析器附带了一组英语无用词（常用单词，例如and或者the ,它们对相关性没有多少影响），它们会被删除。由于理解英语语法的规则，这个分词器可以提取英语单词的词干。英语分词器会产生下面的词条（注意看transparent、calling和 set_trans已经变为词根格式）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>, shape, semi, transpar, call, set_tran, 5</span><br></pre></td></tr></table></figure><h4 id="分析器使用场景">分析器使用场景</h4><p>当我们索引一个文档，它的全文域被分析成词条以用来创建倒排索引。但是，当我们在全文域搜索的时候，我们需要将查询字符串通过相同的分析过程，以保证我们搜索的词条格式与索引中的词条格式一致。全文查询，理解每个域是如何定义的，因此它们可以做正确的事：</p><ul><li>当你查询一个全文域时，会对查询字符串应用相同的分析器，以产生正确的搜索词条列表</li><li>当你查询一个精确值域时，不会分析查询字符串，而是搜索你指定的精确值</li></ul><h4 id="测试分析器">测试分析器</h4><p>有些时候很难理解分词的过程和实际被存储到索引中的词条，特别是你刚接触Elasticsearch。为了理解发生了什么，你可以使用analyze API来看文本是如何被分析的。在消息体里，指定分析器和要分析的文本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#GET http://localhost:9200/_analyze</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"analyzer"</span>: <span class="string">"standard"</span>,</span><br><span class="line">    <span class="string">"text"</span>: <span class="string">"Text to analyze"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>token是实际存储到索引中的词条。</li><li>start_ offset 和end_ offset指明字符在原始字符串中的位置。</li><li>position指明词条在原始文本中出现的位置。</li></ul><h4 id="指定分析器">指定分析器</h4><p>当Elasticsearch在你的文档中检测到一个新的字符串域，它会自动设置其为一个全文字符串域，使用 标准 分析器对它进行分析。你不希望总是这样。可能你想使用一个不同的分析器，适用于你的数据使用的语言。有时候你想要一个字符串域就是一个字符串域，不使用分析，直接索引你传入的精确值，例如用户 ID 或者一个内部的状态域或标签。要做到这一点，我们必须手动指定这些域的映射。（细粒度指定分析器）</p><h4 id="IK分词器">IK分词器</h4><p>当我们发送&quot;测试单词&quot;时，默认分词器会将每个字都分开，这不符合不符合我们的使用要求，所以我们需要下载 ES 对应版本的中文分词器</p><blockquote><p><a href="https://github.com/medcl/elasticsearch-analysis-ik/releases/tag/v7.8.0" target="_blank" rel="noopener" title="IK 中文分词器下载网址">IK 中文分词器下载网址</a></p></blockquote><p>将解压后的后的文件夹放入 ES 根目录下的 plugins 目录下，重启 ES 即可使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># GET http://localhost:9200/_analyze</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"text"</span>:<span class="string">"测试单词"</span>,</span><br><span class="line">  <span class="string">"analyzer"</span>:<span class="string">"ik_max_word"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ik_max_word：会将文本做最细粒度的拆分</li><li>ik_smart：会将文本做最粗粒度的拆分</li></ul><p>ES 中也可以进行扩展词汇，首先查询</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#GET http://localhost:9200/_analyze</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"text"</span>:<span class="string">"弗雷尔卓德"</span>,</span><br><span class="line">    <span class="string">"analyzer"</span>:<span class="string">"ik_max_word"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先进入 ES 根目录中的 plugins 文件夹下的 ik 文件夹，进入 config 目录，创建 custom.dic文件，写入&quot;弗雷尔卓德&quot;</li><li>同时打开 <code>IKAnalyzer.cfg.xml </code>文件，将新建的 custom.dic 配置其中</li><li>重启 ES 服务器 </li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">properties</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"http://java.sun.com/dtd/properties.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">comment</span>&gt;</span>IK Analyzer 扩展配置<span class="tag">&lt;/<span class="name">comment</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--用户可以在这里配置自己的扩展字典 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"ext_dict"</span>&gt;</span>custom.dic<span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--用户可以在这里配置自己的扩展停止词字典--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"ext_stopwords"</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--用户可以在这里配置远程扩展字典 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;entry key="remote_ext_dict"&gt;words_location&lt;/entry&gt; --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--用户可以在这里配置远程扩展停止词字典--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;entry key="remote_ext_stopwords"&gt;words_location&lt;/entry&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="自定义分析器">自定义分析器</h4><p>虽然Elasticsearch带有一些现成的分析器，然而在分析器上Elasticsearch真正的强大之处在于，你可以通过在一个适合你的特定数据的设置之中组合字符过滤器、分词器、词汇单元过滤器来创建自定义的分析器。在分析与分析器我们说过，一个分析器就是在一个包里面组合了三种函数的一个包装器，三种函数按照顺序被执行</p><ul><li>字符过滤器</li></ul><p>字符过滤器用来整理一个尚未被分词的字符串。例如，如果我们的文本是HTML格式的，它会包含像<code>&lt;p&gt;</code>或者<code>&lt;div&gt;</code>这样的HTML标签，这些标签是我们不想索引的。我们可以使用html清除字符过滤器来移除掉所有的HTML标签，并且像把<code>&amp;Aacute;</code>转换为相对应的Unicode字符Á 这样，转换HTML实体。一个分析器可能有0个或者多个字符过滤器。</p><ul><li>分词器</li></ul><p>一个分析器必须有一个唯一的分词器。分词器把字符串分解成单个词条或者词汇单元。标准分析器里使用的标准分词器把一个字符串根据单词边界分解成单个词条，并且移除掉大部分的标点符号，然而还有其他不同行为的分词器存在。例如，关键词分词器完整地输出接收到的同样的字符串，并不做任何分词。空格分词器只根据空格分割文本。正则分词器根据匹配正则表达式来分割文本。</p><ul><li>词单元过滤器</li></ul><p>经过分词，作为结果的词单元流会按照指定的顺序通过指定的词单元过滤器。词单元过滤器可以修改、添加或者移除词单元。我们已经提到过lowercase和stop词过滤器，但是在Elasticsearch 里面还有很多可供选择的词单元过滤器。词干过滤器把单词遏制为词干。ascii_folding过滤器移除变音符，把一个像&quot;très”这样的词转换为“tres”。ngram和 edge_ngram词单元过滤器可以产生适合用于部分匹配或者自动补全的词单元。</p><ul><li>自定义分析器例子</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#PUT http://localhost:9200/my_index</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"settings"</span>: &#123;</span><br><span class="line">        <span class="string">"analysis"</span>: &#123;</span><br><span class="line">            <span class="string">"char_filter"</span>: &#123;</span><br><span class="line">                <span class="string">"&amp;_to_and"</span>: &#123;</span><br><span class="line">                    <span class="string">"type"</span>: <span class="string">"mapping"</span>, </span><br><span class="line">                    <span class="string">"mappings"</span>: [</span><br><span class="line">                        <span class="string">"&amp;=&gt; and "</span></span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, </span><br><span class="line">            <span class="string">"filter"</span>: &#123;</span><br><span class="line">                <span class="string">"my_stopwords"</span>: &#123;</span><br><span class="line">                    <span class="string">"type"</span>: <span class="string">"stop"</span>, </span><br><span class="line">                    <span class="string">"stopwords"</span>: [</span><br><span class="line">                        <span class="string">"the"</span>, </span><br><span class="line">                        <span class="string">"a"</span></span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, </span><br><span class="line">            <span class="string">"analyzer"</span>: &#123;</span><br><span class="line">                <span class="string">"my_analyzer"</span>: &#123;</span><br><span class="line">                    <span class="string">"type"</span>: <span class="string">"custom"</span>, </span><br><span class="line">                    <span class="string">"char_filter"</span>: [</span><br><span class="line">                        <span class="string">"html_strip"</span>, </span><br><span class="line">                        <span class="string">"&amp;_to_and"</span></span><br><span class="line">                    ], </span><br><span class="line">                    <span class="string">"tokenizer"</span>: <span class="string">"standard"</span>, </span><br><span class="line">                    <span class="string">"filter"</span>: [</span><br><span class="line">                        <span class="string">"lowercase"</span>, </span><br><span class="line">                        <span class="string">"my_stopwords"</span></span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>索引被创建以后，使用 analyze API 来 测试这个新的分析器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># GET http://127.0.0.1:9200/my_index/_analyze</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"text"</span>:<span class="string">"The quick &amp; brown fox"</span>,</span><br><span class="line">    <span class="string">"analyzer"</span>: <span class="string">"my_analyzer"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-6-文档控制">4.6 文档控制</h3><h4 id="文档冲突">文档冲突</h4><p>当我们使用index API更新文档，可以一次性读取原始文档，做我们的修改，然后重新索引整个文档。最近的索引请求将获胜：无论最后哪一个文档被索引，都将被唯一存储在 Elasticsearch 中。如果其他人同时更改这个文档，他们的更改将丢失。</p><p>很多时候这是没有问题的。也许我们的主数据存储是一个关系型数据库，我们只是将数据复制到Elasticsearch中并使其可被搜索。也许两个人同时更改相同的文档的几率很小。或者对于我们的业务来说偶尔丢失更改并不是很严重的问题。但有时丢失了一个变更就是非常严重的。变更越频繁，读数据和更新数据的间隙越长，也就越可能丢失变更。在数据库领域中，有两种方法通常被用来确保并发更新时变更不会丢失：</p><ul><li>悲观并发控制：这种方法被关系型数据库广泛使用，它假定有变更冲突可能发生，因此阻塞访问资源以防止冲突。一个典型的例子是读取一行数据之前先将其锁住，确保只有放置锁的线程能够对这行数据进行修改。</li><li>乐观并发控制：Elasticsearch 中使用的这种方法假定冲突是不可能发生的，并且不会阻塞正在尝试的操作。然而，如果源数据在读写当中被修改，更新将会失败。应用程序接下来将决定该如何解决冲突。例如，可以重试更新、使用新的数据、或者将相关情况报告给用户。</li></ul><h4 id="乐观并发控制">乐观并发控制</h4><p>Elasticsearch是分布式的。当文档创建、更新或删除时，新版本的文档必须复制到集群中的其他节点。Elasticsearch也是异步和并发的，这意味着这些复制请求被并行发送，并且到达目的地时也许顺序是乱的。Elasticsearch需要一种方法确保文档的旧版本不会覆盖新的版本。</p><p>当我们之前讨论index , GET和DELETE请求时，我们指出每个文档都有一个<code>_version</code>（版本号），当文档被修改时版本号递增。Elasticsearch使用这个version号来确保变更以正确顺序得到执行。如果旧版本的文档在新版本之后到达，它可以被简单的忽略。我们可以利用version号来确保应用中相互冲突的变更不会导致数据丢失。我们通过指定想要修改文档的 version号来达到这个目的。如果该版本不是当前版本号，我们的请求将会失败。老的版本es使用version，但是新版本不支持了，会报下面的错误，提示我们用<code>if_seq _no</code>和<code>if _primary_term</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建索引数据</span></span><br><span class="line">PUT http://127.0.0.1:9200/shopping/_create/1001</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"title"</span>:<span class="string">"小米手机"</span>,</span><br><span class="line">    <span class="string">"category"</span>:<span class="string">"小米"</span>,</span><br><span class="line">    <span class="string">"images"</span>:<span class="string">"http://www.gulixueyuan.com/xm.jpg"</span>,</span><br><span class="line">    <span class="string">"price"</span>:3999.00</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 返回值</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"_index"</span>: <span class="string">"shopping"</span>,</span><br><span class="line">    <span class="string">"_type"</span>: <span class="string">"_doc"</span>,</span><br><span class="line">    <span class="string">"_id"</span>: <span class="string">"1001"</span>,</span><br><span class="line">    <span class="string">"_version"</span>: 1,</span><br><span class="line">    <span class="string">"result"</span>: <span class="string">"created"</span>,</span><br><span class="line">    <span class="string">"_shards"</span>: &#123;</span><br><span class="line">        <span class="string">"total"</span>: 2,</span><br><span class="line">        <span class="string">"successful"</span>: 1,</span><br><span class="line">        <span class="string">"failed"</span>: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"_seq_no"</span>: 0,</span><br><span class="line">    <span class="string">"_primary_term"</span>: 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 旧版本使用的防止冲突更新方法</span></span><br><span class="line">POST http://127.0.0.1:9200/shopping/_update/1001?version=1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"doc"</span>: &#123;</span><br><span class="line">        <span class="string">"title"</span>: <span class="string">"小米手机2"</span>,</span><br><span class="line">        <span class="string">"category"</span>: <span class="string">"小米"</span>,</span><br><span class="line">        <span class="string">"images"</span>: <span class="string">"http://www.gulixueyuan.com/xm.jpg"</span>,</span><br><span class="line">        <span class="string">"price"</span>: 4999.00</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新版本使用的防止冲突更新方法：</span></span><br><span class="line">POST http://127.0.0.1:9200/shopping/_update/1001?if_seq_no=1&amp;if_primary_term=1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"doc"</span>: &#123;</span><br><span class="line">        <span class="string">"title"</span>: <span class="string">"小米手机2"</span>,</span><br><span class="line">        <span class="string">"category"</span>: <span class="string">"小米"</span>,</span><br><span class="line">        <span class="string">"images"</span>: <span class="string">"http://www.gulixueyuan.com/xm.jpg"</span>,</span><br><span class="line">        <span class="string">"price"</span>: 4999.00</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="外部系统版本控制">外部系统版本控制</h4><p>一个常见的设置是使用其它数据库作为主要的数据存储，使用Elasticsearch做数据检索，这意味着主数据库的所有更改发生时都需要被复制到Elasticsearch，如果多个进程负责这一数据同步，你可能遇到类似于之前描述的并发问题。</p><p>如果你的主数据库已经有了版本号，或一个能作为版本号的字段值比如timestamp，那么你就可以在 Elasticsearch 中通过增加<code> version_type=extermal</code>到查询字符串的方式重用这些相同的版本号，版本号必须是大于零的整数，且小于9.2E+18，一个Java中 long类型的正值。外部版本号的处理方式和我们之前讨论的内部版本号的处理方式有些不同，Elasticsearch不是检查当前<code>_version</code>和请求中指定的版本号是否相同，而是检查当前<code>_version</code>是否小于指定的版本号。如果请求成功，外部的版本号作为文档的新<code>_version</code>进行存储。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#POST http://127.0.0.1:9200/shopping/_doc/1001?version=100&amp;version_type=external</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="string">"title"</span>: <span class="string">"小米手机2"</span>,</span><br><span class="line">        <span class="string">"category"</span>: <span class="string">"小米"</span>,</span><br><span class="line">        <span class="string">"images"</span>: <span class="string">"http://www.gulixueyuan.com/xm.jpg"</span>,</span><br><span class="line">        <span class="string">"price"</span>: 4999.00</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-7-文档展示-Kibana">4.7 文档展示-Kibana</h3><blockquote><p>Kibana是一个免费且开放的用户界面，能够让你对Elasticsearch 数据进行可视化，并让你在Elastic Stack 中进行导航。你可以进行各种操作，从跟踪查询负载，到理解请求如何流经你的整个应用，都能轻松完成。<br><a href="https://artifacts.elastic.co/downloads/kibana/kibana-7.8.0-windows-x86_64.zip" target="_blank" rel="noopener" title="Kibana下载网址">Kibana下载网址</a></p></blockquote><ul><li><p>解压缩下载的 zip 文件</p></li><li><p>修改 <code>config/kibana.yml</code> 文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认端口</span></span><br><span class="line"><span class="attr">server.port:</span> <span class="number">5601</span></span><br><span class="line"><span class="comment"># ES 服务器的地址</span></span><br><span class="line"><span class="attr">elasticsearch.hosts:</span> <span class="string">["http://localhost:9200"]</span></span><br><span class="line"><span class="comment"># 索引名</span></span><br><span class="line"><span class="attr">kibana.index:</span> <span class="string">".kibana"</span></span><br><span class="line"><span class="comment"># 支持中文</span></span><br><span class="line"><span class="attr">i18n.locale:</span> <span class="string">"zh-CN"</span></span><br></pre></td></tr></table></figure></li><li><p>Windows 环境下执行 bin/kibana.bat 文件（首次启动有点耗时）</p></li><li><p>通过浏览器访问：<code>http://localhost:5601</code>，选择控制台，打开可以验证<code>GET shopping/_doc/1001</code></p></li></ul><h1>五、Elasticsearch 集成</h1><h2 id="1、SpringData-框架集成">1、SpringData 框架集成</h2><h3 id="1-1-Spring-Data-框架使用">1.1 Spring Data 框架使用</h3><blockquote><p><a href="https://spring.io/projects/spring-data" target="_blank" rel="noopener" title="Spring Data 的官网">Spring Data 的官网</a></p></blockquote><p>pring Data是一个用于简化数据库、非关系型数据库、索引库访问，并支持云服务的开源框架。其主要目标是使得对数据的访问变得方便快捷，并支持 map-reduce框架和云计算数据服务。Spring Data可以极大的简化JPA(Elasticsearch…)的写法，可以在几乎不用写实现的情况下，实现对数据的访问和操作。除了CRUD 外，还包括如分页、排序等一些常用的功能。</p><h3 id="1-2-Spring-Data-Elasticsearch-介绍">1.2 Spring Data Elasticsearch 介绍</h3><blockquote><p><a href="https://spring.io/projects/spring-data-elasticsearch" target="_blank" rel="noopener" title="Spring Data Elasticsearch 官网">Spring Data Elasticsearch 官网</a></p></blockquote><p>Spring Data Elasticsearch基于Spring Data API简化 Elasticsearch 操作，将原始操作Elasticsearch 的客户端API进行封装。Spring Data为Elasticsearch 项目提供集成搜索引擎。Spring Data Elasticsearch POJO的关键功能区域为中心的模型与Elastichsearch交互文档和轻松地编写一个存储索引库数据访问层</p><h3 id="1-3-框架集成">1.3 框架集成</h3><p>首先新建项目，引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springdata-elasticsearch-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-elasticsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        自动配置注解处理器，及spring-boot-configuration-processor。--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 resources 目录中增加<code>application.yml</code>文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">elasticsearch:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="comment"># es 服务地址</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9200</span> <span class="comment"># es 服务端口</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置日志级别,开启 debug 日志</span></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">com.cjz.study:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure><p>创建数据实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@Document</span>(indexName = <span class="string">"shopping"</span>,shards = <span class="number">3</span>,replicas = <span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//必须有 id,这里的 id 是全局唯一的标识，等同于 es 中的"_id"</span></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id;<span class="comment">//商品唯一标识</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * type : 字段数据类型</span></span><br><span class="line"><span class="comment">     * analyzer : 分词器类型</span></span><br><span class="line"><span class="comment">     * index : 是否索引(默认:true)</span></span><br><span class="line"><span class="comment">     * Keyword : 短语,不进行分词</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Field</span>(type = FieldType.Text, analyzer = <span class="string">"ik_max_word"</span>)</span><br><span class="line">    <span class="keyword">private</span> String title;<span class="comment">//商品名称</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field</span>(type = FieldType.Keyword)</span><br><span class="line">    <span class="keyword">private</span> String category;<span class="comment">//分类名称 表示该字段内容是一个文本并作为一个整体不可分，默认建立索引</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field</span>(type = FieldType.Double)</span><br><span class="line">    <span class="keyword">private</span> Double price;<span class="comment">//商品价格</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field</span>(type = FieldType.Keyword, index = <span class="keyword">false</span>)</span><br><span class="line">    <span class="keyword">private</span> String images;<span class="comment">//图片地址</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置类</p><ul><li>ElasticsearchRestTemplate是spring-data-elasticsearch项目中的一个类,和其他spring项目中的 template类似。</li><li>在新版的spring-data-elasticsearch 中，ElasticsearchRestTemplate 代替了原来的ElasticsearchTemplate</li><li>原因是ElasticsearchTemplate基于TransportClient，TransportClient即将在8.x 以后的版本中移除。所以，我们推荐使用ElasticsearchRestTemplate</li><li>ElasticsearchRestTemplate基于RestHighLevelClient客户端的。需要自定义配置类，继承AbstractElasticsearchConfiguration，并实现elasticsearchClient()抽象方法，创建RestHighLevelClient对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractElasticsearchConfiguration</span> <span class="keyword">extends</span> <span class="title">ElasticsearchConfigurationSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//需重写本方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> RestHighLevelClient <span class="title">elasticsearchClient</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name = &#123; <span class="string">"elasticsearchOperations"</span>, <span class="string">"elasticsearchTemplate"</span> &#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ElasticsearchOperations <span class="title">elasticsearchOperations</span><span class="params">(ElasticsearchConverter elasticsearchConverter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ElasticsearchRestTemplate(elasticsearchClient(), elasticsearchConverter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要自定义配置类，继承AbstractElasticsearchConfiguration，并实现elasticsearchClient()抽象方法，创建RestHighLevelClient对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"elasticsearch"</span>)</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElasticsearchConfig</span> <span class="keyword">extends</span> <span class="title">AbstractElasticsearchConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line">    <span class="keyword">private</span> Integer port;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写父类方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestHighLevelClient <span class="title">elasticsearchClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RestClientBuilder builder = RestClient.builder(<span class="keyword">new</span> HttpHost(host, port));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span></span><br><span class="line">                RestHighLevelClient(builder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建DAO 数据访问对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProductDao</span> <span class="keyword">extends</span> <span class="title">ElasticsearchRepository</span>&lt;<span class="title">Product</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-集成测试-索引操作">1.4 集成测试-索引操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">// 选择自己主程序的名字</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span>(<span class="title">classes</span> </span>= Application<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">SpringDataESIndexTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//注入 ElasticsearchRestTemplate</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ElasticsearchRestTemplate elasticsearchRestTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建索引并增加映射配置</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建索引，系统初始化会自动创建索引</span></span><br><span class="line">        System.out.println(<span class="string">"创建索引"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建索引并增加映射配置</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建索引，系统初始化会自动创建索引</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = elasticsearchRestTemplate.deleteIndex(Product<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(<span class="string">"删除索引"</span> + flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-集成测试-文档操作">1.5 集成测试-文档操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span>(<span class="title">classes</span> </span>= Application<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">SpringDataESProductDaoTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ProductDao productDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Product product = <span class="keyword">new</span> Product();</span><br><span class="line">        product.setId(<span class="number">2L</span>);</span><br><span class="line">        product.setTitle(<span class="string">"华为手机"</span>);</span><br><span class="line">        product.setCategory(<span class="string">"手机"</span>);</span><br><span class="line">        product.setPrice(<span class="number">2999.0</span>);</span><br><span class="line">        product.setImages(<span class="string">"http://www.atguigu/hw.jpg"</span>);</span><br><span class="line">        productDao.save(product);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//POSTMAN, GET http://localhost:9200/product/_doc/2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Product product = <span class="keyword">new</span> Product();</span><br><span class="line">        product.setId(<span class="number">2L</span>);</span><br><span class="line">        product.setTitle(<span class="string">"小米 2 手机"</span>);</span><br><span class="line">        product.setCategory(<span class="string">"手机"</span>);</span><br><span class="line">        product.setPrice(<span class="number">9999.0</span>);</span><br><span class="line">        product.setImages(<span class="string">"http://www.atguigu/xm.jpg"</span>);</span><br><span class="line">        productDao.save(product);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//POSTMAN, GET http://localhost:9200/product/_doc/2</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getById</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Product product = productDao.findById(<span class="number">2L</span>).orElse(<span class="keyword">new</span> Product());</span><br><span class="line">        System.out.println(product);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Iterable&lt;Product&gt; products = productDao.findAll();</span><br><span class="line">        <span class="keyword">for</span> (Product product : products) &#123;</span><br><span class="line">            System.out.println(product);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Product product = <span class="keyword">new</span> Product();</span><br><span class="line">        product.setId(<span class="number">2L</span>);</span><br><span class="line">        productDao.delete(product);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//POSTMAN, GET http://localhost:9200/product/_doc/2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//批量新增</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Product&gt; productList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Product product = <span class="keyword">new</span> Product();</span><br><span class="line">            product.setId(Long.valueOf(i));</span><br><span class="line">            product.setTitle(<span class="string">"["</span>+i+<span class="string">"]小米手机"</span>);</span><br><span class="line">            product.setCategory(<span class="string">"手机"</span>);</span><br><span class="line">            product.setPrice(<span class="number">1999.0</span> + i);</span><br><span class="line">            product.setImages(<span class="string">"http://www.atguigu/xm.jpg"</span>);</span><br><span class="line">            productList.add(product);</span><br><span class="line">        &#125;</span><br><span class="line">        productDao.saveAll(productList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findByPageable</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Sort sort = Sort.by(Sort.Direction.DESC,<span class="string">"id"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> currentPage=<span class="number">0</span>;<span class="comment">//当前页，第一页从 0 开始， 1 表示第二页</span></span><br><span class="line">        <span class="keyword">int</span> pageSize = <span class="number">5</span>;<span class="comment">//每页显示多少条</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置查询分页</span></span><br><span class="line">        PageRequest pageRequest = PageRequest.of(currentPage, pageSize,sort);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分页查询</span></span><br><span class="line">        Page&lt;Product&gt; productPage = productDao.findAll(pageRequest);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Product Product : productPage.getContent()) &#123;</span><br><span class="line">            System.out.println(Product);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-6-集成测试-文档搜索">1.6 集成测试-文档搜索</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span>(<span class="title">classes</span> </span>= Application<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">SpringDataESSearchTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ProductDao productDao;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">termQuery</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TermQueryBuilder queryBuilders = QueryBuilders.termQuery(<span class="string">"title"</span>, <span class="string">"小米"</span>);</span><br><span class="line">        Iterable&lt;Product&gt; search = productDao.search(queryBuilders);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Product product : search) &#123;</span><br><span class="line">            System.out.println(product);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * term 查询加分页</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">termQueryByPage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> currentPage = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> pageSize = <span class="number">5</span>;</span><br><span class="line">        <span class="comment">//设置查询分页</span></span><br><span class="line">        PageRequest pageRequest = PageRequest.of(currentPage, pageSize);</span><br><span class="line">        TermQueryBuilder termQueryBuilder = QueryBuilders.termQuery(<span class="string">"title"</span>, <span class="string">"小米"</span>);</span><br><span class="line">        Iterable&lt;Product&gt; products =</span><br><span class="line">                productDao.search(termQueryBuilder, pageRequest);</span><br><span class="line">        <span class="keyword">for</span> (Product product : products) &#123;</span><br><span class="line">            System.out.println(product);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、Spark-Streaming-框架集成">2、Spark Streaming 框架集成</h2><h3 id="2-1-Spark-Streaming-框架介绍">2.1 Spark Streaming 框架介绍</h3><p>Spark Streaming 是Spark core API的扩展，支持实时数据流的处理，并且具有可扩展，高吞吐量，容错的特点。数据可以从许多来源获取,如Kafka， Flume，Kinesis或TCP sockets，并且可以使用复杂的算法进行处理，这些算法使用诸如 map，reduce，join和 window等高级函数表示。最后，处理后的数据可以推送到文件系统，数据库等。实际上，您可以将Spark的机器学习和图形处理算法应用于数据流。</p><h3 id="2-2-框架集成">2.2 框架集成</h3><p>创建新的maven空项目，修改pom依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>study-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sparkstreaming-elasticsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.spark<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spark-core_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.spark<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spark-streaming_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- elasticsearch 的客户端 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch-rest-high-level-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- elasticsearch 依赖 2.x 的 log4j --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;dependency&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;version&gt;2.11.1&lt;/version&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;/dependency&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &amp;lt;!&amp;ndash; junit 单元测试 &amp;ndash;&amp;gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;dependency&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;groupId&gt;junit&lt;/groupId&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;artifactId&gt;junit&lt;/artifactId&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;version&gt;4.12&lt;/version&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;/dependency&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>功能实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">object SparkStreamingESTEST &#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">def <span class="title">main</span><span class="params">(args: Array[String])</span>: Unit </span>= &#123;</span><br><span class="line">    val sparkConf = <span class="keyword">new</span> SparkConf().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"ESTest"</span>)</span><br><span class="line">    val ssc = <span class="keyword">new</span> StreamingContext(sparkConf, Seconds(<span class="number">3</span>))</span><br><span class="line">    val ds: ReceiverInputDStream[String] = ssc.socketTextStream(<span class="string">"localhost"</span>, <span class="number">9999</span>)</span><br><span class="line">    ds.foreachRDD(</span><br><span class="line">      rdd =&gt; &#123;</span><br><span class="line">        println(<span class="string">"*************** "</span> + <span class="keyword">new</span> Date())</span><br><span class="line">        rdd.foreach(</span><br><span class="line">          data =&gt; &#123;</span><br><span class="line">            val client = <span class="keyword">new</span> RestHighLevelClient(RestClient.builder(<span class="keyword">new</span> HttpHost(<span class="string">"localhost"</span>, <span class="number">9200</span>, <span class="string">"http"</span>)));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置索引及唯一性标识</span></span><br><span class="line">            val ss = data.split(<span class="string">" "</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 新增文档 - 请求对象</span></span><br><span class="line">            val request = <span class="keyword">new</span> IndexRequest();</span><br><span class="line">            request.index(<span class="string">"product"</span>).id(ss(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">            val json =</span><br><span class="line">              s<span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">                | &#123; "</span>data<span class="string">" : "</span>$&#123;ss(<span class="number">1</span>)&#125;<span class="string">" &#125;</span></span><br><span class="line"><span class="string">                |"</span><span class="string">""</span>.stripMargin</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加文档数据，数据格式为 JSON 格式</span></span><br><span class="line">            request.source(json,XContentType.JSON);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 客户端发送请求，获取响应对象</span></span><br><span class="line">            val response = client.index(request,</span><br><span class="line">              RequestOptions.DEFAULT);</span><br><span class="line">            System.out.println(<span class="string">"_index:"</span> + response.getIndex());</span><br><span class="line">            System.out.println(<span class="string">"_id:"</span> + response.getId());</span><br><span class="line">            System.out.println(<span class="string">"_result:"</span> + response.getResult());</span><br><span class="line">            client.close()</span><br><span class="line">          &#125;</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">    ssc.start()</span><br><span class="line">    ssc.awaitTermination();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、Flink-框架集成">3、Flink 框架集成</h2><h3 id="3-1-Flink-框架介绍">3.1 Flink 框架介绍</h3><p>Apache Spark是一-种基于内存的快速、通用、可扩展的大数据分析计算引擎。Apache Spark掀开了内存计算的先河，以内存作为赌注，贏得了内存计算的飞速发展。但是在其火热的同时，开发人员发现，在Spark中，计算框架普遍存在的缺点和不足依然没有完全解决，而这些问题随着5G时代的来临以及决策者对实时数据分析结果的迫切需要而凸显的更加明显：</p><ul><li>乱序数据，迟到数据</li><li>低延迟，高吞吐，准确性</li><li>容错性</li><li>数据精准一次性处理（Exactly-Once）</li></ul><p>Apache Flink是一个框架和分布式处理引擎，用于对无界和有界数据流进行有状态计算。在Spark火热的同时，也默默地发展自己，并尝试着解决其他计算框架的问题。慢慢地，随着这些问题的解决，Flink 慢慢被绝大数程序员所熟知并进行大力推广，阿里公司在2015年改进Flink，并创建了内部分支Blink，目前服务于阿里集团内部搜索、推荐、广告和蚂蚁等大量核心实时业务</p><h3 id="3-2-demo实现">3.2 demo实现</h3><p>首先创建空项目，引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>study-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-elasticsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-scala_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-streaming-scala_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-clients_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-connector-elasticsearch7_2.11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- jackson --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.11.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>功能实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlinkElasticsearchSinkTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//构建Flink 环境对象</span></span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//数据的输入</span></span><br><span class="line">        DataStreamSource&lt;String&gt; source = env.socketTextStream(<span class="string">"localhost"</span>, <span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用ESBuilder 构建输出</span></span><br><span class="line">        List&lt;HttpHost&gt; hostList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        hostList.add(<span class="keyword">new</span> HttpHost(<span class="string">"127.0.0.1"</span>, <span class="number">9200</span>, <span class="string">"http"</span>));</span><br><span class="line">        ElasticsearchSink.Builder&lt;String&gt; stringBuilder = <span class="keyword">new</span> ElasticsearchSink.Builder&lt;&gt;(hostList,</span><br><span class="line">                <span class="keyword">new</span> ElasticsearchSinkFunction&lt;String&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String s, RuntimeContext runtimeContext, RequestIndexer requestIndexer)</span> </span>&#123;</span><br><span class="line">                        IndexRequest indexRequest = Requests.indexRequest();</span><br><span class="line">                        Map&lt;String, String&gt; json = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                        json.put(<span class="string">"data"</span>, s);</span><br><span class="line">                        indexRequest.index(<span class="string">"flink-index"</span>);</span><br><span class="line">                        indexRequest.id(<span class="string">"9001"</span>);</span><br><span class="line">                        indexRequest.source(json);</span><br><span class="line">                        requestIndexer.add(indexRequest);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="comment">//Sink ： 数据的输出</span></span><br><span class="line">        stringBuilder.setBulkFlushMaxActions(<span class="number">1</span>);</span><br><span class="line">        source.addSink(stringBuilder.build());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行操作</span></span><br><span class="line">        env.execute(<span class="string">"flink-job"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>六、Elasticsearch 优化</h1><h2 id="1、硬件选择">1、硬件选择</h2><p>Elasticsearch 的基础是 Lucene，所有的索引和文档数据是存储在本地的磁盘中，具体的路径可在 ES 的配置文件…/config/elasticsearch.yml中配置，如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Path to directory where to store the data (separate multiple locations by comma):</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="attr">path.data:</span> <span class="string">/path/to/data</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Path to log files:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="attr">path.logs:</span> <span class="string">/path/to/logs</span></span><br></pre></td></tr></table></figure><ul><li>使用SSD就像其他地方提过的，他们比机械磁盘优秀多了</li><li>使用RAID0。条带化RAID会提高磁盘IO，代价显然就是当一块硬盘故障时整个就故障了。不要使用镜像或者奇偶校验RAID，因为副本已经提供了这个功能</li><li>另外，使用多块硬盘，并允许Elasticsearch 通过多个path data目录配置把数据条带化分配到它们上面</li><li>不要使用远程挂载的存储，比如NFS或者SMB/CIFS。这个引入的延迟对性能来说完全是背道而驰的</li></ul><h2 id="2、分片策略">2、分片策略</h2><h3 id="2-1-合理设置分片数">2.1 合理设置分片数</h3><p>分片和副本的设计为 ES 提供了支持分布式和故障转移的特性，但并不意味着分片和副本是可以无限分配的。而且索引的分片完成分配后由于索引的路由机制，我们是不能重新修改分片数的。但是需要知道的是，一个分片并不是没有代价的：</p><ul><li>一个分片的底层即为一个 Lucene 索引，会消耗一定文件句柄、内存、以及 CPU运转</li><li>每一个搜索请求都需要命中索引中的每一个分片，如果每一个分片都处于不同的节点还好， 但如果多个分片都需要在同一个节点上竞争使用相同的资源就有些糟糕了</li><li>用于计算相关度的词项统计信息是基于分片的。如果有许多分片，每一个都只有很少的数据会导致很低的相关度</li></ul><p>一个业务索引具体需要分配多少分片可能需要架构师和技术人员对业务的增长有个预先的判断，横向扩展应当分阶段进行。为下一阶段准备好足够的资源。 只有当你进入到下一个阶段，你才有时间思考需要作出哪些改变来达到这个阶段。一般来说，我们遵循一些原则：</p><ul><li><p>控制每个分片占用的硬盘容量不超过 ES 的最大 JVM 的堆空间设置（一般设置不超过 32G，参考下文的 JVM 设置原则），因此，如果索引的总容量在 500G 左右，那分片大小在 16 个左右即可；当然，最好同时考虑原则 2。</p></li><li><p>考虑一下 node 数量，一般一个节点有时候就是一台物理机，如果分片数过多，大大超过了节点数，很可能会导致一个节点上存在多个分片，一旦该节点故障，即使保持了 1 个以上的副本，同样有可能会导致数据丢失，集群无法恢复。所以， 一般都设置分片数不超过节点数的 3 倍。</p></li><li><p>主分片，副本和节点最大数之间数量，我们分配的时候可以参考以下关系：  </p><p><strong>节点数&lt;=主分片数 *（副本数+1）</strong></p></li></ul><h3 id="2-2-推迟分片分配">2.2 推迟分片分配</h3><p>对于节点瞬时中断的问题，默认情况，集群会等待一分钟来查看节点是否会重新加入，如果这个节点在此期间重新加入，重新加入的节点会保持其现有的分片数据，不会触发新的分片分配。这样就可以减少 ES 在自动再平衡可用分片时所带来的极大开销。通过修改参数<code> delayed_timeout</code> ，可以延长再均衡的时间，可以全局设置也可以在索引级别进行修改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#PUT /_all/_settings</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"settings"</span>: &#123;</span><br><span class="line">    <span class="string">"index.unassigned.node_left.delayed_timeout"</span>: <span class="string">"5m"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、路由选择">3、路由选择</h2><p>当我们查询文档的时候， Elasticsearch 如何知道一个文档应该存放到哪个分片中呢？它其实是通过下面这个公式来计算出来</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shard = <span class="built_in">hash</span>(routing) % number_of_primary_shards</span><br></pre></td></tr></table></figure><p>routing 默认值是文档的 id，也可以采用自定义值，比如用户 id。</p><p><strong>不带routing查询</strong></p><p>在查询的时候因为不知道要查询的数据具体在哪个分片上，所以整个过程分为2个步骤</p><ul><li>分发：请求到达协调节点后，协调节点将查询请求分发到每个分片上。</li><li>聚合：协调节点搜集到每个分片上查询结果，在将查询的结果进行排序，之后给用户返回结果。</li></ul><p><strong>带routing查询</strong></p><p>询的时候，可以直接根据routing 信息定位到某个分配查询，不需要查询所有的分配，经过协调节点排序。向上面自定义的用户查询，如果routing 设置为userid 的话，就可以直接查询出数据来，效率提升很多。</p><h2 id="4、写入速度优化">4、写入速度优化</h2><p>ES 的默认配置，是综合了数据可靠性、写入速度、搜索实时性等因素。实际使用时，我们需要根据公司要求，进行偏向性的优化。针对于搜索性能要求不高，但是对写入要求较高的场景，我们需要尽可能的选择恰当写优化策略。综合来说，可以考虑以下几个方面来提升写索引的性能：</p><ul><li>加大Translog Flush，目的是降低Iops、Writeblock</li><li>增加Index Refesh间隔，目的是减少Segment Merge的次数</li><li>调整Bulk 线程池和队列</li><li>优化节点间的任务分布</li><li>优化Lucene层的索引建立，目的是降低CPU及IO</li></ul><h3 id="4-1-优化存储设备">4.1 优化存储设备</h3><p>ES 是一种密集使用磁盘的应用，在段合并的时候会频繁操作磁盘，所以对磁盘要求较高，当磁盘速度提升之后，集群的整体性能会大幅度提高</p><h3 id="4-2-合理使用合并">4.2 合理使用合并</h3><p>Lucene 以段的形式存储数据。<strong>当有新的数据写入索引时， Lucene 就会自动创建一个新的段</strong>。随着数据量的变化，段的数量会越来越多，消耗的多文件句柄数及 CPU 就越多，查询效率就会下降。由于 Lucene 段合并的计算量庞大，会消耗大量的 I/O，所以 ES 默认采用较保守的策略，让后台定期进行段合并。</p><h3 id="4-3-减少-Refresh-的次数">4.3 减少 Refresh 的次数</h3><p>Lucene 在新增数据时，采用了延迟写入的策略，<strong>默认情况下索引的refresh_interval 为1 秒</strong>。Lucene 将待写入的数据先写到内存中，超过 1 秒（默认）时就会触发一次 Refresh，然后 Refresh 会把内存中的的数据刷新到操作系统的文件缓存系统中。如果我们对搜索的实效性要求不高，可以将 Refresh 周期延长，例如 30 秒。这样还可以有效地减少段刷新次数，但这同时意味着需要消耗更多的 Heap 内存。</p><h3 id="4-4-加大-Flush-设置">4.4 加大 Flush 设置</h3><p>Flush 的主要目的是把文件缓存系统中的段持久化到硬盘，当 Translog 的数据量达到 512MB 或者 30 分钟时，会触发一次 Flush。<code>index.translog.flush_threshold_size</code> 参数的<strong>默认值是 512MB</strong>，我们进行修改。增加参数值意味着文件缓存系统中可能需要存储更多的数据，所以我们需要为操作系统的文件缓存系统留下足够的空间。</p><h3 id="4-5-减少副本的数量">4.5 减少副本的数量</h3><p>ES 为了保证集群的可用性，提供了 Replicas（副本）支持，然而每个副本也会执行分析、索引及可能的合并过程，所以 Replicas 的数量会严重影响写索引的效率。</p><p>当写索引时，需要把写入的数据都同步到副本节点，副本节点越多，写索引的效率就越慢。如果我们需要大批量进行写入操作，<strong>可以先禁止Replica复制</strong>，设置<br><code>index.number_of_replicas: 0</code> 关闭副本。在写入完成后， Replica 修改回正常的状态。</p><h2 id="5、内存设置">5、内存设置</h2><p><strong>ES 默认安装后设置的内存是 1GB</strong>，对于任何一个现实业务来说，这个设置都太小了。如果是通过解压安装的 ES，则在 ES 安装文件中包含一个<code> jvm.option</code> 文件，添加如下命令来设置 ES 的堆大小， Xms 表示堆的初始大小， Xmx 表示可分配的最大内存，都是 1GB。确保 Xmx 和 Xms 的大小是相同的，其目的是为了能够在 Java 垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小而浪费资源，可以减轻伸缩堆大小带来的压力。</p><p>假设你有一个 64G 内存的机器，按照正常思维思考，你可能会认为把 64G 内存都给ES 比较好，但现实是这样吗， 越大越好？虽然内存对 ES 来说是非常重要的，但是答案是否定的！因为 ES 堆内存的分配需要满足以下两个原则：</p><ul><li><strong>不要超过物理内存的 50%</strong>： Lucene 的设计目的是把底层 OS 里的数据缓存到内存中。Lucene 的段是分别存储到单个文件中的，这些文件都是不会变化的，所以很利于缓存，同时操作系统也会把这些段文件缓存起来，以便更快的访问。如果我们设置的堆内存过大， Lucene 可用的内存将会减少，就会严重影响降低 Lucene 的全文本查询性能。</li><li>堆内存的大小最好不要超过 32GB：在 Java 中，所有对象都分配在堆上，然后有一个 Klass Pointer 指针指向它的类元数据。这个指针在 64 位的操作系统上为 64 位， 64 位的操作系统可以使用更多的内存（2^64）。在 32 位的系统上为 32 位， 32 位的操作系统的最大寻址空间为 4GB（2^32）。但是 64 位的指针意味着更大的浪费，因为你的指针本身大了。浪费内存不算，更糟糕的是，更大的指针在主内存和缓存器（例如 LLC, L1 等）之间移动数据的时候，会占用更多的带宽。</li></ul><p>最终我们都会采用 31 G 设置</p><ul><li>-Xms 31g</li><li>-Xmx 31g</li></ul><p>假设你有个机器有 128 GB 的内存，你可以创建两个节点，每个节点内存分配不超过 32 GB。也就是说不超过 64 GB 内存给 ES 的堆内存，剩下的超过 64 GB 的内存给 Lucene</p><h2 id="6、重要配置项">6、重要配置项</h2><table><thead><tr><th><strong>参数名</strong></th><th>**参数值**</th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><a href="http://cluster.name" target="_blank" rel="noopener">cluster.name</a></td><td>elasticsearch</td><td>配置 ES 的集群名称，默认值是 ES，建议改成与所存数据相关的名称， ES 会自动发现在同一网段下的 集群名称相同的节点</td></tr><tr><td><a href="http://node.name" target="_blank" rel="noopener">node.name</a></td><td>node-1</td><td>集群中的节点名，在同一个集群中不能重复。节点 的名称一旦设置，就不能再改变了。当然，也可以 设 置 成 服 务 器 的 主 机 名 称 ， 例 如 <a href="http://node.name" target="_blank" rel="noopener">node.name</a>😒{HOSTNAME}</td></tr><tr><td>node.master</td><td>true</td><td>指定该节点是否有资格被选举成为 Master 节点，默 认是 True，如果被设置为 True，则只是有资格成为 Master 节点，具体能否成为 Master 节点，需要通 过选举产生</td></tr><tr><td>node.data</td><td>true</td><td>指定该节点是否存储索引数据，默认为 True。数据 的增、删、改、查都是在 Data 节点完成的</td></tr><tr><td>index.number_of_shards</td><td>1</td><td>设置都索引分片个数，默认是 1 片。也可以在创建 索引时设置该值，具体设置为多大都值要根据数据 量的大小来定。如果数据量不大，则设置成 1 时效 率最高</td></tr><tr><td>index.number_of_replicas</td><td>1</td><td>设置默认的索引副本个数，默认为 1 个。副本数越 多，集群的可用性越好，但是写索引时需要同步的 数据越多</td></tr><tr><td>transport.tcp.compress</td><td>true</td><td>设置在节点间传输数据时是否压缩，默认为 False， 不压缩</td></tr><tr><td>discovery.zen.minimum_master_nodes</td><td>1</td><td>设置在选举 Master 节点时需要参与的最少的候选 主节点数，默认为 1。如果使用默认值，则当网络 不稳定时有可能会出现脑裂。 合 理 的 数 值 为 (master_eligible_nodes/2)+1 ， 其 中 master_eligible_nodes 表示集群中的候选主节点数</td></tr><tr><td>discovery.zen.ping.timeout</td><td>3s</td><td>设置在集群中自动发现其他节点时 Ping 连接的超 时时间，默认为 3 秒。 在较差的网络环境下需要设置得大一点，防止因误 判该节点的存活状态而导致分片的转移</td></tr></tbody></table><h1>七、Elasticsearch面试题</h1><h2 id="1、为什么要使用-Elasticsearch？">1、为什么要使用 Elasticsearch？</h2><p>系统中的数据， 随着业务的发展，时间的推移， 将会非常多， 而业务中往往采用模糊查询进行数据的搜索， 而模糊查询会导致查询引擎放弃索引，导致系统查询数据时都是全表扫描，在百万级别的数据库中，查询效率是非常低下的，而我们使用 ES 做一个全文索引，将经常查询的系统功能的某些字段，比如说电商系统的商品表中商品名，描述、价格还有 id 这些字段我们放入 ES 索引库里，可以提高查询速度。</p><h2 id="2、Elasticsearch-的-master-选举流程">2、Elasticsearch 的 master 选举流程</h2><ul><li>Elasticsearch的选主是ZenDiscovery模块负责的，主要包含Ping（节点之间通过这个RPC来发现彼此），和Unicast（单播模块包含-一个主机列表以控制哪些节点需要ping通）这两部分</li><li>对所有可以成为master的节点（node master: true）根据nodeId字典排序，每次选举每个节点都把自己所知道节点排一次序，然后选出第一个（第0位）节点，暂且认为它是master节点</li><li>如果对某个节点的投票数达到一定的值（可以成为master节点数n/2+1）并且该节点自己也选举自己，那这个节点就是master。否则重新选举一直到满足上述条件</li><li>master节点的职责主要包括集群、节点和索引的管理，不负责文档级别的管理；data节点可以关闭http功能</li></ul><h2 id="3、Elasticsearch-集群脑裂问题？">3、Elasticsearch 集群脑裂问题？</h2><p><strong>&quot;脑裂&quot;问题可能的成因：</strong></p><ul><li>网络问题：集群间的网络延迟导致一些节点访问不到master, 认为master 挂掉了从而选举出新的master,并对master上的分片和副本标红，分配新的主分片</li><li>节点负载：主节点的角色既为master又为data,访问量较大时可能会导致ES停止响应造成大面积延迟，此时其他节点得不到主节点的响应认为主节点挂掉了，会重新选取主节点</li><li>内存回收：data 节点上的ES进程占用的内存较大，引发JVM的大规模内存回收，造成ES进程失去响应</li></ul><p><strong>脑裂问题解决方案：</strong></p><ul><li>减少误判：<code>discovery.zen.ping_timeout</code> 节点状态的响应时间，默认为3s，可以适当调大，如果master在该响应时间的范围内没有做出响应应答，判断该节点已经挂掉了。调大参数（如6s，discovery.zen.ping_timeout:6），可适当减少误判</li><li>选举触发：<code>discovery.zen.minimum_master_nodes:1</code>，该参數是用于控制选举行为发生的最小集群主节点数量。当备选主节点的个數大于等于该参数的值，且备选主节点中有该参数个节点认为主节点挂了，进行选举。官方建议为<code>(n / 2) +1</code>, n为主节点个数（即有资格成为主节点的节点个数）</li><li>角色分离：即master节点与data节点分离，限制角色<ul><li>主节点配置为：node.master: true，node.data: false</li><li>从节点配置为：node.master: false，node.data: true</li></ul></li></ul><h2 id="4、Elasticsearch-索引文档的流程？">4、Elasticsearch 索引文档的流程？</h2><p><img src="https://img-blog.csdnimg.cn/336ec75951974a2faa5479b5227f7752.png#pic_center" alt="在这里插入图片描述"></p><ul><li>协调节点默认使用文档 ID 参与计算（也支持通过 routing），以便为路由提供合适的分片：<code>shard = hash(document_id) % (num_of_primary_shards)</code></li><li>当分片所在的节点接收到来自协调节点的请求后，会将请求写入到 Memory Buffer，然后定时（<strong>默认是每隔 1 秒</strong>）写入到 Filesystem Cache，这个从 Memory Buffer 到 Filesystem Cache 的过程就叫做 refresh；</li><li>当然在某些情况下，存在<code> Momery Buffer</code> 和 <code>Filesystem Cache</code> 的数据可能会丢失， ES 是通过 translog的机制来保证数据的可靠性的。其实现机制是接收到请求后，同时也会写入到 translog 中，当 Filesystemcache 中的数据写入到磁盘中时，才会清除掉，这个过程叫做 flush；</li><li>在 flush 过程中，内存中的缓冲将被清除，内容被写入一个新段，段的 fsync 将创建一个新的提交点，并将内容刷新到磁盘，旧的 translog 将被删除并开始一个新的 translog。</li><li>flush 触发的时机是定时触发（默认 30 分钟）或者 translog 变得太大（默认为 512M）时；</li></ul><h2 id="5、Elasticsearch-更新和删除文档的流程">5、Elasticsearch 更新和删除文档的流程</h2><ul><li>删除和更新也都是写操作，但是 Elasticsearch 中的文档是不可变的，因此不能被删除或者改动以展示其变更；</li><li>磁盘上的每个段都有一个相应的.del 文件。当删除请求发送后，文档并没有真的被删除，而是在.del文件中被标记为删除。该文档依然能匹配查询，但是会在结果中被过滤掉。当段合并时，在.del 文件中被标记为删除的文档将不会被写入新段。</li><li>在新的文档被创建时， Elasticsearch 会为该文档指定一个版本号，当执行更新时，旧版本的文档在.del文件中被标记为删除，新版本的文档被索引到一个新段。旧版本的文档依然能匹配查询，但是会在结果中被过滤掉。</li></ul><h2 id="6、Elasticsearch-搜索的流程？">6、Elasticsearch 搜索的流程？</h2><p><img src="https://img-blog.csdnimg.cn/340cf54ffc674987b2b5bce3136bcf8c.png#pic_center" alt="在这里插入图片描述"></p><ul><li>搜索被执行成一个两阶段过程，我们称之为 <code>Query Then Fetch</code>；</li><li>在初始查询阶段时，查询会广播到索引中每一个分片拷贝（主分片或者副本分片）。 每个分片在本地执行搜索并构建一个匹配文档的大小为 from + size 的优先队列。 PS：在搜索的时候是会查询<code>Filesystem Cache</code> 的，但是有部分数据还在 Memory Buffer，所以搜索是近实时的。</li><li>每个分片返回各自优先队列中 所有文档的 ID 和排序值 给协调节点，它合并这些值到自己的优先队列中来产生一个全局排序后的结果列表。</li><li>接下来就是取回阶段， 协调节点辨别出哪些文档需要被取回并向相关的分片提交多个 GET 请求。每个分片加载并丰富文档，如果有需要的话，接着返回文档给协调节点。一旦所有的文档都被取回了，协调节点返回结果给客户端。</li><li>Query Then Fetch 的搜索类型在文档相关性打分的时候参考的是本分片的数据，这样在文档数量较少的时候可能不够准确， DFS Query Then Fetch 增加了一个预查询的处理，询问 Term 和 Document frequency，这个评分更准确，但是性能会变差。</li></ul><h2 id="7、Elasticsearch-在部署时，对-Linux-的设置有哪些优化方法">7、Elasticsearch 在部署时，对 Linux 的设置有哪些优化方法</h2><ul><li>64 GB 内存的机器是非常理想的， 但是 32 GB 和 16 GB 机器也是很常见的。少于 8 GB 会适得其反</li><li>如果你要在更快的 CPUs 和更多的核心之间选择，选择更多的核心更好。多个内核提供的额外并发远胜过稍微快一点点的时钟频率</li><li>如果你负担得起 SSD，它将远远超出任何旋转介质。 基于 SSD 的节点，查询和索引性能都有提升。如果你负担得起， SSD 是一个好的选择</li><li>即使数据中心们近在咫尺，也要避免集群跨越多个数据中心。绝对要避免集群跨越大的地理距离</li><li>请确保运行你应用程序的 JVM 和服务器的 JVM 是完全一样的。 在 Elasticsearch 的几个地方，使用 Java 的本地序列化</li><li>通过设置 gateway.recover_after_nodes、 gateway.expected_nodes、 gateway.recover_after_time 可以在集群重启的时候避免过多的分片交换，这可能会让数据恢复从数个小时缩短为几秒钟</li><li>Elasticsearch 默认被配置为使用单播发现，以防止节点无意中加入集群。只有在同一台机器上运行的节点才会自动组成集群。最好使用单播代替组播</li><li>不要随意修改垃圾回收器（CMS）和各个线程池的大小</li><li>把你的内存的（少于）一半给 Lucene（但不要超过 32 GB！），通过 ES_HEAP_SIZE 环境变量设置</li><li>内存交换到磁盘对服务器性能来说是致命的。如果内存交换到磁盘上，一个 100 微秒的操作可能变成 10 毫秒。 再想想那么多 10 微秒的操作时延累加起来。 不难看出 swapping 对于性能是多么可怕</li><li>Lucene 使用了大量的文件。同时， Elasticsearch 在节点和 HTTP 客户端之间进行通信也使用了大量的套接字。 所有这一切都需要足够的文件描述符。你应该增加你的文件描述符，设置一个很大的值，如 64,000</li></ul><h2 id="8、GC-方面，在使用-Elasticsearch-时要注意什么？">8、GC 方面，在使用 Elasticsearch 时要注意什么？</h2><ul><li>倒排词典的索引需要常驻内存，无法 GC，需要监控 data node 上 <code>segment memory</code> 增长趋势。</li><li>各类缓存， field cache, filter cache, indexing cache, bulk queue 等等，要设置合理的大小，并且要应该根据最坏的情况来看 heap 是否够用，也就是各类缓存全部占满的时候，还有 heap 空间可以分配给其他任务吗？避免采用 clear cache 等“自欺欺人”的方式来释放内存</li><li>避免返回大量结果集的搜索与聚合。确实需要大量拉取数据的场景，可以采用 scan &amp; scroll api 来实现</li><li>cluster stats 驻留内存并无法水平扩展，超大规模集群可以考虑分拆成多个集群通过 tribe node 连接</li><li>想知道 heap 够不够，必须结合实际应用场景，并对集群的 heap 使用情况做持续的监控</li></ul><h2 id="9、Elasticsearch-对于大数据量（上亿量级）的聚合如何实现">9、Elasticsearch 对于大数据量（上亿量级）的聚合如何实现</h2><p>Elasticsearch 提供的首个近似聚合是 cardinality 度量。它提供一个字段的基数，即该字段的 distinct或者 unique 值的数目。它是基于 HLL 算法的。 HLL 会先对我们的输入作哈希运算，然后根据哈希运算的结果中的 bits 做概率估算从而得到基数。其特点是：可配置的精度，用来控制内存的使用（更精确 ＝ 更多内存）；小的数据集精度是非常高的；我们可以通过配置参数，来设置去重需要的固定内存使用量。无论数千还是数十亿的唯一值，内存使用量只与你配置的精确度相关。</p><h2 id="10、在并发情况下，-Elasticsearch-如果保证读写一致">10、在并发情况下， Elasticsearch 如果保证读写一致</h2><ul><li>可以通过版本号使用乐观并发控制，以确保新版本不会被旧版本覆盖，由应用层来处理具体的冲突；</li><li>另外对于写操作，一致性级别支持 <code>quorum/one/all</code>，<strong>默认为 quorum</strong>，即只有当大多数分片可用时才允许写操作。但即使大多数可用，也可能存在因为网络等原因导致写入副本失败，这样该副本被认为故障，分片将会在一个不同的节点上重建。</li><li>对于读操作，可以设置** replication 为 sync(默认)<strong>，这使得操作在主分片和副本分片都完成后才会返回；如果设置 replication 为 async 时，也可以通过设置搜索请求参数</strong>_preference 为 primary** 来查询主分片，确保文档是最新版本。</li></ul><h2 id="11、如何监控-Elasticsearch-集群状态">11、如何监控 Elasticsearch 集群状态</h2><ul><li>elasticsearch-head 插件。</li><li>通过 Kibana 监控 Elasticsearch。你可以实时查看你的集群健康状态和性能，也可以分析过去的集群、索引和节点指标</li></ul><h2 id="12、是否了解字典树">12、是否了解字典树</h2><p>字典树又称单词查找树， Trie 树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：<strong>利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高</strong>。</p><p>Trie 的核心思想是空间换时间，利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。它有 3 个基本性质：</p><ul><li>根节点不包含字符，除根节点外每一个节点都只包含一个字符。</li><li>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。</li><li>每个节点的所有子节点包含的字符都不相同</li></ul><p>对于中文的字典树，每个节点的子节点用一个哈希表存储，这样就不用浪费太大的空间，而且查询速度上可以保留哈希的复杂度 O(1)</p><h2 id="13、Elasticsearch-中的集群、节点、索引、文档、类型是什么">13、Elasticsearch 中的集群、节点、索引、文档、类型是什么</h2><ul><li>集群是一个或多个节点（服务器）的集合，它们共同保存您的整个数据，并提供跨所有节点的联合索引和搜索功能。群集由唯一名 称标识，默认情况下为&quot;elasticsearch&quot;。此名称很重要，因为如果节点设置为按名称加入群集，则该节点只能是群集的一部分</li><li>节点是属于集群一部分的单个服务器。它存储数据并参与群集索引和搜索功能。</li><li>索引就像关系数据库中的“数据库”。它有一个定义多种类型的映射。索引是逻辑名称空间，映射到一个或多个主分片，并且可以有零个或多个副本分片。<code>MySQL =&gt;数据库，Elasticsearch=&gt;索引</code></li><li>文档类似于关系数据库中的一行。不同之处在于索引中的每个文档可以具有不同的结构(字段)，但是对于通用字段应该具有相同的数据类型。<code>MySQL =&gt; Databases =&gt; Tables =&gt; Columns / Rows，Elasticsearch=&gt; Indices =&gt; Types =&gt;具有属性的文档Doc</code></li><li>类型是索引的逻辑类别/分区，其语义完全取决于用户</li></ul><h2 id="14、Elasticsearch-中的倒排索引是什么">14、Elasticsearch 中的倒排索引是什么</h2><p><strong>倒排索引是搜索引擎的核心</strong>。搜索引擎的主要目标是在查找发生搜索条件的文档时提供快速搜索。ES中的倒排索引其实就是 lucene 的倒排索引，区别于传统的正向索引， <strong>倒排索引会再存储数据时将关键词和数据进行关联，保存到倒排表中，然后查询时，将查询内容进行分词后在倒排表中进行查询</strong>，最后匹配数据即可</p><hr><p>参考资料：<a href="https://www.bilibili.com/video/BV1hh411D7sb/" target="_blank" rel="noopener" title="https://www.bilibili.com/video/BV1hh411D7sb/">https://www.bilibili.com/video/BV1hh411D7sb/</a></p>]]></content>
    
    
    <summary type="html">&lt;h1&gt;一、ElasticSearch概述&lt;/h1&gt;
&lt;h2 id=&quot;1、ElasticSearch是什么&quot;&gt;1、ElasticSearch是什么&lt;/h2&gt;
&lt;p&gt;Elasticsearch是一个&lt;strong&gt;实时的分布式搜索和分析引擎&lt;/strong&gt;。它可以帮助你用前所未有的速度去处理大规模数据。它可以用于&lt;strong&gt;全文搜索，结构化搜索以及分析&lt;/strong&gt;，当然你也可以将这三者进行组合。&lt;/p&gt;
&lt;p&gt;Elasticsearch是一个建&lt;strong&gt;立在全文搜索引擎 Apache Lucene™ 基础&lt;/strong&gt;上的搜索引擎，可以说Lucene是当今最先进，最高效的全功能开源搜索引擎框架。但是Lucene只是一个框架，要充分利用它的功能，需要使用JAVA，并且在程序中集成Lucene。当然Elasticsearch并不仅仅是Lucene这么简单，它不但包括了全文搜索功能，还可以进行以下工作:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分布式实时文件存储，并将每一个字段都编入索引，使其可以被搜索。&lt;/li&gt;
&lt;li&gt;实时分析的分布式搜索引擎。&lt;/li&gt;
&lt;li&gt;可以扩展到上百台服务器，处理PB级别的结构化或非结构化数据。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Java" scheme="https://www.shawn22.xyz/categories/Java/"/>
    
    
    <category term="中间件" scheme="https://www.shawn22.xyz/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Druid-DataSource监控MySQL</title>
    <link href="https://www.shawn22.xyz/posts/799f9c4.html"/>
    <id>https://www.shawn22.xyz/posts/799f9c4.html</id>
    <published>2023-03-05T16:12:17.000Z</published>
    <updated>2023-03-05T16:39:27.796Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、基本概念">1、基本概念</h2><p>我们都使用过连接池，比如<code>C3P0，DBCP，hikari， Druid</code>，虽然HikariCP的速度稍快，但Druid能够提供强大的监控和扩展功能，也是阿里巴巴的开源项目。Druid是阿里巴巴开发的号称为监控而生的数据库连接池，在功能、性能、扩展性方面，都超过其他数据库连接池，包括<code>DBCP、C3P0、BoneCP、Proxool、JBoss DataSource</code>等等，秒杀一切。</p><p>Druid可以很好的监控DB池连接和SQL的执行情况，天生就是针对监控而生的DB连接池。Spring Boot默认数据源<code>HikariDataSource</code>与<code>JdbcTemplate</code>中已经介绍Spring Boot 2.x默认使用Hikari数据源，可以说Hikari与Driud都是当前Java Web上最优秀的数据源。而Druid已经在阿里巴巴部署了超过600个应用，经过好几年生产环境大规模部署的严苛考验！</p><ul><li><strong>stat：</strong> Druid内置提供一个<code>StatFilter</code>，用于统计监控信息。</li><li><strong>wall：</strong> Druid防御SQL注入攻击的<code>WallFilter</code>就是通过Druid的SQL Parser分析。Druid提供的<code>SQL Parser</code>可以在JDBC层拦截SQL做相应处理，比如说分库分表、审计等。</li><li><strong>log4j2：</strong> 这个就是 日志记录的功能，可以把sql语句打印到log4j2供排查问题。</li></ul><a id="more"></a><h2 id="2、相关配置">2、相关配置</h2><h3 id="2-1-添加依赖">2.1 添加依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">alibabaDruidStarter.version</span>&gt;</span>1.2.11<span class="tag">&lt;/<span class="name">alibabaDruidStarter.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;alibabaDruidStarter.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-2-配置属性">2.2 配置属性</h3><ul><li><strong>配置Druid数据源（连接池）：</strong> 如同c3p0、dbcp数据源可以设置数据源连接初始化大小、最大连接数、等待时间、最小连接数 等一样，Druid数据源同理可以进行设置。</li><li><strong>配置Druid web监控filter（WebStatFilter）：</strong> 这个过滤器的作用就是统计web应用请求中所有的数据库信息，比如 发出的sql语句，sql执行的时间、请求次数、请求的url地址、以及seesion监控、数据库表的访问次数等等。</li><li><strong>配置Druid后台管理Servlet（StatViewServlet）：</strong> Druid数据源具有监控的功能，并提供了一个web界面方便用户查看，类似安装 路由器 时，人家也提供了一个默认的web页面；需要设置Druid的后台管理页面的属性，比如 登录账号、密码等。</li></ul><p>【注意】：<code>Druid Spring Boot Starter</code>配置属性的名称完全遵照Druid，可以通过Spring Boot配置文件来配置Druid数据库连接池和监控，如果没有配置则使用默认值，如下在<code>application.yml</code>配置相关属性：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># spring 配置</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/superjson?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false</span></span><br><span class="line">    <span class="comment"># 连接池配置</span></span><br><span class="line">    <span class="attr">druid:</span></span><br><span class="line">      <span class="comment"># 初始化大小，最小，最大</span></span><br><span class="line">      <span class="attr">initial-size:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">min-idle:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">max-active:</span> <span class="number">20</span></span><br><span class="line">      <span class="comment"># 配置获取连接等待超时的时间</span></span><br><span class="line">      <span class="attr">max-wait:</span> <span class="number">60000</span></span><br><span class="line">      <span class="comment"># 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位毫秒</span></span><br><span class="line">      <span class="attr">time-between-eviction-runs-millis:</span> <span class="number">60000</span></span><br><span class="line">      <span class="comment"># 配置一个连接在池中最小生存时间</span></span><br><span class="line">      <span class="attr">min-evictable-idle-time-millis:</span> <span class="number">300000</span></span><br><span class="line">      <span class="attr">validation-query:</span> <span class="string">SELECT</span> <span class="number">1</span> <span class="string">FROM</span> <span class="string">user</span></span><br><span class="line">      <span class="attr">test-while-idle:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">test-on-borrow:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">test-on-return:</span> <span class="literal">false</span></span><br><span class="line">      <span class="comment"># 打开 PSCache，并且指定每个连接上 PSCache 的大小</span></span><br><span class="line">      <span class="attr">pool-prepared-statements:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">max-pool-prepared-statement-per-connection-size:</span> <span class="number">20</span></span><br><span class="line">      <span class="comment"># 配置监控统计拦截的 Filter，去掉后监控界面 SQL 无法统计，wall 用于防火墙</span></span><br><span class="line">      <span class="attr">filters:</span> <span class="string">stat,wall,slf4j</span></span><br><span class="line">      <span class="comment"># 通过 connection-properties 属性打开 mergeSql 功能；慢 SQL 记录</span></span><br><span class="line">      <span class="attr">connection-properties:</span> <span class="string">druid.stat.mergeSql\=true;druid.stat.slowSqlMillis\=5000</span></span><br><span class="line">      <span class="comment"># 配置 DruidStatFilter</span></span><br><span class="line">      <span class="attr">web-stat-filter:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">url-pattern:</span> <span class="string">/*</span></span><br><span class="line">        <span class="attr">exclusions:</span> <span class="string">.js,*.gif,*.jpg,*.bmp,*.png,*.css,*.ico,/druid/*</span></span><br><span class="line">      <span class="comment"># 配置 DruidStatViewServlet</span></span><br><span class="line">      <span class="attr">stat-view-servlet:</span></span><br><span class="line">        <span class="attr">url-pattern:</span> <span class="string">/druid/*</span></span><br><span class="line">        <span class="comment"># IP 白名单，没有配置或者为空，则允许所有访问</span></span><br><span class="line">        <span class="attr">allow:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">        <span class="comment"># IP 黑名单，若白名单也存在，则优先使用</span></span><br><span class="line">        <span class="attr">deny:</span> <span class="number">192.168</span><span class="number">.31</span><span class="number">.253</span></span><br><span class="line">        <span class="comment"># 禁用 HTML 中 Reset All 按钮</span></span><br><span class="line">        <span class="attr">reset-enable:</span> <span class="literal">false</span></span><br><span class="line">        <span class="comment"># 登录用户名/密码</span></span><br><span class="line">        <span class="attr">login-username:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">login-password:</span> <span class="number">123456</span></span><br><span class="line">        <span class="comment"># 需要设置enabled=true,否则会报出There was an unexpected error (type=Not Found, status=404).错误，或者将druid-spring-boot-starter的版本降低到1.1.10及以下</span></span><br><span class="line">        <span class="comment"># 是否启用StatViewServlet（监控页面）默认值为false（考虑到安全问题默认并未启动，如需启用建议设置密码或白名单以保障安全）</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>上述配置文件的参数可以在<code>com.alibaba.druid.spring.boot.autoconfigure.properties.DruidStatProperties</code>和 <code>org.springframework.boot.autoconfigure.jdbc.DataSourcePropertie</code>中找到</p><h3 id="2-3-配置Filter">2.3 配置Filter</h3><p>可以通过<code>spring.datasource.druid.filters=stat,wall,log4j ...</code>的方式来启用相应的内置Filter，不过这些Filter都是默认配置。如果默认配置不能满足需求，可以放弃这种方式，通过配置文件来配置Filter，如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置StatFilter </span></span><br><span class="line">spring.datasource.druid.filter.stat.enabled=<span class="literal">true</span></span><br><span class="line">spring.datasource.druid.filter.stat.db-type=h2</span><br><span class="line">spring.datasource.druid.filter.stat.log-slow-sql=<span class="literal">true</span></span><br><span class="line">spring.datasource.druid.filter.stat.slow-sql-millis=2000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置WallFilter </span></span><br><span class="line">spring.datasource.druid.filter.wall.enabled=<span class="literal">true</span></span><br><span class="line">spring.datasource.druid.filter.wall.db-type=h2</span><br><span class="line">spring.datasource.druid.filter.wall.config.delete-allow=<span class="literal">false</span></span><br><span class="line">spring.datasource.druid.filter.wall.config.drop-table-allow=<span class="literal">false</span></span><br></pre></td></tr></table></figure><p>目前为以下Filter提供了配置支持，根据（<code>spring.datasource.druid.filter.*</code>）进行配置</p><ul><li>StatFilter</li><li>WallFilter</li><li>ConfigFilter</li><li>EncodingConvertFilter</li><li>Slf4jLogFilter</li><li>Log4jFilter</li><li>Log4j2Filter</li><li>CommonsLogFilter</li></ul><p>不想使用内置的Filters，要想使自定义Filter配置生效需要将对应Filter的enabled设置为true，<code>Druid Spring Boot Starter</code>默认禁用StatFilter，可以将其enabled设置为true来启用它。</p><h2 id="3、监控页面">3、监控页面</h2><p>启动项目后，访问<code>http://localhost:8081/druid/login.html</code>来到登录页面，输入用户名密码登录</p><ul><li>数据源页面 是当前<code>DataSource</code>配置的基本信息，上述配置的<code>Filter</code>可以在里面找到，如果没有配置 Filter（一些信息会无法统计，例如<code>SQL监控</code>会无法获取<code>JDBC</code>相关的SQL执行信息）<br><img src="https://img-blog.csdnimg.cn/b308f1e1734b4094aac8f9ca7fd0b797.png" alt="在这里插入图片描述"></li><li><code>SQL</code>监控页面，统计了所有<code>SQL</code>语句的执行情况<br><img src="https://img-blog.csdnimg.cn/5a1ca5a87402427da8768473132bfd73.png" alt="在这里插入图片描述"></li><li><code>URL</code>监控页面，统计了所有<code>Controller</code>接口的访问以及执行情况<br><img src="https://img-blog.csdnimg.cn/b4e3c56954454dd386660adc140ed180.png" alt="在这里插入图片描述"></li><li><code>Spring</code>监控页面，利用<code>aop</code>对指定接口的执行时间，<code>jdbc</code>数进行记录<br><img src="https://img-blog.csdnimg.cn/181cb48e155b4eeaa48ba3956d86e4cd.png" alt="在这里插入图片描述"></li><li><code>SQL</code>防火墙页面<br>druid提供了黑白名单的访问，可以清楚的看到sql防护情况</li><li><code>Session</code>监控页面<br>可以看到当前的<code>session</code>状况，创建时间、最后活跃时间、请求次数、请求时间等详细参数。</li><li><code>JSONAPI</code>页面<br>通过<code>api</code>的形式访问<code>Druid</code>的监控接口，api接口返回<code>Json</code>形式数据</li></ul><h2 id="4、sql监控">4、sql监控</h2><p>配置Druid web监控filter（<code>WebStatFilter</code>）这个过滤器，作用就是统计web应用请求中所有的数据库信息，比如 发出的sql语句，sql执行的时间、请求次数、请求的url地址、以及seesion监控、数据库表的访问次数，如下配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">druid:</span></span><br><span class="line">      <span class="comment">########## 配置WebStatFilter，用于采集web关联监控的数据 ##########</span></span><br><span class="line">      <span class="attr">web-stat-filter:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span>                   <span class="comment"># 启动 StatFilter</span></span><br><span class="line">        <span class="attr">url-pattern:</span> <span class="string">/*</span>                 <span class="comment"># 过滤所有url</span></span><br><span class="line">        <span class="attr">exclusions:</span> <span class="string">"*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*"</span> <span class="comment"># 排除一些不必要的url</span></span><br><span class="line">        <span class="attr">session-stat-enable:</span> <span class="literal">true</span>       <span class="comment"># 开启session统计功能</span></span><br><span class="line">        <span class="attr">session-stat-max-count:</span> <span class="number">1000</span>    <span class="comment"># session的最大个数,默认100</span></span><br></pre></td></tr></table></figure><h2 id="5、慢sql记录">5、慢sql记录</h2><p>有时候，系统中有些SQL执行很慢，我们希望使用日志记录下来，可以开启Druid的慢SQL记录功能，如下配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">druid:</span></span><br><span class="line">      <span class="attr">filter:</span></span><br><span class="line">        <span class="attr">stat:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span>         <span class="comment"># 开启DruidDataSource状态监控</span></span><br><span class="line">          <span class="attr">db-type:</span> <span class="string">mysql</span>        <span class="comment"># 数据库的类型</span></span><br><span class="line">          <span class="attr">log-slow-sql:</span> <span class="literal">true</span>    <span class="comment"># 开启慢SQL记录功能</span></span><br><span class="line">          <span class="attr">slow-sql-millis:</span> <span class="number">2000</span> <span class="comment"># 默认3000毫秒，这里超过2s，就是慢，记录到日志</span></span><br></pre></td></tr></table></figure><p>启动后，如果遇到执行慢的SQL，便会输出到日志中</p><h2 id="6、spring-监控">6、spring 监控</h2><p>访问之后spring监控默认是没有数据的，但需要导入SprngBoot的AOP的Starter，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--SpringBoot 的aop 模块--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>同时需要在application.yml按如下配置:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Spring监控AOP切入点，如com.springboot.template.dao.*,配置多个英文逗号分隔</span></span><br><span class="line"><span class="string">spring.datasource.druid.aop-patterns="com.springboot.template.dao.*"</span></span><br></pre></td></tr></table></figure><h2 id="7、去广告-Ad">7、去广告(Ad)</h2><p>访问监控页面的时候，你可能会在页面底部（footer）看到阿里巴巴的广告，原因：引入的druid的jar包中的common.js(里面有一段js代码是给页面的footer追加广告的)，有两种方式去广告，两种方式都可以，建议使用的是第一种，从根源解决。</p><h3 id="7-1-直接手动注释这段代码">7.1 直接手动注释这段代码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果是使用Maven，直接到本地仓库中，查找这个jar包，注释如下代码</span></span><br><span class="line">// this.buildFooter();</span><br><span class="line"><span class="comment"># common.js的位置</span></span><br><span class="line">com/alibaba/druid/1.1.23/druid-1.1.23.jar!/support/http/resources/js/common.js</span><br></pre></td></tr></table></figure><h3 id="7-2-使用过滤器过滤">7.2 使用过滤器过滤</h3><p>注册一个过滤器，过滤<code>common.js</code>的请求，使用正则表达式替换相关的广告内容，如下代码所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter</span>(DruidDataSourceAutoConfigure<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnProperty</span>(<span class="title">name</span> </span>= <span class="string">"spring.datasource.druid.stat-view-servlet.enabled"</span>,</span><br><span class="line">havingValue = <span class="string">"true"</span>, matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoveDruidAdConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 方法名: removeDruidAdFilterRegistrationBean</span></span><br><span class="line"><span class="comment">    * 方法描述 除去页面底部的广告</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> properties com.alibaba.druid.spring.boot.autoconfigure.properties.DruidStatProperties</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> org.springframework.boot.web.servlet.FilterRegistrationBean</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">removeDruidAdFilterRegistrationBean</span><span class="params">(DruidStatProperties properties)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取web监控页面的参数</span></span><br><span class="line">        DruidStatProperties.StatViewServlet config = properties.getStatViewServlet();</span><br><span class="line">        <span class="comment">// 提取common.js的配置路径</span></span><br><span class="line">        String pattern = config.getUrlPattern() != <span class="keyword">null</span> ? config.getUrlPattern() : <span class="string">"/druid/*"</span>;</span><br><span class="line">        String commonJsPattern = pattern.replaceAll(<span class="string">"\\*"</span>, <span class="string">"js/common.js"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> String filePath = <span class="string">"support/http/resources/js/common.js"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建filter进行过滤</span></span><br><span class="line">        Filter filter = <span class="keyword">new</span> Filter() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">                chain.doFilter(request, response);</span><br><span class="line">                <span class="comment">// 重置缓冲区，响应头不会被重置</span></span><br><span class="line">                response.resetBuffer();</span><br><span class="line">                <span class="comment">// 获取common.js</span></span><br><span class="line">                String text = Utils.readFromResource(filePath);</span><br><span class="line">                <span class="comment">// 正则替换banner, 除去底部的广告信息</span></span><br><span class="line">                text = text.replaceAll(<span class="string">"&lt;a.*?banner\"&gt;&lt;/a&gt;&lt;br/&gt;"</span>, <span class="string">""</span>);</span><br><span class="line">                text = text.replaceAll(<span class="string">"powered.*?shrek.wang&lt;/a&gt;"</span>, <span class="string">""</span>);</span><br><span class="line">                response.getWriter().write(text);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        FilterRegistrationBean registrationBean = <span class="keyword">new</span> FilterRegistrationBean();</span><br><span class="line">        registrationBean.setFilter(filter);</span><br><span class="line">        registrationBean.addUrlPatterns(commonJsPattern);</span><br><span class="line">        <span class="keyword">return</span> registrationBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8、-获取-Druid-的监控数据">8、 获取 Druid 的监控数据</h2><p>Druid的监控数据可以在开启<code>StatFilter</code>后，通过<code>DruidStatManagerFacade</code>进行获取;<code>DruidStatManagerFacade#getDataSourceStatDataList</code>该方法可以获取所有数据源的监控数据，除此之外<code>DruidStatManagerFacade</code>还提供了一些其他方法，可以按需选择使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/druid"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DruidStatController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/stat"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">druidStat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 获取数据源的监控数据</span></span><br><span class="line">        <span class="keyword">return</span> DruidStatManagerFacade.getInstance().getDataSourceStatDataList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>转载自：<a href="https://blog.csdn.net/lvoelife/article/details/128092586" target="_blank" rel="noopener">https://blog.csdn.net/lvoelife/article/details/128092586</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1、基本概念&quot;&gt;1、基本概念&lt;/h2&gt;
&lt;p&gt;我们都使用过连接池，比如&lt;code&gt;C3P0，DBCP，hikari， Druid&lt;/code&gt;，虽然HikariCP的速度稍快，但Druid能够提供强大的监控和扩展功能，也是阿里巴巴的开源项目。Druid是阿里巴巴开发的号称为监控而生的数据库连接池，在功能、性能、扩展性方面，都超过其他数据库连接池，包括&lt;code&gt;DBCP、C3P0、BoneCP、Proxool、JBoss DataSource&lt;/code&gt;等等，秒杀一切。&lt;/p&gt;
&lt;p&gt;Druid可以很好的监控DB池连接和SQL的执行情况，天生就是针对监控而生的DB连接池。Spring Boot默认数据源&lt;code&gt;HikariDataSource&lt;/code&gt;与&lt;code&gt;JdbcTemplate&lt;/code&gt;中已经介绍Spring Boot 2.x默认使用Hikari数据源，可以说Hikari与Driud都是当前Java Web上最优秀的数据源。而Druid已经在阿里巴巴部署了超过600个应用，经过好几年生产环境大规模部署的严苛考验！&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;stat：&lt;/strong&gt; Druid内置提供一个&lt;code&gt;StatFilter&lt;/code&gt;，用于统计监控信息。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;wall：&lt;/strong&gt; Druid防御SQL注入攻击的&lt;code&gt;WallFilter&lt;/code&gt;就是通过Druid的SQL Parser分析。Druid提供的&lt;code&gt;SQL Parser&lt;/code&gt;可以在JDBC层拦截SQL做相应处理，比如说分库分表、审计等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;log4j2：&lt;/strong&gt; 这个就是 日志记录的功能，可以把sql语句打印到log4j2供排查问题。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Java" scheme="https://www.shawn22.xyz/categories/Java/"/>
    
    
    <category term="SQL" scheme="https://www.shawn22.xyz/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>ShardingSphere5学习笔记</title>
    <link href="https://www.shawn22.xyz/posts/2738e02e.html"/>
    <id>https://www.shawn22.xyz/posts/2738e02e.html</id>
    <published>2022-10-31T13:45:12.000Z</published>
    <updated>2022-10-31T13:46:15.559Z</updated>
    
    <content type="html"><![CDATA[<h1>一、简介</h1><h2 id="1、介绍">1、介绍</h2><blockquote><p>本文属于改参考文章的升级版，部分内容可以参考：<a href="https://blog.csdn.net/lemon_TT/article/details/120201007" target="_blank" rel="noopener" title="ShardingSphere数据库中间件基础学习">ShardingSphere数据库中间件基础学习</a></p></blockquote><p>互联网业务兴起之后，海量用户加上海量数据的特点，单个数据库服务器已经难以满足业务需要，必须考虑数据库集群的方式来提升性能。高性能数据库集群的第一种方式是&quot;<code>读写分离</code>&quot;，第二种方式是&quot;<code>数据库分片</code>&quot;；</p><p>读写分离和数据分片具体的实现方式一般有两种： <code>程序代码封装</code>和<code>中间件封装</code>，中间件软件有**Apache ShardingSphere（程序级别和中间件级别）**和MyCat（数据库中间件）</p><a id="more"></a><h2 id="2、读写分离架构">2、读写分离架构</h2><h3 id="2-1-理论介绍">2.1 理论介绍</h3><p>**读写分离原理：**读写分离的基本原理是将数据库读写操作分散到不同的节点上</p><p><strong>读写分离的基本实现：</strong></p><ul><li><p><code>主库负责处理事务性的增删改操作，从库负责处理查询操作</code>，能够有效的避免由数据更新导致的行锁，使得整个系统的查询性能得到极大的改善。</p></li><li><p>读写分离是<code>根据 SQL 语义的分析</code>，<code>将读操作和写操作分别路由至主库与从库</code>。</p></li><li><p>通过<code>一主多从</code>的配置方式，可以将查询请求均匀的分散到多个数据副本，能够进一步的提升系统的处理能力。</p></li><li><p>使用<code>多主多从</code>的方式，不但能够提升系统的吞吐量，还能够提升系统的可用性，可以达到在任何一个数据库宕机，甚至磁盘物理损坏的情况下仍然不影响系统的正常运行。</p></li></ul><h3 id="2-2-CAP理论">2.2 CAP理论</h3><p>CAP 定理（CAP theorem）又被称作布鲁尔定理（Brewer’s theorem），是加州大学伯克利分校的计算机科学家埃里克·布鲁尔（Eric Brewer）在 2000 年的 ACM PODC 上提出的一个猜想。在一个<code>分布式系统中</code>，当涉及读写操作时，只能保证**一致性（Consistence）、可用性（Availability）、分区容错性（Partition Tolerance）**三者中的两个，另外一个必须被牺牲。</p><ul><li><p>C 一致性（Consistency）：对某个指定的客户端来说，读操作保证能够返回最新的写操作结果</p></li><li><p>A 可用性（Availability）：非故障的节点在合理的时间内返回合理的响应<code>（不是错误和超时的响应）</code></p></li><li><p>P 分区容忍性（Partition Tolerance）：当出现网络分区后<code>（可能是丢包，也可能是连接中断，还可能是拥塞）</code>，系统能够继续“履行职责”</p></li></ul><p><strong>CAP特点：</strong></p><ul><li><p>CP：<code>为了保证一致性</code>，当发生分区现象后，N1 节点上的数据已经更新到 y，但由于 N1 和 N2 之间的复制通道中断，数据 y 无法同步到 N2，N2 节点上的数据还是 x。<code>这时客户端 C 访问 N2 时，N2 需要返回 Error，提示客户端 C“系统现在发生了错误”，</code>这种处理方式<code>违背了可用性</code>（Availability）的要求，因此 CAP 三者只能满足 CP</p></li><li><p>AP：<code>为了保证可用性</code>，当发生分区现象后，N1 节点上的数据已经更新到 y，但由于 N1 和 N2 之间的复制通道中断，数据 y 无法同步到 N2，N2 节点上的数据还是 x。<code>这时客户端 C 访问 N2 时，N2 将当前自己拥有的数据 x 返回给客户端 C 了</code>，而实际上当前最新的数据已经是 y 了，这就<code>不满足一致性</code>（Consistency）的要求了，因此 CAP 三者只能满足 AP。注意：这里 N2 节点返回 x，虽然不是一个“正确”的结果，但是一个“合理”的结果，因为 x 是旧的数据，并不是一个错乱的值，只是不是最新的数据而已</p></li></ul><p>CAP 理论中的 <code>C 在实践中是不可能完美实现的</code>，在数据复制的过程中，节点N1 和节点 N2 的数据并不一致（强一致性）。即使无法做到<code>强一致性</code>，但应用可以采用适合的方式达到<code>最终一致性</code>。具有如下特点：</p><ul><li><p>基本可用（Basically Available）：分布式系统在出现故障时，允许损失部分可用性，即保证核心可用。</p></li><li><p>软状态（Soft State）：允许系统存在中间状态，而该中间状态不会影响系统整体可用性。这里的中间状态就是 CAP 理论中的数据不一致。</p></li><li><p><code>最终一致性（Eventual Consistency）：系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。</code></p></li></ul><h2 id="3、数据库分片架构">3、数据库分片架构</h2><ul><li><p><strong>读写分离的问题</strong></p><p>读写分离分散了数据库读写操作的压力，但没有分散存储压力，为了满足业务数据存储的需求，就需要<code>将存储分散到多台数据库服务器上</code>。</p></li><li><p><strong>数据分片</strong></p><p>将存放在单一数据库中的数据分散地存放至多个数据库或表中，以达到提升性能瓶颈以及可用性的效果。 数据分片的有效手段是对关系型数据库进行<code>分库和分表</code>。数据分片的拆分方式又分为<code>垂直分片和水平分片</code></p></li></ul><h3 id="3-1-垂直分片">3.1 垂直分片</h3><ul><li><p><strong>垂直分库</strong></p><p><code>按照业务拆分的方式称为垂直分片，又称为纵向拆分</code>，它的核心理念是专库专用。 在拆分之前，一个数据库由多个数据表构成，每个表对应着不同的业务。而拆分之后，则是按照业务将表进行归类，分布到不同的数据库中，从而将压力分散至不同的数据库。 垂直拆分可以缓解数据量和访问量带来的问题，但无法根治。<code>如果垂直拆分之后，表中的数据量依然超过单节点所能承载的阈值，则需要水平分片来进一步处理</code></p></li><li><p><strong>垂直分表</strong></p><p><code>垂直分表适合将表中某些不常用的列，或者是占了大量空间的列拆分出去。</code>假设我们是一个婚恋网站，用户在筛选其他用户的时候，主要是用 age 和 sex 两个字段进行查询，而 nickname 和 description 两个字段主要用于展示，一般不会在业务查询中用到。description 本身又比较长，因此我们可以将这两个字段独立到另外一张表中，这样在查询 age 和 sex 时，就能带来一定的性能提升。垂直分表引入的复杂性主要体现在表操作的数量要增加。</p></li></ul><h3 id="3-2-水平分片">3.2 水平分片</h3><blockquote><p><strong>阿里巴巴Java开发手册：</strong>【推荐】单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。说明：如果预计三年后的数据量根本达不到这个级别，<code>请不要在创建表时就分库分表</code></p></blockquote><p><code>水平分片又称为横向拆分。</code> 相对于垂直分片，它不再将数据根据业务逻辑分类，而是通过某个字段（或某几个字段），根据某种规则将数据分散至多个库或表中，每个分片仅包含数据的一部分。 例如：根据主键分片，偶数主键的记录放入 0 库（或表），奇数主键的记录放入 1 库（或表）。单表进行切分后，是否将多个表分散在不同的数据库服务器中，可以根据实际的切分效果来确定。</p><ul><li><p><strong>水平分表</strong>：单表切分为多表后，新的表即使在同一个数据库服务器中，也可能带来可观的性能提升，如果性能能够满足业务要求，可以不拆分到多台数据库服务器，毕竟业务分库也会引入很多复杂性；</p></li><li><p><strong>水平分库</strong>：如果单表拆分为多表后，单台服务器依然无法满足性能要求，那就需要将多个表分散在不同的数据库服务器中。</p></li></ul><h2 id="4、ShardingSphere介绍">4、ShardingSphere介绍</h2><h3 id="4-1-简介">4.1 简介</h3><blockquote><p>官网：<a href="https://shardingsphere.apache.org/index_zh.html" target="_blank" rel="noopener" title="https://shardingsphere.apache.org/index_zh.html">https://shardingsphere.apache.org/index_zh.html</a><br>文档：<a href="https://shardingsphere.apache.org/document/5.1.1/cn/overview/" target="_blank" rel="noopener" title="https://shardingsphere.apache.org/document/5.1.1/cn/overview/">https://shardingsphere.apache.org/document/5.1.1/cn/overview/</a></p></blockquote><p>Apache ShardingSphere 由 JDBC、Proxy 和 Sidecar（规划中）这 3 款既能够独立部署，又支持混合部署配合使用的产品组成。</p><h3 id="4-2-ShardingSphere-JDBC">4.2 ShardingSphere-JDBC</h3><p><strong>程序代码封装</strong>。定位为轻量级 Java 框架，<code>在 Java 的 JDBC 层提供的额外服务</code>。 它使用客户端直连数据库，<code>以 jar 包形式提供服务</code>，无需额外部署和依赖，可理解为增强版的 JDBC 驱动，完全兼容 JDBC 和各种 ORM 框架<br><img src="https://img-blog.csdnimg.cn/31051ed9bd9d40cbb49cefa3f3728179.png#pic_center" alt="在这里插入图片描述"></p><h3 id="4-3-ShardingSphere-Proxy">4.3 ShardingSphere-Proxy</h3><p>**中间件封装。**定位为透明化的<code>数据库代理端</code>，提供封装了数据库二进制协议的服务端版本，用于完成对异构语言的支持。 目前提供 MySQL 和 PostgreSQL版本，它可以使用任何兼容 MySQL/PostgreSQL 协议的访问客户端（如：MySQL Command Client, MySQL Workbench, Navicat 等）操作数据，对 DBA 更加友好</p><p><img src="https://img-blog.csdnimg.cn/e413c0c62538488d85a6a5033ad827ad.png#pic_center" alt="在这里插入图片描述"></p><h1>二、MySQL主从配置</h1><h2 id="1、MySQL主从同步原理">1、MySQL主从同步原理</h2><blockquote><p>详细也可以参考上一篇<a href="https://blog.csdn.net/lemon_TT/article/details/120201007" target="_blank" rel="noopener" title="ShardingSphere文章">ShardingSphere文章</a><br>Docker参考文章：<a href="https://blog.csdn.net/lemon_TT/article/details/125981712" target="_blank" rel="noopener" title="docker学习笔记">docker学习笔记</a></p></blockquote><p><strong>基本原理：</strong></p><p>slave会从master读取binlog来进行数据同步</p><p><strong>具体步骤：</strong></p><ul><li><p><code>step1：</code>master将数据改变记录到<code>二进制日志（binary log）</code>中。</p></li><li><p><code>step2：</code> 当slave上执行 <code>start slave</code> 命令之后，slave会创建一个 <code>IO 线程</code>用来连接master，请求master中的binlog。</p></li><li><p><code>step3：</code>当slave连接master时，master会创建一个 <code>log dump 线程</code>，用于发送 binlog 的内容。在读取 binlog 的内容的操作中，会对主节点上的 binlog 加锁，当读取完成并发送给从服务器后解锁。</p></li><li><p><code>step4：</code>IO 线程接收主节点 binlog dump 进程发来的更新之后，保存到 <code>中继日志（relay log）</code> 中。</p></li><li><p><code>step5：</code>slave的<code>SQL线程</code>，读取relay log日志，并解析成具体操作，从而实现主从操作一致，最终数据一致。</p></li></ul><h2 id="2、主服务器准备">2、主服务器准备</h2><p><strong>step1：<strong>docker中</strong>创建并启动MySQL主服务器</strong>：<code>端口3306</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">-p 3306:3306 \</span><br><span class="line">-v /data/mysql/master/conf:/etc/mysql/conf.d \</span><br><span class="line">-v /data/master/data:/var/lib/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=123456 \</span><br><span class="line">--name mysql-master \</span><br><span class="line">mysql:8.0.29</span><br></pre></td></tr></table></figure><p><strong>step2：创建MySQL主服务器配置文件</strong>，默认情况下MySQL的binlog日志是自动开启的，可以通过如下配置定义一些可选配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vim /data/mysql/master/conf/my.cnf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line"><span class="comment"># 服务器唯一id，默认值1</span></span><br><span class="line">server-id=1</span><br><span class="line"><span class="comment"># 设置日志格式，默认值ROW</span></span><br><span class="line">binlog_format=STATEMENT</span><br><span class="line"><span class="comment"># 二进制日志名，默认binlog</span></span><br><span class="line"><span class="comment"># log-bin=binlog</span></span><br><span class="line"><span class="comment"># 设置需要复制的数据库，默认复制全部数据库，优先级比binlog-do-db高</span></span><br><span class="line"><span class="comment">#binlog-do-db=mytestdb</span></span><br><span class="line"><span class="comment"># 设置不需要复制的数据库，不配置binlog-do-db这个才生效</span></span><br><span class="line"><span class="comment">#binlog-ignore-db=mysql</span></span><br><span class="line"><span class="comment">#binlog-ignore-db=infomation_schema</span></span><br></pre></td></tr></table></figure><p>最后重启</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart mysql-master</span><br></pre></td></tr></table></figure><p><code>binlog格式说明：</code></p><ul><li><p>binlog_format=STATEMENT：日志记录的是主机数据库的<code>写指令</code>，性能高，但是now()之类的函数以及获取系统参数的操作会出现主从数据不同步的问题。</p></li><li><p>binlog_format=ROW（默认）：日志记录的是主机数据库的<code>写后的数据</code>，批量操作时性能较差，解决now()或者 user()或者 @@hostname 等操作在主从机器上不一致的问题。</p></li><li><p>binlog_format=MIXED：是以上两种level的混合使用，有函数用ROW，没函数用STATEMENT，但是无法识别系统变量</p></li></ul><p><strong>step3：使用命令行登录MySQL主服务器</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#进入容器：env LANG=C.UTF-8 避免容器中显示中文乱码</span></span><br><span class="line">docker <span class="built_in">exec</span> -it mysql-master env LANG=C.UTF-8 /bin/bash</span><br><span class="line"><span class="comment">#进入容器内的mysql命令行</span></span><br><span class="line">mysql -uroot -p</span><br><span class="line"><span class="comment">#修改默认密码校验方式</span></span><br><span class="line">ALTER USER <span class="string">'root'</span>@<span class="string">'%'</span> IDENTIFIED WITH mysql_native_password BY <span class="string">'123456'</span>;</span><br></pre></td></tr></table></figure><p><strong>step4：主机中创建slave用户</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建slave用户</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">'slave'</span>@<span class="string">'%'</span>;</span><br><span class="line"><span class="comment">-- 设置密码</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">'slave'</span>@<span class="string">'%'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">WITH</span> mysql_native_password <span class="keyword">BY</span> <span class="string">'123456'</span>;</span><br><span class="line"><span class="comment">-- 授予复制权限</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">REPLICATION</span> <span class="keyword">SLAVE</span> <span class="keyword">ON</span> *.* <span class="keyword">TO</span> <span class="string">'slave'</span>@<span class="string">'%'</span>;</span><br><span class="line"><span class="comment">-- 刷新权限</span></span><br><span class="line"><span class="keyword">FLUSH</span> <span class="keyword">PRIVILEGES</span>;</span><br></pre></td></tr></table></figure><p><strong>step5：主机中查询master状态</strong></p><p>执行完此步骤后<code>不要再操作主服务器MYSQL</code>，防止主服务器状态值变化，记下<code>File</code>和<code>Position</code>的值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW MASTER STATUS;</span><br></pre></td></tr></table></figure><h2 id="3、从服务器准备">3、从服务器准备</h2><p>这里可以配置多台从机slave1、slave2…</p><p><strong>step1：在docker中创建并启动MySQL从服务器：</strong><code>端口3307</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">-p 3307:3306 \</span><br><span class="line">-v /data/mysql/slave1/conf:/etc/mysql/conf.d \</span><br><span class="line">-v //mysql/slave1/data:/var/lib/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=123456 \</span><br><span class="line">--name mysql-slave1 \</span><br><span class="line">mysql:8.0.29</span><br></pre></td></tr></table></figure><p><strong>step2：创建MySQL从服务器配置文件</strong>，最后重启MySQL容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vim /data/mysql/slave1/conf/my.cnf</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line"><span class="comment"># 服务器唯一id，每台服务器的id必须不同，如果配置其他从机，注意修改id</span></span><br><span class="line">server-id=2</span><br><span class="line"><span class="comment"># 中继日志名，默认xxxxxxxxxxxx-relay-bin</span></span><br><span class="line"><span class="comment">#relay-log=relay-bin</span></span><br></pre></td></tr></table></figure><p><strong>step3：使用命令行登录MySQL从服务器</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#进入容器：</span></span><br><span class="line">docker <span class="built_in">exec</span> -it mysql-slave1 env LANG=C.UTF-8 /bin/bash</span><br><span class="line"><span class="comment">#进入容器内的mysql命令行</span></span><br><span class="line">mysql -uroot -p</span><br><span class="line"><span class="comment">#修改默认密码校验方式</span></span><br><span class="line">ALTER USER <span class="string">'root'</span>@<span class="string">'%'</span> IDENTIFIED WITH mysql_native_password BY <span class="string">'123456'</span>;</span><br></pre></td></tr></table></figure><p><strong>step4：在从机上配置主从关系</strong>，在<strong>从机</strong>上执行以下SQL操作</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CHANGE</span> <span class="keyword">MASTER</span> <span class="keyword">TO</span> MASTER_HOST=<span class="string">'192.168.249.135'</span>,MASTER_USER=<span class="string">'slave'</span>,MASTER_PASSWORD=<span class="string">'123456'</span>, MASTER_PORT=<span class="number">3306</span>,MASTER_LOG_FILE=<span class="string">'binlog.000003'</span>,MASTER_LOG_POS=<span class="number">1616</span>;</span><br></pre></td></tr></table></figure><h2 id="4、启动主从同步">4、启动主从同步</h2><p>启动从机的复制功能，执行SQL；当<code>Slave_IO_Running: Yes</code>和<code>Slave_SQL_Running: Yes</code>都为Yes时启动成功</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> <span class="keyword">SLAVE</span>;</span><br><span class="line"><span class="comment">-- 查看状态（不需要分号）</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">SLAVE</span> <span class="keyword">STATUS</span>\G</span><br></pre></td></tr></table></figure><p><strong>停止与重置</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 在从机上执行。功能说明：停止I/O 线程和SQL线程的操作。</span></span><br><span class="line"><span class="keyword">stop</span> <span class="keyword">slave</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在从机上执行。功能说明：用于删除SLAVE数据库的relaylog日志文件，并重新启用新的relaylog文件。</span></span><br><span class="line"><span class="keyword">reset</span> <span class="keyword">slave</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在主机上执行。功能说明：删除所有的binglog日志文件，并将日志索引文件清空，重新开始所有新的日志文件。</span></span><br><span class="line"><span class="comment">-- 用于第一次进行搭建主从库时，进行主库binlog初始化工作；</span></span><br><span class="line"><span class="keyword">reset</span> <span class="keyword">master</span>;</span><br></pre></td></tr></table></figure><p>测试，在主机中执行以下SQL，在从机中查看数据库、表和数据是否已经被同步</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> db_user;</span><br><span class="line"><span class="keyword">USE</span> db_user;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_user (</span><br><span class="line"> <span class="keyword">id</span> <span class="built_in">BIGINT</span> AUTO_INCREMENT,</span><br><span class="line"> uname <span class="built_in">VARCHAR</span>(<span class="number">30</span>),</span><br><span class="line"> PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_user(uname) <span class="keyword">VALUES</span>(<span class="string">'shawn'</span>);</span><br><span class="line"><span class="comment">-- 动态获取主机名字</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_user(uname) <span class="keyword">VALUES</span>(@@hostname);</span><br></pre></td></tr></table></figure><h2 id="5、常见问题">5、常见问题</h2><h3 id="5-1-示例一">5.1 示例一</h3><p>启动主从同步后，常见错误是<code>Slave_IO_Running： No 或者 Connecting</code> 的情况，此时查看下方的 <code>Last_IO_ERROR</code>错误日志，根据日志中显示的错误信息在网上搜索解决方案即可</p><p><strong>典型的错误例如：</strong><code>Last_IO_Error: Got fatal error 1236 from master when reading data from binary log: 'Client requested master to start replication from position &gt; file size'</code></p><p><strong>解决方案：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 在从机停止slave</span></span><br><span class="line">SLAVE <span class="keyword">STOP</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在主机查看mater状态</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">MASTER</span> <span class="keyword">STATUS</span>;</span><br><span class="line"><span class="comment">-- 在主机刷新日志</span></span><br><span class="line"><span class="keyword">FLUSH</span> <span class="keyword">LOGS</span>;</span><br><span class="line"><span class="comment">-- 再次在主机查看mater状态（会发现File和Position发生了变化）</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">MASTER</span> <span class="keyword">STATUS</span>;</span><br><span class="line"><span class="comment">-- 修改从机连接主机的SQL，并重新连接即可</span></span><br></pre></td></tr></table></figure><h3 id="5-2-示例二">5.2 示例二</h3><p>启动docker容器后提示 <code>WARNING: IPv4 forwarding is disabled. Networking will not work.</code>此错误，虽然不影响主从同步的搭建，但是如果想从远程客户端通过以下方式连接docker中的MySQL则没法连接</p><p><strong>解决方案：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#修改配置文件，这是Centos的解决方案，原理是这样</span></span><br><span class="line">vim /usr/lib/sysctl.d/00-system.conf</span><br><span class="line"><span class="comment">#追加</span></span><br><span class="line">net.ipv4.ip_forward=1</span><br><span class="line"><span class="comment">#接着重启网络</span></span><br><span class="line">systemctl restart network</span><br></pre></td></tr></table></figure><h1>三、ShardingSphere-JDBC</h1><h2 id="1、ShardingSphere-JDBC读写分离">1、ShardingSphere-JDBC读写分离</h2><blockquote><p><a href="https://shardingsphere.apache.org/document/5.1.1/cn/user-manual/shardingsphere-jdbc/spring-boot-starter/mode/" target="_blank" rel="noopener" title="https://shardingsphere.apache.org/document/5.1.1/cn/user-manual/shardingsphere-jdbc/spring-boot-starter/mode/">https://shardingsphere.apache.org/document/5.1.1/cn/user-manual/shardingsphere-jdbc/spring-boot-starter/mode/</a></p></blockquote><h3 id="1-1-环境与项目创建">1.1 环境与项目创建</h3><p>添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shardingsphere<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shardingsphere-jdbc-core-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>创建实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableName</span>(<span class="string">"t_user"</span>)</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@TableId</span>(type = IdType.AUTO)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String uname;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建Mapper</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-配置文件">1.2 配置文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"># 应用名称</span><br><span class="line">spring.application.name&#x3D;sharging-jdbc-demo</span><br><span class="line"># 开发环境设置</span><br><span class="line">spring.profiles.active&#x3D;dev</span><br><span class="line"># 内存模式，正式环境一般是集群模式</span><br><span class="line">spring.shardingsphere.mode.type&#x3D;Memory</span><br><span class="line"></span><br><span class="line"># 配置真实数据源</span><br><span class="line">spring.shardingsphere.datasource.names&#x3D;master,slave1</span><br><span class="line"></span><br><span class="line"># 配置第 1 个数据源</span><br><span class="line">spring.shardingsphere.datasource.master.type&#x3D;com.zaxxer.hikari.HikariDataSource</span><br><span class="line">spring.shardingsphere.datasource.master.driver-class-name&#x3D;com.mysql.jdbc.Driver</span><br><span class="line">spring.shardingsphere.datasource.master.jdbc-url&#x3D;jdbc:mysql:&#x2F;&#x2F;192.168.249.135:3306&#x2F;db_user</span><br><span class="line">spring.shardingsphere.datasource.master.username&#x3D;root</span><br><span class="line">spring.shardingsphere.datasource.master.password&#x3D;123456</span><br><span class="line"></span><br><span class="line"># 配置第 2 个数据源</span><br><span class="line">spring.shardingsphere.datasource.slave1.type&#x3D;com.zaxxer.hikari.HikariDataSource</span><br><span class="line">spring.shardingsphere.datasource.slave1.driver-class-name&#x3D;com.mysql.jdbc.Driver</span><br><span class="line">spring.shardingsphere.datasource.slave1.jdbc-url&#x3D;jdbc:mysql:&#x2F;&#x2F;192.168.249.135:3307&#x2F;db_user</span><br><span class="line">spring.shardingsphere.datasource.slave1.username&#x3D;root</span><br><span class="line">spring.shardingsphere.datasource.slave1.password&#x3D;123456</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 读写分离类型，如: Static，Dynamic</span><br><span class="line">spring.shardingsphere.rules.readwrite-splitting.data-sources.myds.type&#x3D;Static</span><br><span class="line"># 写数据源名称</span><br><span class="line">spring.shardingsphere.rules.readwrite-splitting.data-sources.myds.props.write-data-source-name&#x3D;master</span><br><span class="line"># 读数据源名称，多个从数据源用逗号分隔</span><br><span class="line">spring.shardingsphere.rules.readwrite-splitting.data-sources.myds.props.read-data-source-names&#x3D;slave1</span><br><span class="line"></span><br><span class="line"># 负载均衡算法名称</span><br><span class="line">spring.shardingsphere.rules.readwrite-splitting.data-sources.myds.load-balancer-name&#x3D;alg_round</span><br><span class="line"></span><br><span class="line"># 负载均衡算法配置</span><br><span class="line"># 负载均衡算法类型</span><br><span class="line">spring.shardingsphere.rules.readwrite-splitting.load-balancers.alg_round.type&#x3D;ROUND_ROBIN</span><br><span class="line">spring.shardingsphere.rules.readwrite-splitting.load-balancers.alg_random.type&#x3D;RANDOM</span><br><span class="line">spring.shardingsphere.rules.readwrite-splitting.load-balancers.alg_weight.type&#x3D;WEIGHT</span><br><span class="line">spring.shardingsphere.rules.readwrite-splitting.load-balancers.alg_weight.props.slave1&#x3D;1</span><br><span class="line">#spring.shardingsphere.rules.readwrite-splitting.load-balancers.alg_weight.props.slave2&#x3D;2</span><br><span class="line"></span><br><span class="line"># 打印SQl</span><br><span class="line">spring.shardingsphere.props.sql-show&#x3D;true</span><br></pre></td></tr></table></figure><h3 id="1-3-测试">1.3 测试</h3><ul><li><strong>读写分离测试</strong></li></ul><p>测试插入，通过日志可以看到Logic SQL逻辑SQl，因为应用程序将请求发送给<code>ShardingSphere</code>后并不关心是插入到哪台服务器，比如这里只是单纯把请求发送给myds的服务器组，由<code>ShardingSphere</code>的配置决定哪台是写服务器，最终进行SQL插入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadwriteTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写入数据的测试</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsert</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setUname(<span class="string">"顺丰"</span>);</span><br><span class="line">        userMapper.insert(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>事务测试</strong></li></ul><p>为了保证主从库间的事务一致性，避免跨服务的分布式事务，ShardingSphere-JDBC的<code>主从模型中，事务中的数据读写均用主库</code>。</p><ul><li><p>不添加@Transactional：insert对主库操作，select对从库操作</p></li><li><p>添加@Transactional：则insert和select均对主库操作</p></li><li><p>**注意：**在JUnit环境下的@Transactional注解，默认情况下就会对事务进行回滚（即使在没加注解@Rollback，也会对事务回滚）</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 事务测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Transactional</span><span class="comment">//开启事务</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTrans</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setUname(<span class="string">"圆通"</span>);</span><br><span class="line">    userMapper.insert(user);</span><br><span class="line"></span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>负载均衡测试</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读数据测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSelectAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(<span class="keyword">null</span>);</span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(<span class="keyword">null</span>);<span class="comment">//执行第二次测试负载均衡</span></span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、ShardingSphere-JDBC垂直分片">2、ShardingSphere-JDBC垂直分片</h2><blockquote><p><a href="https://shardingsphere.apache.org/document/5.1.1/cn/user-manual/shardingsphere-jdbc/spring-boot-starter/rules/sharding/" target="_blank" rel="noopener" title="https://shardingsphere.apache.org/document/5.1.1/cn/user-manual/shardingsphere-jdbc/spring-boot-starter/rules/sharding/">https://shardingsphere.apache.org/document/5.1.1/cn/user-manual/shardingsphere-jdbc/spring-boot-starter/rules/sharding/</a></p></blockquote><h3 id="2-1-环境准备">2.1 环境准备</h3><p>创建server-user容器和server-order容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">-p 3301:3306 \</span><br><span class="line">-v /data/server/user/conf:/etc/mysql/conf.d \</span><br><span class="line">-v /data/server/user/data:/var/lib/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=123456 \</span><br><span class="line">--name server-user \</span><br><span class="line">mysql:8.0.29</span><br><span class="line"></span><br><span class="line">docker run -d \</span><br><span class="line">-p 3302:3306 \</span><br><span class="line">-v /data/server/order/conf:/etc/mysql/conf.d \</span><br><span class="line">-v /data/server/order/data:/var/lib/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=123456 \</span><br><span class="line">--name server-order \</span><br><span class="line">mysql:8.0.29</span><br></pre></td></tr></table></figure><p>登录MySQL服务器修改一下密码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#进入容器：</span></span><br><span class="line">docker <span class="built_in">exec</span> -it server-user env LANG=C.UTF-8 /bin/bash</span><br><span class="line"><span class="comment">#进入容器内的mysql命令行</span></span><br><span class="line">mysql -uroot -p</span><br><span class="line"><span class="comment">#修改默认密码插件</span></span><br><span class="line">ALTER USER <span class="string">'root'</span>@<span class="string">'%'</span> IDENTIFIED WITH mysql_native_password BY <span class="string">'123456'</span>;</span><br></pre></td></tr></table></figure><p>在两个库分布创建数据表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 这是server-user</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> db_user;</span><br><span class="line"><span class="keyword">USE</span> db_user;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_user (</span><br><span class="line"> <span class="keyword">id</span> <span class="built_in">BIGINT</span> AUTO_INCREMENT,</span><br><span class="line"> uname <span class="built_in">VARCHAR</span>(<span class="number">30</span>),</span><br><span class="line"> PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 这是server-order</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> db_order;</span><br><span class="line"><span class="keyword">USE</span> db_order;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_order (</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">BIGINT</span> AUTO_INCREMENT,</span><br><span class="line">  order_no <span class="built_in">VARCHAR</span>(<span class="number">30</span>),</span><br><span class="line">  user_id <span class="built_in">BIGINT</span>,</span><br><span class="line">  amount <span class="built_in">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>),</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>) </span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="2-2-程序实现">2.2 程序实现</h3><p>创建实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableName</span>(<span class="string">"t_order"</span>)</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="meta">@TableId</span>(type = IdType.AUTO)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String orderNo;</span><br><span class="line">    <span class="keyword">private</span> Long userId;</span><br><span class="line">    <span class="keyword">private</span> BigDecimal amount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建Mapper</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderMapper</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">Order</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置垂直分片</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"># 应用名称</span><br><span class="line">spring.application.name&#x3D;sharding-jdbc-demo</span><br><span class="line"># 环境设置</span><br><span class="line">spring.profiles.active&#x3D;dev</span><br><span class="line"></span><br><span class="line"># 配置真实数据源</span><br><span class="line">spring.shardingsphere.datasource.names&#x3D;server-user,server-order</span><br><span class="line"></span><br><span class="line"># 配置第 1 个数据源</span><br><span class="line">spring.shardingsphere.datasource.server-user.type&#x3D;com.zaxxer.hikari.HikariDataSource</span><br><span class="line">spring.shardingsphere.datasource.server-user.driver-class-name&#x3D;com.mysql.jdbc.Driver</span><br><span class="line">spring.shardingsphere.datasource.server-user.jdbc-url&#x3D;jdbc:mysql:&#x2F;&#x2F;192.168.249.135:3301&#x2F;db_user</span><br><span class="line">spring.shardingsphere.datasource.server-user.username&#x3D;root</span><br><span class="line">spring.shardingsphere.datasource.server-user.password&#x3D;123456</span><br><span class="line"></span><br><span class="line"># 配置第 2 个数据源</span><br><span class="line">spring.shardingsphere.datasource.server-order.type&#x3D;com.zaxxer.hikari.HikariDataSource</span><br><span class="line">spring.shardingsphere.datasource.server-order.driver-class-name&#x3D;com.mysql.jdbc.Driver</span><br><span class="line">spring.shardingsphere.datasource.server-order.jdbc-url&#x3D;jdbc:mysql:&#x2F;&#x2F;192.168.249.135:3302&#x2F;db_order</span><br><span class="line">spring.shardingsphere.datasource.server-order.username&#x3D;root</span><br><span class="line">spring.shardingsphere.datasource.server-order.password&#x3D;123456</span><br><span class="line"></span><br><span class="line"># 标准分片表配置（数据节点）</span><br><span class="line"># spring.shardingsphere.rules.sharding.tables.&lt;table-name&gt;.actual-data-nodes&#x3D;值</span><br><span class="line"># 值由数据源名 + 表名组成，以小数点分隔。</span><br><span class="line"># &lt;table-name&gt;：逻辑表名</span><br><span class="line">spring.shardingsphere.rules.sharding.tables.t_user.actual-data-nodes&#x3D;server-user.t_user</span><br><span class="line">spring.shardingsphere.rules.sharding.tables.t_order.actual-data-nodes&#x3D;server-order.t_order</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 打印SQL</span><br><span class="line">spring.shardingsphere.props.sql-show&#x3D;true</span><br></pre></td></tr></table></figure><h3 id="2-3-测试垂直分片">2.3 测试垂直分片</h3><p>测试通过日志可以发现程序写的是<strong>逻辑表名</strong>，会通过Sharding配置文件自动路由到对应的数据源下的数据表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShardingTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderMapper orderMapper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 垂直分片：插入数据测试</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsertOrderAndUser</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setUname(<span class="string">"强哥"</span>);</span><br><span class="line">        userMapper.insert(user);</span><br><span class="line"></span><br><span class="line">        Order order = <span class="keyword">new</span> Order();</span><br><span class="line">        order.setOrderNo(<span class="string">"SHAWN001"</span>);</span><br><span class="line">        order.setUserId(user.getId());</span><br><span class="line">        order.setAmount(<span class="keyword">new</span> BigDecimal(<span class="number">100</span>));</span><br><span class="line">        orderMapper.insert(order);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 垂直分片：查询数据测试</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSelectFromOrderAndUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">        User user = userMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">        Order order = orderMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果运行报错<code>Public Key Retrieval is not allowed</code>，是因为ShardingSphere-JDBC远程连接的方式默认的密码加密规则是：<strong>mysql_native_password</strong>。因此需要在服务器端修改服务器的密码加密规则，如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">'root'</span>@<span class="string">'%'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">WITH</span> mysql_native_password <span class="keyword">BY</span> <span class="string">'123456'</span>;</span><br></pre></td></tr></table></figure><h1>四、ShardingSphere-JDBC水平分片(常用)</h1><h2 id="1、环境准备">1、环境准备</h2><p>创建两个Mysql容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">-p 3310:3306 \</span><br><span class="line">-v /data/server/order0/conf:/etc/mysql/conf.d \</span><br><span class="line">-v /data/server/order0/data:/var/lib/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=123456 \</span><br><span class="line">--name server-order0 \</span><br><span class="line">mysql:8.0.29</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker run -d \</span><br><span class="line">-p 3311:3306 \</span><br><span class="line">-v /data/server/order1/conf:/etc/mysql/conf.d \</span><br><span class="line">-v /data/server/order1/data:/var/lib/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=123456 \</span><br><span class="line">--name server-order1 \</span><br><span class="line">mysql:8.0.29</span><br></pre></td></tr></table></figure><p>登录MySQL服务器操作</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#进入容器：</span></span><br><span class="line">docker exec -it server-order1 env LANG=C.UTF-8 /bin/bash</span><br><span class="line"><span class="comment">#进入容器内的mysql命令行</span></span><br><span class="line">mysql -uroot -p</span><br><span class="line"><span class="comment">#修改默认密码插件</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">'root'</span>@<span class="string">'%'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">WITH</span> mysql_native_password <span class="keyword">BY</span> <span class="string">'123456'</span>;</span><br></pre></td></tr></table></figure><p>创建数据库：和server-order1相同<code>注意：</code>水平分片的id需要在业务层实现，不能依赖数据库的主键自增</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> db_order;</span><br><span class="line"><span class="keyword">USE</span> db_order;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_order0 (</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">BIGINT</span>,</span><br><span class="line">  order_no <span class="built_in">VARCHAR</span>(<span class="number">30</span>),</span><br><span class="line">  user_id <span class="built_in">BIGINT</span>,</span><br><span class="line">  amount <span class="built_in">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>),</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>) </span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_order1 (</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">BIGINT</span>,</span><br><span class="line">  order_no <span class="built_in">VARCHAR</span>(<span class="number">30</span>),</span><br><span class="line">  user_id <span class="built_in">BIGINT</span>,</span><br><span class="line">  amount <span class="built_in">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>),</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>) </span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="2、基本水平分片">2、基本水平分片</h2><h3 id="2-1-基本配置">2.1 基本配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;基本配置</span><br><span class="line"># 应用名称</span><br><span class="line">spring.application.name&#x3D;sharging-jdbc-demo</span><br><span class="line"># 开发环境设置</span><br><span class="line">spring.profiles.active&#x3D;dev</span><br><span class="line"># 内存模式</span><br><span class="line">spring.shardingsphere.mode.type&#x3D;Memory</span><br><span class="line"># 打印SQl</span><br><span class="line">spring.shardingsphere.props.sql-show&#x3D;true</span><br></pre></td></tr></table></figure><h3 id="2-2-数据源配置">2.2 数据源配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;数据源配置</span><br><span class="line"># 配置真实数据源</span><br><span class="line">spring.shardingsphere.datasource.names&#x3D;server-user,server-order0,server-order1</span><br><span class="line"></span><br><span class="line"># 配置第 1 个数据源</span><br><span class="line">spring.shardingsphere.datasource.server-user.type&#x3D;com.zaxxer.hikari.HikariDataSource</span><br><span class="line">spring.shardingsphere.datasource.server-user.driver-class-name&#x3D;com.mysql.jdbc.Driver</span><br><span class="line">spring.shardingsphere.datasource.server-user.jdbc-url&#x3D;jdbc:mysql:&#x2F;&#x2F;192.168.249.135:3301&#x2F;db_user</span><br><span class="line">spring.shardingsphere.datasource.server-user.username&#x3D;root</span><br><span class="line">spring.shardingsphere.datasource.server-user.password&#x3D;123456</span><br><span class="line"></span><br><span class="line"># 配置第 2 个数据源</span><br><span class="line">spring.shardingsphere.datasource.server-order0.type&#x3D;com.zaxxer.hikari.HikariDataSource</span><br><span class="line">spring.shardingsphere.datasource.server-order0.driver-class-name&#x3D;com.mysql.jdbc.Driver</span><br><span class="line">spring.shardingsphere.datasource.server-order0.jdbc-url&#x3D;jdbc:mysql:&#x2F;&#x2F;192.168.249.135:3310&#x2F;db_order</span><br><span class="line">spring.shardingsphere.datasource.server-order0.username&#x3D;root</span><br><span class="line">spring.shardingsphere.datasource.server-order0.password&#x3D;123456</span><br><span class="line"></span><br><span class="line"># 配置第 3 个数据源</span><br><span class="line">spring.shardingsphere.datasource.server-order1.type&#x3D;com.zaxxer.hikari.HikariDataSource</span><br><span class="line">spring.shardingsphere.datasource.server-order1.driver-class-name&#x3D;com.mysql.jdbc.Driver</span><br><span class="line">spring.shardingsphere.datasource.server-order1.jdbc-url&#x3D;jdbc:mysql:&#x2F;&#x2F;192.168.249.135:3311&#x2F;db_order</span><br><span class="line">spring.shardingsphere.datasource.server-order1.username&#x3D;root</span><br><span class="line">spring.shardingsphere.datasource.server-order1.password&#x3D;123456</span><br></pre></td></tr></table></figure><h3 id="2-3-标椎分片表配置">2.3 标椎分片表配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;标准分片表配置（数据节点配置）</span><br><span class="line"># spring.shardingsphere.rules.sharding.tables.&lt;table-name&gt;.actual-data-nodes&#x3D;值</span><br><span class="line"># 值由数据源名 + 表名组成，以小数点分隔。多个表以逗号分隔，支持 inline 表达式。</span><br><span class="line"># &lt;table-name&gt;：逻辑表名</span><br><span class="line">spring.shardingsphere.rules.sharding.tables.t_user.actual-data-nodes&#x3D;server-user.t_user</span><br><span class="line">spring.shardingsphere.rules.sharding.tables.t_order.actual-data-nodes&#x3D;server-order0.t_order0,server-order0.t_order1,server-order1.t_order0,server-order1.t_order1</span><br></pre></td></tr></table></figure><p>修改Order实体类的主键策略：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@TableId(type = IdType.AUTO)//依赖数据库的主键自增策略</span></span><br><span class="line"><span class="meta">@TableId</span>(type = IdType.ASSIGN_ID)<span class="comment">//分布式id</span></span><br></pre></td></tr></table></figure><p>测试：保留上面配置中的一个分片表节点分别进行测试，检查每个分片节点是否可用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 水平分片：插入数据测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsertOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Order order = <span class="keyword">new</span> Order();</span><br><span class="line">    order.setOrderNo(<span class="string">"SHAWN001"</span>);</span><br><span class="line">    order.setUserId(<span class="number">1L</span>);</span><br><span class="line">    order.setAmount(<span class="keyword">new</span> BigDecimal(<span class="number">100</span>));</span><br><span class="line">    orderMapper.insert(order);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-行表达式">2.4 行表达式</h3><blockquote><p><a href="https://shardingsphere.apache.org/document/5.1.1/cn/features/sharding/concept/inline-expression/" target="_blank" rel="noopener" title="https://shardingsphere.apache.org/document/5.1.1/cn/features/sharding/concept/inline-expression/">https://shardingsphere.apache.org/document/5.1.1/cn/features/sharding/concept/inline-expression/</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;标准分片表配置（数据节点配置）</span><br><span class="line"># spring.shardingsphere.rules.sharding.tables.&lt;table-name&gt;.actual-data-nodes&#x3D;值</span><br><span class="line"># 值由数据源名 + 表名组成，以小数点分隔。多个表以逗号分隔，支持 inline 表达式。</span><br><span class="line"># &lt;table-name&gt;：逻辑表名</span><br><span class="line">spring.shardingsphere.rules.sharding.tables.t_user.actual-data-nodes&#x3D;server-user.t_user</span><br><span class="line">spring.shardingsphere.rules.sharding.tables.t_order.actual-data-nodes&#x3D;server-order$-&gt;&#123;0..1&#125;.t_order$-&gt;&#123;0..1&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-分片算法配置">2.5 分片算法配置</h3><blockquote><p><a href="https://shardingsphere.apache.org/document/5.1.1/cn/user-manual/shardingsphere-jdbc/builtin-algorithm/sharding/" target="_blank" rel="noopener" title="https://shardingsphere.apache.org/document/5.1.1/cn/user-manual/shardingsphere-jdbc/builtin-algorithm/sharding/">https://shardingsphere.apache.org/document/5.1.1/cn/user-manual/shardingsphere-jdbc/builtin-algorithm/sharding/</a></p></blockquote><ul><li><strong>水平分库</strong></li></ul><p>分片规则：order表中<code>user_id</code>为偶数时，数据插入<code>server-order0服务器</code>，<code>user_id</code>为奇数时，数据插入<code>server-order1服务器</code>。这样分片的好处是，同一个用户的订单数据，一定会被插入到同一台服务器上，查询一个用户的订单时效率较高。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#------------------------分库策略</span><br><span class="line"># 分片列名称</span><br><span class="line">spring.shardingsphere.rules.sharding.tables.t_order.database-strategy.standard.sharding-column&#x3D;user_id</span><br><span class="line"># 分片算法名称</span><br><span class="line">spring.shardingsphere.rules.sharding.tables.t_order.database-strategy.standard.sharding-algorithm-name&#x3D;alg_inline_userid</span><br><span class="line"></span><br><span class="line">#------------------------分片算法配置</span><br><span class="line"># 行表达式分片算法</span><br><span class="line"># 分片算法类型</span><br><span class="line">spring.shardingsphere.rules.sharding.sharding-algorithms.alg_inline_userid.type&#x3D;INLINE</span><br><span class="line"># 分片算法属性配置</span><br><span class="line">spring.shardingsphere.rules.sharding.sharding-algorithms.alg_inline_userid.props.algorithm-expression&#x3D;server-order$-&gt;&#123;user_id % 2&#125;</span><br><span class="line"></span><br><span class="line"># 取模分片算法</span><br><span class="line"># 分片算法类型</span><br><span class="line">spring.shardingsphere.rules.sharding.sharding-algorithms.alg_mod.type&#x3D;MOD</span><br><span class="line"># 分片算法属性配置</span><br><span class="line">spring.shardingsphere.rules.sharding.sharding-algorithms.alg_mod.props.sharding-count&#x3D;2</span><br></pre></td></tr></table></figure><p>因为只是暂时设置了分库，但未分表，先设置只在 <code>t_order0</code>表上进行测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxx.actual-data-nodes&#x3D;server-order$-&gt;&#123;0..1&#125;.t_order0</span><br></pre></td></tr></table></figure><p>测试：可以分别测试行表达式分片算法和取模分片算法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 水平分片：分库插入数据测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsertOrderDatabaseStrategy</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        Order order = <span class="keyword">new</span> Order();</span><br><span class="line">        order.setOrderNo(<span class="string">"SHAWN001"</span>);</span><br><span class="line">        order.setUserId(i + <span class="number">1</span>);</span><br><span class="line">        order.setAmount(<span class="keyword">new</span> BigDecimal(<span class="number">100</span>));</span><br><span class="line">        orderMapper.insert(order);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>水平分表</strong></p><p>分片规则：order表中<code>order_no的哈希值为偶数时</code>，数据插入对应服务器的<code>t_order0表</code>，<code>order_no的哈希值为奇数时</code>，数据插入对应服务器的<code>t_order1表</code>。因为order_no是字符串形式，因此不能直接取模。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#------------------------分表策略</span><br><span class="line"># 分片列名称</span><br><span class="line">spring.shardingsphere.rules.sharding.tables.t_order.table-strategy.standard.sharding-column&#x3D;order_no</span><br><span class="line"># 分片算法名称</span><br><span class="line">spring.shardingsphere.rules.sharding.tables.t_order.table-strategy.standard.sharding-algorithm-name&#x3D;alg_hash_mod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#------------------------分片算法配置</span><br><span class="line"># 哈希取模分片算法</span><br><span class="line"># 分片算法类型</span><br><span class="line">spring.shardingsphere.rules.sharding.sharding-algorithms.alg_hash_mod.type&#x3D;HASH_MOD</span><br><span class="line"># 分片算法属性配置</span><br><span class="line">spring.shardingsphere.rules.sharding.sharding-algorithms.alg_hash_mod.props.sharding-count&#x3D;2</span><br></pre></td></tr></table></figure><p>测试前不要忘记将如下节点改回原来的状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxx.actual-data-nodes&#x3D;server-order$-&gt;&#123;0..1&#125;.t_order$-&gt;&#123;0..1&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 水平分片：分表插入数据测试</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsertOrderTableStrategy</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">1</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">        Order order = <span class="keyword">new</span> Order();</span><br><span class="line">        order.setOrderNo(<span class="string">"ATGUIGU"</span> + i);</span><br><span class="line">        order.setUserId(<span class="number">1L</span>);</span><br><span class="line">        order.setAmount(<span class="keyword">new</span> BigDecimal(<span class="number">100</span>));</span><br><span class="line">        orderMapper.insert(order);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">5</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">        Order order = <span class="keyword">new</span> Order();</span><br><span class="line">        order.setOrderNo(<span class="string">"ATGUIGU"</span> + i);</span><br><span class="line">        order.setUserId(<span class="number">2L</span>);</span><br><span class="line">        order.setAmount(<span class="keyword">new</span> BigDecimal(<span class="number">100</span>));</span><br><span class="line">        orderMapper.insert(order);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试哈希取模</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHash</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意hash取模的结果是整个字符串hash后再取模，和数值后缀是奇数还是偶数无关</span></span><br><span class="line">    System.out.println(<span class="string">"ATGUIGU001"</span>.hashCode() % <span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">"ATGUIGU0011"</span>.hashCode() % <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 水平分片：查询所有记录</span></span><br><span class="line"><span class="comment"> * 查询了两个数据源，每个数据源中使用UNION ALL连接两个表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testShardingSelectAll</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;Order&gt; orders = orderMapper.selectList(<span class="keyword">null</span>);</span><br><span class="line">    orders.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 水平分片：根据user_id查询记录</span></span><br><span class="line"><span class="comment"> * 查询了一个数据源，每个数据源中使用UNION ALL连接两个表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testShardingSelectByUserId</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    QueryWrapper&lt;Order&gt; orderQueryWrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">    orderQueryWrapper.eq(<span class="string">"user_id"</span>, <span class="number">1L</span>);</span><br><span class="line">    List&lt;Order&gt; orders = orderMapper.selectList(orderQueryWrapper);</span><br><span class="line">    orders.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6-分布式序列算法">2.6 分布式序列算法</h3><blockquote><p><a href="https://shardingsphere.apache.org/document/5.1.1/cn/features/sharding/concept/key-generator/" target="_blank" rel="noopener" title="https://shardingsphere.apache.org/document/5.1.1/cn/features/sharding/concept/key-generator/">https://shardingsphere.apache.org/document/5.1.1/cn/features/sharding/concept/key-generator/</a></p></blockquote><p>水平分片需要关注全局序列，因为不能简单的使用基于数据库的主键自增。这里有两种方案：一种是<strong>基于MyBatisPlus的id策略</strong>；一种是<strong>ShardingSphere-JDBC的全局序列配置</strong>。</p><p><code>基于MyBatisPlus的id策略,</code>将Order类的id设置成如下形式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableId</span>(type = IdType.ASSIGN_ID)</span><br><span class="line"><span class="keyword">private</span> Long id;</span><br></pre></td></tr></table></figure><p><code>基于ShardingSphere-JDBC的全局序列配置</code>，和前面的MyBatisPlus的策略二选一</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#------------------------分布式序列策略配置</span><br><span class="line"># 分布式序列列名称</span><br><span class="line">spring.shardingsphere.rules.sharding.tables.t_order.key-generate-strategy.column&#x3D;id</span><br><span class="line"># 分布式序列算法名称</span><br><span class="line">spring.shardingsphere.rules.sharding.tables.t_order.key-generate-strategy.key-generator-name&#x3D;alg_snowflake</span><br><span class="line"></span><br><span class="line"># 分布式序列算法配置</span><br><span class="line"># 分布式序列算法类型</span><br><span class="line">spring.shardingsphere.rules.sharding.key-generators.alg_snowflake.type&#x3D;SNOWFLAKE</span><br><span class="line"># 分布式序列算法属性配置</span><br><span class="line">#spring.shardingsphere.rules.sharding.key-generators.alg_snowflake.props.xxx&#x3D;</span><br></pre></td></tr></table></figure><p>此时，需要将实体类中的id策略修改成以下形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当配置了shardingsphere-jdbc的分布式序列时，自动使用shardingsphere-jdbc的分布式序列</span></span><br><span class="line"><span class="comment">//当没有配置shardingsphere-jdbc的分布式序列时，自动依赖数据库的主键自增策略</span></span><br><span class="line"><span class="meta">@TableId</span>(type = IdType.AUTO)</span><br></pre></td></tr></table></figure><h2 id="3、多表关联">3、多表关联</h2><p>创建关联表，在<code>server-order0、server-order1</code>服务器中分别创建两张订单详情表<code>t_order_item0、t_order_item1</code>。我们希望<code>同一个用户的订单表和订单详情表中的数据都在同一个数据源中，避免跨库关联</code>，因此这两张表我们使用相同的分片策略。那么在<code>t_order_item</code>中我们也需要创建<code>order_no</code>和<code>user_id</code>这两个分片键</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_order_item0(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">BIGINT</span>,</span><br><span class="line">    order_no <span class="built_in">VARCHAR</span>(<span class="number">30</span>),</span><br><span class="line">    user_id <span class="built_in">BIGINT</span>,</span><br><span class="line">    price <span class="built_in">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>),</span><br><span class="line">    <span class="string">`count`</span> <span class="built_in">INT</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_order_item1(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">BIGINT</span>,</span><br><span class="line">    order_no <span class="built_in">VARCHAR</span>(<span class="number">30</span>),</span><br><span class="line">    user_id <span class="built_in">BIGINT</span>,</span><br><span class="line">    price <span class="built_in">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>),</span><br><span class="line">    <span class="string">`count`</span> <span class="built_in">INT</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>创建实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableName</span>(<span class="string">"t_order_item"</span>)</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderItem</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当配置了shardingsphere-jdbc的分布式序列时，自动使用shardingsphere-jdbc的分布式序列</span></span><br><span class="line">    <span class="meta">@TableId</span>(type = IdType.AUTO)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String orderNo;</span><br><span class="line">    <span class="keyword">private</span> Long userId;</span><br><span class="line">    <span class="keyword">private</span> BigDecimal price;</span><br><span class="line">    <span class="keyword">private</span> Integer count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建Mapper</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderItemMapper</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">OrderItem</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置关联表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#------------------------标准分片表配置（数据节点配置）</span><br><span class="line">spring.shardingsphere.rules.sharding.tables.t_order_item.actual-data-nodes&#x3D;server-order$-&gt;&#123;0..1&#125;.t_order_item$-&gt;&#123;0..1&#125;</span><br><span class="line"></span><br><span class="line">#------------------------分库策略</span><br><span class="line"># 分片列名称</span><br><span class="line">spring.shardingsphere.rules.sharding.tables.t_order_item.database-strategy.standard.sharding-column&#x3D;user_id</span><br><span class="line"># 分片算法名称</span><br><span class="line">spring.shardingsphere.rules.sharding.tables.t_order_item.database-strategy.standard.sharding-algorithm-name&#x3D;alg_mod</span><br><span class="line"></span><br><span class="line">#------------------------分表策略</span><br><span class="line"># 分片列名称</span><br><span class="line">spring.shardingsphere.rules.sharding.tables.t_order_item.table-strategy.standard.sharding-column&#x3D;order_no</span><br><span class="line"># 分片算法名称</span><br><span class="line">spring.shardingsphere.rules.sharding.tables.t_order_item.table-strategy.standard.sharding-algorithm-name&#x3D;alg_hash_mod</span><br><span class="line"></span><br><span class="line">#------------------------分布式序列策略配置</span><br><span class="line"># 分布式序列列名称</span><br><span class="line">spring.shardingsphere.rules.sharding.tables.t_order_item.key-generate-strategy.column&#x3D;id</span><br><span class="line"># 分布式序列算法名称</span><br><span class="line">spring.shardingsphere.rules.sharding.tables.t_order_item.key-generate-strategy.key-generator-name&#x3D;alg_snowflake</span><br></pre></td></tr></table></figure><p>测试插入数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试关联表插入</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsertOrderAndOrderItem</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">1</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">        Order order = <span class="keyword">new</span> Order();</span><br><span class="line">        order.setOrderNo(<span class="string">"ATGUIGU"</span> + i);</span><br><span class="line">        order.setUserId(<span class="number">1L</span>);</span><br><span class="line">        orderMapper.insert(order);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> j = <span class="number">1</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">            OrderItem orderItem = <span class="keyword">new</span> OrderItem();</span><br><span class="line">            orderItem.setOrderNo(<span class="string">"ATGUIGU"</span> + i);</span><br><span class="line">            orderItem.setUserId(<span class="number">1L</span>);</span><br><span class="line">            orderItem.setPrice(<span class="keyword">new</span> BigDecimal(<span class="number">10</span>));</span><br><span class="line">            orderItem.setCount(<span class="number">2</span>);</span><br><span class="line">            orderItemMapper.insert(orderItem);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">5</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">        Order order = <span class="keyword">new</span> Order();</span><br><span class="line">        order.setOrderNo(<span class="string">"ATGUIGU"</span> + i);</span><br><span class="line">        order.setUserId(<span class="number">2L</span>);</span><br><span class="line">        orderMapper.insert(order);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> j = <span class="number">1</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">            OrderItem orderItem = <span class="keyword">new</span> OrderItem();</span><br><span class="line">            orderItem.setOrderNo(<span class="string">"ATGUIGU"</span> + i);</span><br><span class="line">            orderItem.setUserId(<span class="number">2L</span>);</span><br><span class="line">            orderItem.setPrice(<span class="keyword">new</span> BigDecimal(<span class="number">1</span>));</span><br><span class="line">            orderItem.setCount(<span class="number">3</span>);</span><br><span class="line">            orderItemMapper.insert(orderItem);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、绑定表">4、绑定表</h2><p>创建VO对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderVo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String orderNo;</span><br><span class="line">    <span class="keyword">private</span> BigDecimal amount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加Mapper方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderMapper</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">Order</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select</span>(&#123;<span class="string">"SELECT o.order_no, SUM(i.price * i.count) AS amount"</span>,</span><br><span class="line">            <span class="string">"FROM t_order o JOIN t_order_item i ON o.order_no = i.order_no"</span>,</span><br><span class="line">            <span class="string">"GROUP BY o.order_no"</span>&#125;)</span><br><span class="line">    <span class="function">List&lt;OrderVo&gt; <span class="title">getOrderAmount</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试关联查询</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试关联表查询</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetOrderAmount</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;OrderVo&gt; orderAmountList = orderMapper.getOrderAmount();</span><br><span class="line">    orderAmountList.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置绑定表，在原来水平分片配置的基础上添加如下配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#------------------------绑定表</span><br><span class="line">spring.shardingsphere.rules.sharding.binding-tables[0]&#x3D;t_order,t_order_item</span><br></pre></td></tr></table></figure><p>配置完绑定表后再次进行关联查询的测试：</p><ul><li><p>**如果不配置绑定表：测试的结果为8个SQL。**多表关联查询会出现笛卡尔积关联。</p></li><li><p><strong>如果配置绑定表：测试的结果为4个SQL。</strong> 多表关联查询不会出现笛卡尔积关联，关联查询效率将大大提升。</p></li></ul><p><code>绑定表：</code>指分片规则一致的一组分片表。 使用绑定表进行多表关联查询时，<strong>必须使用分片键进行关联</strong>，否则会出现笛卡尔积关联或跨库关联，从而影响查询效率。</p><h2 id="5、广播表">5、广播表</h2><blockquote><p><a href="https://shardingsphere.apache.org/document/5.1.1/cn/user-manual/shardingsphere-jdbc/spring-boot-starter/rules/sharding/" target="_blank" rel="noopener" title="https://shardingsphere.apache.org/document/5.1.1/cn/user-manual/shardingsphere-jdbc/spring-boot-starter/rules/sharding/">https://shardingsphere.apache.org/document/5.1.1/cn/user-manual/shardingsphere-jdbc/spring-boot-starter/rules/sharding/</a></p></blockquote><h3 id="5-1-广播表介绍">5.1 广播表介绍</h3><p>指所有的分片数据源中都存在的表，表结构及其数据在每个数据库中均完全一致。 适用于数据量不大且需要与海量数据的表进行关联查询的场景，例如：字典表。</p><p>广播具有以下特性：</p><ul><li><p>插入、更新操作会实时在所有节点上执行，保持各个分片的数据一致性</p></li><li><p>查询操作，只从一个节点获取</p></li><li><p>可以跟任何一个表进行 JOIN 操作</p></li></ul><h3 id="5-2-创建广播表">5.2 创建广播表</h3><p>在server-order0、server-order1和server-user服务器中分别创建t_dict表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_dict(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">BIGINT</span>,</span><br><span class="line">    dict_type <span class="built_in">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="5-3-程序实现">5.3 程序实现</h3><p>创建实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableName</span>(<span class="string">"t_dict"</span>)</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dict</span> </span>&#123;</span><br><span class="line">    <span class="comment">//可以使用MyBatisPlus的雪花算法</span></span><br><span class="line">    <span class="meta">@TableId</span>(type = IdType.ASSIGN_ID)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String dictType;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建Mapper</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DictMapper</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">Dict</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置广播表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#数据节点可不配置，默认情况下，向所有数据源广播</span><br><span class="line">spring.shardingsphere.rules.sharding.tables.t_dict.actual-data-nodes&#x3D;server-user.t_dict,server-order$-&gt;&#123;0..1&#125;.t_dict</span><br><span class="line"></span><br><span class="line"># 广播表</span><br><span class="line">spring.shardingsphere.rules.sharding.broadcast-tables[0]&#x3D;t_dict</span><br></pre></td></tr></table></figure><h3 id="5-4-测试">5.4 测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> DictMapper dictMapper;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 广播表：每个服务器中的t_dict同时添加了新数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBroadcast</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Dict dict = <span class="keyword">new</span> Dict();</span><br><span class="line">    dict.setDictType(<span class="string">"type1"</span>);</span><br><span class="line">    dictMapper.insert(dict);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询操作，只从一个节点获取数据</span></span><br><span class="line"><span class="comment"> * 随机负载均衡规则</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSelectBroadcast</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;Dict&gt; dicts = dictMapper.selectList(<span class="keyword">null</span>);</span><br><span class="line">    dicts.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>五、ShardingSphere-Proxy</h1><h2 id="1、环境搭建与安装">1、环境搭建与安装</h2><blockquote><p><a href="https://shardingsphere.apache.org/document/5.1.1/cn/quick-start/shardingsphere-proxy-quick-start/" target="_blank" rel="noopener" title="https://shardingsphere.apache.org/document/5.1.1/cn/quick-start/shardingsphere-proxy-quick-start/">https://shardingsphere.apache.org/document/5.1.1/cn/quick-start/shardingsphere-proxy-quick-start/</a></p></blockquote><h3 id="1-1-获取包">1.1 获取包</h3><p>目前 ShardingSphere-Proxy 提供了 3 种获取方式：</p><ul><li><p><a href="https://shardingsphere.apache.org/document/5.1.1/cn/user-manual/shardingsphere-proxy/startup/bin/" target="_blank" rel="noopener" title="二进制发布包">二进制发布包</a></p></li><li><p><a href="https://shardingsphere.apache.org/document/5.1.1/cn/user-manual/shardingsphere-proxy/startup/docker/" target="_blank" rel="noopener" title="Docker">Docker</a></p></li><li><p><a href="https://shardingsphere.apache.org/document/5.1.1/cn/user-manual/shardingsphere-proxy/startup/helm/" target="_blank" rel="noopener" title="Helm">Helm</a></p></li></ul><h3 id="1-2-使用二进制发布包安装">1.2 使用二进制发布包安装</h3><p>二进制包既可以Linux系统运行，又可以在windows系统运行</p><p><strong>step1：解压二进制包</strong></p><p><code>apache-shardingsphere-5.1.1-shardingsphere-proxy-bin.tar.gz</code></p><p>windows：使用解压软件解压文件</p><p>Linux：将文件上传至/opt目录，并解压</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf apache-shardingsphere-5.1.1-shardingsphere-proxy-bin.tar.gz</span><br></pre></td></tr></table></figure><p><strong>step2：MySQL驱动</strong></p><p><code>mysql-connector-java-8.0.22.jar</code>，将MySQl驱动放至解压目录中的<code>ext-lib</code>目录</p><p><strong>spte3：修改配置conf/server.yaml</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="type">!AUTHORITY</span></span><br><span class="line">    <span class="attr">users:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">root@%:root</span></span><br><span class="line">    <span class="attr">provider:</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">ALL_PRIVILEGES_PERMITTED</span></span><br><span class="line"></span><br><span class="line"><span class="attr">props:</span></span><br><span class="line">  <span class="attr">sql-show:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><strong>spte4：启动ShardingSphere-Proxy</strong></p><p>Linux 操作系统请运行 <code>bin/start.sh</code>；Windows 操作系统请运行 <code>bin/start.bat</code>；指定端口号和配置文件目录：<code>bin/start.bat ${proxy_port} ${proxy_conf_directory}</code> </p><p><strong>step5：远程连接ShardingSphere-Proxy</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h192.168.100.1 -P3307 -uroot -p</span><br></pre></td></tr></table></figure><p><strong>step6：访问测试</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">databases</span>;</span><br></pre></td></tr></table></figure><h3 id="1-3-使用Docker安装">1.3 使用Docker安装</h3><p><strong>step1：启动Docker容器</strong>，若容器内存太小，创建容器的时候使用JVM参数限制</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">-v /data/server/proxy<span class="_">-a</span>/conf:/opt/shardingsphere-proxy/conf \</span><br><span class="line">-v /data/server/proxy<span class="_">-a</span>/ext-lib:/opt/shardingsphere-proxy/ext-lib \</span><br><span class="line">-e ES_JAVA_OPTS=<span class="string">"-Xmx256m -Xms256m -Xmn128m"</span> \</span><br><span class="line">-p 3321:3307 \</span><br><span class="line">--name server-proxy<span class="_">-a</span> \</span><br><span class="line">apache/shardingsphere-proxy:5.1.1</span><br></pre></td></tr></table></figure><p><strong>step2：上传MySQL驱动</strong></p><p>将MySQL驱动上传至<code>/data/server/proxy-a/ext-lib</code>目录</p><p><strong>spte3：修改配置server.yaml</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="type">!AUTHORITY</span></span><br><span class="line">    <span class="attr">users:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">root@%:root</span></span><br><span class="line">    <span class="attr">provider:</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">ALL_PRIVILEGES_PERMITTED</span></span><br><span class="line"></span><br><span class="line"><span class="attr">props:</span></span><br><span class="line">  <span class="attr">sql-show:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>将配置文件上传至<code>/data/server/proxy-a/conf</code>目录</p><p><strong>spte4：重启容器</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart server-proxy<span class="_">-a</span></span><br></pre></td></tr></table></figure><p><strong>step5：远程连接ShardingSphere-Proxy</strong></p><p>ShardingSphere-Proxy容器中默认情况下没有mysql命令行客户端的安装，因此需要远程访问</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h192.168.249.135 -P3321 -uroot -p</span><br></pre></td></tr></table></figure><p><strong>step6：访问测试</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">databases</span>;</span><br></pre></td></tr></table></figure><h2 id="2、ShardingSphere-Proxy读写分离">2、ShardingSphere-Proxy读写分离</h2><h3 id="2-1-修改配置文件">2.1 修改配置文件</h3><p>修改配置config-readwrite-splitting.yaml，ShardingSphere-JDBC的配置是ShardingSphere-Proxy的子集，因此可以复用</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 逻辑名字</span></span><br><span class="line"><span class="attr">schemaName:</span> <span class="string">readwrite_splitting_db</span></span><br><span class="line"></span><br><span class="line"><span class="attr">dataSources:</span></span><br><span class="line">  <span class="attr">write_ds:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://192.168.249.135:3306/db_user?serverTimezone=UTC&amp;useSSL=false</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">connectionTimeoutMilliseconds:</span> <span class="number">30000</span></span><br><span class="line">    <span class="attr">idleTimeoutMilliseconds:</span> <span class="number">60000</span></span><br><span class="line">    <span class="attr">maxLifetimeMilliseconds:</span> <span class="number">1800000</span></span><br><span class="line">    <span class="attr">maxPoolSize:</span> <span class="number">50</span></span><br><span class="line">    <span class="attr">minPoolSize:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">read_ds_0:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://192.168.249.135:3307/db_user?serverTimezone=UTC&amp;useSSL=false</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">connectionTimeoutMilliseconds:</span> <span class="number">30000</span></span><br><span class="line">    <span class="attr">idleTimeoutMilliseconds:</span> <span class="number">60000</span></span><br><span class="line">    <span class="attr">maxLifetimeMilliseconds:</span> <span class="number">1800000</span></span><br><span class="line">    <span class="attr">maxPoolSize:</span> <span class="number">50</span></span><br><span class="line">    <span class="attr">minPoolSize:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">read_ds_1:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://192.168.249.135:3308/db_user?serverTimezone=UTC&amp;useSSL=false</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">connectionTimeoutMilliseconds:</span> <span class="number">30000</span></span><br><span class="line">    <span class="attr">idleTimeoutMilliseconds:</span> <span class="number">60000</span></span><br><span class="line">    <span class="attr">maxLifetimeMilliseconds:</span> <span class="number">1800000</span></span><br><span class="line">    <span class="attr">maxPoolSize:</span> <span class="number">50</span></span><br><span class="line">    <span class="attr">minPoolSize:</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="type">!READWRITE_SPLITTING</span></span><br><span class="line">  <span class="attr">dataSources:</span></span><br><span class="line">    <span class="attr">readwrite_ds:</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">Static</span></span><br><span class="line">      <span class="attr">props:</span></span><br><span class="line">        <span class="attr">write-data-source-name:</span> <span class="string">write_ds</span></span><br><span class="line">        <span class="attr">read-data-source-names:</span> <span class="string">read_ds_0,read_ds_1</span></span><br></pre></td></tr></table></figure><p>将配置文件上传至<code>/data/server/proxy-a/conf</code>目录，最后重启容器</p><h3 id="2-2-实时查看日志">2.2 实时查看日志</h3><p>可以通过这种方式查看服务器中输出的SQL语句</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it server-proxy<span class="_">-a</span> env LANG=C.UTF-8 /bin/bash</span><br><span class="line">tail -f /opt/shardingsphere-proxy/logs/stdout.log</span><br></pre></td></tr></table></figure><h3 id="2-3-远程访问测试">2.3 远程访问测试</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show databases;</span><br><span class="line">mysql&gt; use readwrite_splitting_db;</span><br><span class="line">mysql&gt; show tables;</span><br><span class="line">mysql&gt; select * from t_user;</span><br><span class="line">mysql&gt; select * from t_user;</span><br><span class="line">mysql&gt; insert into t_user(uname) values('wang5');</span><br></pre></td></tr></table></figure><h3 id="2-4-应用程序访问Proxy">2.4 应用程序访问Proxy</h3><p>添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>创建实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableName</span>(<span class="string">"t_user"</span>)</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@TableId</span>(type = IdType.AUTO)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String uname;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建Mapper</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置数据源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 应用名称</span><br><span class="line">spring.application.name&#x3D;sharding-proxy-demo</span><br><span class="line"># 开发环境设置</span><br><span class="line">spring.profiles.active&#x3D;dev</span><br><span class="line"></span><br><span class="line">#mysql数据库连接（proxy）</span><br><span class="line">spring.datasource.driver-class-name&#x3D;com.mysql.jdbc.Driver</span><br><span class="line">spring.datasource.url&#x3D;jdbc:mysql:&#x2F;&#x2F;192.168.249.135:3321&#x2F;readwrite_splitting_db?serverTimezone&#x3D;GMT%2B8&amp;useSSL&#x3D;false</span><br><span class="line">spring.datasource.username&#x3D;root</span><br><span class="line">spring.datasource.password&#x3D;root</span><br><span class="line"></span><br><span class="line">#mybatis日志</span><br><span class="line">mybatis-plus.configuration.log-impl&#x3D;org.apache.ibatis.logging.stdout.StdOutImpl</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShardingProxyDemoApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读数据测试</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSelectAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;User&gt; users = userMapper.selectList(<span class="keyword">null</span>);</span><br><span class="line">        users.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、ShardingSphere-Proxy垂直分片">3、ShardingSphere-Proxy垂直分片</h2><p>修改配置config-sharding.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">schemaName:</span> <span class="string">sharding_db</span></span><br><span class="line"></span><br><span class="line"><span class="attr">dataSources:</span></span><br><span class="line">  <span class="attr">ds_0:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://192.168.249.135:3301/db_user?serverTimezone=UTC&amp;useSSL=false</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">connectionTimeoutMilliseconds:</span> <span class="number">30000</span></span><br><span class="line">    <span class="attr">idleTimeoutMilliseconds:</span> <span class="number">60000</span></span><br><span class="line">    <span class="attr">maxLifetimeMilliseconds:</span> <span class="number">1800000</span></span><br><span class="line">    <span class="attr">maxPoolSize:</span> <span class="number">50</span></span><br><span class="line">    <span class="attr">minPoolSize:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">ds_1:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://192.168.249.135:3302/db_order?serverTimezone=UTC&amp;useSSL=false</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">connectionTimeoutMilliseconds:</span> <span class="number">30000</span></span><br><span class="line">    <span class="attr">idleTimeoutMilliseconds:</span> <span class="number">60000</span></span><br><span class="line">    <span class="attr">maxLifetimeMilliseconds:</span> <span class="number">1800000</span></span><br><span class="line">    <span class="attr">maxPoolSize:</span> <span class="number">50</span></span><br><span class="line">    <span class="attr">minPoolSize:</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="type">!SHARDING</span></span><br><span class="line">  <span class="attr">tables:</span></span><br><span class="line">    <span class="attr">t_user:</span></span><br><span class="line">      <span class="attr">actualDataNodes:</span> <span class="string">ds_0.t_user</span></span><br><span class="line">    <span class="attr">t_order:</span></span><br><span class="line">      <span class="attr">actualDataNodes:</span> <span class="string">ds_1.t_order</span></span><br></pre></td></tr></table></figure><p>实时查看日志，可以通过这种方式查看服务器中输出的SQL语句</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it server-proxy<span class="_">-a</span> env LANG=C.UTF-8 /bin/bash</span><br><span class="line">tail -f /opt/shardingsphere-proxy/logs/stdout.log</span><br></pre></td></tr></table></figure><p>远程访问测试</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show databases;</span><br><span class="line">mysql&gt; use sharding_db;</span><br><span class="line">mysql&gt; show tables;</span><br><span class="line">mysql&gt; select * from t_order;</span><br><span class="line">mysql&gt; select * from t_user;</span><br></pre></td></tr></table></figure><h2 id="4、ShardingSphere-Proxy水平分片">4、ShardingSphere-Proxy水平分片</h2><p>修改配置config-sharding.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">schemaName:</span> <span class="string">sharding_db</span></span><br><span class="line"></span><br><span class="line"><span class="attr">dataSources:</span></span><br><span class="line">  <span class="attr">ds_user:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://192.168.249.135:3301/db_user?serverTimezone=UTC&amp;useSSL=false</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">connectionTimeoutMilliseconds:</span> <span class="number">30000</span></span><br><span class="line">    <span class="attr">idleTimeoutMilliseconds:</span> <span class="number">60000</span></span><br><span class="line">    <span class="attr">maxLifetimeMilliseconds:</span> <span class="number">1800000</span></span><br><span class="line">    <span class="attr">maxPoolSize:</span> <span class="number">50</span></span><br><span class="line">    <span class="attr">minPoolSize:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">ds_order0:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://192.168.249.135:3310/db_order?serverTimezone=UTC&amp;useSSL=false</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">connectionTimeoutMilliseconds:</span> <span class="number">30000</span></span><br><span class="line">    <span class="attr">idleTimeoutMilliseconds:</span> <span class="number">60000</span></span><br><span class="line">    <span class="attr">maxLifetimeMilliseconds:</span> <span class="number">1800000</span></span><br><span class="line">    <span class="attr">maxPoolSize:</span> <span class="number">50</span></span><br><span class="line">    <span class="attr">minPoolSize:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">ds_order1:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://192.168.249.135:3311/db_order?serverTimezone=UTC&amp;useSSL=false</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">connectionTimeoutMilliseconds:</span> <span class="number">30000</span></span><br><span class="line">    <span class="attr">idleTimeoutMilliseconds:</span> <span class="number">60000</span></span><br><span class="line">    <span class="attr">maxLifetimeMilliseconds:</span> <span class="number">1800000</span></span><br><span class="line">    <span class="attr">maxPoolSize:</span> <span class="number">50</span></span><br><span class="line">    <span class="attr">minPoolSize:</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="type">!SHARDING</span></span><br><span class="line">  <span class="attr">tables:</span></span><br><span class="line">    <span class="attr">t_user:</span></span><br><span class="line">      <span class="attr">actualDataNodes:</span> <span class="string">ds_user.t_user</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">t_order:</span></span><br><span class="line">      <span class="attr">actualDataNodes:</span> <span class="string">ds_order$&#123;0..1&#125;.t_order$&#123;0..1&#125;</span></span><br><span class="line">      <span class="attr">databaseStrategy:</span></span><br><span class="line">        <span class="attr">standard:</span></span><br><span class="line">          <span class="attr">shardingColumn:</span> <span class="string">user_id</span></span><br><span class="line">          <span class="attr">shardingAlgorithmName:</span> <span class="string">alg_mod</span></span><br><span class="line">      <span class="attr">tableStrategy:</span></span><br><span class="line">        <span class="attr">standard:</span></span><br><span class="line">          <span class="attr">shardingColumn:</span> <span class="string">order_no</span></span><br><span class="line">          <span class="attr">shardingAlgorithmName:</span> <span class="string">alg_hash_mod</span></span><br><span class="line">      <span class="attr">keyGenerateStrategy:</span></span><br><span class="line">        <span class="attr">column:</span> <span class="string">id</span></span><br><span class="line">        <span class="attr">keyGeneratorName:</span> <span class="string">snowflake</span></span><br><span class="line">    <span class="attr">t_order_item:</span></span><br><span class="line">      <span class="attr">actualDataNodes:</span> <span class="string">ds_order$&#123;0..1&#125;.t_order_item$&#123;0..1&#125;</span></span><br><span class="line">      <span class="attr">databaseStrategy:</span></span><br><span class="line">        <span class="attr">standard:</span></span><br><span class="line">          <span class="attr">shardingColumn:</span> <span class="string">user_id</span></span><br><span class="line">          <span class="attr">shardingAlgorithmName:</span> <span class="string">alg_mod</span></span><br><span class="line">      <span class="attr">tableStrategy:</span></span><br><span class="line">        <span class="attr">standard:</span></span><br><span class="line">          <span class="attr">shardingColumn:</span> <span class="string">order_no</span></span><br><span class="line">          <span class="attr">shardingAlgorithmName:</span> <span class="string">alg_hash_mod</span></span><br><span class="line">      <span class="attr">keyGenerateStrategy:</span></span><br><span class="line">        <span class="attr">column:</span> <span class="string">id</span></span><br><span class="line">        <span class="attr">keyGeneratorName:</span> <span class="string">snowflake</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">bindingTables:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">t_order,t_order_item</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="attr">broadcastTables:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">t_dict</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">shardingAlgorithms:</span></span><br><span class="line">    <span class="attr">alg_inline_userid:</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">INLINE</span></span><br><span class="line">      <span class="attr">props:</span></span><br><span class="line">        <span class="attr">algorithm-expression:</span> <span class="string">server-order$-&gt;&#123;user_id</span> <span class="string">%</span> <span class="number">2</span><span class="string">&#125;</span></span><br><span class="line">    <span class="attr">alg_mod:</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">MOD</span></span><br><span class="line">      <span class="attr">props:</span></span><br><span class="line">        <span class="attr">sharding-count:</span> <span class="number">2</span></span><br><span class="line">    <span class="attr">alg_hash_mod:</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">HASH_MOD</span></span><br><span class="line">      <span class="attr">props:</span></span><br><span class="line">        <span class="attr">sharding-count:</span> <span class="number">2</span></span><br><span class="line">  </span><br><span class="line">  <span class="attr">keyGenerators:</span></span><br><span class="line">    <span class="attr">snowflake:</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">SNOWFLAKE</span></span><br></pre></td></tr></table></figure><p>实时查看日志，可以通过这种方式查看服务器中输出的SQL语句</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it server-proxy<span class="_">-a</span> env LANG=C.UTF-8 /bin/bash</span><br><span class="line">tail -f /opt/shardingsphere-proxy/logs/stdout.log</span><br></pre></td></tr></table></figure><p>远程访问测试</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show databases;</span><br><span class="line">mysql&gt; use sharding_db;</span><br><span class="line">mysql&gt; show tables;</span><br><span class="line">mysql&gt; select * from t_order; --测试水平分片</span><br><span class="line">mysql&gt; select * from t_dict; --测试广播表</span><br></pre></td></tr></table></figure><hr><p>参考</p><p><a href="https://shardingsphere.apache.org/document/5.1.1/cn/overview/" target="_blank" rel="noopener" title="https://shardingsphere.apache.org/document/5.1.1/cn/overview/">https://shardingsphere.apache.org/document/5.1.1/cn/overview/</a></p><p><a href="https://www.bilibili.com/video/BV1ta411g7Jf/" target="_blank" rel="noopener" title="https://www.bilibili.com/video/BV1ta411g7Jf/">https://www.bilibili.com/video/BV1ta411g7Jf/</a></p>]]></content>
    
    
    <summary type="html">&lt;h1&gt;一、简介&lt;/h1&gt;
&lt;h2 id=&quot;1、介绍&quot;&gt;1、介绍&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;本文属于改参考文章的升级版，部分内容可以参考：&lt;a href=&quot;https://blog.csdn.net/lemon_TT/article/details/120201007&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; title=&quot;ShardingSphere数据库中间件基础学习&quot;&gt;ShardingSphere数据库中间件基础学习&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;互联网业务兴起之后，海量用户加上海量数据的特点，单个数据库服务器已经难以满足业务需要，必须考虑数据库集群的方式来提升性能。高性能数据库集群的第一种方式是&amp;quot;&lt;code&gt;读写分离&lt;/code&gt;&amp;quot;，第二种方式是&amp;quot;&lt;code&gt;数据库分片&lt;/code&gt;&amp;quot;；&lt;/p&gt;
&lt;p&gt;读写分离和数据分片具体的实现方式一般有两种： &lt;code&gt;程序代码封装&lt;/code&gt;和&lt;code&gt;中间件封装&lt;/code&gt;，中间件软件有**Apache ShardingSphere（程序级别和中间件级别）**和MyCat（数据库中间件）&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://www.shawn22.xyz/categories/Java/"/>
    
    
    <category term="中间件" scheme="https://www.shawn22.xyz/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Java高级技术之Gradle</title>
    <link href="https://www.shawn22.xyz/posts/f064074e.html"/>
    <id>https://www.shawn22.xyz/posts/f064074e.html</id>
    <published>2022-10-31T13:44:00.000Z</published>
    <updated>2022-10-31T13:46:15.562Z</updated>
    
    <content type="html"><![CDATA[<h1>一、Gradle入门</h1><h2 id="1、简介">1、简介</h2><blockquote><p>Gradle 是一款Google 推出的基于 JVM、通用灵活的项目构建工具，支持 Maven，JCenter 多种第三方仓库;支持传递性依赖管理、废弃了繁杂的xml 文件，转而使用简洁的、支持多种语言(例如：java、groovy 等)的 build 脚本文件；<br>官网地址: <a href="https://gradle.org/" target="_blank" rel="noopener" title="https://gradle.org/">https://gradle.org/</a></p></blockquote><p>作为Java开发程序员,如果想下载Spring、SpringBoot等Spring家族的源码，基本上基于Gradle构建的，所以虽然目前市面上常见的项目构建工具有<strong>Ant、Maven、Gradle，主流还是Maven，但是未来趋势Gradle</strong>。</p><a id="more"></a><h2 id="2、常见的项目构建工具">2、常见的项目构建工具</h2><ul><li><p>Ant</p><p> 2000 年 Apache 推出的纯Java 编写构建工具，通过 xml[build.xml]文件管理项目。优点：使用灵活，速度快(快于 gradle 和 maven)；缺点：Ant 没有强加任何编码约定的项目目录结构,开发人员需编写繁杂XML 文件构建指令,对开发人员是一个挑战。  </p></li><li><p>Maven</p><p>2004 年Apache 组织推出的再次使用xml 文件[pom.xml]管理项目的构建工具。  优点: 遵循一套约定大于配置的项目目录结构，使用统一的GAV 坐标进行依赖管理,侧重于包管理。缺点：项目构建过程僵化,配置文件编写不够灵活、不方便自定义组件,构建速度慢于 gradle。  </p></li><li><p>Gradle</p><p>2012 年Google 推出的基于Groovy 语言的全新项目构建工具，集合了Ant 和 Maven 各自的优势。<br>优点：集 Ant 脚本的灵活性+Maven 约定大于配置的项目目录优势,支持多种远程仓库和插件,侧重于大项目构建。缺点：学习成本高、资料少、脚本灵活、版本兼容性差等。</p></li></ul><p><img src="https://img-blog.csdnimg.cn/8a955de36fd94a869309aca92bfe5af5.png#pic_center" alt="在这里插入图片描述"></p><h2 id="3、Gradle安装">3、Gradle安装</h2><h3 id="3-1-安装说明">3.1 安装说明</h3><blockquote><p>Gradle官网：<a href="https://gradle.org/" target="_blank" rel="noopener" title="https://gradle.org/">https://gradle.org/</a>Gradle<br>官方下载安装教程页面：<a href="https://gradle.org/install/" target="_blank" rel="noopener" title="https://gradle.org/install/">https://gradle.org/install/</a><br>Gradle官方用户手册：<a href="https://docs.gradle.org/current/userguide/userguide.html" target="_blank" rel="noopener" title="https://docs.gradle.org/current/userguide/userguide.html">https://docs.gradle.org/current/userguide/userguide.html</a></p></blockquote><p>SpringBoot 官方文档明确指出,目前SpringBoot 的 Gradle 插件需要gradle6.8 版本及以上，所以我们这里选择 7.x 版本；但其中SpringBoot 与Gradle 存在版本兼容问题，<strong>Gradle 与Idea 也存在兼容问题</strong>，所以考虑到 java 程序员会使用SpringBoot，所以要选择 6.8 版本及高于 6.8 版本的Gradle,那么相应的idea 版本也要升级。一般去查看<code>{IDEA安装根目录}\plugins\gradle\lib\</code>查看对应gradle版本</p><p>具体参考文档:<a href="https://docs.spring.io/spring-boot/docs/2.5.0/gradle-plugin/reference/htmlsingle/#getting-started" target="_blank" rel="noopener" title="https://docs.spring.io/spring-boot/docs/2.5.0/gradle-plugin/reference/htmlsingle/#getting-started">https://docs.spring.io/spring-boot/docs/2.5.0/gradle-plugin/reference/htmlsingle/#getting-started</a></p><h3 id="3-2-JDK和Gradle安装">3.2 JDK和Gradle安装</h3><blockquote><p>安装参考：<a href="https://blog.csdn.net/enterpc/article/details/122293244" target="_blank" rel="noopener" title="Gradle 安装配置详解">Gradle 安装配置详解</a></p></blockquote><p>要求Jdk 为 1.8 或者 1.8 版本以上，并配置好环境变量；Gradle去<a href="https://gradle.org/releases/" target="_blank" rel="noopener" title="下载页">下载页</a>进行对应版本下载，同时和maven一样配置好环境变量，<code>gradle -v </code>或者 <code>gradle --version</code>检测是否安装成功</p><blockquote><p>特别注意：这里我们接着再配置一个<strong>GRADLE_USER_HOME 环境变量</strong>:  <code>GRADLE_USER_HOME</code> 相当于配置Gradle 本地仓库位置和 Gradle Wrapper 缓存目录。  Gradle本地仓库可以和Maven本地仓库目录一致</p></blockquote><h2 id="4、Gradle-项目目录结构">4、Gradle 项目目录结构</h2><p>Gradle 项目默认目录结构和Maven 项目的目录结构一致,都是基于约定大于配置【Convention Over Configuration】</p><p><img src="https://img-blog.csdnimg.cn/e69659bcd27245339fe1723ed0c0bea3.png#pic_center" alt="在这里插入图片描述"></p><ul><li><p>只有war工程才有webapp目录，对于普通的jar工程并没有webapp目录  </p></li><li><p>gradlew与gradlew.bat执行的指定wrapper版本中的gradle指令,不是本地安装的gradle指令(可以删除)</p></li></ul><h2 id="5、Gradle-创建项目">5、Gradle 创建项目</h2><h3 id="5-1-常用指令">5.1 常用指令</h3><blockquote><p>gradle 的指令要在含有<code>build.gradle</code> 的目录执行</p></blockquote><ul><li><p>gradle clean：清空build目录</p></li><li><p>gradle classes：编译业务代码和配置文件</p></li><li><p>gradle test：编译测试代码，生成测试报告</p></li><li><p>gradle build：构建项目</p></li><li><p>gradle build -x test：跳过测试构建</p></li></ul><h3 id="5-2-maven源修改">5.2 maven源修改</h3><p>我们可以在gradle 的<strong>init.d 目录下创建以.gradle 结尾的文件</strong>，.gradle 文件可以实现在build 开始之前执行，这里创建init.gradle文件</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenLocal() </span><br><span class="line">        maven &#123; name <span class="string">"Alibaba"</span>; url <span class="string">"https://maven.aliyun.com/repository/public"</span> &#125; </span><br><span class="line">        maven &#123; name <span class="string">"Bstek"</span>;url <span class="string">"https://nexus.bsdn.org/content/groups/public/"</span> &#125; </span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">    buildscript &#123;</span><br><span class="line">        repositories &#123;</span><br><span class="line">            maven &#123; name <span class="string">"Alibaba"</span>; url <span class="string">'https://maven.aliyun.com/repository/public'</span> &#125; </span><br><span class="line">            maven &#123; name <span class="string">"Bstek"</span>; url <span class="string">'https://nexus.bsdn.org/content/groups/public/'</span> &#125; </span><br><span class="line">            maven &#123; name <span class="string">"M2"</span>; url <span class="string">'https://plugins.gradle.org/m2/'</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>启用init.gradle 文件的方法</strong></p><ul><li><p>在命令行指定文件，例如：<code>gradle --init-script yourdir/init.gradle -q taskName</code>。你可以多次输入此命令来指定多个init文件</p></li><li><p>把<code>init.gradle</code>文件放到<code> USER_HOME/.gradle/</code> 目录下  </p></li><li><p>把以.gradle结尾的文件放到<code> USER_HOME/.gradle/init.d/</code> 目录下  </p></li><li><p>把以.gradle结尾的文件放到 <code>GRADLE_HOME/init.d/</code> 目录下  </p></li></ul><p>如果存在上面的4种方式的2种以上，gradle会按上面的1-4序号依次执行这些文件，如果给定目录下存在多个init脚本，会按拼音a-z顺序执行这些脚本，每个init脚本都存在一个对应的gradle实例,你在这个文件中调用的所有方法和属性，都会委托给这个gradle实例，每个init脚本都实现了Script接口</p><p><strong>仓库地址说明</strong></p><ul><li><p><code>mavenLocal()</code>: 指定使用maven本地仓库，而本地仓库在配置maven时settings文件指定的仓库位置。如E:/repository，gradle 查找jar包顺序如下：<code>USER_HOME/.m2/settings.xml </code>&gt;&gt; <code>M2_HOME/conf/settings.xml</code> &gt;&gt; <code>USER_HOME/.m2/repository</code>  </p></li><li><p><code>maven { url 地址}</code>，指定maven仓库，一般用私有仓库地址或其它的第三方库【比如阿里镜像仓库地址】</p></li><li><p><code>mavenCentral()</code>：这是Maven的中央仓库，无需配置，直接声明就可以使用。jcenter()：JCenter中央仓库，实际也是是用的maven搭建的，但相比Maven仓库更友好，通过CDN分发，并且支持https访问，在新版本中已经废弃了，替换为了mavenCentral()。  </p></li></ul><p>gradle可以通过指定仓库地址为本地maven仓库地址和远程仓库地址相结合的方式，避免每次都会去远程仓库下载依赖库。这种方式也有一定的问题，如果本地maven仓库有这个依赖，就会从直接加载本地依赖，如果本地仓库没有该依赖，那么还是会从远程下载。但是下载的jar不是存储在本地maven仓库中，而是放在自己的缓存目录中，默认在<code>USER_HOME/.gradle/caches</code>目录，当然如果我们配置过<code>GRADLE_USER_HOME</code>环境变量，则会放在<code>GRADLE_USER_HOME/caches</code>目录，不可以将gradle caches指向maven repository。</p><p><strong>阿里云仓库地址请参考</strong>：<a href="https://developer.aliyun.com/mvn/guide" target="_blank" rel="noopener" title="https://developer.aliyun.com/mvn/guide">https://developer.aliyun.com/mvn/guide</a></p><h3 id="5-3-Wrapper-包装器">5.3 Wrapper 包装器</h3><blockquote><p>Gradle Wrapper 实际上就是对 Gradle 的一层包装，用于解决实际开发中可能会遇到的不同的项目需要不同版本的 Gradle。</p></blockquote><p>例如把自己的代码共享给其他人使用，可能出现如下情况:  对方电脑没有安装 gradle；对方电脑安装过 gradle，但是版本太旧了。这时候，我们就可以考虑使用 Gradle Wrapper 了。这也是官方建议使用 Gradle Wrapper 的原因。</p><p>实际上有了 Gradle Wrapper 之后，我们<strong>本地是可以不配置 Gradle 的</strong>，下载Gradle 项目后，使用 gradle 项目自带的wrapper 操作也是可以的。  项目中的<strong>gradlew、gradlew.cmd</strong>脚本用的就是wrapper中规定的gradle版本。<br>而我们上面提到的gradle指令用的是本地gradle，所以gradle指令和gradlew指令所使用的gradle版本有可能是不一样的。gradlew、gradlew.cmd的使用方式与gradle使用方式完全一致，只不过把gradle指令换成了gradlew指令。  我们也可在终端执行 gradlew 指令时，指定指定一些参数，来控制 Wrapper 的生成，比如依赖的版本等</p><ul><li><p><code>—gradle-version</code>：指定使用的Gradle版本；</p></li><li><p><code>—gradle-distribution-url</code>：指定下载Gradle发行版的url地址</p></li><li><p><code>gradle wrapper --gradle-version=4.4</code>：升级wrapper版本号，只是修改gradle.properties中wrapper版本，未实际下载  </p></li><li><p><code>gradle wrapper --gradle-version 5.2.1 --distribution-type all</code>:关联源码用</p></li></ul><p>**GradleWrapper 的执行流程 **</p><ul><li><p>当我们第一次执行 <code>./gradlew build</code> 命令的时候，gradlew 会读取 <code>gradle-wrapper.properties</code> 文件的配置信息  </p></li><li><p>准确的将指定版本的 gradle 下载并解压到指定的位置(<strong>GRADLE_USER_HOME目录下的wrapper/dists目录中</strong>)  </p></li><li><p>构建本地缓存(<strong>GRADLE_USER_HOME目录下的caches目录中</strong>)，下载再使用相同版本的gradle就不用下载了</p></li><li><p>之后执行的 <code>./gradlew</code> 所有命令都是使用指定的 gradle 版本</p></li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 下载的Gradle压缩包解压后存储的主目录</span><br><span class="line">distributionBase=GRADLE_USER_HOME</span><br><span class="line"># 相对于distributionBase的解压后的Gradle</span><br><span class="line">distributionPath=wrapper/dists</span><br><span class="line"># Gradle发行版压缩包的下载地址</span><br><span class="line">distributionUrl=https\:<span class="comment">//services.gradle.org/distributions/gradle-7.5.1-bin.zip</span></span><br><span class="line"># 压缩包的路径同distributionBase，只不过是存放zip压缩包的</span><br><span class="line">zipStoreBase=GRADLE_USER_HOME</span><br><span class="line"># 同distributionPath,只不过是存放zip压缩包的</span><br><span class="line">zipStorePath=wrapper/dists</span><br></pre></td></tr></table></figure><p>注意：前面提到的 <code>GRALE_USER_HOME</code> 环境变量用于这里的Gradle Wrapper 下载的特定版本的gradle 存储目录。如果我们没有配置过<code>GRALE_USER_HOME</code> 环境变量，<code>默认在当前用户家目录下的.gradle 文件夹中</code></p><h1>二、Gradle 与 Idea 整合</h1><h2 id="1、Groovy简介">1、Groovy简介</h2><blockquote><p>在某种程度上，Groovy 可以被视为Java 的一种脚本化改良版，Groovy 也是运行在 JVM 上，它可以很好地与 Java 代码及其相关库进行交互操作。它是一种成熟的面向对象编程语言，既可以面向对象编程，又可以用作纯粹的脚本语言。</p></blockquote><p>大多数有效的 Java 代码也可以转换为有效的 Groovy 代码，Groovy 和 Java 语言的主要区别是：完成同样的任务所需的Groovy 代码比 Java 代码更少。其特点为：</p><ul><li><p>功能强大，例如提供了动态类型转换、闭包和元编程（metaprogramming）支持</p></li><li><p>支持函数式编程，不需要main 函数</p></li><li><p>默认导入常用的包</p></li><li><p>类不支持 default 作用域,且默认作用域为public。</p></li><li><p>Groovy 中基本类型也是对象，可以直接调用对象的方法。</p></li><li><p>支持DSL（Domain Specific Languages 领域特定语言）和其它简洁的语法，让代码变得易于阅读和维护。</p></li><li><p>Groovy 是基于Java 语言的，所以完全兼容Java 语法,所以对于java 程序员学习成本较低。详细了解请参考：<a href="http://www.groovy-lang.org/documentation.html" target="_blank" rel="noopener" title="http://www.groovy-lang.org/documentation.html">http://www.groovy-lang.org/documentation.html</a></p></li></ul><h2 id="2、Groovy-安装-非必须-和项目创建">2、Groovy 安装[非必须]和项目创建</h2><blockquote><p>下载地址: <a href="https://groovy.apache.org/download.html" target="_blank" rel="noopener" title="https://groovy.apache.org/download.html">https://groovy.apache.org/download.html</a></p></blockquote><p>安装完后配置好环境变量，创建项目时选择Groovy项目，同时指定对应的Groovy SDK</p><h2 id="3、Groovy基本类型">3、Groovy基本类型</h2><ul><li><p><strong>类型转换</strong>：当需要时，类型之间会自动发生类型转换: 字符串（String）、基本类型(如int) 和类型的包装类 (如Integer)  </p></li><li><p>类说明：如果在一个groovy 文件中没有任何类定义，它将被当做 script 来处理，也就意味着这个文件将被透明的转换为一个 Script 类型的类，这个自动转换得到的类将使用原始的 groovy 文件名作为类的名字。groovy 文件的内容被打包进run 方法，另外在新产生的类中被加入一个main 方法以进行外部执行该脚本。</p></li></ul><p><img src="https://img-blog.csdnimg.cn/87810886329544f69291cf2d1b4c8526.png#pic_center" alt="在这里插入图片描述"></p><h3 id="3-1-基本注意点">3.1 基本注意点</h3><p>方法调用时,在不含有歧义的地方可以省略方法调用时的括号。这类似于使用<code>${变量名}</code>时，括号在不引起歧义的地方可以省略是一样的</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> num1=<span class="number">1</span>; </span><br><span class="line"><span class="keyword">def</span> num2= <span class="number">2</span>;</span><br><span class="line">println <span class="string">"$num1 + $num2 = $&#123;num1+num2&#125;"</span></span><br></pre></td></tr></table></figure><h3 id="3-2-引号说明">3.2 引号说明</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> num1=<span class="number">1</span>; </span><br><span class="line"><span class="keyword">def</span> num2=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">def</span> str1=<span class="string">"1d"</span>; <span class="comment">//双引号</span></span><br><span class="line"><span class="keyword">def</span> str2=<span class="string">'dsd'</span>; <span class="comment">//单引号</span></span><br><span class="line"><span class="comment">//双引号运算能力,单引号用于常量字符串,三引号相当于模板字符串，可以支持换行</span></span><br><span class="line">println <span class="string">"$num1 + $num2 = $&#123;num1 + num2&#125;"</span></span><br><span class="line"><span class="comment">//基本数据类型也可以作为对象使用,可以调用对象的方法</span></span><br><span class="line">println(num1.getClass().toString()) </span><br><span class="line">println(str1.getClass().toString()) </span><br><span class="line">println(str2.getClass().toString())</span><br></pre></td></tr></table></figure><h3 id="3-3-三个语句结构">3.3 三个语句结构</h3><p>Groovy 支持顺序结构从上向下依次解析、分支结构(if…else、if…else if …else…、switch…case、for、while、do…while)</p><p>具体参考官网：<a href="http://www.groovy-lang.org/semantics.html" target="_blank" rel="noopener" title="http://www.groovy-lang.org/semantics.html#_conditional_structures">http://www.groovy-lang.org/semantics.html#_conditional_structures</a></p><h3 id="3-4-类型及权限修饰符">3.4 类型及权限修饰符</h3><ul><li><p>原生数据类型及包装类</p></li><li><p>类、内部类、抽象类、接口  </p></li><li><p>注解  </p></li><li><p>Trait: 可以看成是带有方法实现的接口</p></li></ul><blockquote><p>Groovy 中 各 种 各 样 的 数 据 类 型 和 权 限 修 饰 符 及 Goovy 与 Java 区 别 请 参 考 ：  <a href="http://www.groovy-lang.org/objectorientation.html" target="_blank" rel="noopener" title="http://www.groovy-lang.org/objectorientation.html#_modifiers_on_a_property">http://www.groovy-lang.org/objectorientation.html#_modifiers_on_a_property</a></p></blockquote><p>Groovy 类与 Java 类之间的主要区别是:  </p><ul><li><p>没有可见性修饰符的类或方法自动是公共的(可以使用一个特殊的注释来实现包的私有可见性)。  </p></li><li><p>没有可见性修饰符的字段将自动转换为属性，不需要显式的 getter 和 setter 方法。  </p></li><li><p>如果属性声明为 final，则不会生成 setter。  </p></li><li><p>一个源文件可能包含一个或多个类(但是如果一个文件不包含类定义的代码，则将其视为脚本)。脚本只是具有一些特殊约定的类,它们的名称与源文件相同(所以不要在脚本中包含与脚本源文件名相同的类定义)。  </p></li></ul><h3 id="3-5-集合操作">3.5 集合操作</h3><blockquote><p>参考官网:<a href="http://www.groovy-lang.org/syntax.html" target="_blank" rel="noopener" title="http://www.groovy-lang.org/syntax.html#_number_type_suffixes">http://www.groovy-lang.org/syntax.html#_number_type_suffixes</a></p></blockquote><p>Groovy中可以把不同的基本类型添加到同一集合中</p><ul><li><p>List：<code>add()/plus()/remove()/removeElement()/removeAll()/pop()/putAt()/each()/size()/contains()</code></p></li><li><p>Map：<code>put()/remove()/+、-/each()</code></p></li></ul><h3 id="3-6-类导入">3.6 类导入</h3><blockquote><p>参考官网地址：<a href="http://www.groovy-lang.org/structure.html#_imports" target="_blank" rel="noopener" title="http://www.groovy-lang.org/structure.html#_imports">http://www.groovy-lang.org/structure.html#_imports</a></p></blockquote><p>Groovy 遵循 Java 允许 import 语句解析类引用的概念</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> groovy.xml.MarkupBuilder </span><br><span class="line"><span class="keyword">def</span> xml = <span class="keyword">new</span> MarkupBuilder() </span><br><span class="line"><span class="keyword">assert</span> xml != <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>Groovy 语言默认提供的导入</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.* </span><br><span class="line"><span class="keyword">import</span> java.util.* </span><br><span class="line"><span class="keyword">import</span> java.io.* </span><br><span class="line"><span class="keyword">import</span> java.net.* </span><br><span class="line"><span class="keyword">import</span> groovy.lang.* </span><br><span class="line"><span class="keyword">import</span> groovy.util.*</span><br><span class="line"><span class="keyword">import</span> java.math.BigInteger</span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal</span><br></pre></td></tr></table></figure><h3 id="3-7-异常处理">3.7 异常处理</h3><blockquote><p>参考官网地址： <a href="http://www.groovy-lang.org/semantics.html#_try_catch_finally" target="_blank" rel="noopener" title="http://www.groovy-lang.org/semantics.html#_try_catch_finally">http://www.groovy-lang.org/semantics.html#_try_catch_finally</a></p></blockquote><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> z </span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">def</span> i = <span class="number">7</span>, j = <span class="number">0</span> </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">def</span> k = i / j </span><br><span class="line">        <span class="keyword">assert</span> <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        z = <span class="string">'reached here'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> ( e ) &#123;</span><br><span class="line">    <span class="keyword">assert</span> e <span class="keyword">in</span> ArithmeticException </span><br><span class="line">    <span class="keyword">assert</span> z == <span class="string">'reached here'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-8-闭包">3.8 闭包</h3><blockquote><p>参考：<a href="http://www.groovy-lang.org/closures.html" target="_blank" rel="noopener" title="http://www.groovy-lang.org/closures.html">http://www.groovy-lang.org/closures.html</a></p></blockquote><p><strong>闭包</strong>：Groovy 中的闭包是一个开放的、匿名的代码块，它可以接受参数、也可以有返回值。闭包可以引用其周围作用域中声明的变量。  </p><p><strong>语法</strong>：<code>{ [closureParameters -&gt; ] statements }  </code><br>其中[ closureParameters-&gt; ]是一个可选的逗号分隔的参数列表,参数后面是 Groovy 语句。参数类似于方法参数列表， 这些参数可以是类型化的,也可以是非类型化的。当指定参数列表时，需要使用-&gt; 字符，用于将参数与闭包体分离。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//闭包体完成变量自增操作</span></span><br><span class="line">&#123; item++ &#125;</span><br><span class="line"><span class="comment">//闭包使用 空参数列表 明确规定这是无参的</span></span><br><span class="line">&#123; -&gt; item++ &#125;</span><br><span class="line"><span class="comment">//闭包中有一个默认的参数[it]，写不写无所谓</span></span><br><span class="line">&#123; println it &#125;</span><br><span class="line">&#123; it -&gt; println it &#125;</span><br><span class="line"><span class="comment">//如果不想使用默认的闭包参数it,那需要显示自定义参数的名称</span></span><br><span class="line">&#123; name -&gt; println name &#125;</span><br><span class="line"><span class="comment">//闭包也可以接受多个参数</span></span><br><span class="line">&#123; String x, <span class="keyword">int</span> y -&gt;</span><br><span class="line">    println <span class="string">"hey $&#123;x&#125; the value is $&#123;y&#125;"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//闭包参数也可是一个对象</span></span><br><span class="line">&#123; reader -&gt;</span><br><span class="line">    <span class="keyword">def</span> line = reader.readLine() </span><br><span class="line">    line.trim()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>闭包调用方式： 闭包是 groovy.lang.Closure 的实例。它可以像任何其他变量一样分配给一个变量或字段。  <code>闭包对象(参数)</code> ；<code>闭包对象.call(参数)</code></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> isOdd = &#123; <span class="keyword">int</span> i -&gt; i%<span class="number">2</span> != <span class="number">0</span> &#125; </span><br><span class="line"><span class="keyword">assert</span> isOdd(<span class="number">3</span>) == <span class="literal">true</span></span><br><span class="line"><span class="keyword">assert</span> isOdd.call(<span class="number">2</span>) == <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> isEven = &#123; it%<span class="number">2</span> == <span class="number">0</span> &#125; </span><br><span class="line"><span class="keyword">assert</span> isEven(<span class="number">3</span>) == <span class="literal">false</span> </span><br><span class="line"><span class="keyword">assert</span> isEven.call(<span class="number">2</span>) == <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ===============================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//无参闭包</span></span><br><span class="line"><span class="keyword">def</span> run(Closure closure)&#123; </span><br><span class="line">    println(<span class="string">"run start..."</span>)</span><br><span class="line">    closure() println(<span class="string">"run end..."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run &#123;</span><br><span class="line">    println <span class="string">"running......"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有参闭包</span></span><br><span class="line"><span class="keyword">def</span> caculate(Closure closure)&#123;</span><br><span class="line">    <span class="keyword">def</span> num1=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">def</span> num2=<span class="number">3</span>; </span><br><span class="line">    println(<span class="string">"caculate start..."</span>)</span><br><span class="line">    closure(num1,num2) </span><br><span class="line">    println(<span class="string">"caculate end..."</span>)</span><br><span class="line">&#125;</span><br><span class="line">caculate &#123;x,y -&gt; println <span class="string">"计算结果为：$x+$y=$&#123;x+y&#125;"</span>&#125; <span class="comment">//在build.gradle文件中我们见到的很多都是闭包格式的。</span></span><br></pre></td></tr></table></figure><h2 id="4、Gradle创建工程">4、Gradle创建工程</h2><h3 id="4-1-创建">4.1 创建</h3><p>创建项目时，选择Build System为Gradle，DSL为Groovy；之后修改当前项目使用本地安装的gradle：可以加快下载项目依赖jar 包的速度【配置了私服地址】(在Settings→Build,Execution→Build Tools→Gradle中配置本地)</p><p><strong>注意事项</strong></p><ul><li><p>在Terminal 中执行以gradlew 开头命令和操作图形化的IDEA 使用Gradle 版本不一定是同一个版本；Terminal中以gradlew开头指令用的是Wrapper规定的gradle版本，wrapper中规定版本默认和idea插件中规定的版本一致；而图形化的IDEA使用Gradle是本地安装的</p></li><li><p>目前只能是在创建项目时重新设置本地gradle，创建新项目需要重新去改</p></li><li><p> 我 们 在 <code>gradle.build</code> 文 件 添 加 依 赖 之 后 ， 这 些 依 赖 会 在 下 载 到<code>GRADLE_USER_HOME/caches/modules-2/files-2.1</code> 目录下面,所以这里的 GRADLE_USER_HOME 相当于 Gradle 的本地仓库</p></li></ul><p>对于低版本的war包部署，可以参考Gretty 官网地址：<a href="http://akhikhl.github.io/gretty-doc/index.html" target="_blank" rel="noopener" title="http://akhikhl.github.io/gretty-doc/index.html">http://akhikhl.github.io/gretty-doc/index.html</a></p><h3 id="4-2-测试">4.2 测试</h3><blockquote><p>测试任务自动检测并执行测试源集中的所有单元测试。测试执行完成后会生成一个报告。支持JUnit 和 TestNG 测试</p></blockquote><p>Gradle 对于Junit4.x 支持</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    testImplementation <span class="string">group:</span> <span class="string">'junit'</span> ,<span class="string">name:</span> <span class="string">'junit'</span>, <span class="string">version:</span> <span class="string">'4.12'</span></span><br><span class="line">&#125;</span><br><span class="line">test &#123;</span><br><span class="line">    useJUnit()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Gradle 对于Junit5.x 版本支持</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    testImplementation <span class="string">'org.junit.jupiter:junit-jupiter-api:5.8.1'</span> </span><br><span class="line">    testRuntimeOnly <span class="string">'org.junit.jupiter:junit-jupiter-engine:5.8.1'</span></span><br><span class="line">&#125;</span><br><span class="line">test &#123;</span><br><span class="line">    useJUnitPlatform()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：无论是 Junt4.x 版本还是Junit5.x 版本，我们只需在 build.gradle 目录下执行gradle test 指令，gradle 就会帮我们执行所有的加了@Test 注解的测试，并生成测试报告。</p><p>gradle 在junit 中的批量测试，可以设置包含或者排除某些特定测试</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test &#123;</span><br><span class="line">    enabled <span class="literal">true</span> </span><br><span class="line">    useJUnit() </span><br><span class="line">    include <span class="string">'com/**'</span></span><br><span class="line">    exclude <span class="string">'com/abc/**'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>三、Gradle进阶学习</h1><h2 id="1、生命周期">1、生命周期</h2><p>Gradle 项目的生命周期分为三大阶段:<code> Initialization -&gt; Configuration -&gt; Execution</code>. 每个阶段都有自己的职责</p><p><img src="https://img-blog.csdnimg.cn/567abb068c1345ada13d2df1c0c55fe1.jpeg#pic_center" alt="在这里插入图片描述"></p><ul><li><p><strong>Initialization 阶段</strong>主要目的是初始化构建，它又分为两个子过程，一个是执行 Init Script，另一个是执行 Setting Script</p></li><li><p>init.gradle 文件会在每个项目 build 之前被调用，用于做一些初始化的操作，它主要有如下作用：  </p><ul><li><p>配置内部的仓库信息（如公司的 maven 仓库信息）</p></li><li><p>配置一些全局属性；  </p></li><li><p>配置用户名及密码信息（如公司仓库的用户名和密码信息）</p></li></ul></li><li><p>Setting Script 则更重要, 它初始化了一次构建所参与的所有模块</p></li><li><p><strong>Configuration 阶段</strong>：这个阶段开始加载项目中所有模块的 Build Script。所谓 “加载” 就是执行 build.gradle 中的语句, 根据脚本代码创建对应的 task, 最终根据所有 task 生成由 Task 组成的有向无环图(Directed Acyclic Graphs)</p></li><li><p>Execution 阶段：这个阶段会根据上个阶段构建好的有向无环图，按着顺序执行 Task【Action 动作】</p></li></ul><h2 id="2、Settings文件">2、Settings文件</h2><ul><li><p>作用：主要是在项目初始化阶段确定一下引入哪些工程需要加入到项目构建中，为构建项目工程树做准备。  </p></li><li><p>工程树：gradle 中有工程树的概念，类似于 maven 中的project 与module。  </p></li><li><p>内容：里面主要定义了当前 gradle 项目及子 project 的项目名称  </p></li><li><p>位置：必须放在根工程目录下。  </p></li><li><p>名字：为settings.gradle 文件，不能发生变化  </p></li><li><p>对应实例：与 org.gradle.api.initialization.Settings 实例是一一对应的关系。每个项目只有一个settings 文件。  </p></li><li><p>关注：作为开发者我们只需要关注该文件中的include 方法即可。使用相对路径【 : 】引入子工程。  </p></li><li><p>一个子工程只有在setting 文件中配置了才会被 gradle 识别，这样在构建的时候才会被包含进去</p></li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根工程项目名</span></span><br><span class="line">rootProject.name = <span class="string">'root'</span></span><br><span class="line"><span class="comment">//包含的子工程名称</span></span><br><span class="line">include <span class="string">'subject01'</span> </span><br><span class="line">include <span class="string">'subject02'</span> </span><br><span class="line">include <span class="string">'subject03'</span></span><br><span class="line"><span class="comment">//包含的子工程下的子工程名称</span></span><br><span class="line">include <span class="string">'subject01:subproject011'</span> </span><br><span class="line">include <span class="string">'subject01:subproject012'</span></span><br></pre></td></tr></table></figure><h2 id="3、Task">3、Task</h2><blockquote><p>项目实质上是 Task 对象的集合。一个 Task 表示一个逻辑上较为独立的执行过程，比如编译Java 源代码，拷贝文件， 打包Jar 文件，甚至可以是执行一个系统命令。另外，一个 Task 可以读取和设置Project 的Property 以完成特定的操作<br>可参考官方文档：<a href="https://docs.gradle.org/current/userguide/tutorial_using_tasks.html" target="_blank" rel="noopener" title="https://docs.gradle.org/current/userguide/tutorial_using_tasks.html">https://docs.gradle.org/current/userguide/tutorial_using_tasks.html</a></p></blockquote><h3 id="3-1-入门Demo">3.1 入门Demo</h3><p>在<code>build.gradle</code>编写一下测试，在文件所在的目录执行命令: <code>gradle -i A</code>。  </p><ul><li><p>task 的配置段是在配置阶段完成  </p></li><li><p>task 的doFirst、doLast 方法是执行阶段完成，并且doFirst 在doLast 执行之前执行。  </p></li><li><p>区分任务的<strong>配置段和任务的行为</strong>，任务的配置段在配置阶段执行，任务的行为在执行阶段执行</p></li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">task A &#123;</span><br><span class="line">    println <span class="string">"root taskA"</span> </span><br><span class="line">    doFirst()&#123;</span><br><span class="line">        println <span class="string">"root taskA doFirst"</span></span><br><span class="line">    &#125;</span><br><span class="line">    doLast()&#123;</span><br><span class="line">        println <span class="string">"root taskA doLast"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-任务的行为">3.2 任务的行为</h3><p>doFirst、doLast 两个方法可以在任务内部定义，也可以在任务外部定义</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> map=<span class="keyword">new</span> HashMap&lt;String,Object&gt;();</span><br><span class="line"><span class="comment">//action属性可以设置为闭包，设置task自身的行为</span></span><br><span class="line">map.put(<span class="string">"action"</span>,&#123;println <span class="string">"taskD.."</span>&#125;)</span><br><span class="line">task(map,<span class="string">"a"</span>)&#123;</span><br><span class="line">    description   <span class="string">'taskA description  '</span></span><br><span class="line">    group <span class="string">"atguigu"</span></span><br><span class="line">    <span class="comment">//在task内部定义doFirst、doLast行为</span></span><br><span class="line">    doFirst &#123;</span><br><span class="line">        <span class="keyword">def</span> name = <span class="string">'doFirst..'</span> </span><br><span class="line">        println name</span><br><span class="line">    &#125;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        <span class="keyword">def</span> name = <span class="string">'doLast..'</span> </span><br><span class="line">        println name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在task外部定义doFirst、doLast行为</span></span><br><span class="line">a.doFirst &#123;</span><br><span class="line">    println it.description</span><br><span class="line">&#125;</span><br><span class="line">a.doLast &#123;</span><br><span class="line">    println it.group</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">//taskA description </span></span><br><span class="line"><span class="comment">//doFirst..</span></span><br><span class="line"><span class="comment">//taskD..</span></span><br><span class="line"><span class="comment">//doLast..</span></span><br><span class="line"><span class="comment">//atguigu</span></span><br></pre></td></tr></table></figure><p><strong>底层原理分析</strong></p><p>无论是定义<strong>任务自身的 action</strong>,还是添加的<strong>doLast</strong>、<strong>doFirst</strong> 方法，其实底层都被放入到一个Action 的List 中了，最初这个 action List 是空的，当我们设置了 action【任务自身的行为】，它先将action 添加到列表中，此时列表中只有一个action，<strong>后续执行doFirst 的时候doFirst 在action 前面添加，执行 doLast 的时候doLast 在action 后面添加</strong>。doFirst 永远添加在actions List 的第一位，保证添加的Action 在现有的 action List 元素的最前面；doLast 永远都是在action List 末尾添加，保证其添加的Action 在现有的action List 元素的最后面。一个往前面添加，一个往后面添加，<strong>最后这个action List 就按顺序形成了doFirst、doSelf、doLast 三部分的 Actions，就达到 doFirst、doSelf、doLast 三部分的 Actions 顺序执行的目的</strong>。  注意其中&lt;&lt;代表doLast，在gradle5.x 版本之后就废弃</p><h3 id="3-3-任务的依赖">3.3 任务的依赖</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数方式依赖</span></span><br><span class="line">task A &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="string">"TaskA.."</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">task <span class="string">'B'</span> &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="string">"TaskB.."</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//参数方式依赖: dependsOn后面用冒号</span></span><br><span class="line">task <span class="string">'C'</span>(<span class="string">dependsOn:</span> [<span class="string">'A'</span>, <span class="string">'B'</span>]) &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="string">"TaskC.."</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =====================================</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//内部依赖</span></span><br><span class="line"><span class="comment">//参数方式依赖</span></span><br><span class="line">task <span class="string">'C'</span> &#123;</span><br><span class="line">    <span class="comment">//内部依赖：dependsOn后面用 = 号</span></span><br><span class="line">    dependsOn= [A,B] </span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="string">"TaskC.."</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =====================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//外部依赖:可变参数,引号可加可不加</span></span><br><span class="line">C.dependsOn(B,<span class="string">'A'</span>)</span><br></pre></td></tr></table></figure><ul><li><p>当一个 Task 依赖多个Task 的时候，被依赖的Task 之间如果没有依赖关系，那么它们的执行顺序是随机的，并无影响</p></li><li><p>重复依赖的任务只会执行一次</p></li></ul><h3 id="3-4-任务执行">3.4 任务执行</h3><blockquote><p>参考：<a href="https://docs.gradle.org/current/userguide/command_line_interface.html" target="_blank" rel="noopener" title="https://docs.gradle.org/current/userguide/command_line_interface.html#sec:command_line_executing_tasks">https://docs.gradle.org/current/userguide/command_line_interface.html#sec:command_line_executing_tasks</a></p></blockquote><p><strong>任务执行语法：gradle [taskName…] [–option-name…]</strong></p><table><thead><tr><th><strong>分类</strong></th><th><strong>解释</strong></th></tr></thead><tbody><tr><td><strong>常见的任务（*）</strong></td><td><strong>gradle build</strong>: 构建项目:编译、测试、打包等操作  <strong>gradle run</strong> :运行一个服务,需要application 插件支持，并且指定了主启动类才能运行  <strong>gradle clean</strong>: 请求当前项目的 build 目录  <strong>gradle init</strong> : 初始化 gradle 项目使用  <strong>gradle wrapper</strong>:生成wrapper 文件夹的。  <strong>gradle wrapper</strong> 升级wrapper 版本号：gradle wrapper --gradle-version=4.4  gradle wrapper --gradle-version 5.2.1 --distribution-type all :关联源码用</td></tr><tr><td>项目报告相关任务</td><td><strong>gradle projects</strong> : 列出所选项目及子项目列表，以层次结构的形式显示  <strong>gradle tasks</strong>: 列出所选项目【当前 project,不包含父、子】的已分配给任务组的那些任务gradle tasks --all :列出所选项目的所有任务。  gradle tasks --group=“build setup”:列出所选项目中指定分组中的任务。  gradle help --task someTask :显示某个任务的详细信息  gradle dependencies :查看整个项目的依赖信息，以依赖树的方式显示  gradle properties 列出所选项目的属性列表</td></tr><tr><td>调试相关选项</td><td>-h,–help: 查看帮助信息  -v, --version:打印 Gradle、 Groovy、 Ant、 JVM 和操作系统版本信息。  -S, --full-stacktrace:打印出所有异常的完整(非常详细)堆栈跟踪信息。  -s,–stacktrace: 打印出用户异常的堆栈跟踪(例如编译错误)。  -Dorg.gradle.daemon.debug=true: 调试 Gradle 守护进程。  -Dorg.gradle.debug=true:调试 Gradle 客户端(非 daemon)进程。  -Dorg.gradle.debug.port=(port number):指定启用调试时要侦听的端口号。默认值为 5005。</td></tr><tr><td>性能选项:【备注: 在<strong>gradle.properties</strong>中指定这些选项中的许多选项，因此不需要命令行标志】</td><td>–build-cache, --no-build-cache： 尝试重用先前版本的输出。默认关闭(off)。  –max-workers: 设置 Gradle 可以使用的woker 数。默认值是处理器数。  -parallel, --no-parallel: 并行执行项目。有关此选项的限制，请参阅并行项目执行。默认设置为关闭(off)</td></tr><tr><td>守护进程选项，也可以配置在<strong>gradle.properties</strong>中</td><td>–daemon, --no-daemon: 使用 Gradle 守护进程运行构建。默认是on  –foreground:在前台进程中启动 Gradle 守护进程。  -Dorg.gradle.daemon.idletimeout=(number of milliseconds):  Gradle Daemon 将在这个空闲时间的毫秒数之后停止自己。默认值为 10800000(3 小时)。</td></tr><tr><td>日志选项</td><td>-Dorg.gradle.logging.level=(quiet,warn,lifecycle,info,debug):  通过 Gradle 属性设置日志记录级别。  -q, --quiet: 只能记录错误信息  -w, --warn: 设置日志级别为 warn  -i, --info: 将日志级别设置为 info  -d, --debug:登录调试模式(包括正常的堆栈跟踪)</td></tr><tr><td>其它(*)</td><td><strong>-x</strong>:-x 等价于: --exclude-task : 常见gradle -x test clean build  <strong>–rerun-tasks</strong>: 强制执行任务，忽略up-to-date ,常见gradle build --rerun-tasks  <strong>–continue</strong>: 忽略前面失败的任务,继续执行,而不是在遇到第一个失败时立即停止执行。每个遇到的故障都将在构建结束时报告，常见：gradle build --continuegradle init --type pom :将maven 项目转换为gradle 项目(根目录执行)  gradle [taskName] :执行自定义任务</td></tr></tbody></table><p>前面提到的Gradle 指令本质:一个个的task[任务]，Gradle 中所有操作都是基于任务完成的。</p><p><img src="https://img-blog.csdnimg.cn/a17badc783b9424195df3d1e1dfd54fd.png#pic_center" alt="在这里插入图片描述"></p><h3 id="3-5-任务定义方式">3.5 任务定义方式</h3><p>任务定义方式，总体分为两大类:一种是<strong>通过 Project 中的task()方法</strong>,另一种是通过tasks 对象的 create 或者register 方法</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">task(<span class="string">'A'</span>, &#123;<span class="comment">//任务名称,闭包都作为参数println "taskA..."</span></span><br><span class="line">&#125;)</span><br><span class="line">task(<span class="string">'B'</span>) &#123;<span class="comment">//闭包作为最后一个参数可以直接从括号中拿出来println "taskB..."</span></span><br><span class="line">&#125;</span><br><span class="line">task C &#123;<span class="comment">//groovy语法支持省略方法括号:上面三种本质是一种println "taskC..."</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">def</span> map = <span class="keyword">new</span> HashMap&lt;String, Object&gt;(); map.put(<span class="string">"action"</span>, &#123; println <span class="string">"taskD.."</span> &#125;) <span class="comment">//action属性可以设置为闭包task(map,"D");</span></span><br><span class="line">tasks.create(<span class="string">'E'</span>) &#123;<span class="comment">//使用tasks的create方法println "taskE.."</span></span><br><span class="line">&#125;</span><br><span class="line">tasks.register(<span class="string">'f'</span>) &#123; <span class="comment">//注：register执行的是延迟创建。也即只有当task被需要使用的时候才会被创建。</span></span><br><span class="line">  println <span class="string">"taskF  "</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们也可以在定义任务的同时指定任务的属性</p><ul><li><p>type：基于一个存在的Task来创建，和继承类似，默认值DefaultTask</p></li><li><p>overwrite：是否替换存在的Task，这个和type配合使用，默认值false</p></li><li><p>dependsOn：用户配置任务的依赖，默认值[]</p></li><li><p>action：添加到任务中的一个Action或者一个闭包，默认值null</p></li><li><p>description：用于配置任务的描述，默认值null</p></li><li><p>group：用于配置任务的分组，默认值null</p></li></ul><p>在定义任务时也可以给任务分配属性：定义任务的时候可以直接指定任务属性，也可以给已有的任务动态分配属性</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//①.F是任务名，前面通过具名参数给map的属性赋值,以参数方式指定任务的属性信息</span></span><br><span class="line">task(<span class="string">group:</span> <span class="string">"atguigu"</span>, <span class="string">description:</span> <span class="string">"this is task B"</span>, <span class="string">"F"</span>)</span><br><span class="line"><span class="comment">//②.H是任务名，定义任务的同时，在内部直接指定属性信息</span></span><br><span class="line">task(<span class="string">"H"</span>) &#123;</span><br><span class="line">    group(<span class="string">"atguigu"</span>) description(<span class="string">"this is the task H"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//③.Y是任务名，给已有的任务 在外部直接指定属性信息</span></span><br><span class="line">task <span class="string">"y"</span> &#123;&#125;</span><br><span class="line">y.group = <span class="string">"atguigu"</span></span><br><span class="line">clean.group(<span class="string">"atguigu"</span>) <span class="comment">//案例：给已有的clean任务重新指定组信息</span></span><br></pre></td></tr></table></figure><h3 id="3-6-任务类型">3.6 任务类型</h3><blockquote><p><a href="https://docs.gradle.org/current/dsl/index.html" target="_blank" rel="noopener" title="https://docs.gradle.org/current/dsl/index.html">https://docs.gradle.org/current/dsl/index.html</a></p></blockquote><p>我们定义的task 都是DefaultTask 类型的，如果要完成某些具体的操作完全需要我们自己去编写gradle 脚本，势必有些麻烦，那有没有一些现成的任务类型可以使用呢？有的，Gradle 官网给出了一些现成的任务类型帮助我们快速完成想要的任务，我们只需要在创建任务的时候，指定当前任务的类型即可，然后即可使用这种类型中的属性和API 方法了</p><table><thead><tr><th><strong>常见任务类型</strong></th><th><strong>该类型任务的作用</strong></th></tr></thead><tbody><tr><td>Delete</td><td>删除文件或目录</td></tr><tr><td>Copy</td><td>将文件复制到目标目录中。此任务还可以在复制时重命名和筛选文件。</td></tr><tr><td>CreateStartScripts</td><td>创建启动脚本</td></tr><tr><td>Exec</td><td>执行命令行进程</td></tr><tr><td>GenerateMavenPom</td><td>生成 Maven 模块描述符(POM)文件。</td></tr><tr><td>GradleBuild</td><td>执行 Gradle 构建</td></tr><tr><td>Jar</td><td>组装 JAR 归档文件</td></tr><tr><td>JavaCompile</td><td>编译 Java 源文件</td></tr><tr><td>Javadoc</td><td>为 Java 类 生 成 HTML API 文 档</td></tr><tr><td>PublishToMavenRepository</td><td>将 MavenPublication 发布到 mavenartifactrepostal。</td></tr><tr><td>Tar</td><td>组装 TAR 存档文件</td></tr><tr><td>Test</td><td>执行 JUnit (3.8.x、4.x 或 5.x)或 TestNG 测试。</td></tr><tr><td>Upload</td><td>将 Configuration 的构件上传到一组存储库。</td></tr><tr><td>War</td><td>组装 WAR 档案。</td></tr><tr><td>Zip</td><td>组装 ZIP 归档文件。默认是压缩 ZIP 的内容</td></tr></tbody></table><p>举例在命令行执行 gradle myClean 发现就可以将当前project 的 build 目录删除</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tasks.register(<span class="string">'myClean'</span>, Delete) &#123; </span><br><span class="line">  delete buildDir</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义 Task 类型</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> myTask = task MyDefinitionTask(<span class="string">type:</span> CustomTask) </span><br><span class="line">myTask.doFirst() &#123;</span><br><span class="line">  println <span class="string">"task 执行之前 执行的 doFirst方法"</span></span><br><span class="line">&#125;</span><br><span class="line">myTask.doLast() &#123;</span><br><span class="line">  println <span class="string">"task 执行之后 执行的 doLast方法"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomTask</span> <span class="keyword">extends</span> <span class="title">DefaultTask</span> &#123;</span></span><br><span class="line"><span class="comment">//@TaskAction表示Task本身要执行的方法@TaskAction</span></span><br><span class="line">  <span class="keyword">def</span> doSelf() &#123;</span><br><span class="line">    println <span class="string">"Task 自身 在执行的in doSelf"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-7-任务的执行顺序与动态分配">3.7 任务的执行顺序与动态分配</h3><blockquote><p>官网：<a href="https://docs.gradle.org/current/dsl/org.gradle.api.Task.html" target="_blank" rel="noopener" title="https://docs.gradle.org/current/dsl/org.gradle.api.Task.html">https://docs.gradle.org/current/dsl/org.gradle.api.Task.html</a></p></blockquote><p>在 Gradle 中, 有三种方式可以指定 Task 执行顺序：  </p><ul><li><p>dependsOn 强依赖方式  </p></li><li><p>通过 Task 输入输出  </p></li><li><p>通过 API 指定执行顺序</p></li></ul><p>gradle可以使用它在循环中注册同一类型的多个任务</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建 4 个任务,但是任务 0 必须依赖于任务 2 和 3,那么代表任务 2 和 3 需要在任务 0 之前优先加载。</span></span><br><span class="line"><span class="number">4.</span>times &#123; counter -&gt;</span><br><span class="line">    tasks.register(<span class="string">"task$counter"</span>) &#123;</span><br><span class="line">        doLast &#123;</span><br><span class="line">            println <span class="string">"I'm task number $counter"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">tasks.named(<span class="string">'task0'</span>) &#123; dependsOn(<span class="string">'task2'</span>, <span class="string">'task3'</span>) &#125;</span><br></pre></td></tr></table></figure><h3 id="3-8-任务的关闭、开启与超时">3.8 任务的关闭、开启与超时</h3><p>每个任务都有一个 timeout 可用于限制其执行时间的属性。当任务达到超时时，其任务执行线程将被中断。该任务将被标记为失败。终结器任务仍将运行。如果 --continue 使用，其他任务可以在此之后继续运行。不响应中断的任务无法超时。Gradle 的所有内置任务均会及时响应超时</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//每个任务都有一个 enabled 默认为的标志 true。将其设置为 false 阻止执行任何任务动作。禁用的任务将标记为“跳过”。</span></span><br><span class="line">task disableMe &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="string">'This task is Executing...'</span></span><br><span class="line">    &#125;</span><br><span class="line">    enabled(<span class="literal">true</span>)<span class="comment">//直接设置任务开启，默认值为true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//disableMe.enabled = false //设置关闭任务</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ===========================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在控制台使用: gradle a b 测试会发现执行a 的时候,由于a 执行超时，抛出异常，所以没有继续往下执行【b 也没执行】。</span></span><br><span class="line"><span class="comment">//然后在控制台使用: gradle a b –continue,测试会发现a 虽然执行失败，但是 b 还是执行了。</span></span><br><span class="line">task a() &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>)</span><br><span class="line">        println <span class="string">"当前任务a执行了"</span></span><br><span class="line">    &#125;</span><br><span class="line">    timeout = Duration.ofMillis(<span class="number">500</span>)</span><br><span class="line">&#125;</span><br><span class="line">task b() &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="string">"当前任务b执行了"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-9-任务的查找">3.9 任务的查找</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">task atguigu &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="string">"让天下没有难学的技术：尚硅谷"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据任务名查找</span></span><br><span class="line">tasks.findByName(<span class="string">"atguigu"</span>).doFirst(&#123;println <span class="string">"尚硅谷校区1：北京  "</span>&#125;)</span><br><span class="line">tasks.getByName(<span class="string">"atguigu"</span>).doFirst(&#123;println <span class="string">"尚硅谷校区2：深圳  "</span>&#125;)</span><br><span class="line"><span class="comment">//根据任务路径查找【相对路径】</span></span><br><span class="line">tasks.findByPath(<span class="string">":atguigu"</span>).doFirst(&#123;println <span class="string">"尚硅谷校区3：上海    "</span>&#125;)</span><br><span class="line">tasks.getByPath(<span class="string">":atguigu"</span>).doFirst(&#123;println <span class="string">"尚硅谷校区4：武汉  "</span>&#125;)</span><br></pre></td></tr></table></figure><h3 id="3-10-任务的规则">3.10 任务的规则</h3><p>使用 gradle abc hello 进行测试，此时当 abc 任务不存在时，也不会报异常【不中断执行】而是提示自定义的规则信息，继续执行 hello 任务。此外，它还可以根据不同的规则动态创建需要的任务等情况</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">task hello &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="string">'hello 尚硅谷的粉丝们'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tasks.addRule(<span class="string">"对该规则的一个描述，便于调试、查看等"</span>)&#123; String taskName -&gt; task(taskName) &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="string">"该$&#123;taskName&#125;任务不存在，请查证后再执行"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-11-任务的-onlyIf-断言">3.11 任务的 onlyIf 断言</h3><p>断言就是一个条件表达式。Task 有一个 onlyIf 方法。它接受一个闭包作为参数，如果该闭包返回 true 则该任务执行， 否则跳过。这有很多用途，比如控制程序哪些情况下打什么包，什么时候执行单元测试，什么情况下执行单元测试的时候不执行网络测试等</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">task hello &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="string">'hello 尚硅谷的粉丝们'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hello.onlyIf &#123; !project.hasProperty(<span class="string">'fensi'</span>) &#125;</span><br></pre></td></tr></table></figure><p>测试：通过-P 为Project 添加fensi 属性 <code>gradle hello -Pfensi</code></p><h3 id="3-12-默认任务">3.12 默认任务 </h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">defaultTasks <span class="string">'myClean'</span>, <span class="string">'myRun'</span> </span><br><span class="line">tasks.register(<span class="string">'myClean'</span>) &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="string">'Default Cleaning!'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">tasks.register(<span class="string">'myRun'</span>) &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="string">'Default Running!'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">tasks.register(<span class="string">'other'</span>) &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="string">"I'm not a default task!"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//gradle -q</span></span><br></pre></td></tr></table></figure><h2 id="4、Gradle-中的文件操作">4、Gradle 中的文件操作</h2><h3 id="4-1-本地文件">4.1 本地文件</h3><p>使用 <code>Project.file(java.lang.Object)</code>方法，通过指定文件的相对路径或绝对路径来对文件的操作,其中相对路径为相对当前project**[根project 或者子project]**的目录。其实使用 <code>Project.file(java.lang.Object)</code>方法创建的 File 对象就是 Java 中的 File 对象，我们可以使用它就像在 Java 中使用一样</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用相对路径</span></span><br><span class="line">File configFile = file(<span class="string">'src/conf.xml'</span>)</span><br><span class="line">configFile.createNewFile();</span><br><span class="line"><span class="comment">// 使用绝对路径</span></span><br><span class="line">configFile = file(<span class="string">'D:\\conf.xml'</span>)</span><br><span class="line">println(configFile.createNewFile())</span><br><span class="line"><span class="comment">// 使用一个文件对象</span></span><br><span class="line">configFile = <span class="keyword">new</span> File(<span class="string">'src/config.xml'</span>)</span><br><span class="line">println(configFile.exists())</span><br></pre></td></tr></table></figure><h3 id="4-2-文件集合">4.2 文件集合</h3><p>文 件 集 合 就 是 一 组 文 件 的 列 表 , 在 Gradle 中 , 文 件 集 合 用 FileCollection 接 口 表 示 ，我 们 可 以 使 用 <code>Project.files(java.lang.Object[])</code>方法来获得一个文件集合对象</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> collection = files(<span class="string">'src/test1.txt'</span>, <span class="keyword">new</span> File(<span class="string">'src/test2.txt'</span>), [<span class="string">'src/test3.txt'</span>, <span class="string">'src/test4.txt'</span>])</span><br><span class="line">collection.forEach() &#123; File it -&gt;</span><br><span class="line">    it.createNewFile() <span class="comment">//创建该文件</span></span><br><span class="line">    println it.name <span class="comment">//输出文件名</span></span><br><span class="line">&#125;</span><br><span class="line">Set set1 = collection.files <span class="comment">// 把文件集合转换为java中的Set类型</span></span><br><span class="line">Set set2 = collection <span class="keyword">as</span> Set</span><br><span class="line">List list = collection <span class="keyword">as</span> List<span class="comment">//  把文件集合转换为java中的List类型</span></span><br><span class="line"><span class="keyword">for</span> (item <span class="keyword">in</span> list) &#123;</span><br><span class="line">    println item.name</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">def</span> union = collection + files(<span class="string">'src/test5.txt'</span>) <span class="comment">// 添加或者删除一个集合</span></span><br><span class="line"><span class="keyword">def</span> minus = collection - files(<span class="string">'src/test3.txt'</span>)</span><br><span class="line">union.forEach() &#123; File it -&gt;</span><br><span class="line">    println it.name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-文件树">4.3 文件树</h3><p>文件树是有层级结构的文件集合,一个文件树它可以代表一个目录结构或一 ZIP 压缩包中的内容结构。文件树是从文件集合继承过来的,所以文件树具有文件集合所有的功能。我们可以使用 <code>Project.fileTree(java.util.Map)</code>方法来创建文件树对象， 还可以使用过虑条件来包含或排除相关文件</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> tree = fileTree(<span class="string">dir:</span> <span class="string">'src/main'</span>, <span class="string">include:</span> <span class="string">'**/*.java'</span>)</span><br><span class="line">tree = fileTree(<span class="string">'src/main'</span>) &#123;</span><br><span class="line">    include <span class="string">'**/*.java'</span></span><br><span class="line">&#125;</span><br><span class="line">tree = fileTree(<span class="string">dir:</span> <span class="string">'src/main'</span>, <span class="string">include:</span> <span class="string">'**/*.java'</span>) <span class="comment">//第三种方式:通过路径和闭包创建文件树：具名参数给map传值</span></span><br><span class="line">tree = fileTree(<span class="string">dir:</span> <span class="string">'src/main'</span>, <span class="string">includes:</span> [<span class="string">'**/*.java'</span>, <span class="string">'**/*.xml'</span>, <span class="string">'**/*.txt'</span>], <span class="string">exclude:</span> <span class="string">'**/*test*/**'</span>)</span><br><span class="line">tree.each &#123; File file -&gt; <span class="comment">// 遍历文件树的所有文件</span></span><br><span class="line">    println file</span><br><span class="line">    println file.name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-文件拷贝">4.4 文件拷贝</h3><p>我们可以使用 Copy 任务来拷贝文件，通过它可以过虑指定拷贝内容，还能对文件进行重命名操作等。Copy 任务必须指定一组需要拷贝的文件和拷贝到的目录，这里使用<code>CopySpec.from(java.lang.Object[])</code>方法指定原文件；使用<code>CopySpec.into(java.lang.Object)</code>方法指定目标目录</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">task copyTask(<span class="string">type:</span> Copy) &#123;</span><br><span class="line">    from <span class="string">'src/main/resources'</span></span><br><span class="line">    into <span class="string">'build/config'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>from()方法接受的参数和文件集合时files()一样。当参数为一个目录时，该目录下所有的文件都会被拷贝到指定目录下（目录自身不会被拷贝）；当参数为一个文件时，该文件会被拷贝到指定目录；如果参数指定的文件不存在，就会被忽略； 当参数为一个 Zip 压缩文件，该压缩文件的内容会被拷贝到指定目录。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">task copyTask(<span class="string">type:</span> Copy) &#123;</span><br><span class="line"><span class="comment">// 拷贝src/main/webapp目录下所有的文件</span></span><br><span class="line">    from <span class="string">'src/main/webapp'</span></span><br><span class="line"><span class="comment">// 拷贝单独的一个文件</span></span><br><span class="line">    from <span class="string">'src/staging/index.html'</span></span><br><span class="line"><span class="comment">// 从Zip压缩文件中拷贝内容</span></span><br><span class="line">    from zipTree(<span class="string">'src/main/assets.zip'</span>)</span><br><span class="line"><span class="comment">// 拷贝到的目标目录</span></span><br><span class="line">    into <span class="string">'build/explodedWar'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在拷贝文件的时候还可以添加过虑条件来指定包含或排除的文件</span></span><br><span class="line">task copyTaskWithPatterns(<span class="string">type:</span> Copy) &#123;</span><br><span class="line">    from <span class="string">'src/main/webapp'</span></span><br><span class="line">    into <span class="string">'build/explodedWar'</span></span><br><span class="line">    include <span class="string">'**/*.html'</span></span><br><span class="line">    include <span class="string">'**/*.jsp'</span></span><br><span class="line">    exclude &#123; details -&gt; details.file.name.endsWith(<span class="string">'.html'</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在拷贝文件的时候还可以对文件进行重命名操作</span></span><br><span class="line">task rename(<span class="string">type:</span> Copy) &#123;</span><br><span class="line">    from <span class="string">'src/main/webapp'</span></span><br><span class="line">    into <span class="string">'build/explodedWar'</span></span><br><span class="line"><span class="comment">// 使用一个闭包方式重命名文件</span></span><br><span class="line">    rename &#123; String fileName -&gt;</span><br><span class="line">        fileName.replace(<span class="string">'-staging-'</span>, <span class="string">''</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝</span></span><br><span class="line">task copyMethod &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        copy &#123;</span><br><span class="line">            from <span class="string">'src/main/webapp'</span></span><br><span class="line">            into <span class="string">'build/explodedWar'</span></span><br><span class="line">            include <span class="string">'**/*.html'</span></span><br><span class="line">            include <span class="string">'**/*.jsp'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行gradle build即可</span></span><br><span class="line">copy &#123;</span><br><span class="line"><span class="comment">//相对路径或者绝对路径</span></span><br><span class="line">    from file(<span class="string">'src/main/resources/ddd.txt'</span>) <span class="comment">//file也可以换成new File()</span></span><br><span class="line">    into <span class="keyword">this</span>.buildDir.absolutePath</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5-文件归档">4.5 文件归档</h3><blockquote><p>官方文档：<a href="https://docs.gradle.org/current/userguide/working_with_files.html" target="_blank" rel="noopener" title="https://docs.gradle.org/current/userguide/working_with_files.html">https://docs.gradle.org/current/userguide/working_with_files.html</a></p></blockquote><p>通常一个项目会有很多的Jar 包，我们希望把项目打包成一个WAR，ZIP 或TAR 包进行发布，这时我们就可以使用Zip，Tar，Jar，War 和Ear 任务来实现，不过它们的用法都一样，所以在这里我只介绍Zip 任务的示例。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'java'</span></span><br><span class="line">version=<span class="number">1.0</span></span><br><span class="line">task myZip(<span class="string">type:</span> Zip) &#123;</span><br><span class="line">    from <span class="string">'src/main'</span></span><br><span class="line">    into <span class="string">'build'</span> <span class="comment">//保存到build目录中</span></span><br><span class="line">    baseName = <span class="string">'myGame'</span></span><br><span class="line">&#125;</span><br><span class="line">println myZip.archiveName</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Project.zipTree(java.lang.Object)和 Project.tarTree(java.lang.Object)方法来创建访问 Zip 压缩包的文件树对象</span></span><br><span class="line"><span class="comment">// 使用zipTree</span></span><br><span class="line">FileTree zip = zipTree(<span class="string">'someFile.zip'</span>)</span><br><span class="line"><span class="comment">// 使用tarTree</span></span><br><span class="line">FileTree tar = tarTree(<span class="string">'someFile.tar'</span>)</span><br></pre></td></tr></table></figure><h2 id="5、Dependencies">5、Dependencies</h2><h3 id="5-1-依赖方式">5.1 依赖方式</h3><p>Gradle 中的依赖分别为直接依赖，项目依赖，本地jar 依赖</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  <span class="comment">//依赖当前项目下的某个模块[子工程]</span></span><br><span class="line">  implementation project(<span class="string">':subject01'</span>)</span><br><span class="line">  <span class="comment">//直接依赖本地的某个jar文件</span></span><br><span class="line">  implementation files(<span class="string">'libs/foo.jar'</span>, <span class="string">'libs/bar.jar'</span>)</span><br><span class="line">  <span class="comment">//配置某文件夹作为依赖项</span></span><br><span class="line">  implementation fileTree(<span class="string">dir:</span> <span class="string">'libs'</span>, <span class="string">include:</span> [<span class="string">'*.jar'</span>])</span><br><span class="line">  <span class="comment">//直接依赖</span></span><br><span class="line">  implementation <span class="string">'org.apache.logging.log4j:log4j:2.17.2'</span></span><br><span class="line">  testImplementation <span class="string">'org.springframework.boot:spring-boot-starter-test'</span></span><br><span class="line">  <span class="comment">//完整写法</span></span><br><span class="line">  <span class="comment">//implementation group: 'org.apache.logging.log4j', name: 'log4j', version: '2.17.2'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当执行 <strong>build 命令时</strong>，gradle 就会去配置的依赖仓库中下载对应的 Jar，并应用到项目中</p><h3 id="5-2-依赖类型">5.2 依赖类型</h3><blockquote><p><a href="https://docs.gradle.org/current/userguide/java_library_plugin.html#java_library_plugin:" target="_blank" rel="noopener" title="https://docs.gradle.org/current/userguide/java_library_plugin.html#java_library_plugin:">https://docs.gradle.org/current/userguide/java_library_plugin.html#java_library_plugin:</a> 各个依赖范围的关系和说明<br><a href="https://docs.gradle.org/current/userguide/upgrading_version_6.html#sec:configuration_removal" target="_blank" rel="noopener" title="https://docs.gradle.org/current/userguide/upgrading_version_6.html#sec:configuration_removal">https://docs.gradle.org/current/userguide/upgrading_version_6.html#sec:configuration_removal</a> : 依赖范围升级和移除<br><a href="https://docs.gradle.org/current/userguide/java_library_plugin.html#java_library_plugin%EF%BC%9AAPI" target="_blank" rel="noopener" title="https://docs.gradle.org/current/userguide/java_library_plugin.html#java_library_plugin：API">https://docs.gradle.org/current/userguide/java_library_plugin.html#java_library_plugin：API</a> 和implemention 区别<br><a href="https://docs.gradle.org/current/userguide/java_plugin.html#java_plugin:" target="_blank" rel="noopener" title="https://docs.gradle.org/current/userguide/java_plugin.html#java_plugin:">https://docs.gradle.org/current/userguide/java_plugin.html#java_plugin:</a> 执行java 命令时都使用了哪些依赖范围的依</p></blockquote><p>类似于 Maven 的 scope 标签，gradle 也提供了依赖的类型</p><table><thead><tr><th>compileOnly</th><th>由<strong>java插件</strong>提供，曾短暂的叫provided,后续版本已经改成了compileOnly,适用于编译期需要而不需要打包的情  况</th></tr></thead><tbody><tr><td>runtimeOnly</td><td>由 java 插件提供,只在运行期有效,编译时不需要,<strong>比如mysql 驱动包</strong>。取代老版本中被移除的 runtime</td></tr><tr><td>implementation</td><td>由 java 插件提供,针对源码[src/main 目录] ,在编译、运行时都有效,取代老版本中被移除的 compile</td></tr><tr><td>testCompileOnly</td><td>由 <strong>java 插件</strong>提供,用于编译测试的依赖项，运行时不需要</td></tr><tr><td>testRuntimeOnly</td><td>由 <strong>java 插件</strong>提供,只在测试运行时需要，而不是在测试编译时需要,取代老版本中被移除的testRuntime</td></tr><tr><td>testImplementation</td><td>由 java 插件提供,<strong>针对测试代码[src/test 目录]</strong> 取代老版本中被移除的testCompile</td></tr><tr><td>providedCompile</td><td><strong>war 插件</strong>提供支持，编译、测试阶段代码需要依赖此类jar 包，而运行阶段容器已经提供了相应的支持，所  以无需将这些文件打入到war 包中了;<strong>例如servlet-api.jar、jsp-api.jar</strong></td></tr><tr><td>compile</td><td>编译范围依赖在所有的 classpath 中可用，同时它们也会被打包。在<strong>gradle 7.0 已经移除</strong></td></tr><tr><td>runtime</td><td>runtime 依赖在运行和测试系统的时候需要,在编译的时候不需要,比如mysql 驱动包。在 gradle 7.0 已经移除</td></tr><tr><td>api</td><td><strong>java-library 插件</strong>提供支持,这些依赖项可以传递性地导出给使用者，用于编译时和运行时。取代老版本中被  移除的 compile</td></tr><tr><td>compileOnlyApi</td><td>java-library 插件提供支持,在声明模块和使用者在编译时需要的依赖项，但在运行时不需要。</td></tr></tbody></table><h3 id="5-3-api-与implementation-区别">5.3 api 与implementation 区别</h3><table><thead><tr><th></th><th>api</th><th>implementation</th></tr></thead><tbody><tr><td>编译时</td><td>能进行依赖传递，底层变，全部都要变、编译速度慢</td><td>不能进行依赖传递，底层变不用全部都要变、编译速度快</td></tr><tr><td>运行时</td><td>运行时会加载，所有模块的class都要被加载</td><td>运行时会加载，所有模块的class都要被加载</td></tr><tr><td>应用场景</td><td>适用于多模块依赖，避免重复依赖模块</td><td>多数情况下使用implementation</td></tr></tbody></table><p>api 的适用场景是多module 依赖，moduleA 工程依赖了 module B，同时module B 又需要依赖了 module C，modelA 工程也需要去依赖 module C；这个时候避免重复依赖module，可以使用 module B api 依赖的方式去依赖module C，modelA 工程只需要依赖 moduleB 即可。  </p><p>总之，<strong>除非涉及到多模块依赖，为了避免重复依赖，咱们会使用api，其它情况我们优先选择implementation，拥有大量的api 依赖项会显著增加构建时间</strong>。</p><h3 id="5-4-依赖冲突及解决方案">5.4 依赖冲突及解决方案</h3><p>依赖冲突是指&quot;在编译过程中, 如果存在某个依赖的多个版本, 构建系统应该选择哪个进行构建的问题&quot;</p><p>默认下，<strong>Gradle 会使用最新版本的jar 包【考虑到新版本的jar 包一般都是向下兼容的】</strong>，实际开发中，还是建议使用官方自带的这种解决方案。当然除此之外，Gradle 也为我们提供了一系列的解决依赖冲突的方法: <strong>exclude移除一个依赖，不允许依赖传递，强制使用某个版本</strong></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Exclude 排除某个依赖</span></span><br><span class="line">dependencies &#123;</span><br><span class="line">    testImplementation <span class="string">'org.junit.jupiter:junit-jupiter-api:5.8.1'</span></span><br><span class="line">    testRuntimeOnly <span class="string">'org.junit.jupiter:junit-jupiter-engine:5.8.1'</span></span><br><span class="line">    implementation(<span class="string">'org.hibernate:hibernate-core:3.6.3.Final'</span>)&#123;</span><br><span class="line">        <span class="comment">//排除某一个库(slf4j)依赖:如下三种写法都行</span></span><br><span class="line">        exclude <span class="string">group:</span> <span class="string">'org.slf4j'</span></span><br><span class="line">        exclude <span class="string">module:</span> <span class="string">'slf4j-api'</span></span><br><span class="line">        exclude <span class="string">group:</span> <span class="string">'org.slf4j'</span>,<span class="string">module:</span> <span class="string">'slf4j-api'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//排除之后,使用手动的引入即可。</span></span><br><span class="line">    implementation <span class="string">'org.slf4j:slf4j-api:1.4.0'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不允许依赖传递</span></span><br><span class="line">dependencies &#123;</span><br><span class="line">    testImplementation <span class="string">'org.junit.jupiter:junit-jupiter-api:5.8.1'</span></span><br><span class="line">    testRuntimeOnly <span class="string">'org.junit.jupiter:junit-jupiter-engine:5.8.1'</span></span><br><span class="line">    implementation(<span class="string">'org.hibernate:hibernate-core:3.6.3.Final'</span>)&#123;</span><br><span class="line">        <span class="comment">//不允许依赖传递，一般不用</span></span><br><span class="line">        transitive(<span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//排除之后,使用手动的引入即可</span></span><br><span class="line">    implementation <span class="string">'org.slf4j:slf4j-api:1.4.0'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//强制使用某个版本</span></span><br><span class="line">dependencies &#123;</span><br><span class="line">    testImplementation <span class="string">'org.junit.jupiter:junit-jupiter-api:5.8.1'</span></span><br><span class="line">    testRuntimeOnly <span class="string">'org.junit.jupiter:junit-jupiter-engine:5.8.1'</span></span><br><span class="line">    implementation(<span class="string">'org.hibernate:hibernate-core:3.6.3.Final'</span>)</span><br><span class="line">    <span class="comment">//强制使用某个版本!!【官方建议使用这种方式】</span></span><br><span class="line">    implementation(<span class="string">'org.slf4j:slf4j-api:1.4.0!!'</span>)</span><br><span class="line">    <span class="comment">//这种效果和上面那种一样,强制指定某个版本</span></span><br><span class="line">    implementation(<span class="string">'org.slf4j:slf4j-api:1.4.0'</span>)&#123;</span><br><span class="line">        version&#123;</span><br><span class="line">            strictly(<span class="string">"1.4.0"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们可以先查看当前项目中到底有哪些依赖冲突</span></span><br><span class="line"><span class="comment">//下面我们配置，当Gradle 构建遇到依赖冲突时，就立即构建失败</span></span><br><span class="line">configurations.all() &#123;</span><br><span class="line">    Configuration configuration -&gt;</span><br><span class="line">        <span class="comment">//当遇到版本冲突时直接构建失败</span></span><br><span class="line">        configuration.resolutionStrategy.failOnVersionConflict()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6、Gradle-插件">6、Gradle 插件</h2><h3 id="6-1-插件介绍">6.1 插件介绍</h3><ul><li><p>促进代码重用、减少功能类似代码编写、提升工作效率</p></li><li><p>促进项目更高程度的模块化、自动化、便捷化</p></li><li><p>可插拔式的的扩展项目的功能</p></li></ul><p>在项目构建过程中做很多事情，把插件应用到项目中，通常可以完成:</p><ul><li><p>可以添加任务【task】到项目中，从而帮助完成测试、编译、打包等</p></li><li><p>可以添加依赖配置到项目中。</p></li><li><p>可以向项目中拓展新的扩展属性、方法等。</p></li><li><p>可以对项目进行一些约定，如应用Java 插件后，约定src/main/java 目录是我们的源代码存在位置，编译时编译这个目录下的Java 源代码文件</p></li></ul><h3 id="6-2-插件的分类和使用">6.2 插件的分类和使用</h3><p><strong>脚本插件</strong></p><p>脚本插件的本质就是一个脚本文件，使用<strong>脚本插件时通过apply from:将脚本加载进来</strong>就可以了，后面的脚本文件可以是本地的也可以是网络上的脚本文件，下面定义一段脚本，我们在 build.gradle 文件中使用。</p><p>脚本文件模块化的基础，可按功能把我们的脚本进行拆分一个个公用、职责分明的文件，然后在主脚本文件引用，比如：将很多共有的库版本号一起管理、应用构建版本一起管理等</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//version.gradle文件</span></span><br><span class="line">ext &#123;</span><br><span class="line">    company= <span class="string">"尚硅谷"</span></span><br><span class="line">    cfgs = [</span><br><span class="line">            <span class="string">compileSdkVersion :</span> JavaVersion.VERSION_1_8</span><br><span class="line">    ]</span><br><span class="line">    spring = [</span><br><span class="line">            <span class="string">version :</span> <span class="string">'5.0.0'</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//build.gradle文件</span></span><br><span class="line"><span class="comment">//map作为参数，可以直接引入</span></span><br><span class="line">apply <span class="string">from:</span> <span class="string">'version.gradle'</span></span><br><span class="line">task taskVersion&#123;</span><br><span class="line">    doLast&#123;</span><br><span class="line">        println <span class="string">"公司名称为：$&#123;company&#125;,JDK版本是$&#123;cfgs.compileSdkVersion&#125;,版本号是$&#123;spring.version&#125;"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>对象插件之内部插件[核心插件]</strong></p><blockquote><p><a href="https://docs.gradle.org/current/userguide/plugin_reference.html" target="_blank" rel="noopener" title="https://docs.gradle.org/current/userguide/plugin_reference.html">https://docs.gradle.org/current/userguide/plugin_reference.html</a></p></blockquote><p>二进制插件[对象插件]就是实现了org.gradle.api.Plugin 接口的插件，每个Java Gradle 插件都有一个plugin id</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用plugins DSL 方式</span></span><br><span class="line"><span class="comment">// 如果是第三方插件已经被托管在https://plugins.gradle.org/</span></span><br><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">'org.springframework.boot'</span> version <span class="string">'2.7.5'</span></span><br><span class="line">    id <span class="string">'java'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以使用闭包作为project.apply方法的一个参数</span></span><br><span class="line">apply&#123;</span><br><span class="line">    plugin <span class="string">'java'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用方式1：Map具名参数,全类名</span></span><br><span class="line">apply <span class="string">plugin:</span>org.gradle.api.plugins.JavaPlugin</span><br><span class="line"><span class="comment">//org.gradle.api.plugins默认导入：使用方式2</span></span><br><span class="line">apply <span class="string">plugin:</span>JavaPlugin</span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'java'</span> <span class="comment">//核心插件，无需事先引入，使用方式3:插件的id</span></span><br></pre></td></tr></table></figure><p><strong>第三方插件</strong></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用传统的应用方式</span></span><br><span class="line">buildscript &#123;</span><br><span class="line">    ext &#123;</span><br><span class="line">        springBootVersion = <span class="string">"2.3.3.RELEASE"</span></span><br><span class="line">    &#125;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenLocal()</span><br><span class="line">        maven &#123; url <span class="string">'http://maven.aliyun.com/nexus/content/groups/public'</span> &#125;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 此处先引入插件</span></span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath(<span class="string">"org.springframework.boot:spring-boot-gradle-plugin:$&#123;springBootVersion&#125;"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//再应用插件</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'org.springframework.boot'</span> <span class="comment">//社区插件,需要事先引入，不必写版本号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用plugins DSL 方式</span></span><br><span class="line"><span class="comment">// 如果是第三方插件已经被托管在https://plugins.gradle.org/</span></span><br><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">'org.springframework.boot'</span> version <span class="string">'2.7.5'</span></span><br><span class="line">    id <span class="string">'java'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>用户自定义插件</strong></p><blockquote><p>参考地址：<a href="https://docs.gradle.org/current/userguide/custom_plugins.html" target="_blank" rel="noopener" title="https://docs.gradle.org/current/userguide/custom_plugins.html">https://docs.gradle.org/current/userguide/custom_plugins.html</a></p></blockquote><p>我们直接执行hello 任务./gradle hello 即可,这种方式实现的插件我们一般不使用，因为这种方式局限性太强，只能本Project，而其他的Project 不能使用</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">GreetingPluginExtension</span> &#123;</span></span><br><span class="line">    Property&lt;String&gt; getMessage()</span><br><span class="line">    Property&lt;String&gt; getGreeter()</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreetingPlugin</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; &#123;</span></span><br><span class="line">    <span class="keyword">void</span> apply(Project project) &#123;</span><br><span class="line">        <span class="keyword">def</span> extension = project.extensions.create(<span class="string">'greeting'</span>, GreetingPluginExtension)</span><br><span class="line">        project.task(<span class="string">'hello'</span>) &#123;</span><br><span class="line">            doLast &#123;</span><br><span class="line">                println <span class="string">"$&#123;extension.message.get()&#125; from $&#123;extension.greeter.get()&#125;"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">apply <span class="string">plugin:</span> GreetingPlugin</span><br><span class="line"><span class="comment">// Configure the extension using a DSL block</span></span><br><span class="line">greeting &#123;</span><br><span class="line">    message = <span class="string">'Hi'</span></span><br><span class="line">    greeter = <span class="string">'Gradle'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3-buildSrc-项目">6.3 buildSrc 项目</h3><p><strong>buildSrc 是Gradle 默认的插件目录</strong>，编译 Gradle 的时候会自动识别这个目录，将其中的代码编译为插件。</p><ul><li><p>首先先建立一个名为** buildSrc 的 java Module**，将 buildSrc 从 included modules 移除，重新构建，然后只保留 <strong>build.gradle</strong>和src/main 目录，其他全部删掉，注意名字一定是 buildSrc，不然会找不到插件</p></li><li><p>然后修改<code>build.gradle</code>中的内容</p></li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'groovy'</span> <span class="comment">//必须</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'maven-publish'</span></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation gradleApi() <span class="comment">//必须</span></span><br><span class="line">    implementation localGroovy() <span class="comment">//必须</span></span><br><span class="line">&#125;</span><br><span class="line">repositories &#123;</span><br><span class="line">    google()</span><br><span class="line">    jcenter()</span><br><span class="line">    mavenCentral() <span class="comment">//必须</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把项目入口设置为src/main/groovy</span></span><br><span class="line">sourceSets &#123;</span><br><span class="line">    main &#123;</span><br><span class="line">        groovy &#123;</span><br><span class="line">            srcDir <span class="string">'src/main/groovy'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后实现插件代码Text.groovy，注意文件后缀为groovy，文件要引入package com.atguigu</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.gradle.api.Plugin</span><br><span class="line"><span class="keyword">import</span> org.gradle.api.Project</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Text</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; &#123;</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> apply(Project project) &#123;</span><br><span class="line">        project.task(<span class="string">"atguigu"</span>) &#123;</span><br><span class="line">            doLast &#123;</span><br><span class="line">                println(<span class="string">"自定义atguigu插件"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来在main 目录下创建resources 目录，在<strong>resources <strong>目录下创建META-INF 目录，在META-INF 目录下创建gradle-plugins 目录，在gradle-plugins 目录下创建</strong>properties <strong>文件，properties 文件可以自己命名，但是</strong>要以.properties 结尾</strong>，比如<code>com.atguigu.plugin.properties</code>，其com.atguigu.plugin 就是自定义的包名路径</p><p>最后需要<strong>在properties 文件中指明我们实现插件的全类名implementation-class=com.atguigu.Text</strong>；然后在module 引入我们写的插件<code>apply plugin:'com.atguigu.plugin'</code>，然后执行插件的任务<code>./gradle atguigu</code></p><p><strong>如果想给其他工程使用，可以上传maven</strong></p><ul><li><p>首先将上述buildSrc 目录复制一份，修改文件夹名，然后在settings.gradle 文件中使用include 引入</p></li><li><p>修改build.gradle 文件，发布到maven 仓库中</p></li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'groovy'</span> <span class="comment">//必须</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'maven-publish'</span></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation gradleApi() <span class="comment">//必须</span></span><br><span class="line">    implementation localGroovy() <span class="comment">//必须</span></span><br><span class="line">&#125;</span><br><span class="line">repositories &#123;</span><br><span class="line">    google()</span><br><span class="line">    jcenter()</span><br><span class="line">    mavenCentral() <span class="comment">//必须</span></span><br><span class="line">&#125;</span><br><span class="line">sourceSets &#123; <span class="comment">//把项目入口设置为src/main/groovy</span></span><br><span class="line">    main &#123;</span><br><span class="line">        groovy &#123;</span><br><span class="line">            srcDir <span class="string">'src/main/groovy'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">publishing &#123;</span><br><span class="line">    publications &#123;</span><br><span class="line">        myLibrary(MavenPublication) &#123;</span><br><span class="line">            groupId = <span class="string">'com.atguigu.plugin'</span> <span class="comment">//指定GAV坐标信息</span></span><br><span class="line">            artifactId = <span class="string">'library'</span></span><br><span class="line">            version = <span class="string">'1.1'</span></span><br><span class="line">            from components.java<span class="comment">//发布jar包</span></span><br><span class="line"><span class="comment">//from components.web///引入war插件，发布war包</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven &#123; url <span class="string">"$rootDir/lib/release"</span> &#125;</span><br><span class="line"><span class="comment">//发布项目到私服中</span></span><br><span class="line"><span class="comment">// maven &#123;</span></span><br><span class="line"><span class="comment">// name = 'myRepo' //name属性可选,表示仓库名称，url必填</span></span><br><span class="line"><span class="comment">// //发布地址:可以是本地仓库或者maven私服</span></span><br><span class="line"><span class="comment">// //url = layout.buildDirectory.dir("repo")</span></span><br><span class="line"><span class="comment">// //url='http://my.org/repo'</span></span><br><span class="line"><span class="comment">// // change URLs to point to your repos, e.g. http://my.org/repo</span></span><br><span class="line"><span class="comment">// //认证信息:用户名和密码</span></span><br><span class="line"><span class="comment">// credentials &#123;</span></span><br><span class="line"><span class="comment">// username = 'joe'</span></span><br><span class="line"><span class="comment">// password = 'secret'</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>执行publish 指令,发布到根project 或者maven 私服仓库（这里发布到了本地）</p></li><li><p>使用插件,在项目级build.gradle 文件中将插件添加到classpath：</p></li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven &#123; url <span class="string">"$rootDir/lib/release"</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath <span class="string">"com.atguigu.plugin:library:1.1"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'java'</span></span><br><span class="line"><span class="comment">//是在atguiguplugin 中定义的插件ID</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'com.atguigu.plugin'</span></span><br></pre></td></tr></table></figure><ul><li>执行<code>gradle build</code> 指令就会在控制台看到自定义插件的输出，说明自定义插件就已经生效了</li></ul><h3 id="6-4-插件常用属性">6.4 插件常用属性</h3><p>参考官网：<a href="https://docs.gradle.org/current/userguide/plugin_reference.html" target="_blank" rel="noopener" title="https://docs.gradle.org/current/userguide/plugin_reference.html">https://docs.gradle.org/current/userguide/plugin_reference.html</a></p><p><img src="https://img-blog.csdnimg.cn/b60546ea76ab41a3b9e23dd5943cde4c.png#pic_center" alt="在这里插入图片描述"></p><h2 id="7、build-gradle-文件">7、build.gradle 文件</h2><ul><li><p>build.gradle 是一个gradle 的构建脚本文件，支持java、groovy 等语言</p></li><li><p>每个project 都会有一个build.gradle 文件，该文件是项目构建的入口，可配置版本、插件、依赖库等信息</p></li><li><p>每个build 文件都有一个对应的 Project 实例，对build.gradle 文件配置，本质就是设置Project 实例的属性和方法</p></li><li><p>由于每个 project 都会有一个build 文件，那么Root Project 也不列外。Root Project 可以获取到所有 Child Project，所以在Root Project 的 build 文件中我们可以对Child Project 统一配置，比如应用的插件、依赖的maven 中心仓库等。</p></li></ul><p><img src="https://img-blog.csdnimg.cn/d4b85b16274e4f3b927f1c2e1c5c74a2.png#pic_center" alt="在这里插入图片描述"></p><h3 id="7-1-常见属性代码">7.1 常见属性代码</h3><ul><li><p>group+name+version 类似于 maven 的group+artifactId+version  </p></li><li><p>encoding 解决业务代码与测试代码中文乱码问题</p></li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定使用什么版本的JDK语法编译源代码,跟编译环境有关,在有java插件时才能用</span></span><br><span class="line">sourceCompatibility = <span class="number">1.8</span></span><br><span class="line"><span class="comment">//指定生成特定于某个JDK版本的class文件:跟运行环境有关,在有java插件时才能用</span></span><br><span class="line">targetCompatibility = <span class="number">1.8</span></span><br><span class="line"><span class="comment">//业务编码字符集,注意这是指定源码解码的字符集[编译器]</span></span><br><span class="line">compileJava.options.encoding <span class="string">"UTF-8"</span></span><br><span class="line"><span class="comment">//测试编码字符集,注意这是指定源码解码的字符集[编译器]</span></span><br><span class="line">compileTestJava.options.encoding <span class="string">"UTF-8"</span></span><br><span class="line"><span class="comment">//编译JAVA文件时采用UTF-8:注意这是指定源码编码的字符集【源文件】</span></span><br><span class="line">tasks.withType(JavaCompile) &#123;</span><br><span class="line">    options.encoding = <span class="string">"UTF-8"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编译JAVA文件时采用UTF-8:注意这是指定文档编码的字符集【源文件】</span></span><br><span class="line">tasks.withType(Javadoc) &#123;</span><br><span class="line">    options.encoding = <span class="string">"UTF-8"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-2-Repositories">7.2 Repositories</h3><p>Gradle 没有自己的远程仓库，而是使用Maven、jcenter、jvy、google 这些远程仓库</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    <span class="comment">//gradle中会按着仓库配置的顺序，从上往下依次去对应的仓库中找所需要的jar包:</span></span><br><span class="line">    <span class="comment">//如果找到，则停止向下搜索，如果找不到，继续在下面的仓库中查找</span></span><br><span class="line">    <span class="comment">//指定去本地某个磁盘目录中查找:使用本地file文件协议:一般不用这种方式</span></span><br><span class="line">    maven &#123; url <span class="string">'file:///D:/repos/mavenrepos3.5.4'</span>&#125; maven &#123; url <span class="string">"$rootDir/lib/release"</span> &#125;</span><br><span class="line">    <span class="comment">//指定去maven的本地仓库查找</span></span><br><span class="line">    mavenLocal()</span><br><span class="line">    <span class="comment">//指定去maven的私服或者第三方镜像仓库查找</span></span><br><span class="line">    maven &#123; name <span class="string">"Alibaba"</span> ; url <span class="string">"https://maven.aliyun.com/repository/public"</span> &#125; maven &#123; name <span class="string">"Bstek"</span> ; url <span class="string">"https://nexus.bsdn.org/content/groups/public/"</span> &#125;</span><br><span class="line">    <span class="comment">//指定去maven的远程仓库查找:即 https://repo.maven.apache.org/maven2/</span></span><br><span class="line">    mavenCentral()</span><br><span class="line">    <span class="comment">//去google仓库查找google()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-3-Subprojects-与-Allprojects">7.3 Subprojects 与 Allprojects</h3><p>**allprojects <strong>是对所有project(<strong>包括Root Project+ child Project[当前工程和所有子工程]</strong>)的进行统一配置，而</strong>subprojects  **是对所有Child Project 的进行统一配置</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    tasks.create(<span class="string">'hello'</span>) &#123;</span><br><span class="line">        doLast &#123;</span><br><span class="line">            task -&gt;</span><br><span class="line">                println <span class="string">"project name is $task.project.name"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">subprojects &#123;</span><br><span class="line">    hello.doLast&#123;</span><br><span class="line">        task-&gt;</span><br><span class="line">            println <span class="string">"here is subprojects $task.project.name"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在对单个Project 进行单独配置</span></span><br><span class="line">project(<span class="string">'subject01'</span>) &#123;</span><br><span class="line">    task subject01 &#123;</span><br><span class="line">        doLast &#123;</span><br><span class="line">            println <span class="string">'for subject01'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-4-ext-用户自定义属性">7.4 ext 用户自定义属性</h3><blockquote><p>详细请参考：<a href="https://docs.gradle.org/current/userguide/build_environment.html#sec:gradle_configuration_properties" target="_blank" rel="noopener" title="https://docs.gradle.org/current/userguide/build_environment.html#sec:gradle_configuration_properties">https://docs.gradle.org/current/userguide/build_environment.html#sec:gradle_configuration_properties</a></p></blockquote><p>Project 和Task 都允许用户添加额外的自定义属性，要添加额外的属性，通过应用所属对象的ext 属性即可实现。添加之后可以通过ext 属性对自定义属性读取和设置，如果要同时添加多个自定义属性,可以通过ext 代码块</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义一个Project的属性</span></span><br><span class="line">ext.age = <span class="number">18</span></span><br><span class="line"><span class="comment">//通过代码块同时自定义多个属性</span></span><br><span class="line">ext &#123;</span><br><span class="line">    phone = <span class="number">19292883833</span></span><br><span class="line">    address=<span class="string">"北京尚硅谷"</span></span><br><span class="line">&#125;</span><br><span class="line">task extCustomProperty &#123;</span><br><span class="line"><span class="comment">//在task中自定义属性</span></span><br><span class="line">    ext &#123;</span><br><span class="line">        desc = <span class="string">"奥利给"</span></span><br><span class="line">    &#125;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="string">"年龄是：$&#123;age&#125;"</span></span><br><span class="line">        println <span class="string">"电话是：$&#123;phone&#125;"</span></span><br><span class="line">        println <span class="string">"地址是：$&#123;address&#125;"</span></span><br><span class="line">        println <span class="string">"尚硅谷：$&#123;desc&#125;"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ext 配置的是用户自定义属性，而gradle.properties 中一般定义系统属性、环境变量、项目属性、JVM 相关配置信息。例如gradle.properties 文件案例：加快构建速度的，gradle.properties 文件中的属性会自动在项目运行时加载。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">## 设置此参数主要是编译下载包会占用大量的内存，可能会内存溢出</span><br><span class="line">org.gradle.jvmargs=-Xms4096m -Xmx8192m</span><br><span class="line">## 开启gradle缓存</span><br><span class="line">org.gradle.caching=<span class="literal">true</span></span><br><span class="line">#开启并行编译</span><br><span class="line">org.gradle.parallel=<span class="literal">true</span></span><br><span class="line">#启用新的孵化模式</span><br><span class="line">org.gradle.configureondemand=<span class="literal">true</span></span><br><span class="line">#开启守护进程</span><br><span class="line">org.gradle.daemon=<span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="7-5-Buildscript">7.5 Buildscript</h3><p>buildscript 里是gradle 脚本执行所需依赖，分别是对应的 maven 库和插件</p><ul><li><p><strong>buildscript{}必须在build.gradle 文件的最前端</strong></p></li><li><p>对于多项目构建，项目的buildscript ()方法声明的依赖关系可用于其所有子项目的构建脚本</p></li><li><p>构建脚本依赖可能是Gradle 插件</p></li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.codec.binary.Base64</span><br><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath <span class="string">group:</span> <span class="string">'commons-codec'</span>, <span class="string">name:</span> <span class="string">'commons-codec'</span>, <span class="string">version:</span> <span class="string">'1.2'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">tasks.register(<span class="string">'encode'</span>) &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        <span class="keyword">def</span> <span class="keyword">byte</span>[] encodedString = <span class="keyword">new</span> Base64().encode(<span class="string">'hello world\n'</span>.getBytes())</span><br><span class="line">        println <span class="keyword">new</span> String(encodedString)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//老式apply插件的引用方式,使用apply+buildscript</span></span><br><span class="line">buildscript &#123;</span><br><span class="line">    ext &#123;</span><br><span class="line">        springBootVersion = <span class="string">"2.3.3.RELEASE"</span></span><br><span class="line">    &#125;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenLocal()</span><br><span class="line">        maven &#123; url <span class="string">'http://maven.aliyun.com/nexus/content/groups/public'</span> &#125;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//此处引入插件</span></span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath(<span class="string">"org.springframework.boot:spring-boot-gradle-plugin:$&#123;springBootVersion&#125;"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'java'</span> <span class="comment">//核心插件，无需事先引入</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'org.springframework.boot'</span> <span class="comment">//社区插件，需要事先引入,才能应用，不必写版本号</span></span><br></pre></td></tr></table></figure><h2 id="8、项目发布">8、项目发布</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">'java-library'</span> <span class="comment">//如果发布war包，需要war插件,java-library支持带源码、文档发布</span></span><br><span class="line">    id <span class="string">'maven-publish'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//带源码和javadoc的发布:需要'java-library'插件支持:它是java的升级版，java插件的功能java-library都有</span></span><br><span class="line"><span class="comment">//javadoc.options.encoding="UTF-8"</span></span><br><span class="line"><span class="comment">//java &#123;</span></span><br><span class="line"><span class="comment">// withJavadocJar()</span></span><br><span class="line"><span class="comment">// withSourcesJar()</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">publishing &#123;</span><br><span class="line">    publications &#123;</span><br><span class="line">        myLibrary(MavenPublication) &#123;</span><br><span class="line">            groupId = <span class="string">'org.gradle.sample'</span> <span class="comment">//指定GAV坐标信息</span></span><br><span class="line">            artifactId = <span class="string">'library'</span></span><br><span class="line">            version = <span class="string">'1.1'</span></span><br><span class="line">            from components.java<span class="comment">//发布jar包</span></span><br><span class="line">             <span class="comment">//from components.web///引入war插件，发布war包</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        <span class="comment">//本地仓库位于USER_HOME/.m2/repository</span></span><br><span class="line">        mavenLocal()</span><br><span class="line">        <span class="comment">//发布项目到私服中</span></span><br><span class="line">        maven &#123;</span><br><span class="line">            name = <span class="string">'myRepo'</span> <span class="comment">//name属性可选,表示仓库名称，url必填</span></span><br><span class="line">            <span class="comment">//发布地址:可以是本地仓库或者maven私服</span></span><br><span class="line">            <span class="comment">//url = layout.buildDirectory.dir("repo")</span></span><br><span class="line">            <span class="comment">// change URLs to point to your repos, e.g. http://my.org/repo</span></span><br><span class="line">            <span class="keyword">def</span> releasesRepoUrl = layout.buildDirectory.dir(<span class="string">'repos/releases'</span>)</span><br><span class="line">            <span class="keyword">def</span> snapshotsRepoUrl = layout.buildDirectory.dir(<span class="string">'repos/snapshots'</span>)</span><br><span class="line">            url = version.endsWith(<span class="string">'SNAPSHOT'</span>) ? snapshotsRepoUrl : releasesRepoUrl</span><br><span class="line">            <span class="comment">//认证信息:用户名和密码</span></span><br><span class="line">            <span class="comment">// credentials &#123;</span></span><br><span class="line">            <span class="comment">// username = 'joe'</span></span><br><span class="line">            <span class="comment">// password = 'secret'</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行发布命令，将项目发布到本地仓库或者远程仓库。<strong>常见的发布指令</strong>有：</p><ul><li><p>generatePomFileForPubNamePublication: 生成pom 文件</p></li><li><p>publishPubNamePublicationToRepoNameRepository:发布项目到指定仓库,如果没有仓库名，默认为maven</p></li><li><p>publishPubNamePublicationToMavenLocal: 将PubName 发布复制到本地Maven 仓库中包括POM 文件和其他元数据。</p></li><li><p>publish: 发布到repositories 中指定的仓库(为比如Maven 私服)</p></li><li><p>publishToMavenLocal: 执行所有发布任务中的操作发布到本地maven 仓库【默认在用户家目录下的.m2/repository】</p></li></ul><h2 id="9、生命周期中Hook">9、生命周期中Hook</h2><h3 id="9-1-生命周期详细介绍">9.1 生命周期详细介绍</h3><p><img src="https://img-blog.csdnimg.cn/da28922ef82f48c58f3d8d0b965e1c12.jpeg#pic_center" alt="在这里插入图片描述"></p><p><strong>Gradle 初始化阶段</strong></p><ul><li><p>在<code>settings.gradle</code> 执行完后,会回调Gradle 对象的<code>settingsEvaluated</code> 方法</p></li><li><p>在构建所有工程build.gradle 对应的Project 对象后,也既初始化阶段完毕,会回调Gradle 对象的projectsLoaded 方法</p></li></ul><p><strong>Gradle 配置阶段</strong></p><ul><li><p>Gradle 会循环执行每个工程的build.gradle 脚本文件</p></li><li><p>在执行当前工程<code>build.gradle</code> 前，会回调Gradle 对象的<code>beforeProject </code>方法和当前Project 对象的<code>beforeEvaluate </code>方法，虽然beforeEvalute 属于project 的生命周期, 但是此时build script 尚未被加载， 所以<code>beforeEvaluate </code>的设置依然要在init script 或setting script 中进行，不要在build script 中使用<code>project.beforeEvaluate</code> 方法。</p></li><li><p>在执行当前工程build.gradle 后，会回调Gradle 对象的<code>afterProject </code>方法和当前Project 对象的afterEvaluate 方法</p></li><li><p>在所有工程的<code>build.gradle</code> 执行完毕后，会回调Gradle 对象的<code>projectsEvaluated </code>方法</p></li><li><p>在构建Task 依赖有向无环图后,也就是配置阶段完毕,会回调<code>TaskExecutionGraph </code>对象的<code>whenReady </code>方法</p></li></ul><p><strong>Gradle 执行阶段</strong></p><ul><li><p>Gradle 会循环执行Task 及其依赖的Task</p></li><li><p>在当前Task 执行之前,会回调<code>TaskExecutionGraph </code>对象的<code>beforeTask </code>方法</p></li><li><p>在当前Task 执行之后,会回调<code>TaskExecutionGraph </code>对象的<code>afterTask </code>方法</p></li></ul><p>当所有的Task 执行完毕后，会回调Gradle 对象的<code>buildFinish</code> 方法。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">gradle.settingsEvaluated &#123; <span class="comment">//1.settingsEvaluated钩子函数,在初始化阶段完成</span></span><br><span class="line">    println <span class="string">"settingsEvaluated"</span></span><br><span class="line">&#125;</span><br><span class="line">gradle.projectsLoaded &#123; <span class="comment">//2.projectsLoaded钩子函数,在初始化阶段完成</span></span><br><span class="line">    println <span class="string">"projectsLoaded"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//声明一个变量：表示当前项目名,在每次执行某个项目的beforeEvaluate方法时先给projectName变量赋值</span></span><br><span class="line"><span class="comment">//这样方便在：gradle.beforeProject和afterProject两个钩子函数使用。</span></span><br><span class="line"><span class="keyword">def</span> projectName=<span class="string">""</span></span><br><span class="line">gradle.addProjectEvaluationListener( <span class="keyword">new</span> ProjectEvaluationListener()&#123;</span><br><span class="line"><span class="comment">//3.执行各个project的beforeEvaluate：在配置阶段完成</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> beforeEvaluate(Project project) &#123;</span><br><span class="line">        projectName=project.name</span><br><span class="line">        println <span class="string">"$&#123;project.name&#125; Project beforeEvaluate"</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//5.执行各个project的afterEvaluate：在配置阶段完成</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> afterEvaluate(Project project, ProjectState projectState) &#123;</span><br><span class="line">        println <span class="string">"$&#123;project.name&#125; Project afterEvaluate"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">gradle.beforeProject &#123;<span class="comment">//4.执行各个project的beforeProject：在配置阶段完成</span></span><br><span class="line">    println <span class="string">"$&#123;projectName&#125; beforeProject..."</span></span><br><span class="line">&#125;</span><br><span class="line">gradle.afterProject &#123;<span class="comment">//6.执行各个project的afterProject：在配置阶段完成</span></span><br><span class="line">    println <span class="string">"$&#123;projectName&#125; afterProject..."</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//7.所有工程的build.gradle 执行完毕后，回调Gradle 对象的projectsEvaluated 方法：在配置阶段完成</span></span><br><span class="line"><span class="keyword">def</span> rootProjectName=rootProject.getName()</span><br><span class="line">gradle.projectsEvaluated &#123;</span><br><span class="line">    println <span class="string">"$&#123;rootProjectName&#125; projectsEvaluated..."</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//8.配置阶段完毕后，回调TaskExecutionGraph 对象的whenReady 方法：在配置阶段完成</span></span><br><span class="line">gradle.taskGraph.whenReady &#123;</span><br><span class="line">    println <span class="string">"$&#123;rootProjectName&#125; taskGraph whenReady..."</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//9.在当前Task执行之前,会回调TaskExecutionGraph 对象的beforeTask方法：在执行阶段完成</span></span><br><span class="line">gradle.taskGraph.beforeTask &#123;task -&gt;</span><br><span class="line">    println <span class="string">"this is the task $&#123;task.name&#125; of the project $&#123;task.getProject().name&#125; beforeTask.."</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//10.在当前Task执行之后,会回调TaskExecutionGraph 对象的afterTask方法：在执行阶段完成</span></span><br><span class="line">gradle.taskGraph.afterTask &#123;task -&gt;</span><br><span class="line">    println <span class="string">"this is the task $&#123;task.name&#125; of the project $&#123;task.getProject().name&#125; afterTask.."</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//11.当所有的Task 执行完毕后，会回调Gradle 对象的buildFinish 方法：在执行阶段完成</span></span><br><span class="line">gradle.buildFinished &#123;</span><br><span class="line">    println <span class="string">"$&#123;rootProjectName&#125; buildFinished..."</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-2-生命周期扩展">9.2 生命周期扩展</h3><p>在<code>settings.gradle</code> 中添加监听器，查看task 有向无环图</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">gradle.taskGraph.addTaskExecutionGraphListener(<span class="keyword">new</span> TaskExecutionGraphListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//生成有向无环图</span></span><br><span class="line">    <span class="keyword">void</span> graphPopulated(TaskExecutionGraph taskExecutionGraph) &#123;</span><br><span class="line">        taskExecutionGraph.allTasks.forEach(task-&gt;&#123;<span class="comment">//核心逻辑:通过taskExecutionGraph获得所有的task</span></span><br><span class="line">            taskExecutionGraph.allTasks.forEach(releaseTask-&gt;&#123;</span><br><span class="line">                println <span class="string">"尚硅谷:"</span> + releaseTask.getProject().name + <span class="string">":"</span> + releaseTask.name</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>计算Gradle 构建过程中各个阶段的耗时</strong>:需要注意，这里只是计算了初始化阶段的<code>settings 文件</code>，并没有计算<code>init.gradle</code> 初始化的时间</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> projectName=rootProject.getName() <span class="comment">//定义项目名</span></span><br><span class="line"><span class="keyword">long</span> beginOfSetting = System.currentTimeMillis() <span class="comment">//初始化阶段开始时间</span></span><br><span class="line"><span class="keyword">def</span> beginOfConfig <span class="comment">//配置阶段开始时间</span></span><br><span class="line"><span class="keyword">def</span> configHasBegin = <span class="literal">false</span> <span class="comment">//配置阶段是否开始了，只执行一次</span></span><br><span class="line"><span class="keyword">def</span> beginOfProjectConfig = <span class="keyword">new</span> HashMap() <span class="comment">//存放每个build.gradle 执行之前的时间</span></span><br><span class="line"><span class="keyword">def</span> beginOfTaskExecute <span class="comment">//执行阶段开始时间</span></span><br><span class="line">gradle.projectsLoaded &#123; <span class="comment">//初始化阶段执行完毕</span></span><br><span class="line">    println <span class="string">"$&#123;projectName&#125;工程初始化总耗时$&#123;System.currentTimeMillis() - beginOfSetting&#125; ms"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//build.gradle 执行前</span></span><br><span class="line">gradle.beforeProject &#123;Project project -&gt;</span><br><span class="line">    <span class="keyword">if</span>(!configHasBegin)&#123;</span><br><span class="line">        configHasBegin = <span class="literal">true</span></span><br><span class="line">        beginOfConfig = System.currentTimeMillis()</span><br><span class="line">    &#125;</span><br><span class="line">    beginOfProjectConfig.put(project,System.currentTimeMillis())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//build.gradle 执行后</span></span><br><span class="line">gradle.afterProject &#123;Project project -&gt;</span><br><span class="line">    <span class="keyword">def</span> begin = beginOfProjectConfig.get(project)</span><br><span class="line">    <span class="keyword">if</span>(project.name == projectName) &#123;</span><br><span class="line">        println <span class="string">"根工程$&#123;projectName&#125; 配置阶段耗时：$&#123;System.currentTimeMillis() - begin&#125; ms"</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        println <span class="string">"子工程$&#123;project.name&#125; 配置阶段耗时：$&#123;System.currentTimeMillis() - begin&#125; ms"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">gradle.taskGraph.whenReady &#123;<span class="comment">//配置阶段完毕</span></span><br><span class="line">    println <span class="string">"整个$&#123;projectName&#125;项目在配置阶段总耗时：$&#123;System.currentTimeMillis() - beginOfConfig&#125; ms"</span></span><br><span class="line">    beginOfTaskExecute = System.currentTimeMillis()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行阶段开始</span></span><br><span class="line">gradle.taskGraph.beforeTask &#123;Task task -&gt;</span><br><span class="line">    task.doFirst &#123;</span><br><span class="line">        task.ext.beginOfTask = System.currentTimeMillis()</span><br><span class="line">    &#125;</span><br><span class="line">    task.doLast &#123;</span><br><span class="line">        println <span class="string">"$&#123;task.name&#125;在执行阶段耗时：$&#123;System.currentTimeMillis() - task.ext.beginOfTask&#125; ms"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">gradle.buildFinished &#123;<span class="comment">//执行阶段完毕</span></span><br><span class="line">    println <span class="string">" 执行阶段总耗时：$&#123;System.currentTimeMillis() - beginOfTaskExecute&#125; ms"</span></span><br><span class="line">    println <span class="string">" 整个构建过程耗时：$&#123;System.currentTimeMillis() - beginOfSetting&#125; ms"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>四、Spring项目相关</h1><h2 id="1、Springboot-项目创建">1、Springboot 项目创建</h2><blockquote><p>Spring Boot Gradle 插件在Gradle 提供Spring Boot 支持。它允许您打包可执行jar 或war 归档文件，运行Spring。参考：<a href="https://docs.spring.io/spring-boot/docs/current/gradle-plugin/reference/htmlsingle/#getting-started" target="_blank" rel="noopener" title="https://docs.spring.io/spring-boot/docs/current/gradle-plugin/reference/htmlsingle/#getting-started">https://docs.spring.io/spring-boot/docs/current/gradle-plugin/reference/htmlsingle/#getting-started</a></p></blockquote><h3 id="1-1-引入springboot-插件">1.1 引入springboot 插件</h3><p>创建SpringBoot项目，选择gradle和groovy，完成后配置本地gradle，然后进行依赖引入(<strong>用Spring Boot脚手架会直接配置好，推荐</strong>)</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    <span class="comment">//维护springboot版本号,不单独使用,和下面两个插件一起用</span></span><br><span class="line">    id <span class="string">'org.springframework.boot'</span> version <span class="string">'2.3.7.RELEASE'</span> </span><br><span class="line">    <span class="comment">// 统一管理版本号，下面依赖就不需要写版本了</span></span><br><span class="line">    id <span class="string">'io.spring.dependency-management'</span> version <span class="string">'1.0.10.RELEASE'</span></span><br><span class="line">    <span class="comment">//进行依赖管理,在引入其它boot依赖时省略版本号、解决jar包冲突问题</span></span><br><span class="line">    id <span class="string">'java'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">'org.springframework.boot:spring-boot-starter'</span></span><br><span class="line">    implementation <span class="string">'org.springframework.boot:spring-boot-starter-web'</span> <span class="comment">//省略版本,原生bom支持,插件management提供</span></span><br><span class="line">    testImplementation(<span class="string">'org.springframework.boot:spring-boot-starter-test'</span>) &#123;</span><br><span class="line">        exclude <span class="string">group:</span> <span class="string">'org.junit.vintage'</span>, <span class="string">module:</span> <span class="string">'junit-vintage-engine'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">test &#123;</span><br><span class="line">    useJUnitPlatform()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-程序运行与打包">1.2 程序运行与打包</h3><p>要想运行当前Springboot 项目，直接执行<code>gradle bootRun</code> 指令或者<code>idea 右侧按钮即可</code>。当然如果想让当前项目打成可执行jar 包，只需执行： <code>gradle bootJar</code> 指令即可。</p><p>Cloud 项目创建也可以借助于脚手架创建，与Boot 项目类似。</p><h3 id="1-3-拓展spring-boot-gradle-plugin-插件">1.3 拓展spring-boot-gradle-plugin 插件</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven &#123; url <span class="string">'https://maven.aliyun.com/repository/public'</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath <span class="string">'org.springframework.boot:spring-boot-gradle-plugin:2.4.1'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这样就不用自己管理版本号了</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'org.springframework.boot'</span></span><br></pre></td></tr></table></figure><h3 id="1-4-全局属性管理">1.4 全局属性管理</h3><p>有时我们在 gradle 里定义了一些<strong>全局属性</strong>，想在 springboot 的 <strong>application 配置文件</strong>里使用，甚至可以给多个模块公用一个全局属性</p><p>首先在根目录<code>build.gradle</code>进行配置，首先需要暴露属性</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 gradle 的配置应用于yml配置文件</span></span><br><span class="line">processResources &#123;</span><br><span class="line">    filesMatching(<span class="string">'application.yml'</span>) &#123;</span><br><span class="line">        expand(project.properties)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 gradle 的配置应用于所有 springboot 配置文件</span></span><br><span class="line">processResources &#123;</span><br><span class="line">    expand(project.properties)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在根目录创建例如<strong>gradle.properties</strong></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">author=shawn</span><br><span class="line">age=<span class="number">18</span></span><br></pre></td></tr></table></figure><p>最后在项目的application引入即可，banner也可以按此方法引入</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">info:</span></span><br><span class="line">  <span class="attr">mine:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">$&#123;author&#125;</span></span><br><span class="line">    <span class="attr">age:</span> <span class="string">$&#123;age&#125;</span></span><br></pre></td></tr></table></figure><h2 id="2、Spring聚合项目">2、Spring聚合项目</h2><blockquote><p>参考Maven聚合项目：<a href="https://blog.csdn.net/lemon_TT/article/details/119654251" target="_blank" rel="noopener" title="SpringBoot聚合项目创建、打包与多环境">SpringBoot聚合项目创建、打包与多环境</a><br>官方参考：<a href="https://docs.spring.io/spring-boot/docs/current/gradle-plugin/reference/htmlsingle/" target="_blank" rel="noopener" title="https://docs.spring.io/spring-boot/docs/current/gradle-plugin/reference/htmlsingle/">https://docs.spring.io/spring-boot/docs/current/gradle-plugin/reference/htmlsingle/</a></p></blockquote><h3 id="2-1-环境与依赖">2.1 环境与依赖</h3><p>本次的微服务结构如下所示，当然也有另一种即消费者和生产者分开单独成一个微服务。创建父工程时选择<code>Spring Initializer</code>脚手架，选择Gradle类型，填写好对于信息，同时删除src等其他非必须文件，然后进入Settings设置全局gradle配置(每次新建都要配置一下)；之后在创建子模块时可以直接选择<strong>新建Gradle</strong>，选择Java语言以及父目录</p><p><img src="https://img-blog.csdnimg.cn/56594942479b4d458109ee892ba4b9d5.png#pic_center" alt="在这里插入图片描述"></p><ul><li><p>microservice-parent： 统一管理所有模块的 jar 包版本信息  </p></li><li><p>microservice-bean： 统一管理所有模块的用到的 pojo 类  </p></li><li><p>microservice-common：统一管理所有模块的用到的工具类、枚举类、异常处理、日志文件、统一返回结果信息</p></li><li><p>microservice-service: 统一封装所有的微服务  </p></li><li><p>microservice-gateway: 封装网关信息</p></li></ul><h3 id="2-2-父工程相关目录">2.2 父工程相关目录</h3><p>首先关注<code>settings.gradle</code>文件，该文件一个项目只能存在一个，用于配置项目的父子关系</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">rootProject.name = <span class="string">'microservice'</span></span><br><span class="line">include <span class="string">'microservice_bean'</span></span><br><span class="line">include <span class="string">'microservice_common'</span></span><br><span class="line">include <span class="string">'microservice_gateway'</span></span><br><span class="line">include <span class="string">'microservice_service'</span></span><br><span class="line">include <span class="string">'microservice_service:service_user'</span></span><br><span class="line"><span class="comment">// 可以设置别名</span></span><br><span class="line">findProject(<span class="string">':microservice_service:service_user'</span>)?.name = 'service_user'</span><br><span class="line">include 'microservice_service:service_order<span class="string">'</span></span><br><span class="line"><span class="string">findProject('</span>:<span class="string">microservice_service:</span>service_order<span class="string">')?.name = '</span>service_order<span class="string">'</span></span><br></pre></td></tr></table></figure><p>然后在根目录创建version.gradle文件，用户自定义用户属性和版本号</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 依赖版本管理</span></span><br><span class="line">ext &#123;</span><br><span class="line">    version = [</span><br><span class="line">            <span class="string">"fastjsonVersion"</span>   : <span class="string">"1.2.72"</span>,</span><br><span class="line">            <span class="string">"mybatisPlus"</span> : <span class="string">"3.0.5"</span>,</span><br><span class="line">            <span class="string">"mysql"</span> : <span class="string">"5.1.46"</span>,</span><br><span class="line">            <span class="string">"swaggerVersion"</span>: <span class="string">"2.7.0"</span>,</span><br><span class="line">            <span class="string">"jjwtVersion"</span>: <span class="string">"0.7.0"</span></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    dependencies = [</span><br><span class="line">            <span class="string">"fastjson"</span>                      : <span class="string">"com.alibaba:fastjson:$&#123;version.fastjsonVersion&#125;"</span>,</span><br><span class="line">            <span class="string">"mybatis-plus-boot-starter"</span>     : <span class="string">"com.baomidou:mybatis-plus-boot-starter:$&#123;version.mybatisPlus&#125;"</span>,</span><br><span class="line">            <span class="string">"mysql"</span>                         : <span class="string">"mysql:mysql-connector-java:$&#123;version.mysql&#125;"</span>,</span><br><span class="line">            <span class="string">"swagger"</span>                       : <span class="string">"io.springfox:springfox-swagger2:$&#123;version.swaggerVersion&#125;"</span>,</span><br><span class="line">            <span class="string">"swaggerUI"</span>                     : <span class="string">"io.springfox:springfox-swagger-ui:$&#123;version.swaggerVersion&#125;"</span>,</span><br><span class="line">            <span class="string">"jjwt"</span>                          : <span class="string">"io.jsonwebtoken:jjwt:$&#123;version.jjwtVersion&#125;"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来<code>build.gradle</code>是父工程的全局配置管理中心，一般在这里设置版本号等信息，然后子工程进行继承，这样子工程就不需要写版本号了。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line">description <span class="string">'gradle微服务实战父工程'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//构建Gradle脚本自身需要的资源，可以声明的资源包括依赖项、第三方插件、maven仓库地址等。</span></span><br><span class="line">buildscript &#123;</span><br><span class="line">    ext &#123;</span><br><span class="line">        <span class="comment">// 自定义扩展 字段 这里定义版本信息</span></span><br><span class="line">        <span class="comment">//定义一个变量，统一规定springboot的版本</span></span><br><span class="line">        springBootVersion = <span class="string">'2.2.1.RELEASE'</span></span><br><span class="line">        springCloudVersion = <span class="string">'Hoxton.RELEASE'</span></span><br><span class="line">        springCloudAlibabaVersion = <span class="string">'0.2.2.RELEASE'</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置仓库</span></span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven &#123; url <span class="string">'https://maven.aliyun.com/nexus/content/groups/public/'</span> &#125;</span><br><span class="line">        maven &#123; url <span class="string">'https://repo.spring.io/milestone'</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath(<span class="string">"org.springframework.boot:spring-boot-gradle-plugin:$&#123;springBootVersion&#125;"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置全局, 包括root项目和子项目</span></span><br><span class="line">allprojects &#123;</span><br><span class="line">    group <span class="string">'com.shawn'</span></span><br><span class="line">    version <span class="string">'1.0-SNAPSHOT'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置编码格式</span></span><br><span class="line">    tasks.withType(JavaCompile) &#123;</span><br><span class="line">        options.encoding = <span class="string">"UTF-8"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置仓库</span></span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenLocal()</span><br><span class="line">        maven &#123; url <span class="string">'https://maven.aliyun.com/nexus/content/groups/public/'</span> &#125;</span><br><span class="line">        maven &#123; url <span class="string">'https://repo.spring.io/milestone'</span>&#125;</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入自定义的用户属性文件</span></span><br><span class="line">apply <span class="string">from:</span> <span class="string">'version.gradle'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//配置所有子项目</span></span><br><span class="line">subprojects &#123;</span><br><span class="line">    <span class="comment">// 使用二进制插件 </span></span><br><span class="line">    apply <span class="string">plugin:</span> <span class="string">'java'</span></span><br><span class="line">    apply <span class="string">plugin:</span> <span class="string">'java-library'</span> <span class="comment">// 可以使用api编译</span></span><br><span class="line">    <span class="comment">//apply plugin: 'idea' // 让Gradle自动生成Intellij的项目文件</span></span><br><span class="line">    <span class="comment">// 依赖管理插件仍然是一个spring-boot-gradle-plugin传递依赖，所以无需在build.gradle配置中明确列出此依赖。</span></span><br><span class="line">    apply <span class="string">plugin:</span> <span class="string">'io.spring.dependency-management'</span> <span class="comment">//依赖管理，用来传递spring的依赖</span></span><br><span class="line"></span><br><span class="line">    sourceCompatibility= JavaVersion.VERSION_1_8</span><br><span class="line">    targetCompatibility=  JavaVersion.VERSION_1_8</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//公用的依赖</span></span><br><span class="line">    dependencies &#123;</span><br><span class="line">        testImplementation <span class="string">'org.junit.jupiter:junit-jupiter-api:5.8.1'</span></span><br><span class="line">        testRuntimeOnly <span class="string">'org.junit.jupiter:junit-jupiter-engine:5.8.1'</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    test &#123;</span><br><span class="line">        useJUnitPlatform()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 可以参考：https://docs.spring.io/spring-boot/docs/current/gradle-plugin/reference/htmlsingle/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认bootJar和bootWar is true</span></span><br><span class="line">    <span class="comment">// jar和war 是false</span></span><br><span class="line">    <span class="comment">// springboot打出的bootJar包  一般是 不能被依赖的</span></span><br><span class="line">    <span class="comment">// 可以参考：https://www.cnblogs.com/karlMa/p/11304524.html</span></span><br><span class="line">    <span class="comment">// 打出来的jar包可以子模块间相互依赖，但经过个人测试后发现不可以被执行</span></span><br><span class="line">    <span class="comment">// 如果不开启的话，后续是会出现模块间找不到依赖的问题！</span></span><br><span class="line">    jar.enabled = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// jar名字带boot</span></span><br><span class="line">    bootJar &#123;</span><br><span class="line">        archiveClassifier = <span class="string">'boot'</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    group = <span class="string">'com.example'</span></span><br><span class="line">    version = <span class="string">'0.0.1-SNAPSHOT'</span> <span class="comment">/* 项目版本,会加在打包文件名中 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// dependencyManagement版本统一管理，类似于父maven的dependencyManagement</span></span><br><span class="line">    <span class="comment">// 此时只是一个依赖管理，并不会导入任何的jar包</span></span><br><span class="line">    <span class="comment">// 子项目需要的时候才会真正导入</span></span><br><span class="line">    dependencyManagement &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 循环导入自定义配置第三方依赖</span></span><br><span class="line">        dependencies &#123;</span><br><span class="line">            <span class="keyword">for</span>(depJar <span class="keyword">in</span> rootProject.ext.dependencies)&#123;</span><br><span class="line">                dependency depJar.value</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 导入SpringBoot和SpringCloud依赖Bom</span></span><br><span class="line">        imports &#123;</span><br><span class="line">            mavenBom <span class="string">"org.springframework.cloud:spring-cloud-dependencies:$&#123;springCloudVersion&#125;"</span></span><br><span class="line">            mavenBom <span class="string">"org.springframework.cloud:spring-cloud-alibaba-dependencies:$&#123;springCloudAlibabaVersion&#125;"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根目录下的xx项目</span></span><br><span class="line">project(<span class="string">':microservice_bean'</span>)&#123;</span><br><span class="line">    description(<span class="string">"微服务实战之bean层:存放表对应的实体类"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">project(<span class="string">":microservice_common"</span>)&#123;</span><br><span class="line">    description(<span class="string">"微服务实战之公共模块:存放微服务常用的工具类"</span>)</span><br><span class="line">    <span class="comment">//依赖</span></span><br><span class="line">    dependencies &#123;</span><br><span class="line">        <span class="comment">// api可以传递，编译速度慢，implement不可以传递，编译速度快</span></span><br><span class="line">        api <span class="string">'com.alibaba:fastjson'</span></span><br><span class="line">        api <span class="string">'mysql:mysql-connector-java'</span></span><br><span class="line">        api <span class="string">'com.baomidou:mybatis-plus-boot-starter'</span></span><br><span class="line">        api <span class="string">'io.springfox:springfox-swagger2'</span></span><br><span class="line">        api <span class="string">'io.springfox:springfox-swagger-ui'</span></span><br><span class="line">        api <span class="string">'io.jsonwebtoken:jjwt'</span></span><br><span class="line"></span><br><span class="line">        api <span class="string">'org.springframework.cloud:spring-cloud-starter-openfeign'</span></span><br><span class="line">        api <span class="string">'org.springframework.cloud:spring-cloud-starter-alibaba-sentinel'</span></span><br><span class="line">        api <span class="string">'org.springframework.cloud:spring-cloud-starter-alibaba-nacos-discovery'</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">project(<span class="string">":microservice_service"</span>)&#123;</span><br><span class="line">    description(<span class="string">"微服务实战之服务模块：存放各个微服务模块"</span>)</span><br><span class="line">    apply <span class="string">plugin:</span> <span class="string">'org.springframework.boot'</span></span><br><span class="line"></span><br><span class="line">    subprojects &#123;</span><br><span class="line">        apply <span class="string">plugin :</span> <span class="string">'java-library'</span></span><br><span class="line">        apply <span class="string">plugin:</span> <span class="string">'org.springframework.boot'</span></span><br><span class="line"></span><br><span class="line">        dependencies &#123;</span><br><span class="line">            api <span class="string">'org.springframework.boot:spring-boot-starter-web'</span></span><br><span class="line">            api project(<span class="string">':microservice_bean'</span>)</span><br><span class="line">            api project(<span class="string">':microservice_common'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-配置公共子模块">2.3 配置公共子模块</h3><p>创建bean和common模块</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jar包后的名字,根据需要自定义</span></span><br><span class="line">archivesBaseName = <span class="string">'common'</span></span><br><span class="line"><span class="comment">// 因为它没有主程序入口，也不需要它达成springboot的jar包</span></span><br><span class="line">bootJar.enabled = <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="2-4-配置Service服务类">2.4 配置Service服务类</h3><p>首先创建service模块服务，下面在分别创建order和user服务，因为service亚父工程不需要jar包，所以在<code>build.gradle</code>配置，同时删除src等其他非必须文件</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不需要打可执行jar包</span></span><br><span class="line">bootJar &#123;</span><br><span class="line">    enabled = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在子模块的build.gradle中进行配置，此时根据需要进行依赖的引入，不过此时不需要进行版本号的编写，版本号统一由父工程进行管理；下面的文件因为版本依赖等已经由父工程配置了，因此无需额外配置</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">archivesBaseName = <span class="string">'order'</span></span><br><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">'java'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">group <span class="string">'com.shawn'</span></span><br><span class="line">version <span class="string">'1.0-SNAPSHOT'</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    testImplementation <span class="string">'org.junit.jupiter:junit-jupiter-api:5.8.1'</span></span><br><span class="line">    testRuntimeOnly <span class="string">'org.junit.jupiter:junit-jupiter-engine:5.8.1'</span></span><br><span class="line">    <span class="comment">//implementation 'org.springframework.boot:spring-boot-starter-web'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test &#123;</span><br><span class="line">    useJUnitPlatform()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//bootJar &#123;</span></span><br><span class="line"><span class="comment">//    archiveClassifier = 'boot'</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure><p>最后如果需要将其他模块的bean加入Spring管理，注意在主启动类添加包扫描路径<code>@ComponentScan(&quot;com.shawn&quot;)</code>，最后在对于的目录下进行打包<code>gradle build</code>，或者IDEA点击bootJar也是打包可执行Jar包(非jar按钮)</p><hr><p>参考</p><p><a href="https://www.bilibili.com/video/BV1yT41137Y7" target="_blank" rel="noopener" title="https://www.bilibili.com/video/BV1yT41137Y7">https://www.bilibili.com/video/BV1yT41137Y7</a></p><p><a href="https://blog.csdn.net/qyb19970829/article/details/110649629" target="_blank" rel="noopener" title="https://blog.csdn.net/qyb19970829/article/details/110649629">https://blog.csdn.net/qyb19970829/article/details/110649629</a></p>]]></content>
    
    
    <summary type="html">&lt;h1&gt;一、Gradle入门&lt;/h1&gt;
&lt;h2 id=&quot;1、简介&quot;&gt;1、简介&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Gradle 是一款Google 推出的基于 JVM、通用灵活的项目构建工具，支持 Maven，JCenter 多种第三方仓库;支持传递性依赖管理、废弃了繁杂的xml 文件，转而使用简洁的、支持多种语言(例如：java、groovy 等)的 build 脚本文件；&lt;br&gt;
官网地址: &lt;a href=&quot;https://gradle.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; title=&quot;https://gradle.org/&quot;&gt;https://gradle.org/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;作为Java开发程序员,如果想下载Spring、SpringBoot等Spring家族的源码，基本上基于Gradle构建的，所以虽然目前市面上常见的项目构建工具有&lt;strong&gt;Ant、Maven、Gradle，主流还是Maven，但是未来趋势Gradle&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://www.shawn22.xyz/categories/Java/"/>
    
    
    <category term="Java基础" scheme="https://www.shawn22.xyz/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
