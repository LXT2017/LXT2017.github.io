<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>星星的猫(&gt;^ω^&lt;)喵</title>
  
  
  <link href="https://www.shawn22.xyz/atom.xml" rel="self"/>
  
  <link href="https://www.shawn22.xyz/"/>
  <updated>2022-04-08T09:03:11.000Z</updated>
  <id>https://www.shawn22.xyz/</id>
  
  <author>
    <name>Shawn</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux开机密码重置</title>
    <link href="https://www.shawn22.xyz/posts/47cb212a.html"/>
    <id>https://www.shawn22.xyz/posts/47cb212a.html</id>
    <published>2022-04-08T09:02:23.000Z</published>
    <updated>2022-04-08T09:03:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1>一、Linux密码重置</h1><h2 id="1、Centos7密码重置">1、Centos7密码重置</h2><p>首先重启centos，随即长按<strong>shift</strong>进入grub菜单</p><p><img src="https://img-blog.csdnimg.cn/f72eae4de65345a4bff2de98c0ad2745.png?type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6a2FTGVtb24=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><a id="more"></a><p>选择正确的内核版本，按e进入编辑界面，<strong>将 [ro] 改为 [rw init=sysroot/bin/sh]</strong>，然后按照指示，<strong>按[ctrl+x]to start</strong>使用单用户模式启动.由于是单用户,就不需要密码进入了.<br><img src="https://img-blog.csdnimg.cn/59d011f51e58476db5dac5fb636a2647.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6a2FTGVtb24=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>然后就可以开始修改密码了，说明一下我有两个用户，root和shawn。首先<strong>输入命令[chroot /sysroot]</strong>，chroot就是change root，也就是改变程序执行时所参考的根目录位置,根目录改为/sysroot。然后<strong>输入命令[passwd root]</strong>，passwd表示更改使用者的密码，最后<strong>输入命令[touch /.autorelabel]</strong> ,在/目录下创建一个.autorelabel文件，而有这个文件存在，系统在重启时就会对整个文件系统进行relabeling。以及<strong>命令[exit]退出</strong>，以及<strong>命令[reboot]重启</strong>。<br><img src="https://img-blog.csdnimg.cn/86c33f5fed5f4dcb95da75a4e5083710.png?type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6a2FTGVtb24=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="2、Ubuntu密码重置">2、Ubuntu密码重置</h2><p><strong>1、重启ubuntu，随即长按shift进入grub菜单；<br>2、选择recovery mode，按&quot;e&quot;键进入编辑页面；<br>3、将ro single替换为rw single init=/bin/bash；<br>4、按ctrl+x进入单用户模式，当前用户即为root；<br>5、修改密码操作：#passwd root<br>输入新密码：#<br>再输入一遍密码：#<br>这是设置root密码，如果是设置其它用户密码使用命令：passwd 用户名 即可<br>6、完成之后重启进入系统即可</strong></p>]]></content>
    
    
    <summary type="html">&lt;h1&gt;一、Linux密码重置&lt;/h1&gt;
&lt;h2 id=&quot;1、Centos7密码重置&quot;&gt;1、Centos7密码重置&lt;/h2&gt;
&lt;p&gt;首先重启centos，随即长按&lt;strong&gt;shift&lt;/strong&gt;进入grub菜单&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/f72eae4de65345a4bff2de98c0ad2745.png?type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6a2FTGVtb24=,size_20,color_FFFFFF,t_70,g_se,x_16&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.shawn22.xyz/categories/Linux/"/>
    
    
    <category term="linux基础" scheme="https://www.shawn22.xyz/tags/linux%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis源码分析</title>
    <link href="https://www.shawn22.xyz/posts/9a55ed5d.html"/>
    <id>https://www.shawn22.xyz/posts/9a55ed5d.html</id>
    <published>2022-03-02T01:42:32.000Z</published>
    <updated>2022-03-02T01:59:06.964Z</updated>
    
    <content type="html"><![CDATA[<h1>一、前言</h1><blockquote><p>MyBatis官方文档：<a href="https://mybatis.org/mybatis-3/zh/" target="_blank" rel="noopener">https://mybatis.org/mybatis-3/zh/</a></p></blockquote><h2 id="1、介绍">1、介绍</h2><p>对于MyBatis，其工作流程实际上分为两部分：<strong>第一，构建，也就是解析我们写的xml配置，将其变成它所需要的对象。第二，执行，在构建完成的基础上，去执行我们的SQL，完成与Jdbc的交互</strong></p><a id="more"></a><h2 id="2、快速上手">2、快速上手</h2><p>数据库配置如<a href="https://blog.csdn.net/lemon_TT/article/details/114846109" target="_blank" rel="noopener">Mybatis学习笔记</a>一样，我的项目结构如下图所示</p><p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/20220301/20220301215805.png" alt></p><p>创建<code>mybatis-config.xml</code>文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span> =<span class="string">"db.properties"</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 使用驼峰命名法 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"mapUnderscoreToCamelCase"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 开启日志--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"logImpl"</span> <span class="attr">value</span>=<span class="string">"STDOUT_LOGGING"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--别名设置，默认是包名，当然也可以每个路径名做一个别名映射 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"org.demo.po"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.driver&#125;"</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 将我们写好的sql映射文件（EmployeeMapper.xml）一定要注册到全局配置文件（mybatis-config.xml）中 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--这里填写resource下的路径--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"mappers/EmployeeMapper.xml"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>创建<code>db.properties</code>外部文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jdbc.driver=com.mysql.cj.jdbc.Driver</span><br><span class="line">jdbc.url=jdbc:mysql:<span class="comment">//localhost:3306/learnmybatis?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=root</span><br></pre></td></tr></table></figure><p>创建<code>EmployeeMapper.xml</code>文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这里修改自己的mapper --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"test"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--resultType别名大小写都可，因为最后会统一变成小写，同时源码已经内置了很多别名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getEmp"</span> <span class="attr">resultType</span>=<span class="string">"Employee"</span>&gt;</span></span><br><span class="line">        select * from employee</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>创建测试文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 加载mybatis框架主配置文件</span></span><br><span class="line">    String resource = <span class="string">"mybatis-config.xml"</span>;</span><br><span class="line">    InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">    <span class="comment">// 读取解析配置文件内容，创建SqlSessionFacory</span></span><br><span class="line">    SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">    <span class="comment">// 获取sqlSession对象</span></span><br><span class="line">    SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">    <span class="comment">// 这种操作不推荐，推荐使用mapper代理方式，后面有提到</span></span><br><span class="line">    <span class="comment">// 执行数据库操作</span></span><br><span class="line">    List&lt;Employee&gt; list = sqlSession.selectList(<span class="string">"test.getEmp"</span>);</span><br><span class="line">    System.out.println(list);</span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    sqlSession.close();</span><br><span class="line">    <span class="comment">// sqlSession.commit();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>二、Mybatis的构建</h1><h2 id="1、核心流程">1、核心流程</h2><h3 id="1-1-介绍">1.1 介绍</h3><p>Configuration 是整个MyBatis的配置体系集中管理中心，前面所学Executor、StatementHandler、Cache、MappedStatement…等绝大部分组件都是由它直接或间接的创建和管理。其主要作用如下</p><ul><li>存储全局配置信息，其来源于settings（设置）</li><li>初始化并维护全局基础组件<ul><li>typeAliases（类型别名）</li><li>typeHandlers（类型处理器）</li><li>plugins（插件）</li><li>environments（环境配置）</li><li>cache(二级缓存空间)</li></ul></li><li>初始化并维护MappedStatement</li><li>组件构造器,并基于插件进行增强<ul><li>newExecutor（执行器）</li><li>newStatementHandler（JDBC处理器）</li><li>newResultSetHandler（结果集处理器）</li><li>newParameterHandler（参数处理器）</li></ul></li></ul><p>Configuration 配置信息来源于xml和注解，每个文件和注解都是由若干个配置元素组成，并呈现嵌套关系，总体关系如下图所示，关于各配置的使用请参见官网给出文档：<a href="https://mybatis.org/mybatis-3/zh/configuration.html#properties" target="_blank" rel="noopener">https://mybatis.org/mybatis-3/zh/configuration.html#properties</a></p><p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/20220301/20220301215814.png" alt></p><p>无论是xml 注解这些配置元素最弱都要被转换成JAVA配置属性或对象组件来承载。其对应关系如下：</p><ul><li>全配置(config.xml) 由Configuration对像属性承载</li><li>sql映射&lt;select|insert…&gt; 或@Select 等由MappedStatement对象承载</li><li>缓存&lt;cache…&gt; 或@CacheNamespace 由Cache对象承载</li><li>结果集映射 由ResultMap 对象承载</li></ul><p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/20220301/20220301215817.png" alt></p><h3 id="1-2-配置文件解析">1.2 配置文件解析</h3><ul><li>XMLConfigBuilder :解析config.xml文件，会直接创建一个configuration对象，用于解析全局配置</li><li>XMLMapperBuilder ：解析Mapper.xml文件，内容包含等</li><li>MapperBuilderAssistant：Mapper.xml解析辅助，在一个Mapper.xml中Cache是对Statement（sql声明）共享的，共享组件的分配即由该解析实现</li><li>XMLStatementBuilder：SQL映射解析 即&lt;select|update|insert|delete&gt; 元素解析成MapperStatement</li><li>SqlSourceBuilder：Sql数据源解析,将声明的SQL解析可执行的SQL</li><li>XMLScriptBuilder：解析动态SQL数据源当中所设置 SqlNode脚本集</li></ul><p><strong>XML文件解析流程</strong></p><p>整体解析流程是从XmlConfigBuilder 开始，然后逐步向内解析，直到解析完所有节点。我们通过一个MappedStatement 解析过程即可了解到期整体解析流程</p><p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/20220301/20220301215820.png" alt></p><p><strong>注解配置解析</strong></p><p>注解解析底层实现是通过反射获取Mapper接口当中注解元素实现。有两种方式一种是直接指定接口名，一种是指定包名然后自动扫描包下所有的接口类。这些逻辑均由Mapper注册器(MapperRegistry)实现。其接收一个接口类参数，并基于该参数创建针对该接口的动态代理工厂，然后解析内部方法注解生成每个MapperStatement 最后添加至Configuration 完成解析。</p><p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/20220301/20220301215824.png" alt></p><h3 id="1-3-源码分析">1.3 源码分析</h3><p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/20220301/20220301215833.png" alt></p><p>进入build方法，可以看见代码将xml文件传入并返回了一个SqlSessionFactory对象，而这个对象是使用构造者模式创建的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(InputStream inputStream, String environment, Properties properties)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 开始解析配置文件，这里先生产一个解析对象</span></span><br><span class="line">    XMLConfigBuilder parser = <span class="keyword">new</span> XMLConfigBuilder(inputStream, environment, properties);</span><br><span class="line">    <span class="keyword">return</span> build(parser.parse());</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error building SqlSession."</span>, e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ErrorContext.instance().reset();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      inputStream.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      <span class="comment">// Intentionally ignore. Prefer previous error.</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在进入build对象的<code>parse()</code>方法，<strong>这个方法初始化Configuration对象，并且解析xml文件，把解析内容放入到Configuration对象中</strong>。其中就包括别名的映射，在初始化阶段别名映射会自动注册一些常用的别名，如果我们自己也配置也自动注册到Configuration对象的TypeAliasRegistry的TYPE_ALIASES的map中，并且把数据源和事务解析以后放入到Environment，给后续的执行提供数据链接和事务管理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Configuration <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//查看该文件是否已经解析过</span></span><br><span class="line">  <span class="keyword">if</span> (parsed) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Each XMLConfigBuilder can only be used once."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果没有解析过，则继续往下解析，并且将标识符置为true</span></span><br><span class="line">  parsed = <span class="keyword">true</span>;</span><br><span class="line">  <span class="comment">//解析&lt;configuration&gt;节点，即从根节点开始解析，名字必须是configuration</span></span><br><span class="line">  parseConfiguration(parser.evalNode(<span class="string">"/configuration"</span>));</span><br><span class="line">  <span class="keyword">return</span> configuration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在进入<code>parseConfiguration()</code>方法，可以看到这个方法已经在解析<code>&lt;configuration&gt;</code>下的节点了，例如<code>&lt;settings&gt;</code>,<code>&lt;typeAliases&gt;</code>,<code>&lt;environments&gt;</code>和<code>&lt;mappers&gt;</code>等，同时返回了<code>Configuration</code>对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// root即是完整的xml内容</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseConfiguration</span><span class="params">(XNode root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//解析&lt;Configuration&gt;下的节点</span></span><br><span class="line">    propertiesElement(root.evalNode(<span class="string">"properties"</span>));</span><br><span class="line">    <span class="comment">//&lt;settings&gt;</span></span><br><span class="line">    Properties settings = settingsAsProperties(root.evalNode(<span class="string">"settings"</span>));</span><br><span class="line">    loadCustomVfs(settings);</span><br><span class="line">    loadCustomLogImpl(settings);</span><br><span class="line">    <span class="comment">// 别名&lt;typeAliases&gt;解析</span></span><br><span class="line">    <span class="comment">// 所谓别名其实就是把你指定的别名对应的class存储在一个Map当中</span></span><br><span class="line">    typeAliasesElement(root.evalNode(<span class="string">"typeAliases"</span>));</span><br><span class="line">    <span class="comment">//插件 &lt;plugins&gt;</span></span><br><span class="line">    pluginElement(root.evalNode(<span class="string">"plugins"</span>));</span><br><span class="line">    <span class="comment">//自定义实例化对象的行为&lt;objectFactory&gt;</span></span><br><span class="line">    objectFactoryElement(root.evalNode(<span class="string">"objectFactory"</span>));</span><br><span class="line">    <span class="comment">//MateObject   方便反射操作实体类的对象</span></span><br><span class="line">    objectWrapperFactoryElement(root.evalNode(<span class="string">"objectWrapperFactory"</span>));</span><br><span class="line">    reflectorFactoryElement(root.evalNode(<span class="string">"reflectorFactory"</span>));</span><br><span class="line">    settingsElement(settings);</span><br><span class="line">    <span class="comment">// read it after objectFactory and objectWrapperFactory issue #631</span></span><br><span class="line">    <span class="comment">//&lt;environments&gt;</span></span><br><span class="line">    environmentsElement(root.evalNode(<span class="string">"environments"</span>));</span><br><span class="line">    databaseIdProviderElement(root.evalNode(<span class="string">"databaseIdProvider"</span>));</span><br><span class="line">    <span class="comment">// typeHandlers</span></span><br><span class="line">    typeHandlerElement(root.evalNode(<span class="string">"typeHandlers"</span>));</span><br><span class="line">    <span class="comment">//主要 &lt;mappers&gt; 指向我们存放SQL的xxxxMapper.xml文件</span></span><br><span class="line">    mapperElement(root.evalNode(<span class="string">"mappers"</span>));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Error parsing SQL Mapper Configuration. Cause: "</span> + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、Configuration对象详解">2、Configuration对象详解</h2><h3 id="2-1-配置文件dataSource-内容替换">2.1 配置文件dataSource 内容替换</h3><p>对于<code>db.properties</code>替代，在<code>parseConfiguration()</code>方法中的<code>propertiesElement(root.evalNode(&quot;properties&quot;));</code>就是对外部配置文件的替换修改，它首先形成Properties对象对其替换</p><p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/20220301/20220301215837.png" alt></p><h3 id="2-2-typeAliasesElement别名设置">2.2 typeAliasesElement别名设置</h3><p>Mybatis别名设置若存在<package>标签，则mapper.xml别名默认是类名(忽略大小写)，同时将其存放于<code>TYPE_ALIASES</code>这个HashMap中，同时里面已经存在很多内置别名，可以直接使用</package></p><p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/20220301/20220301215840.png" alt></p><p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/20220301/20220301215844.png" alt></p><h3 id="2-3-数据库相关内容载入">2.3 数据库相关内容载入</h3><p><code>environmentsElement(root.evalNode(&quot;environments&quot;));</code>方法将数据库相关信息配置(例如事务，数据库账号密码等)存入enviroment对象，最终和configuration相关联存入其对象中</p><p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/20220301/20220301215846.png" alt></p><h3 id="2-4-mapper解析-重要✨">2.4 mapper解析(重要✨)</h3><p><code>mybatis-config.xml</code>文件中我们一定会写一个叫做<mappers>的标签，这个标签中的<code>&lt;mapper&gt;</code>节点存放了我们对数据库进行操作的SQL语句，这里就详细详解一下mapper的执行过程</mappers></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 通过包名，这里要求xml和mapoper包在同一包下 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"org.demo.po"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 通过配置文件路径，多个文件可以通过*Mapper.xml通配符 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"mappers/EmployeeMapper.xml"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 通过Java全限定类名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">"org.demo.mapper.EmployeeMapper.java"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 通过url 通常是mapper不在本地时用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">url</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这是<code>&lt;mappers&gt;</code>标签的几种配置方式，通过这几种配置方式，可以帮助我们更容易理解mappers的解析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mapperElement</span><span class="params">(XNode parent)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//遍历解析mappers下的节点</span></span><br><span class="line">      <span class="keyword">for</span> (XNode child : parent.getChildren()) &#123;</span><br><span class="line">      <span class="comment">//首先解析package节点</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="string">"package"</span>.equals(child.getName())) &#123;</span><br><span class="line">        <span class="comment">//获取包名</span></span><br><span class="line">        String mapperPackage = child.getStringAttribute(<span class="string">"name"</span>);</span><br><span class="line">        configuration.addMappers(mapperPackage);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果不存在package节点，那么扫描mapper节点</span></span><br><span class="line">        <span class="comment">//resource/url/mapperClass三个值只能有一个值是有值的</span></span><br><span class="line">        String resource = child.getStringAttribute(<span class="string">"resource"</span>);</span><br><span class="line">        String url = child.getStringAttribute(<span class="string">"url"</span>);</span><br><span class="line">        String mapperClass = child.getStringAttribute(<span class="string">"class"</span>);</span><br><span class="line">        <span class="comment">//优先级 resource&gt;url&gt;mapperClass</span></span><br><span class="line">        <span class="keyword">if</span> (resource != <span class="keyword">null</span> &amp;&amp; url == <span class="keyword">null</span> &amp;&amp; mapperClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果mapper节点中的resource不为空</span></span><br><span class="line">          ErrorContext.instance().resource(resource);</span><br><span class="line">           <span class="comment">//那么直接加载resource指向的XXXMapper.xml文件为字节流</span></span><br><span class="line">          InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">          <span class="comment">//通过XMLMapperBuilder解析XXXMapper.xml，可以看到这里构建的XMLMapperBuilde还传入了configuration,所以之后肯定是会将mapper封装到configuration对象中去的。</span></span><br><span class="line">          XMLMapperBuilder mapperParser = <span class="keyword">new</span> XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());</span><br><span class="line">          <span class="comment">//解析</span></span><br><span class="line">          mapperParser.parse();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resource == <span class="keyword">null</span> &amp;&amp; url != <span class="keyword">null</span> &amp;&amp; mapperClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">//如果url!=null，那么通过url解析</span></span><br><span class="line">          ErrorContext.instance().resource(url);</span><br><span class="line">          InputStream inputStream = Resources.getUrlAsStream(url);</span><br><span class="line">          XMLMapperBuilder mapperParser = <span class="keyword">new</span> XMLMapperBuilder(inputStream, configuration, url, configuration.getSqlFragments());</span><br><span class="line">          mapperParser.parse();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resource == <span class="keyword">null</span> &amp;&amp; url == <span class="keyword">null</span> &amp;&amp; mapperClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果mapperClass!=null，那么通过加载类构造Configuration</span></span><br><span class="line">          Class&lt;?&gt; mapperInterface = Resources.classForName(mapperClass);</span><br><span class="line">          configuration.addMapper(mapperInterface);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果都不满足  则直接抛异常  如果配置了两个或三个  直接抛异常</span></span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"A mapper element may only specify a url, resource or class, but not more than one."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/20220301/20220301215854.png" alt></p><p>我们的配置文件中写的是通过resource来加载<code>mapper.xml</code>的，所以会通过<code>XMLMapperBuilder</code>来进行解析，我们在进去它的<code>parse()</code>方法。在这个parse()方法中，调用了一个<code>configuationElement</code>代码，用于解析<code>XXXMapper.xml</code>文件中的各种节点，包括<code>&lt;cache&gt;</code>、<code>&lt;cache-ref&gt;</code>、<code>&lt;paramaterMap&gt;</code>（已过时）、<code>&lt;resultMap&gt;</code>、<code>&lt;sql&gt;</code>、还有增删改查节点，和上面相同的是，我们也挑一个主要的来说，因为解析过程都大同小异。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//判断文件是否之前解析过</span></span><br><span class="line">  <span class="keyword">if</span> (!configuration.isResourceLoaded(resource)) &#123;</span><br><span class="line">      <span class="comment">//解析mapper文件节点（主要）(下面贴了代码)</span></span><br><span class="line">    configurationElement(parser.evalNode(<span class="string">"/mapper"</span>));</span><br><span class="line">    configuration.addLoadedResource(resource);</span><br><span class="line">    <span class="comment">//绑定Namespace里面的Class对象</span></span><br><span class="line">    bindMapperForNamespace();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//重新解析之前解析不了的节点，先不看，最后填坑。</span></span><br><span class="line">  parsePendingResultMaps();</span><br><span class="line">  parsePendingCacheRefs();</span><br><span class="line">  parsePendingStatements();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//解析mapper文件里面的节点</span></span><br><span class="line"><span class="comment">// 拿到里面配置的配置项 最终封装成一个MapperedStatemanet</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">configurationElement</span><span class="params">(XNode context)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//获取命名空间 namespace，这个很重要，后期mybatis会通过这个动态代理我们的Mapper接口</span></span><br><span class="line">    String namespace = context.getStringAttribute(<span class="string">"namespace"</span>);</span><br><span class="line">    <span class="keyword">if</span> (namespace == <span class="keyword">null</span> || namespace.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">        <span class="comment">//如果namespace为空则抛一个异常</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Mapper's namespace cannot be empty"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    builderAssistant.setCurrentNamespace(namespace);</span><br><span class="line">    <span class="comment">//解析缓存节点</span></span><br><span class="line">    cacheRefElement(context.evalNode(<span class="string">"cache-ref"</span>));</span><br><span class="line">    cacheElement(context.evalNode(<span class="string">"cache"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析parameterMap（过时）和resultMap  &lt;resultMap&gt;&lt;/resultMap&gt;</span></span><br><span class="line">    parameterMapElement(context.evalNodes(<span class="string">"/mapper/parameterMap"</span>));</span><br><span class="line">    resultMapElements(context.evalNodes(<span class="string">"/mapper/resultMap"</span>));</span><br><span class="line">    <span class="comment">//解析&lt;sql&gt;节点 </span></span><br><span class="line">    <span class="comment">//&lt;sql id="staticSql"&gt;select * from test&lt;/sql&gt; （可重用的代码段）</span></span><br><span class="line">    <span class="comment">//&lt;select&gt; &lt;include refid="staticSql"&gt;&lt;/select&gt;</span></span><br><span class="line">    sqlElement(context.evalNodes(<span class="string">"/mapper/sql"</span>));</span><br><span class="line">    <span class="comment">//解析增删改查节点&lt;select&gt; &lt;insert&gt; &lt;update&gt; &lt;delete&gt;</span></span><br><span class="line">    buildStatementFromContext(context.evalNodes(<span class="string">"select|insert|update|delete"</span>));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Error parsing Mapper XML. The XML location is '"</span> + resource + <span class="string">"'. Cause: "</span> + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里解析其中一项举例，解析增删改查节点<code>&lt;select&gt; &lt;insert&gt; &lt;update&gt; &lt;delete&gt;</code>，进入<code>buildStatementFromContext(context.evalNodes(&quot;select|insert|update|delete&quot;));</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildStatementFromContext</span><span class="params">(List&lt;XNode&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (configuration.getDatabaseId() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      buildStatementFromContext(list, configuration.getDatabaseId());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//解析xml</span></span><br><span class="line">    buildStatementFromContext(list, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildStatementFromContext</span><span class="params">(List&lt;XNode&gt; list, String requiredDatabaseId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (XNode context : list) &#123;</span><br><span class="line">    <span class="keyword">final</span> XMLStatementBuilder statementParser = <span class="keyword">new</span> XMLStatementBuilder(configuration, builderAssistant, context, requiredDatabaseId);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//解析xml节点</span></span><br><span class="line">      statementParser.parseStatementNode();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IncompleteElementException e) &#123;</span><br><span class="line">      <span class="comment">//xml语句有问题时 存储到集合中 等解析完能解析的再重新解析</span></span><br><span class="line">      configuration.addIncompleteStatement(statementParser);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入<code>statementParser.parseStatementNode();</code>方法，解析里面的xml节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseStatementNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取&lt;select id="xxx"&gt;中的id</span></span><br><span class="line">    String id = context.getStringAttribute(<span class="string">"id"</span>);</span><br><span class="line">    <span class="comment">//获取databaseId 用于多数据库，这里为null</span></span><br><span class="line">    String databaseId = context.getStringAttribute(<span class="string">"databaseId"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!databaseIdMatchesCurrent(id, databaseId, <span class="keyword">this</span>.requiredDatabaseId)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取节点名  select update delete insert</span></span><br><span class="line">    String nodeName = context.getNode().getNodeName();</span><br><span class="line">    <span class="comment">//根据节点名，得到SQL操作的类型</span></span><br><span class="line">    SqlCommandType sqlCommandType = SqlCommandType.valueOf(nodeName.toUpperCase(Locale.ENGLISH));</span><br><span class="line">    <span class="comment">//判断是否是查询</span></span><br><span class="line">    <span class="keyword">boolean</span> isSelect = sqlCommandType == SqlCommandType.SELECT;</span><br><span class="line">    <span class="comment">//是否刷新缓存 默认:增删改刷新 查询不刷新</span></span><br><span class="line">    <span class="keyword">boolean</span> flushCache = context.getBooleanAttribute(<span class="string">"flushCache"</span>, !isSelect);</span><br><span class="line">    <span class="comment">//是否使用二级缓存 默认值:查询使用 增删改不使用</span></span><br><span class="line">    <span class="keyword">boolean</span> useCache = context.getBooleanAttribute(<span class="string">"useCache"</span>, isSelect);</span><br><span class="line">    <span class="comment">//是否需要处理嵌套查询结果 group by</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 三组数据 分成一个嵌套的查询结果</span></span><br><span class="line">    <span class="keyword">boolean</span> resultOrdered = context.getBooleanAttribute(<span class="string">"resultOrdered"</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Include Fragments before parsing</span></span><br><span class="line">    XMLIncludeTransformer includeParser = <span class="keyword">new</span> XMLIncludeTransformer(configuration, builderAssistant);</span><br><span class="line">    <span class="comment">//替换Includes标签为对应的sql标签里面的值</span></span><br><span class="line">    includeParser.applyIncludes(context.getNode());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取parameterType名</span></span><br><span class="line">    String parameterType = context.getStringAttribute(<span class="string">"parameterType"</span>);</span><br><span class="line">    <span class="comment">//获取parameterType的Class</span></span><br><span class="line">    Class&lt;?&gt; parameterTypeClass = resolveClass(parameterType);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析配置的自定义脚本语言驱动 这里为null</span></span><br><span class="line">    String lang = context.getStringAttribute(<span class="string">"lang"</span>);</span><br><span class="line">    LanguageDriver langDriver = getLanguageDriver(lang);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parse selectKey after includes and remove them.</span></span><br><span class="line">    <span class="comment">//解析selectKey</span></span><br><span class="line">    processSelectKeyNodes(id, parameterTypeClass, langDriver);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parse the SQL (pre: &lt;selectKey&gt; and &lt;include&gt; were parsed and removed)</span></span><br><span class="line">    <span class="comment">//设置主键自增规则</span></span><br><span class="line">    KeyGenerator keyGenerator;</span><br><span class="line">    String keyStatementId = id + SelectKeyGenerator.SELECT_KEY_SUFFIX;</span><br><span class="line">    keyStatementId = builderAssistant.applyCurrentNamespace(keyStatementId, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (configuration.hasKeyGenerator(keyStatementId)) &#123;</span><br><span class="line">        keyGenerator = configuration.getKeyGenerator(keyStatementId);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        keyGenerator = context.getBooleanAttribute(<span class="string">"useGeneratedKeys"</span>,</span><br><span class="line">                configuration.isUseGeneratedKeys() &amp;&amp; SqlCommandType.INSERT.equals(sqlCommandType))</span><br><span class="line">                ? Jdbc3KeyGenerator.INSTANCE : NoKeyGenerator.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/************************************************************************************/</span></span><br><span class="line">    <span class="comment">//解析Sql（重要）  根据sql文本来判断是否需要动态解析 如果没有动态sql语句且 只有#&#123;&#125;的时候 直接静态解析使用?占位 当有 $&#123;&#125; 不解析</span></span><br><span class="line">    SqlSource sqlSource = langDriver.createSqlSource(configuration, context, parameterTypeClass);</span><br><span class="line">    <span class="comment">//获取StatementType，可以理解为Statement和PreparedStatement</span></span><br><span class="line">    StatementType statementType = StatementType.valueOf(context.getStringAttribute(<span class="string">"statementType"</span>, StatementType.PREPARED.toString()));</span><br><span class="line">    <span class="comment">//没用过</span></span><br><span class="line">    Integer fetchSize = context.getIntAttribute(<span class="string">"fetchSize"</span>);</span><br><span class="line">    <span class="comment">//超时时间</span></span><br><span class="line">    Integer timeout = context.getIntAttribute(<span class="string">"timeout"</span>);</span><br><span class="line">    <span class="comment">//已过时</span></span><br><span class="line">    String parameterMap = context.getStringAttribute(<span class="string">"parameterMap"</span>);</span><br><span class="line">    <span class="comment">//获取返回值类型名</span></span><br><span class="line">    String resultType = context.getStringAttribute(<span class="string">"resultType"</span>);</span><br><span class="line">    <span class="comment">//获取返回值烈性的Class</span></span><br><span class="line">    Class&lt;?&gt; resultTypeClass = resolveClass(resultType);</span><br><span class="line">    <span class="comment">//获取resultMap的id</span></span><br><span class="line">    String resultMap = context.getStringAttribute(<span class="string">"resultMap"</span>);</span><br><span class="line">    <span class="comment">//获取结果集类型</span></span><br><span class="line">    String resultSetType = context.getStringAttribute(<span class="string">"resultSetType"</span>);</span><br><span class="line">    ResultSetType resultSetTypeEnum = resolveResultSetType(resultSetType);</span><br><span class="line">    <span class="keyword">if</span> (resultSetTypeEnum == <span class="keyword">null</span>) &#123;</span><br><span class="line">        resultSetTypeEnum = configuration.getDefaultResultSetType();</span><br><span class="line">    &#125;</span><br><span class="line">    String keyProperty = context.getStringAttribute(<span class="string">"keyProperty"</span>);</span><br><span class="line">    String keyColumn = context.getStringAttribute(<span class="string">"keyColumn"</span>);</span><br><span class="line">    String resultSets = context.getStringAttribute(<span class="string">"resultSets"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将刚才获取到的属性，封装成MappedStatement对象（代码贴在下面）</span></span><br><span class="line">    builderAssistant.addMappedStatement(id, sqlSource, statementType, sqlCommandType,</span><br><span class="line">            fetchSize, timeout, parameterMap, parameterTypeClass, resultMap, resultTypeClass,</span><br><span class="line">            resultSetTypeEnum, flushCache, useCache, resultOrdered,</span><br><span class="line">            keyGenerator, keyProperty, keyColumn, databaseId, langDriver, resultSets);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的MappedStatement对象，这里每一个方法id对应存储一个MappedStatement对象，这样在执行的时候就可以直接通过id获得映射的MappedStatement对象了，即可以直接执行获取mysql结果了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将刚才获取到的属性，封装成MappedStatement对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MappedStatement <span class="title">addMappedStatement</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        String id,</span></span></span><br><span class="line"><span class="function"><span class="params">        SqlSource sqlSource,</span></span></span><br><span class="line"><span class="function"><span class="params">        StatementType statementType,</span></span></span><br><span class="line"><span class="function"><span class="params">        SqlCommandType sqlCommandType,</span></span></span><br><span class="line"><span class="function"><span class="params">        Integer fetchSize,</span></span></span><br><span class="line"><span class="function"><span class="params">        Integer timeout,</span></span></span><br><span class="line"><span class="function"><span class="params">        String parameterMap,</span></span></span><br><span class="line"><span class="function"><span class="params">        Class&lt;?&gt; parameterType,</span></span></span><br><span class="line"><span class="function"><span class="params">        String resultMap,</span></span></span><br><span class="line"><span class="function"><span class="params">        Class&lt;?&gt; resultType,</span></span></span><br><span class="line"><span class="function"><span class="params">        ResultSetType resultSetType,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> flushCache,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> useCache,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> resultOrdered,</span></span></span><br><span class="line"><span class="function"><span class="params">        KeyGenerator keyGenerator,</span></span></span><br><span class="line"><span class="function"><span class="params">        String keyProperty,</span></span></span><br><span class="line"><span class="function"><span class="params">        String keyColumn,</span></span></span><br><span class="line"><span class="function"><span class="params">        String databaseId,</span></span></span><br><span class="line"><span class="function"><span class="params">        LanguageDriver lang,</span></span></span><br><span class="line"><span class="function"><span class="params">        String resultSets)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unresolvedCacheRef) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IncompleteElementException(<span class="string">"Cache-ref not yet resolved"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//id = namespace</span></span><br><span class="line">    id = applyCurrentNamespace(id, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">boolean</span> isSelect = sqlCommandType == SqlCommandType.SELECT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过构造者模式+链式变成，构造一个MappedStatement的构造者</span></span><br><span class="line">    MappedStatement.Builder statementBuilder = <span class="keyword">new</span> MappedStatement.Builder(configuration, id, sqlSource, sqlCommandType)</span><br><span class="line">            .resource(resource)</span><br><span class="line">            .fetchSize(fetchSize)</span><br><span class="line">            .timeout(timeout)</span><br><span class="line">            .statementType(statementType)</span><br><span class="line">            .keyGenerator(keyGenerator)</span><br><span class="line">            .keyProperty(keyProperty)</span><br><span class="line">            .keyColumn(keyColumn)</span><br><span class="line">            .databaseId(databaseId)</span><br><span class="line">            .lang(lang)</span><br><span class="line">            .resultOrdered(resultOrdered)</span><br><span class="line">            .resultSets(resultSets)</span><br><span class="line">            .resultMaps(getStatementResultMaps(resultMap, resultType, id))</span><br><span class="line">            .resultSetType(resultSetType)</span><br><span class="line">            .flushCacheRequired(valueOrDefault(flushCache, !isSelect))</span><br><span class="line">            .useCache(valueOrDefault(useCache, isSelect))</span><br><span class="line">            .cache(currentCache);</span><br><span class="line"></span><br><span class="line">    ParameterMap statementParameterMap = getStatementParameterMap(parameterMap, parameterType, id);</span><br><span class="line">    <span class="keyword">if</span> (statementParameterMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">        statementBuilder.parameterMap(statementParameterMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过构造者构造MappedStatement</span></span><br><span class="line">    MappedStatement statement = statementBuilder.build();</span><br><span class="line">    <span class="comment">//将MappedStatement对象封装到Configuration对象中</span></span><br><span class="line">    configuration.addMappedStatement(statement);</span><br><span class="line">    <span class="keyword">return</span> statement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/20220301/20220301215905.png" alt></p><h2 id="3、动态SQL构建">3、动态SQL构建</h2><h3 id="3-1-动态SQL解析">3.1 动态SQL解析</h3><ul><li>if</li><li>choose (when, otherwise)</li><li>trim (where, set)</li><li>foreach</li></ul><p><strong>OGNL表达示</strong></p><p>OGNL全称是对象导航图语言(Object Graph Navigation Language)是一种JAVA表达示语言，可以方便的存取对象属和方法，已用于逻辑判断。其支持<strong>以下特性</strong>：获取属性属性值，以及子属性值进行逻辑计；表达示中可直接调用方法(如果是无参方法，可以省略括号)；通过下标访问数组或集合；遍历集合</p><h3 id="3-2-动态SQL脚本">3.2 动态SQL脚本</h3><p>每个动态元素都会有一个与之对应的脚本类，即会产生许多SqlNode脚本如<code>if</code> 对应<code>ifSqlNode</code>、<code>forEarch</code>对应<code>ForEachSqlNode</code> 以此类推下去。同时脚本之间是呈现嵌套关系的，比如<code>if</code>元素中会包含一个<code>MixedSqlNode</code> ，而<code>MixedSqlNode</code>下又会包含1至1至多个其它节点，最后组成一课脚本语法树。最后SqlNode的接口非常简单，就只有一个<code>apply</code>方法，方法的作用就是执行当前脚本节点逻辑，并把结果应用到<code>DynamicContext</code>当中去。</p><p>这里要注意下面三个脚本</p><ul><li><code>StaticTextSqlNode</code> 表示一段纯静态文本如： <code>select * from user</code></li><li><code>TextSqlNode</code> 表示一个通过参数拼装的文本如：<code>select * from ${user}</code></li><li><code>MixedSqlNode</code> 表示多个节点的集合</li></ul><p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/20220301/20220301215908.png" alt></p><h3 id="3-3-SqlSource（SQL数据源）">3.3 SqlSource（SQL数据源）</h3><p>SqlSource 是基于XML解析而来，解析的底层是使用Dom4j 把XML解析成一个个子节点，在通过 <strong>XMLScriptBuilder</strong> 遍历这些子节点最后生成对应的Sql源。在上层定义上每个Sql映射（MappedStatement）中都会包含一个SqlSource 用来获取可执行Sql（<code>BoundSql</code>）。SqlSource又分为原生SQL源与动态SQL源，以及第三方源</p><p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/20220301/20220301215911.png" alt></p><ul><li>roviderSqlSource ：第三方法SQL源，每次获取SQL都会基于参数动态创建静态数据源，然后在创建BoundSql</li><li>DynamicSqlSource：动态SQL源包含了SQL脚本，每次获取SQL都会基于参数又及脚本，动态创建创建BoundSql</li><li>RawSqlSource：不包含任何动态元素，原生文本的SQL。但这个SQL是不能直接执行的，需要转换成BoundSql</li><li>StaticSqlSource：包含可执行的SQL，以及参数映射，可直接生成BoundSql。前面三个数据源都要先创建StaticSqlSource然后才创建BoundSql</li></ul><h3 id="3-4-源码流程">3.4 源码流程</h3><p>生成SQL语句代码，首先这里会通过<code>&lt;select&gt;</code>节点获取到我们的SQL语句，假设SQL语句中只有<code>${}</code>，那么直接就什么都不做，在运行的时候直接进行赋值。而如果扫描到了<code>#{}</code>字符串之后，会进行替换，将<code>#{}</code>替换为 <code>?</code>。</p><p>这里会生成一个GenericTokenParser，这个对象可以传入一个openToken和closeToken，如果是<code>#{}</code>，那么openToken就是<code>#{</code>，closeToken就是 <code>}</code>，然后通过parse方法中的<code>handler.handleToken()</code>方法进行替换。在这之前由于已经进行过SQL是否含有<code>#{}</code>的判断了，所以在这里如果是只有<code>${}</code>，那么handler就是BindingTokenParser的实例化对象，如果存在<code>#{}</code>，那么handler就是<code>ParameterMappingTokenHandler</code>的实例化对象。</p><p><code>mapperElement()</code> &gt; <code>mapperParser.parse()</code>  &gt; 进入XMLMapperBuilder类 <code>configurationElement() </code>&gt; <code>buildStatementFromContext()</code> &gt; <code>buildStatementFromContext()</code> &gt; <code>statementParser.parseStatementNode();</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//XMLStatementBuilder类parseStatementNode方法</span></span><br><span class="line"><span class="comment">//解析Sql（重要）根据sql文本来判断是否需要动态解析 如果没有动态sql语句且 只有#&#123;&#125;的时候 直接静态解析使用?占位 当有 $&#123;&#125; 不解析</span></span><br><span class="line">SqlSource sqlSource = langDriver.createSqlSource(configuration, context, parameterTypeClass);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*进入createSqlSource方法*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SqlSource <span class="title">createSqlSource</span><span class="params">(Configuration configuration, XNode script, Class&lt;?&gt; parameterType)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//进入这个构造</span></span><br><span class="line">    XMLScriptBuilder builder = <span class="keyword">new</span> XMLScriptBuilder(configuration, script, parameterType);</span><br><span class="line">    <span class="comment">//进入parseScriptNode</span></span><br><span class="line">    <span class="keyword">return</span> builder.parseScriptNode();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">进入这个方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SqlSource <span class="title">parseScriptNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//#</span></span><br><span class="line">    <span class="comment">//会先解析一遍</span></span><br><span class="line">    MixedSqlNode rootSqlNode = parseDynamicTags(context);</span><br><span class="line">    SqlSource sqlSource;</span><br><span class="line">    <span class="keyword">if</span> (isDynamic) &#123;</span><br><span class="line">      <span class="comment">//如果是$&#123;&#125;会直接不解析，等待执行的时候直接赋值</span></span><br><span class="line">      sqlSource = <span class="keyword">new</span> DynamicSqlSource(configuration, rootSqlNode);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//用占位符方式来解析  #&#123;&#125; --&gt; ?</span></span><br><span class="line">      sqlSource = <span class="keyword">new</span> RawSqlSource(configuration, rootSqlNode, parameterType);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sqlSource;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> MixedSqlNode <span class="title">parseDynamicTags</span><span class="params">(XNode node)</span> </span>&#123;</span><br><span class="line">    List&lt;SqlNode&gt; contents = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//获取select标签下的子标签</span></span><br><span class="line">    NodeList children = node.getNode().getChildNodes();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; children.getLength(); i++) &#123;</span><br><span class="line">      XNode child = node.newXNode(children.item(i));</span><br><span class="line">      <span class="keyword">if</span> (child.getNode().getNodeType() == Node.CDATA_SECTION_NODE || child.getNode().getNodeType() == Node.TEXT_NODE) &#123;</span><br><span class="line">          <span class="comment">//如果是查询</span></span><br><span class="line">        <span class="comment">//获取原生SQL语句 这里是 select * from test where id = #&#123;id&#125;</span></span><br><span class="line">        String data = child.getStringBody(<span class="string">""</span>);</span><br><span class="line">        TextSqlNode textSqlNode = <span class="keyword">new</span> TextSqlNode(data);</span><br><span class="line">        <span class="comment">//检查sql是否是$&#123;&#125;</span></span><br><span class="line">        <span class="keyword">if</span> (textSqlNode.isDynamic()) &#123;</span><br><span class="line">            <span class="comment">//如果是$&#123;&#125;那么直接不解析</span></span><br><span class="line">          contents.add(textSqlNode);</span><br><span class="line">          isDynamic = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果不是，则直接生成静态SQL</span></span><br><span class="line">            <span class="comment">//#&#123;&#125; -&gt; ?</span></span><br><span class="line">          contents.add(<span class="keyword">new</span> StaticTextSqlNode(data));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (child.getNode().getNodeType() == Node.ELEMENT_NODE) &#123; <span class="comment">// issue #628</span></span><br><span class="line">          <span class="comment">//如果是增删改</span></span><br><span class="line">        String nodeName = child.getNode().getNodeName();</span><br><span class="line">        NodeHandler handler = nodeHandlerMap.get(nodeName);</span><br><span class="line">        <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Unknown element &lt;"</span> + nodeName + <span class="string">"&gt; in SQL statement."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        handler.handleNode(child, contents);</span><br><span class="line">        isDynamic = <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MixedSqlNode(contents);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>进入<code>sqlSource = new RawSqlSource()</code>&gt;<code>sqlSourceParser.parse()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*从上面的代码段到这一段中间需要经过很多代码，就不一段一段贴了*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SqlSource <span class="title">parse</span><span class="params">(String originalSql, Class&lt;?&gt; parameterType, Map&lt;String, Object&gt; additionalParameters)</span> </span>&#123;</span><br><span class="line">    ParameterMappingTokenHandler handler = <span class="keyword">new</span> ParameterMappingTokenHandler(configuration, parameterType, additionalParameters);</span><br><span class="line">    <span class="comment">//这里会生成一个GenericTokenParser，传入#&#123;&#125;作为开始和结束，然后调用其parse方法，即可将#&#123;&#125;换为 ?</span></span><br><span class="line">    GenericTokenParser parser = <span class="keyword">new</span> GenericTokenParser(<span class="string">"#&#123;"</span>, <span class="string">"&#125;"</span>, handler);</span><br><span class="line">    <span class="comment">//这里可以解析#&#123;&#125; 将其替换为?</span></span><br><span class="line">    String sql = parser.parse(originalSql);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StaticSqlSource(configuration, sql, handler.getParameterMappings());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//经过一段复杂的解析过程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">parse</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (text == <span class="keyword">null</span> || text.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// search open token</span></span><br><span class="line">    <span class="keyword">int</span> start = text.indexOf(openToken);</span><br><span class="line">    <span class="keyword">if</span> (start == -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> text;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>[] src = text.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> offset = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span> StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    StringBuilder expression = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//遍历里面所有的#&#123;&#125; select ?  ,#&#123;id1&#125; $&#123;&#125;</span></span><br><span class="line">    <span class="keyword">while</span> (start &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (start &gt; <span class="number">0</span> &amp;&amp; src[start - <span class="number">1</span>] == <span class="string">'\') &#123;</span></span><br><span class="line"><span class="string">        // this open token is escaped. remove the backslash and continue.</span></span><br><span class="line"><span class="string">        builder.append(src, offset, start - offset - 1).append(openToken);</span></span><br><span class="line"><span class="string">        offset = start + openToken.length();</span></span><br><span class="line"><span class="string">      &#125; else &#123;</span></span><br><span class="line"><span class="string">        // found open token. let'</span>s search close token.</span><br><span class="line">        <span class="keyword">if</span> (expression == <span class="keyword">null</span>) &#123;</span><br><span class="line">          expression = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          expression.setLength(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        builder.append(src, offset, start - offset);</span><br><span class="line">        offset = start + openToken.length();</span><br><span class="line">        <span class="keyword">int</span> end = text.indexOf(closeToken, offset);</span><br><span class="line">        <span class="keyword">while</span> (end &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (end &gt; offset &amp;&amp; src[end - <span class="number">1</span>] == <span class="string">'\') &#123;</span></span><br><span class="line"><span class="string">            // this close token is escaped. remove the backslash and continue.</span></span><br><span class="line"><span class="string">            expression.append(src, offset, end - offset - 1).append(closeToken);</span></span><br><span class="line"><span class="string">            offset = end + closeToken.length();</span></span><br><span class="line"><span class="string">            end = text.indexOf(closeToken, offset);</span></span><br><span class="line"><span class="string">          &#125; else &#123;</span></span><br><span class="line"><span class="string">            expression.append(src, offset, end - offset);</span></span><br><span class="line"><span class="string">            break;</span></span><br><span class="line"><span class="string">          &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        if (end == -1) &#123;</span></span><br><span class="line"><span class="string">          // close token was not found.</span></span><br><span class="line"><span class="string">          builder.append(src, start, src.length - start);</span></span><br><span class="line"><span class="string">          offset = src.length;</span></span><br><span class="line"><span class="string">        &#125; else &#123;</span></span><br><span class="line"><span class="string">            //使用占位符 ?</span></span><br><span class="line"><span class="string">            //注意handler.handleToken()方法，这个方法是核心</span></span><br><span class="line"><span class="string">          builder.append(handler.handleToken(expression.toString()));</span></span><br><span class="line"><span class="string">          offset = end + closeToken.length();</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">      start = text.indexOf(openToken, offset);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    if (offset &lt; src.length) &#123;</span></span><br><span class="line"><span class="string">      builder.append(src, offset, src.length - offset);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    return builder.toString();</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//BindingTokenParser 的handleToken</span></span><br><span class="line"><span class="string">//当扫描到$&#123;&#125;的时候调用此方法  其实就是不解析 在运行时候在替换成具体的值</span></span><br><span class="line"><span class="string">@Override</span></span><br><span class="line"><span class="string">public String handleToken(String content) &#123;</span></span><br><span class="line"><span class="string">  this.isDynamic = true;</span></span><br><span class="line"><span class="string">  return null;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">//ParameterMappingTokenHandler的handleToken</span></span><br><span class="line"><span class="string">//全局扫描#&#123;id&#125; 字符串之后  会把里面所有 #&#123;&#125; 调用handleToken 替换为?</span></span><br><span class="line"><span class="string">@Override</span></span><br><span class="line"><span class="string">public String handleToken(String content) &#123;</span></span><br><span class="line"><span class="string">      parameterMappings.add(buildParameterMapping(content));</span></span><br><span class="line"><span class="string">      return "?";</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="4、构建总结">4、构建总结</h2><h3 id="4-1-总结">4.1 总结</h3><p>MyBatis需要做的就是，先判断这个节点是用来干什么的，然后再获取这个节点的id、parameterType、resultType等属性，封装成一个MappedStatement对象，由于这个对象很复杂，所以MyBatis使用了构造者模式来构造这个对象，最后当MappedStatement对象构造完成后，将其封装到Configuration对象中。</p><p><strong>MyBatis需要对配置文件进行解析，最终会解析成一个Configuration对象</strong></p><ul><li>Configuration对象，保存了mybatis-config.xml的配置信息。</li><li>MappedStatement，保存了XXXMapper.xml的配置信息。</li></ul><p>但是最终MappedStatement对象会封装到Configuration对象中，合二为一，成为一个单独的对象，也就是Configuration</p><p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/20220301/20220301215916.png" alt></p><h3 id="4-2-面试回答">4.2 面试回答</h3><p>我在开发xxxx项目的时候、使用Mybatis开发项目，我对Mybatis的认识是:它其实是一个orm持久层框架，其实就对jdbc一个封装而得的框架，使用好处其实就可以把jdbc从连接开辟事务管理以及连接关闭和sql执行，对数据的映射pojo整个过程进行一个封装而已。它的整个执行的过程:</p><ul><li>首先会引入mybatis依赖，然后会定义个xml核心配置文件放入类路径resouces，这个文件里面就描述了数据源、mapper映射、别名的映射、数据类型转换、插件、属性配置等。定义好以后，那么接下就是创建一个SqlSessionFactory对象，但是在创建这个对象之前，我们会进行xml文件的解析，解析过程中会使用SqlSessionFacotoryBuilder里面提供了一个build方法。这个方法的做了一个非常核心的事情:初始化Configuration对象，并且把对应类的属性的对象全部初始化，并且解析核心xml文件</li><li>把解析核心的xml配置文件的内容放入到Configuration对象中属性中，其中就包括别名的映射，在初始化阶段别名映射会自动注册一些常用的别名。如果我们自己也配置也会自动注册到<br>Configuration对象的TypeAliasRegistry的map中</li><li>并且把在配置文件中的数据源和事务解析以后放入到Environment，给后续的执行，提供数据链接和事务管理</li><li>然后在解析xxxMapper.xml配置文件，根据配置文件解析的规则，会解析里面对应的节点。比如:&lt;select&lt;update&lt;insert &lt;delete&lt;dql &lt;cache&lt;cache-ref &lt;resultMap等，然后把每个解析的节点放入到一个叫MapperStament对象，sql语句就放入到这个对象SqlSource中</li><li>并且把解析的每一个节点对应的MapperStatment同时放入到Configuration全局的<br>Map (mapperedStatments）中，以节点的id和命名空间+id做为key，以MapperStatement对象做value，给后续执行提供一个参考和方向</li></ul><h1>三、Mybatis的执行</h1><h2 id="1、SqlSession对象生成">1、SqlSession对象生成</h2><h3 id="1-1-Xml对象直接生成">1.1 Xml对象直接生成</h3><p><strong>核心</strong></p><p>将SqlSessionFactoryBuilder中通过build方法创建和装配好Configuration对象通过构造函数进行下传，传递到SqlSession中，最后开辟SqlSession会话对象</p><p><strong>源码分析</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 加载mybatis框架主配置文件</span></span><br><span class="line">    String resource = <span class="string">"mybatis-config.xml"</span>;</span><br><span class="line">    InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">    <span class="comment">// 读取解析配置文件内容，创建SqlSessionFacory</span></span><br><span class="line">    SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">    <span class="comment">/*---------开始注入执行------------*/</span></span><br><span class="line">    <span class="comment">// 获取sqlSession对象</span></span><br><span class="line">    SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">    <span class="comment">// 执行数据库操作</span></span><br><span class="line">    List&lt;Employee&gt; list = sqlSession.selectList(<span class="string">"test.getEmp"</span>);</span><br><span class="line">    System.out.println(list);</span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里进入<code>SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);</code>方法后，Configuration是<code>DefaultSqlSessionFactory</code>的一个属性。而<code>SqlSessionFactoryBuilder</code>在<code>build</code>方法中实际上就是调用XMLConfigBuilder对xml文件进行解析生成<code>Configuration</code>对象，然后注入到SqlSessionFactory中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(InputStream inputStream, String environment, Properties properties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//解析config.xml(mybatis解析xml是用的  java dom)     dom4j sax...</span></span><br><span class="line">      XMLConfigBuilder parser = <span class="keyword">new</span> XMLConfigBuilder(inputStream, environment, properties);</span><br><span class="line">      <span class="comment">//parse(): 解析config.xml里面的节点</span></span><br><span class="line">      <span class="keyword">return</span> build(parser.parse());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error building SqlSession."</span>, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      ErrorContext.instance().reset();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        inputStream.close();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// Intentionally ignore. Prefer previous error.</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(Configuration config)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//注入到SqlSessionFactory</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSessionFactory(config);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultSqlSessionFactory</span><span class="params">(Configuration configuration)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.configuration = configuration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过调用<code>sqlSessionFactory.openSession();</code>方法来获取<code>SqlSession</code>对象，而openSession中实际上就是<strong>对SqlSession做了进一步的加工封装，包括增加了事务、执行器等</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SqlSession <span class="title">openSessionFromDataSource</span><span class="params">(ExecutorType execType, TransactionIsolationLevel level, <span class="keyword">boolean</span> autoCommit)</span> </span>&#123;</span><br><span class="line">    Transaction tx = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//对SqlSession对象进行进一步加工封装</span></span><br><span class="line">        <span class="keyword">final</span> Environment environment = configuration.getEnvironment();</span><br><span class="line">        <span class="keyword">final</span> TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);</span><br><span class="line">        tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);</span><br><span class="line">        <span class="keyword">final</span> Executor executor = configuration.newExecutor(tx, execType);</span><br><span class="line">        <span class="comment">//构建SqlSession对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSession(configuration, executor, autoCommit);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        closeTransaction(tx); <span class="comment">// may have fetched a connection so lets call close()</span></span><br><span class="line">        <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error opening session.  Cause: "</span> + e, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-mapper-代理对象的生成">1.2 mapper 代理对象的生成</h3><p>首先需要修改部分文件内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建EmployeeMapper、代理mapper </span></span><br><span class="line"><span class="keyword">package</span> org.demo.mapper;</span><br><span class="line"><span class="keyword">import</span> org.demo.po.Employee;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EmployeeMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;Employee&gt; <span class="title">getEmp</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同时修改EmployeeMapper.xml的命名空间namespace为</span></span><br><span class="line"><span class="comment">//&lt;mapper namespace="org.demo.mapper.EmployeeMapper"&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//最后修改测试类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 加载mybatis框架主配置文件</span></span><br><span class="line">    String resource = <span class="string">"mybatis-config.xml"</span>;</span><br><span class="line">    InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">    <span class="comment">// 读取解析配置文件内容，创建SqlSessionFacory</span></span><br><span class="line">    SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">    <span class="comment">// 获取sqlSession对象</span></span><br><span class="line">    SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">    <span class="comment">//获取Mapper</span></span><br><span class="line">    EmployeeMapper mapper = sqlSession.getMapper(EmployeeMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">// 执行数据库操作</span></span><br><span class="line">    List&lt;Employee&gt; list = mapper.getEmp();</span><br><span class="line">    System.out.println(list);</span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>源码分析</strong></p><p>从SqlSession的getMapper()方法进入，可以看到这里mapperProxyFactory对象会从一个叫做knownMappers的对象中以<strong>type</strong>为key取出值，这个knownMappers是一个HashMap，存放了我们的EmployeeMapper对象，而这里的type，就是我们上面写的Mapper接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//getMapper方法最终会调用到这里，这个是MapperRegistry的getMapper方法</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//MapperProxyFactory  在解析的时候会生成一个map  map中会有我们的DemoMapper的Class</span></span><br><span class="line">    <span class="keyword">final</span> MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);</span><br><span class="line">    <span class="keyword">if</span> (mapperProxyFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Type "</span> + type + <span class="string">" is not known to the MapperRegistry."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> mapperProxyFactory.newInstance(sqlSession);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Error getting mapper instance. Cause: "</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于knownMappers生成，在configuration对象在解析的时候，会调用parse()方法，这个方法内部有一个<code>bindMapperForNamespace</code>方法，而就是这个方法帮我们完成了knownMappers的生成，并且将我们的Mapper接口put进去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//判断文件是否之前解析过</span></span><br><span class="line">    <span class="keyword">if</span> (!configuration.isResourceLoaded(resource)) &#123;</span><br><span class="line">        <span class="comment">//解析mapper文件</span></span><br><span class="line">      configurationElement(parser.evalNode(<span class="string">"/mapper"</span>));</span><br><span class="line">      configuration.addLoadedResource(resource);</span><br><span class="line">      <span class="comment">//这里：绑定Namespace里面的Class对象*</span></span><br><span class="line">      bindMapperForNamespace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重新解析之前解析不了的节点</span></span><br><span class="line">    parsePendingResultMaps();</span><br><span class="line">    parsePendingCacheRefs();</span><br><span class="line">    parsePendingStatements();</span><br><span class="line">  &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bindMapperForNamespace</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String namespace = builderAssistant.getCurrentNamespace();</span><br><span class="line">    <span class="keyword">if</span> (namespace != <span class="keyword">null</span>) &#123;</span><br><span class="line">      Class&lt;?&gt; boundType = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        boundType = Resources.classForName(namespace);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (boundType != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!configuration.hasMapper(boundType)) &#123;</span><br><span class="line">          configuration.addLoadedResource(<span class="string">"namespace:"</span> + namespace);</span><br><span class="line">            <span class="comment">//这里将接口class传入</span></span><br><span class="line">          configuration.addMapper(boundType);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addMapper</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (type.isInterface()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (hasMapper(type)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Type "</span> + type + <span class="string">" is already known to the MapperRegistry."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">boolean</span> loadCompleted = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//这里将接口信息put进konwMappers。</span></span><br><span class="line">        knownMappers.put(type, <span class="keyword">new</span> MapperProxyFactory&lt;&gt;(type));</span><br><span class="line">        MapperAnnotationBuilder parser = <span class="keyword">new</span> MapperAnnotationBuilder(config, type);</span><br><span class="line">        parser.parse();</span><br><span class="line">        loadCompleted = <span class="keyword">true</span>;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!loadCompleted) &#123;</span><br><span class="line">          knownMappers.remove(type);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在getMapper之后，获取到的是一个Class，之后的代码就简单了，就是生成标准的代理类了，调用newInstance()方法。到这里，就完成了<strong>代理对象</strong>（<strong>MapperProxy</strong>）的创建，很明显的，MyBatis的底层就是对我们的接口进行代理类的实例化，从而操作数据库。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//首先会调用这个newInstance方法</span></span><br><span class="line">    <span class="comment">//动态代理逻辑在MapperProxy里面</span></span><br><span class="line">    <span class="keyword">final</span> MapperProxy&lt;T&gt; mapperProxy = <span class="keyword">new</span> MapperProxy&lt;&gt;(sqlSession, mapperInterface, methodCache);</span><br><span class="line">    <span class="comment">//通过这里调用下面的newInstance方法</span></span><br><span class="line">    <span class="keyword">return</span> newInstance(mapperProxy);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">newInstance</span><span class="params">(MapperProxy&lt;T&gt; mapperProxy)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//jdk自带的动态代理</span></span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), <span class="keyword">new</span> Class[] &#123; mapperInterface &#125;, mapperProxy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看动态代理调用的方法逻辑，进入MapperProxy类，发现实现了<strong>InvocationHandler</strong>接口。</p><p>在方法开始代理之前，首先会先判断是否调用了Object类的方法，如果是，那么MyBatis不会去改变其行为，直接返回，如果是默认方法，则绑定到代理对象中然后调用，如果都不是，那么就是我们定义的mapper接口方法了，那么就开始执行。执行方法需要一个<strong>MapperMethod</strong>对象，这个对象是MyBatis执行方法逻辑使用的，MyBatis这里获取MapperMethod对象的方式是，首先去<strong>方法缓存</strong>中看看是否已经存在了，如果不存在则new一个然后存入缓存中，因为创建代理对象是十分消耗资源的操作。总而言之，这里会得到一个MapperMethod对象，然后通过MapperMethod的excute()方法，来真正地执行逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperProxy</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InvocationHandler</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MapperProxy</span><span class="params">(SqlSession sqlSession, Class&lt;T&gt; mapperInterface, Map&lt;Method, MapperMethod&gt; methodCache)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//构造</span></span><br><span class="line">    <span class="keyword">this</span>.sqlSession = sqlSession;</span><br><span class="line">    <span class="keyword">this</span>.mapperInterface = mapperInterface;</span><br><span class="line">    <span class="keyword">this</span>.methodCache = methodCache;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="comment">//这就是一个很标准的JDK动态代理了</span></span><br><span class="line">    <span class="comment">//执行的时候会调用invoke方法</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (Object<span class="class">.<span class="keyword">class</span>.<span class="title">equals</span>(<span class="title">method</span>.<span class="title">getDeclaringClass</span>())) </span>&#123;</span><br><span class="line">          <span class="comment">//判断方法所属的类</span></span><br><span class="line">          <span class="comment">//是不是调用的Object默认的方法</span></span><br><span class="line">          <span class="comment">//如果是  则不代理，不改变原先方法的行为</span></span><br><span class="line">        <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.isDefault()) &#123;</span><br><span class="line">          <span class="comment">//对于默认方法的处理</span></span><br><span class="line">          <span class="comment">//判断是否为default方法，即接口中定义的默认方法。</span></span><br><span class="line">          <span class="comment">//如果是接口中的默认方法则把方法绑定到代理对象中然后调用。</span></span><br><span class="line">          <span class="comment">//这里不详细说</span></span><br><span class="line">        <span class="keyword">if</span> (privateLookupInMethod == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> invokeDefaultMethodJava8(proxy, method, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> invokeDefaultMethodJava9(proxy, method, args);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果不是默认方法，则真正开始执行MyBatis代理逻辑。</span></span><br><span class="line">    <span class="comment">//获取MapperMethod代理对象</span></span><br><span class="line">    <span class="keyword">final</span> MapperMethod mapperMethod = cachedMapperMethod(method);</span><br><span class="line">    <span class="comment">//执行</span></span><br><span class="line">    <span class="keyword">return</span> mapperMethod.execute(sqlSession, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> MapperMethod <span class="title">cachedMapperMethod</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//动态代理会有缓存，computeIfAbsent 如果缓存中有则直接从缓存中拿</span></span><br><span class="line">      <span class="comment">//如果缓存中没有，则new一个然后放入缓存中</span></span><br><span class="line">      <span class="comment">//因为动态代理是很耗资源的</span></span><br><span class="line">    <span class="keyword">return</span> methodCache.computeIfAbsent(method,</span><br><span class="line">        k -&gt; <span class="keyword">new</span> MapperMethod(mapperInterface, method, sqlSession.getConfiguration()));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后执行逻辑，这里首先会判断SQL的类型：SELECT|DELETE|UPDATE|INSERT，判断SQL类型为SELECT之后，就开始判断返回值类型，根据不同的情况做不同的操作。然后开始获取参数&gt;执行SQL</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//execute() 这里是真正执行SQL的地方</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">execute</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断是哪一种SQL语句</span></span><br><span class="line">    Object result;</span><br><span class="line">    <span class="keyword">switch</span> (command.getType()) &#123;</span><br><span class="line">      <span class="keyword">case</span> INSERT: &#123;</span><br><span class="line">        Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = rowCountResult(sqlSession.insert(command.getName(), param));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> UPDATE: &#123;</span><br><span class="line">        Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = rowCountResult(sqlSession.update(command.getName(), param));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> DELETE: &#123;</span><br><span class="line">        Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = rowCountResult(sqlSession.delete(command.getName(), param));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> SELECT:</span><br><span class="line">          <span class="comment">//我们的例子是查询</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">//判断是否有返回值</span></span><br><span class="line">        <span class="keyword">if</span> (method.returnsVoid() &amp;&amp; method.hasResultHandler()) &#123;</span><br><span class="line">            <span class="comment">//无返回值</span></span><br><span class="line">          executeWithResultHandler(sqlSession, args);</span><br><span class="line">          result = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMany()) &#123;</span><br><span class="line">            <span class="comment">//返回值多行 这里调用这个方法</span></span><br><span class="line">          result = executeForMany(sqlSession, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMap()) &#123;</span><br><span class="line">            <span class="comment">//返回Map</span></span><br><span class="line">          result = executeForMap(sqlSession, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsCursor()) &#123;</span><br><span class="line">            <span class="comment">//返回Cursor</span></span><br><span class="line">          result = executeForCursor(sqlSession, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">          result = sqlSession.selectOne(command.getName(), param);</span><br><span class="line">          <span class="keyword">if</span> (method.returnsOptional()</span><br><span class="line">              &amp;&amp; (result == <span class="keyword">null</span> || !method.getReturnType().equals(result.getClass()))) &#123;</span><br><span class="line">            result = Optional.ofNullable(result);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> FLUSH:</span><br><span class="line">        result = sqlSession.flushStatements();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Unknown execution method for: "</span> + command.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span> &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Mapper method '"</span> + command.getName()</span><br><span class="line">          + <span class="string">" attempted to return null from a method with a primitive return type ("</span> + method.getReturnType() + <span class="string">")."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回值多行 这里调用这个方法</span></span><br><span class="line"><span class="keyword">private</span> &lt;E&gt; <span class="function">Object <span class="title">executeForMany</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//返回值多行时执行的方法</span></span><br><span class="line">    List&lt;E&gt; result;</span><br><span class="line">    <span class="comment">//param是我们传入的参数，如果传入的是Map，那么这个实际上就是Map对象</span></span><br><span class="line">    Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">    <span class="keyword">if</span> (method.hasRowBounds()) &#123;</span><br><span class="line">        <span class="comment">//如果有分页</span></span><br><span class="line">      RowBounds rowBounds = method.extractRowBounds(args);</span><br><span class="line">        <span class="comment">//执行SQL的位置</span></span><br><span class="line">      result = sqlSession.selectList(command.getName(), param, rowBounds);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果没有</span></span><br><span class="line">        <span class="comment">//执行SQL的位置</span></span><br><span class="line">      result = sqlSession.selectList(command.getName(), param);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// issue #510 Collections &amp; arrays support</span></span><br><span class="line">    <span class="keyword">if</span> (!method.getReturnType().isAssignableFrom(result.getClass())) &#123;</span><br><span class="line">      <span class="keyword">if</span> (method.getReturnType().isArray()) &#123;</span><br><span class="line">        <span class="keyword">return</span> convertToArray(result);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> convertToDeclaredCollection(sqlSession.getConfiguration(), result);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  获取参数名的方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getNamedParams</span><span class="params">(Object[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> paramCount = names.size();</span><br><span class="line">    <span class="keyword">if</span> (args == <span class="keyword">null</span> || paramCount == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果传过来的参数是空</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hasParamAnnotation &amp;&amp; paramCount == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//如果参数上没有加注解例如@Param，且参数只有一个，则直接返回参数</span></span><br><span class="line">      <span class="keyword">return</span> args[names.firstKey()];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果参数上加了注解，或者参数有多个。</span></span><br><span class="line">          <span class="comment">//那么MyBatis会封装参数为一个Map，但是要注意，由于jdk的原因，我们只能获取到参数下标和参数名，但是参数名会变成arg0,arg1.</span></span><br><span class="line">        <span class="comment">//所以传入多个参数的时候，最好加@Param，否则假设传入多个String，会造成#&#123;&#125;获取不到值的情况</span></span><br><span class="line">      <span class="keyword">final</span> Map&lt;String, Object&gt; param = <span class="keyword">new</span> ParamMap&lt;&gt;();</span><br><span class="line">      <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : names.entrySet()) &#123;</span><br><span class="line">          <span class="comment">//entry.getValue 就是参数名称</span></span><br><span class="line">        param.put(entry.getValue(), args[entry.getKey()]);</span><br><span class="line">        <span class="comment">//如果传很多个String，也可以使用param1，param2.。。</span></span><br><span class="line">        <span class="comment">// add generic param names (param1, param2, ...)</span></span><br><span class="line">        <span class="keyword">final</span> String genericParamName = GENERIC_NAME_PREFIX + String.valueOf(i + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// ensure not to overwrite parameter named with @Param</span></span><br><span class="line">        <span class="keyword">if</span> (!names.containsValue(genericParamName)) &#123;</span><br><span class="line">          param.put(genericParamName, args[entry.getKey()]);</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> param;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="2、执行SQL前述">2、执行SQL前述</h2><p>进入<code>sqlSession.selectList(&quot;test.getEmp&quot;);</code>方法，可以发现在调用sqlsession执行的selectList、insert、update、delete的时候，其实就是根据执行的statement名字，到Configuration的mapperStatements对应的map中去找到有没有一个对应的 MapperStatement对象，如果找到就返回这个对象，然后给后续执行一个依据和参考</p><p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/20220301/20220301215925.png" alt></p><h2 id="3、执行SQL语句——执行器">3、执行SQL语句——执行器</h2><h3 id="3-1-执行架构">3.1 执行架构</h3><blockquote><p><a href="https://zhuanlan.zhihu.com/p/299020451" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/299020451</a></p></blockquote><p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/20220301/20220301215929.png" alt></p><ul><li><strong>执行器</strong>：Executor, 处理流程的头部，主要负责缓存、事务、批处理。一个执行可用于执行多条SQL。它和SQL处理器是1对N的关系</li><li><strong>Sql处理器</strong>：StatementHandler 用于和JDBC打道，比如基于SQL声明Statement、设置参数、然后就是调用Statement来执行。它只能用于一次SQL的执行</li><li><strong>参数处理器</strong>：ParameterHandler，用于解析SQL参数，并基于参数映射，填充至PrepareStatement。同样它只能用于一次SQL的执行</li><li><strong>结果集处理器</strong>：ResultSetHandler，用于读取ResultSet 结果集，并基于结果集映射，封装成JAVA对象。他也只用用于一次SQL的执行</li></ul><h3 id="3-2-执行器Executor">3.2 执行器Executor</h3><p>执行器的实现有三种：SimpleExecute、ReuseExecute和BatchExecute，这三种执行器有个抽象的基础执行器BaseExecutor，用于<strong>维护缓存和事务</strong>；此外通过装饰器形式添加了一个缓存执行器CachingExecutor，用于<strong>处理二级缓存</strong></p><ul><li><strong>SimpleExecute 简单执行器(默认)</strong><br>SimpleExecutor是执行器的默认实现，主要完成了“执行”功能，在利用StatementHandler 完成。每次调用执行方法 都会构建一个StatementHandler，并预行参数，然后执行<br>默认情况是executor是CachingExecutor。这个执行器是二级缓存的执行器，如果在配置文件xxxxMapper.xml文件中申明了<code>&lt;cache/&gt;</code>节点的话，就是使用CachingExecutor；如果没有，就会委托SimpleExecutor(默认类型是simple，在configuration创建的时候指定)执行器去执行你的SQL语句，然后这里会执行的结果放入loaclCache一级缓存中。<br><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/20220301/20220301215932.png" alt></li><li><strong>ReuseExecute 可重用执行器</strong><br>ReuseExecutor 区别在于他会将在会话期间内的Statement进行缓存，并使用SQL语句作为Key。所以当执行下一请求的时候，不在重复构建Statement，而是从缓存中取出并设置参数，然后执行(参数不同也可以重用)</li><li><strong>BatchExecute 批处理执行器</strong><br>BatchExecutor 顾名思议，它就是用来作批处理的。但会将所 有SQL请求集中起来，最后调用Executor.flushStatements() 方法时一次性将所有请求发送至数据库</li></ul><h3 id="3-3-SimpleExecute-简单执行器源码分析-重点✨">3.3 **SimpleExecute **简单执行器源码分析(重点✨)</h3><p>执行SQL的核心方法就是selectList，即使是selectOne，底层实际上也是调用了selectList方法，然后取第一个而已</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">selectList</span><span class="params">(String statement, Object parameter, RowBounds rowBounds)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//MappedStatement:解析XML时生成的对象， 解析某一个SQL  会封装成MappedStatement，里面存放了我们所有执行SQL所需要的信息</span></span><br><span class="line">      MappedStatement ms = configuration.getMappedStatement(statement);</span><br><span class="line">      <span class="comment">//查询,通过executor</span></span><br><span class="line">      <span class="keyword">return</span> executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error querying database.  Cause: "</span> + e, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>selectList内部调用了<strong>Executor</strong>对象执行SQL语句，首先进入的是CachingExecutor执行器，若没有开启二级缓存，那么委托简单执行器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="comment">//获取sql语句</span></span><br><span class="line">    BoundSql boundSql = ms.getBoundSql(parameterObject);</span><br><span class="line">    <span class="comment">//生成一个缓存的key  </span></span><br><span class="line">    <span class="comment">//key = ms.id + rowBounds.getOffset()+rowBounds.getOffset()+sql+参数+上下文坏境的id</span></span><br><span class="line">    <span class="comment">//这里是-1954235241:110303602:test.getEmp:0:2147483647:select * from employee:development</span></span><br><span class="line">    CacheKey key = createCacheKey(ms, parameterObject, rowBounds, boundSql);</span><br><span class="line">    <span class="keyword">return</span> query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="comment">//二级缓存查询</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">      <span class="comment">//二级缓存的Cache</span></span><br><span class="line">    Cache cache = ms.getCache();</span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//如果Cache不为空则进入</span></span><br><span class="line">      <span class="comment">//如果有需要的话，就刷新缓存（有些缓存是定时刷新的，需要用到这个）</span></span><br><span class="line">      flushCacheIfRequired(ms);</span><br><span class="line">      <span class="comment">//如果这个statement用到了缓存（二级缓存的作用域是namespace，也可以理解为这里的ms）</span></span><br><span class="line">      <span class="keyword">if</span> (ms.isUseCache() &amp;&amp; resultHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ensureNoOutParams(ms, boundSql);</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        <span class="comment">//先从缓存拿</span></span><br><span class="line">        List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key);</span><br><span class="line">        <span class="keyword">if</span> (list == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果缓存的数据等于空，那么查询数据库</span></span><br><span class="line">          list = delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">          <span class="comment">//查询完毕后将数据放入二级缓存</span></span><br><span class="line">          tcm.putObject(cache, key, list); <span class="comment">// issue #578 and #116</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回</span></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果cache根本就不存在，那么直接查询一级缓存。并委托delegate(默认简单执行器)查询</span></span><br><span class="line">    <span class="keyword">return</span> delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先MyBatis在查询时，不会直接查询数据库，而是会进行<strong>二级缓存</strong>的查询，由于二级缓存的作用域是namespace，也可以理解为一个mapper，所以还会判断一下这个mapper是否开启了二级缓存，如果没有开启，则进入<strong>一级缓存</strong>继续查询。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一级缓存查询</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">"executing a query"</span>).object(ms.getId());</span><br><span class="line">    <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"Executor was closed."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (queryStack == <span class="number">0</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;</span><br><span class="line">      clearLocalCache();</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;E&gt; list;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">//查询栈+1</span></span><br><span class="line">      queryStack++;</span><br><span class="line">      <span class="comment">//一级缓存</span></span><br><span class="line">      list = resultHandler == <span class="keyword">null</span> ? (List&lt;E&gt;) localCache.getObject(key) : <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">//对于存储过程有输出资源的处理</span></span><br><span class="line">        handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//如果缓存为空，则从数据库拿</span></span><br><span class="line">        list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       <span class="comment">//查询栈-1</span></span><br><span class="line">      queryStack--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (queryStack == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (DeferredLoad deferredLoad : deferredLoads) &#123;</span><br><span class="line">        deferredLoad.load();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// issue #601</span></span><br><span class="line">      deferredLoads.clear();</span><br><span class="line">      <span class="keyword">if</span> (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &#123;</span><br><span class="line">        <span class="comment">// issue #482</span></span><br><span class="line">        clearLocalCache();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//结果返回</span></span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一级缓存localCache里查到了，那么直接就返回结果了，如果一级缓存没有查到结果，那么最终会进入数据库进行查询</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据库查询</span></span><br><span class="line"><span class="keyword">private</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">queryFromDatabase</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    List&lt;E&gt; list;</span><br><span class="line">    <span class="comment">//先往一级缓存中put一个占位符</span></span><br><span class="line">    localCache.putObject(key, EXECUTION_PLACEHOLDER);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//调用doQuery方法查询数据库</span></span><br><span class="line">      list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      localCache.removeObject(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//往缓存中put真实数据</span></span><br><span class="line">    localCache.putObject(key, list);</span><br><span class="line">    <span class="keyword">if</span> (ms.getStatementType() == StatementType.CALLABLE) &#123;</span><br><span class="line">      localOutputParameterCache.putObject(key, parameter);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//SimpleExecutor类</span></span><br><span class="line"><span class="comment">//真实数据库查询</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Configuration configuration = ms.getConfiguration();</span><br><span class="line">      <span class="comment">//封装，StatementHandler也是MyBatis四大对象之一</span></span><br><span class="line">      StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">      <span class="comment">//#&#123;&#125; -&gt; ? 的SQL在这里初始化</span></span><br><span class="line">      stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">      <span class="comment">//参数赋值完毕之后，才会真正地查询。</span></span><br><span class="line">      <span class="keyword">return</span> handler.query(stmt, resultHandler);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      closeStatement(stmt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结，一级缓存和二级缓存的key是一样的，一级缓存默认开启，二级缓存需要设置开启。这里CacheExecutor使用的是装饰者模式，即在不改变原有类结构和继承的情况下，通过包装原对象去扩展一个新功能。</p><p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/20220301/20220301215936.png" alt></p><h2 id="4、执行SQL语句——数据库查询">4、执行SQL语句——数据库查询</h2><p>执行流程</p><p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/20220301/20220301215940.png" alt></p><h3 id="4-1-StatementHandler介绍">4.1 StatementHandler介绍</h3><p><strong>StatementHandler</strong>即为JDBC处理器，基于JDBC构建JDBC Statement并设置参数，然后执行Sql。每调用会话当中一次SQl，都会有与之相对应的且唯一的Statement实例，一个SQL请求会经过会话，然后是执行器，最由StatementHandler执行jdbc最终到达数据库，这三者之间比例是<strong>1：1：n</strong>。</p><p>StatementHandler接口定义了JDBC操作的相关方法如下，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于JDBC 声明Statement</span></span><br><span class="line"><span class="function">Statement <span class="title">prepare</span><span class="params">(Connection connection, Integer transactionTimeout)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"><span class="comment">// 为Statement 设置方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parameterize</span><span class="params">(Statement statement)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"><span class="comment">// 添加批处理（并非执行）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">batch</span><span class="params">(Statement statement)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"><span class="comment">// 执行update操作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(Statement statement)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"><span class="comment">// 执行query操作</span></span><br><span class="line">&lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> SQLException</span>;</span><br></pre></td></tr></table></figure><p><code>StatementHandler </code>有三个子类<code>SimpleStatementHandler</code>、<code>PreparedStatementHandler</code>、<code>CallableStatementHandler</code>，分别对应JDBC中的<strong>Statement</strong>、<strong>PreparedStatement</strong>、<strong>CallableStatement</strong>。</p><h3 id="4-2-参数处理和转换">4.2 参数处理和转换</h3><p>参数处理即将Java Bean转换成数据类型。总共要经历过三个步骤，<code>ParamNameResolver</code>(参数转换)、<code>ParameterHandler</code>(参数映射)、<code>TypeHandler</code>(参数赋值)</p><p><strong>参数转换</strong></p><p>所有转换逻辑均在ParamNameResolver中实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select</span>(<span class="string">"select * from employee where id = #&#123;id&#125;"</span>)</span><br><span class="line"><span class="meta">@Options</span></span><br><span class="line"><span class="function">Employee <span class="title">getEmpById</span><span class="params">(@Param(<span class="string">"id"</span>)</span> Integer id)</span>;</span><br></pre></td></tr></table></figure><ul><li>单个参数的情况下且没有设置@param注解会直接转换，勿略SQL中的引用名称</li><li>多个参数情况：优先采用@Param中设置的名称，如果没有则用参数序号代替 即&quot;param1、parm2等&quot;</li></ul><p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/20220301/20220301215943.png" alt></p><p><strong>参数映射</strong></p><p>映射是指Map中的key如何与SQL中绑定的参数相对应。以下这几种情况</p><ul><li><strong>单个原始类型</strong>：直接映射，勿略SQL中引用名称</li><li><strong>Map类型</strong>：基于Map key映射</li><li><strong>Object</strong>：基于属性名称映射,支持嵌套对象属性访问</li></ul><p><strong>参数赋值</strong></p><p>通过<code>TypeHandler </code>为<code>PrepareStatement</code>设置值，通常情况下一般的数据类型MyBatis都有与之相对应的TypeHandler</p><h3 id="4-3-结果集封装">4.3 结果集封装</h3><blockquote><p>MetaObject相当于一个工具类，里面还包括分词器等，可以参考<a href="https://blog.csdn.net/wangbo199308/article/details/120407062" target="_blank" rel="noopener">MetaObject详解</a></p></blockquote><p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/20220301/20220301215946.png" alt></p><p>读取ResultSet数据，并将每一行转换成相对应的对象。用户可在转换的过程当中可以通过<code>ResultContext</code>来控制是否要继续转换，转换后的对象都会暂存在<code>ResultHandler</code>中最后统一封装成list返回给调用方，结果集转换中99%的逻辑<code>DefaultResultSetHandler </code>中实现。整个流程可大致分为以下阶段：</p><ul><li>读取结果集</li><li>遍历结果集当中的行</li><li>创建对象</li><li>填充属性</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//PreparedStatementHandler，这里是真正查询</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  PreparedStatement ps = (PreparedStatement) statement;</span><br><span class="line">  ps.execute();</span><br><span class="line">  <span class="keyword">return</span> resultSetHandler.&lt;E&gt; handleResultSets(ps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在SQL执行阶段，MyBatis已经完成了对数据的查询，那么现在还存在最后一个问题，那就是结果集处理，换句话来说，就是将结果集封装成对象，这里会创建一个处理结果集的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DefaultResultSetHandler</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">handleResultSets</span><span class="params">(Statement stmt)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    ErrorContext.instance().activity(<span class="string">"handling results"</span>).object(mappedStatement.getId());</span><br><span class="line">    <span class="comment">//resultMap可以通过多个标签指定多个值，所以存在多个结果集</span></span><br><span class="line">    <span class="keyword">final</span> List&lt;Object&gt; multipleResults = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> resultSetCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//拿到当前第一个结果集</span></span><br><span class="line">    ResultSetWrapper rsw = getFirstResultSet(stmt);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拿到所有的resultMap</span></span><br><span class="line">    List&lt;ResultMap&gt; resultMaps = mappedStatement.getResultMaps();</span><br><span class="line">    <span class="comment">//resultMap的数量</span></span><br><span class="line">    <span class="keyword">int</span> resultMapCount = resultMaps.size();</span><br><span class="line">    validateResultMapsCount(rsw, resultMapCount);</span><br><span class="line">    <span class="comment">//循环处理每一个结果集</span></span><br><span class="line">    <span class="keyword">while</span> (rsw != <span class="keyword">null</span> &amp;&amp; resultMapCount &gt; resultSetCount) &#123;</span><br><span class="line">        <span class="comment">//开始封装结果集 list.get(index) 获取结果集</span></span><br><span class="line">      ResultMap resultMap = resultMaps.get(resultSetCount);</span><br><span class="line">      <span class="comment">//传入resultMap处理结果集 rsw 当前结果集（主线）</span></span><br><span class="line">      handleResultSet(rsw, resultMap, multipleResults, <span class="keyword">null</span>);</span><br><span class="line">      rsw = getNextResultSet(stmt);</span><br><span class="line">      cleanUpAfterHandlingResultSet();</span><br><span class="line">      resultSetCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String[] resultSets = mappedStatement.getResultSets();</span><br><span class="line">    <span class="keyword">if</span> (resultSets != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">while</span> (rsw != <span class="keyword">null</span> &amp;&amp; resultSetCount &lt; resultSets.length) &#123;</span><br><span class="line">        ResultMapping parentMapping = nextResultMaps.get(resultSets[resultSetCount]);</span><br><span class="line">        <span class="keyword">if</span> (parentMapping != <span class="keyword">null</span>) &#123;</span><br><span class="line">          String nestedResultMapId = parentMapping.getNestedResultMapId();</span><br><span class="line">          ResultMap resultMap = configuration.getResultMap(nestedResultMapId);</span><br><span class="line">          handleResultSet(rsw, resultMap, <span class="keyword">null</span>, parentMapping);</span><br><span class="line">        &#125;</span><br><span class="line">        rsw = getNextResultSet(stmt);</span><br><span class="line">        cleanUpAfterHandlingResultSet();</span><br><span class="line">        resultSetCount++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果只有一个结果集，那么从多结果集中取出第一个</span></span><br><span class="line">    <span class="keyword">return</span> collapseSingleResultList(multipleResults);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//处理结果集</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleResultSet</span><span class="params">(ResultSetWrapper rsw, ResultMap resultMap, List&lt;Object&gt; multipleResults, ResultMapping parentMapping)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">   <span class="comment">//处理结果集</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (parentMapping != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handleRowValues(rsw, resultMap, <span class="keyword">null</span>, RowBounds.DEFAULT, parentMapping);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (resultHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">//判断resultHandler是否为空，如果为空建立一个默认的。</span></span><br><span class="line">          <span class="comment">//结果集处理器</span></span><br><span class="line">          DefaultResultHandler defaultResultHandler = <span class="keyword">new</span> DefaultResultHandler(objectFactory);</span><br><span class="line">          <span class="comment">//处理行数据</span></span><br><span class="line">          handleRowValues(rsw, resultMap, defaultResultHandler, rowBounds, <span class="keyword">null</span>);</span><br><span class="line">          multipleResults.add(defaultResultHandler.getResultList());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          handleRowValues(rsw, resultMap, resultHandler, rowBounds, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// issue #228 (close resultsets)</span></span><br><span class="line">      <span class="comment">//关闭结果集</span></span><br><span class="line">      closeResultSet(rsw.getResultSet());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用handleRwoValues()方法进行行数据的处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//处理行数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRowValues</span><span class="params">(ResultSetWrapper rsw, ResultMap resultMap, ResultHandler&lt;?&gt; resultHandler, RowBounds rowBounds, ResultMapping parentMapping)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="comment">//是否存在内嵌的结果集</span></span><br><span class="line">    <span class="keyword">if</span> (resultMap.hasNestedResultMaps()) &#123;</span><br><span class="line">      ensureNoRowBounds();</span><br><span class="line">      checkResultHandler();</span><br><span class="line">      handleRowValuesForNestedResultMap(rsw, resultMap, resultHandler, rowBounds, parentMapping);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//不存在内嵌的结果集</span></span><br><span class="line">      handleRowValuesForSimpleResultMap(rsw, resultMap, resultHandler, rowBounds, parentMapping);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//没有内嵌结果集时调用</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleRowValuesForSimpleResultMap</span><span class="params">(ResultSetWrapper rsw, ResultMap resultMap, ResultHandler&lt;?&gt; resultHandler, RowBounds rowBounds, ResultMapping parentMapping)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    DefaultResultContext&lt;Object&gt; resultContext = <span class="keyword">new</span> DefaultResultContext&lt;&gt;();</span><br><span class="line">    <span class="comment">//获取当前结果集</span></span><br><span class="line">    ResultSet resultSet = rsw.getResultSet();</span><br><span class="line">    skipRows(resultSet, rowBounds);</span><br><span class="line">    <span class="keyword">while</span> (shouldProcessMoreRows(resultContext, rowBounds) &amp;&amp; !resultSet.isClosed() &amp;&amp; resultSet.next()) &#123;</span><br><span class="line">        <span class="comment">//遍历结果集</span></span><br><span class="line">      ResultMap discriminatedResultMap = resolveDiscriminatedResultMap(resultSet, resultMap, <span class="keyword">null</span>);</span><br><span class="line">      <span class="comment">//拿到行数据，将行数据包装成一个Object</span></span><br><span class="line">      Object rowValue = getRowValue(rsw, discriminatedResultMap, <span class="keyword">null</span>);</span><br><span class="line">      storeObject(resultHandler, resultContext, rowValue, parentMapping, resultSet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过每行的结果集，然后将其直接封装成一个Object对象</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">getRowValue</span><span class="params">(ResultSetWrapper rsw, ResultMap resultMap, String columnPrefix)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个空的Map存值</span></span><br><span class="line">    <span class="keyword">final</span> ResultLoaderMap lazyLoader = <span class="keyword">new</span> ResultLoaderMap();</span><br><span class="line">    <span class="comment">//创建一个空对象装行数据</span></span><br><span class="line">    Object rowValue = createResultObject(rsw, resultMap, lazyLoader, columnPrefix);</span><br><span class="line">    <span class="keyword">if</span> (rowValue != <span class="keyword">null</span> &amp;&amp; !hasTypeHandlerForResultObject(rsw, resultMap.getType()))&#123;</span><br><span class="line">        <span class="comment">//通过反射操作返回值</span></span><br><span class="line">        <span class="comment">//此时metaObject.originalObject = rowValue</span></span><br><span class="line">      <span class="keyword">final</span> MetaObject metaObject = configuration.newMetaObject(rowValue);</span><br><span class="line">      <span class="keyword">boolean</span> foundValues = <span class="keyword">this</span>.useConstructorMappings;</span><br><span class="line">      <span class="keyword">if</span> (shouldApplyAutomaticMappings(resultMap, <span class="keyword">false</span>)) &#123;</span><br><span class="line">    <span class="comment">//判断是否需要自动映射，默认自动映射，也可以通过resultMap节点上的autoMapping配置是否自动映射</span></span><br><span class="line">          <span class="comment">//这里是自动映射的操作。</span></span><br><span class="line">        foundValues = applyAutomaticMappings(rsw, resultMap, metaObject, columnPrefix) || foundValues;</span><br><span class="line">      &#125;</span><br><span class="line">      foundValues = applyPropertyMappings(rsw, resultMap, metaObject, lazyLoader, columnPrefix) || foundValues;</span><br><span class="line">      foundValues = lazyLoader.size() &gt; <span class="number">0</span> || foundValues;</span><br><span class="line">      rowValue = foundValues || configuration.isReturnInstanceForEmptyRow() ? rowValue : <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rowValue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在getRowValue中会判断是否是自动映射的，我们这里没有使用ResultMap，所以是自动映射（默认），那么就进入applyAutomaticMappings()方法，而这个方法就会完成对象的封装。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">applyAutomaticMappings</span><span class="params">(ResultSetWrapper rsw, ResultMap resultMap, MetaObject metaObject, String columnPrefix)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">      <span class="comment">//自动映射参数列表</span></span><br><span class="line">    List&lt;UnMappedColumnAutoMapping&gt; autoMapping = createAutomaticMappings(rsw, resultMap, metaObject, columnPrefix);</span><br><span class="line">      <span class="comment">//是否找到了该列</span></span><br><span class="line">    <span class="keyword">boolean</span> foundValues = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!autoMapping.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">      <span class="keyword">for</span> (UnMappedColumnAutoMapping mapping : autoMapping) &#123;</span><br><span class="line">          <span class="comment">//通过列名获取值</span></span><br><span class="line">        <span class="keyword">final</span> Object value = mapping.typeHandler.getResult(rsw.getResultSet(), mapping.column);</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果值不为空，说明找到了该列</span></span><br><span class="line">          foundValues = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span> || (configuration.isCallSettersOnNulls() &amp;&amp; !mapping.primitive)) &#123;</span><br><span class="line">          <span class="comment">// gcode issue #377, call setter on nulls (value is not 'found')</span></span><br><span class="line">            <span class="comment">//在这里赋值</span></span><br><span class="line">          metaObject.setValue(mapping.property, value);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> foundValues;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到这个方法会通过遍历参数列表从而通过<code>metaObject.setValue(mapping.property, value);</code>对返回对象进行赋值，所有的赋值操作在内部都是通过一个叫<code>ObjectWrapper</code>的对象完成的，先看看中代码的<code>metaObject.setValue()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MetaObject类，工具类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(String name, Object value)</span> </span>&#123;</span><br><span class="line">    PropertyTokenizer prop = <span class="keyword">new</span> PropertyTokenizer(name);</span><br><span class="line">    <span class="keyword">if</span> (prop.hasNext()) &#123;</span><br><span class="line">      MetaObject metaValue = metaObjectForProperty(prop.getIndexedName());</span><br><span class="line">      <span class="keyword">if</span> (metaValue == SystemMetaObject.NULL_META_OBJECT) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// don't instantiate child path if value is null</span></span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          metaValue = objectWrapper.instantiatePropertyValue(name, prop, objectFactory);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      metaValue.setValue(prop.getChildren(), value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//这个方法最终会调用objectWrapper.set()对结果进行赋值</span></span><br><span class="line">      objectWrapper.set(prop, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>objectWrapper有两个实现：<strong>BeanWrapper</strong>和<strong>MapWrapper</strong>，如果是自定义类型，那么就会调用BeanWrapper的set方法。<strong>MapWrapper</strong>的set方法实际上就是将属性名和属性值放到map的key和value中，而<strong>BeanWrapper</strong>则是使用了反射，调用了Bean的set方法，将值注入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MapWrapper的set方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(PropertyTokenizer prop, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prop.getIndex() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      Object collection = resolveCollection(prop, map);</span><br><span class="line">      setCollectionValue(prop, collection, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//实际上就是调用了Map的put方法将属性名和属性值放入map中</span></span><br><span class="line">      map.put(prop.getName(), value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//BeanWrapper的set方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(PropertyTokenizer prop, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prop.getIndex() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      Object collection = resolveCollection(prop, object);</span><br><span class="line">      setCollectionValue(prop, collection, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//在这里赋值，通过反射赋值，调用setXX()方法赋值</span></span><br><span class="line">      setBeanProperty(prop, object, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setBeanProperty</span><span class="params">(PropertyTokenizer prop, Object object, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Invoker method = metaClass.getSetInvoker(prop.getName());</span><br><span class="line">      Object[] params = &#123;value&#125;;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        method.invoke(object, params);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ReflectionException(<span class="string">"Could not set property '"</span> + prop.getName() + <span class="string">"' of '"</span> + object.getClass() + <span class="string">"' with value '"</span> + value + <span class="string">"' Cause: "</span> + t.toString(), t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-结果集映射">4.4 结果集映射</h3><p>映射是指返回的ResultSet列与Java Bean 属性之间的对应关系。通过ResultMapping进行映射描述，在用ResultMap封装成一个整体，包括手动映射和自动映射</p><table><thead><tr><th><strong>property</strong></th><th><strong>属性名(必填)</strong></th></tr></thead><tbody><tr><td><strong>column</strong></td><td><strong>列名(必填)</strong></td></tr><tr><td>jdbcType</td><td>jdbc类型(可自动推导)</td></tr><tr><td>javaType</td><td>java类型(可自动推导)</td></tr><tr><td>typeHandler</td><td>类型处理器(可自动推导)</td></tr></tbody></table><p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/20220301/20220301215952.png" alt></p><p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/20220301/20220301215955.png" alt></p><h3 id="4-5-懒加载">4.5 懒加载</h3><blockquote><p><a href="https://wuwenze.com/archives/1052/#%E6%87%92%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84" target="_blank" rel="noopener">懒加载的参考文章之一</a></p></blockquote><p>懒加载是为了改善在映射结果集解析对象属性时，大量的嵌套子查询的并发效率问题，当设置懒加载后，只有在使用指定属性时才会触发子查询，从而实现分散SQL请求的目的</p><p><strong>配置方式</strong></p><p>在mybais主配置文件中配置开启<strong>侵入式加载</strong>和<strong>深度加载</strong>，也可以在xml映射文件中配置<code>fetchType</code>，有效值为 <code>lazy</code> 和 <code>eager</code>。 指定属性后，将在映射中忽略全局配置参数 <code>lazyLoadingEnabled</code>，使用属性的值</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置直接延迟加载，默认是false--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"lazyLoadingEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 侵入式延迟加载开关，默认是true --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"aggressiveLazyLoading"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p><strong>内部原理</strong></p><p>代理过程发生在结果集解析创建对象之后(<code>DefaultResultSetHandler.createResultObject</code>)，如果对应的属性设置了懒加载，则会通过**ProxyFactory **创建代理对象，该对象继承自原对象，然后将对象的值全部拷贝到代理对象，并设置相应<code>MethodHandler</code>（原对象直接抛弃）</p><p>通过对Bean的动态代理，重写所有属性的getXxx方法，代理之后Bean会包含一个<strong>MethodHandler</strong>，内部在包含一个<strong>Map</strong>用于存放待执行懒加载，执行前懒加载前会移除。<strong>LoadPair</strong>用于针对反序列化的Bean准备执行环境。<strong>ResultLoader</strong>用于执行加载操作，执行前如果原执行器关闭会创建一个新的。</p><p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/20220301/20220301215958.png" alt></p><h3 id="4-6-嵌套映射">4.6 嵌套映射</h3><p>映射是指返回的ResultSet列与Java Bean 属性之间的对应关系。通过ResultMapping进行映射描述，在用ResultMap封装成一个整体。<strong>映射分为简单映射与复合嵌套映射，联合查询分为一对一查询和一对多查询</strong></p><p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/20220301/20220301220000.png" alt></p><p><strong>流程说明</strong></p><p>所有映射流程的解析都是在DefaultResultSetHandler当中完成。主要方法如下：</p><ul><li><code>handleRowValuesForNestedResultMap()</code></li></ul><p>嵌套结果集解析入口，在这里会遍历结果集中所有行。并为每一行创建一个RowKey对象。然后调用getRowValue()获取解析结果对象。最后保存至ResultHandler中(注：调用getRowValue前会基于RowKey获取已解析的对象，然后作为partialObject参数发给getRowValue)</p><ul><li><code>getRowValue()</code></li></ul><p>该方法最终会基于当前行生成一个解析好对象。具体职责包括，1.创建对象、2.填充普通属性和3.填充嵌套属性。在解析嵌套属性时会以递归的方式在调用getRowValue获取子对象。最后一步4.基于RowKey 暂存当前解析对象(如果partialObject参数不为空 只会执行 第3步。因为1、2已经执行过了)</p><ul><li><code>applyNestedResultMappings()</code></li></ul><p>解析并填充嵌套结果集映射，遍历所有嵌套映射,然后获取其嵌套ResultMap。接着创建RowKey 去获取暂存区的值。然后调用getRowValue 获取属性对象。最后填充至父对象(如果通过RowKey能获取到属性对象，它还是会去调用getRowsValue，因为有可能属下还存在未解析的属性)</p><p><strong>MyBatis循环依赖问题</strong></p><p>mybatis解决循环依赖主要是利用一级缓存和内置的queryStack标识。mybatis中BaseExecutor执行器对一级缓存进行管控，利用queryStack标识对最终结果进行处理，一级缓存对没有操作的查询缓存key进行空参填充，在嵌套子查询中会判断是否命中一级缓存，然后将其添加到<strong>延迟队列</strong>(非懒加载)，直到整个查询结束再对其进行延迟队列的加载，填充所有数据</p><p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/20220301/20220301220004.png" alt></p><p>其源码主要在DefaultResultSetHandler类中，方法调用手动映射，具体为<code>applyPropertyMappings</code>&gt;<code>getPropertyMappingValue</code>&gt;<code>getNestedQueryMappingValue</code>&gt;<code>ResultLoader </code>- 结果集加载器&gt;再次进入BaseExecutor的query中，对queryStack进行累加，直到跳出整个查询</p><h1>四、Mybatis的缓存</h1><h2 id="1、缓存概述">1、缓存概述</h2><p>myBatis中存在两个缓存，一级缓存和二级缓存</p><ul><li><strong>一级缓存</strong>：也叫做会话级缓存，生命周期仅存在于当前会话，不可以直接关关闭。但可以通过<code>flushCache</code>和<code>localCacheScope</code>对其做相应控制。</li><li><strong>二级缓存</strong>：也叫应用级缓存，缓存对象存在于整个应用周期，而且可以跨线程使用。</li></ul><h2 id="2、一级缓存">2、一级缓存</h2><h3 id="2-1-缓存命中与清空">2.1 缓存命中与清空</h3><p><strong>缓存命中参数</strong></p><ul><li>SQL与参数相同</li><li>同一个会话</li><li>相同的MapperStatement ID</li><li>RowBounds行范围相同</li></ul><p><strong>触发清空缓存</strong></p><ul><li>手动调用clearCache，注意clearLocalCache 不是清空某条具体数据，而是清当前会话下所有一级缓存数据</li><li>执行提交回滚(commit、Rolback)</li><li>执行任意增删改update</li><li>配置flushCache=true</li><li>缓存作用域为Statement(即子查询，子查询依赖一级缓存)</li></ul><h3 id="2-2-集成Spring一级缓存失效">2.2 集成Spring一级缓存失效</h3><p>因为Spring 对SqlSession进行了封装，通过SqlSessionTemplae ，使得每次调用Sql，都会重新构建一个SqlSession，解决方法是</p><ul><li>开启事务，因为一旦开启事务，Spring就不会在执行完SQL之后就销毁SqlSession，因为SqlSession一旦关闭，事务就没了，一旦我们开启事务，在事务期间内，缓存会一直存在</li><li>使用二级缓存</li></ul><p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/20220301/20220301220007.png" alt></p><h2 id="3、二级缓存">3、二级缓存</h2><h3 id="3-1-简介">3.1 简介</h3><p>二级缓存也称作是应用级缓存，与一级缓存不同的，是它的作用范围是整个应用，而且可以跨线程使用。所以二级缓存有更高的命中率，适合缓存一些修改较少的数据，在流程上是先访问二级缓存，在访问一级缓存。二级缓存的更新，必须是在会话提交之后，同时要提交之后才能命中缓存</p><h3 id="3-2-二级缓存使用">3.2 二级缓存使用</h3><p><strong>缓存空间声明</strong></p><p>二级默认缓存默认是不开启的，需要为其声明缓存空间才可以使用，通过**@CacheNamespace** 或 在xml配置**<Cache><strong>。声明之后该缓存为该Mapper所独有，其它Mapper不能访问。如需要多个Mapper共享一个缓存空间可通过</strong>@CacheNamespaceRef <strong>或</strong><cache-ref namespace>**进行引用同一个缓存空间。@CacheNamespace 详细配置见下表：</cache-ref></Cache></p><table><thead><tr><th>配置</th><th>说明</th></tr></thead><tbody><tr><td>implementation</td><td>指定缓存的存储实现类，默认是用HashMap存储在内存当中</td></tr><tr><td>eviction</td><td>指定缓存溢出淘汰实现类，默认LRU ，清除最少使用</td></tr><tr><td>flushInterval</td><td>设置缓存定时全部清空时间，默认不清空。</td></tr><tr><td>size</td><td>指定缓存容量，超出后就会按eviction指定算法进行淘汰</td></tr><tr><td>readWrite</td><td>true即通过序列化复制，来保证缓存对象是可读写的，默认true</td></tr><tr><td>blocking</td><td>为每个Key的访问添加阻塞锁，防止缓存击穿</td></tr><tr><td>properties</td><td>为上述组件，配置额外参数，key对应组件中的字段名。</td></tr></tbody></table><p><strong>缓存其它配置</strong></p><p>除@CacheNamespace 还可以通过其它参数来控制二级缓存</p><table><thead><tr><th>字段</th><th>配置域</th><th>说明</th></tr></thead><tbody><tr><td>cacheEnabled</td><td>在mybatis设置</td><td>二级缓存全局开关，默认开启</td></tr><tr><td>useCache</td><td>&lt;select</td><td>update</td></tr><tr><td>flushCache</td><td>&lt;select</td><td>update</td></tr></tbody></table><p>注意：若<code>*Mapper.xml</code>和<code>mapper</code>接口同时设置SQL查询，并同时配置了缓存，那么两个缓存空间是不一致，需要用缓存引用ref使用同一个缓存空间</p><h3 id="3-3-责任链设计">3.3 责任链设计</h3><p>这里MyBatis抽像出Cache接口，其只定义了缓存中最基本的功能方法：</p><ul><li>设置缓存</li><li>获取缓存</li><li>清除缓存</li><li>获取缓存数量</li></ul><p>然后上述中每一个功能都会对应一个组件类，并基于装饰者加责任链的模式，将各个组件进行串联。在执行缓存的基本功能时，其它的缓存逻辑会沿着这个责任链依次往下传递。</p><p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/20220301/20220301220011.png" alt></p><h3 id="3-4-执行流程">3.4 执行流程</h3><p>原本会话是通过Executor实现SQL调用，这里基于装饰器模式使用CachingExecutor对SQL调用逻辑进行拦截，以嵌入二级缓存相关逻辑。这里SqlSession会话可以对应多个暂存区，而多个暂存区对应一个缓存空间</p><p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/20220301/20220301220014.png" alt></p><p><strong>查询操作query</strong></p><p>当会话调用query() 时，会基于查询语句、参数等数据组成缓存Key，然后尝试从二级缓存中读取数据。读到就直接返回，没有就调用被装饰的Executor去查询数据库，然后在填充至对应的暂存区。</p><blockquote><p>请注意，这里的查询是实时从缓存空间读取的，而变更，只会记录在暂存区</p></blockquote><p><strong>更新操作update</strong></p><p>当执行update操作时，同样会基于查询的语句和参数组成缓存KEY，然后在执行update之前清空缓存。这里清空只针对暂存区，同时记录清空的标记，以便当会话提交之时，依据该标记去清空二级缓存空间。</p><blockquote><p>如果在查询操作中配置了flushCache=true ，也会执行相同的操作。</p></blockquote><p><strong>提交操作commit</strong></p><p>当会话执行commit操作后，会将该会话下所有暂存区的变更，更新到对应二级缓存空间去。</p><h3 id="3-5-缓存源码事务分析">3.5 缓存源码事务分析</h3><p>这个类是MyBatis用于缓存事务管理的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionalCacheManager</span> </span>&#123;</span><br><span class="line"> <span class="comment">//事务缓存</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Cache, TransactionalCache&gt; transactionalCaches = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">(Cache cache)</span> </span>&#123;</span><br><span class="line">    getTransactionalCache(cache).clear();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(Cache cache, CacheKey key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getTransactionalCache(cache).getObject(key);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Cache cache, CacheKey key, Object value)</span> </span>&#123;</span><br><span class="line">    getTransactionalCache(cache).putObject(key, value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (TransactionalCache txCache : transactionalCaches.values()) &#123;</span><br><span class="line">      txCache.commit();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (TransactionalCache txCache : transactionalCaches.values()) &#123;</span><br><span class="line">      txCache.rollback();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> TransactionalCache <span class="title">getTransactionalCache</span><span class="params">(Cache cache)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> transactionalCaches.computeIfAbsent(cache, TransactionalCache::<span class="keyword">new</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TransactionalCacheManager中封装了一个Map，用于将事务缓存对象缓存起来，这个Map的Key是我们的二级缓存对象，而Value是一个叫做TransactionalCache。</p><ul><li>其中在getObject()方法中存在两个分支：如果发现缓存中取出的数据为null，那么会把这个key放到<strong>entriesMissedInCache</strong>中，这个对象的主要作用就是将我们<strong>未命中的key</strong>全都保存下来，防止缓存被击穿，并且当我们在缓存中无法查询到数据，那么就有可能到一级缓存和数据库中查询，那么查询过后会调用putObject()方法，这个方法本应该将我们查询到的数据put到真实缓存中，但是现在由于存在事务，所以暂时先放到<strong>entriesToAddOnCommit</strong>中；如果发现缓存中取出的数据不为null，那么会查看<strong>事务提交标识</strong>(<strong>clearOnCommit</strong>)是否为true，如果为true，代表事务已经提交了，之后缓存会被清空，所以返回null，如果为false，那么由于事务还没有被提交，所以返回当前缓存中存的数据</li><li>事务提交成功时有以下几步：清空真实缓存、将本地缓存（未提交的事务缓存 entriesToAddOnCommit）刷新到真实缓存、将所有值复位</li><li>回滚步骤：清空真实缓存中未命中的缓存、将所有值复位</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionalCache</span> <span class="keyword">implements</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(TransactionalCache<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//真实缓存对象</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Cache delegate;</span><br><span class="line">  <span class="comment">//是否需要清空提交空间的标识</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> clearOnCommit;</span><br><span class="line">  <span class="comment">//所有待提交的缓存</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Object, Object&gt; entriesToAddOnCommit;</span><br><span class="line">  <span class="comment">//未命中的缓存集合，防止击穿缓存，并且如果查询到的数据为null，说明要通过数据库查询，有可能存在数据不一致，都记录到这个地方</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Object&gt; entriesMissedInCache;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TransactionalCache</span><span class="params">(Cache delegate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.delegate = delegate;</span><br><span class="line">    <span class="keyword">this</span>.clearOnCommit = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">this</span>.entriesToAddOnCommit = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">this</span>.entriesMissedInCache = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> delegate.getId();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> delegate.getSize();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// issue #116</span></span><br><span class="line">    Object object = delegate.getObject(key);</span><br><span class="line">    <span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果取出的是空，那么放到未命中缓存，并且在查询数据库之后putObject中将本应该放到真实缓存中的键值对放到待提交事务缓存</span></span><br><span class="line">      entriesMissedInCache.add(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果不为空</span></span><br><span class="line">    <span class="comment">// issue #146</span></span><br><span class="line">    <span class="comment">//查看缓存清空标识是否为false，如果事务提交了就为true，事务提交了会更新缓存，所以返回null。</span></span><br><span class="line">    <span class="keyword">if</span> (clearOnCommit) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果事务没有提交，那么返回原先缓存中的数据，</span></span><br><span class="line">      <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object object)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//如果返回的数据为null，那么有可能到数据库查询，查询到的数据先放置到待提交事务的缓存中</span></span><br><span class="line">      <span class="comment">//本来应该put到缓存中，现在put到待提交事务的缓存中去。</span></span><br><span class="line">    entriesToAddOnCommit.put(key, object);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">removeObject</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//如果事务提交了，那么将清空缓存提交标识设置为true</span></span><br><span class="line">    clearOnCommit = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//清空entriesToAddOnCommit</span></span><br><span class="line">    entriesToAddOnCommit.clear();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (clearOnCommit) &#123;</span><br><span class="line">        <span class="comment">//如果为true，那么就清空缓存。</span></span><br><span class="line">      delegate.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把本地缓存刷新到真实缓存。</span></span><br><span class="line">    flushPendingEntries();</span><br><span class="line">    <span class="comment">//然后将所有值复位。</span></span><br><span class="line">    reset();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//事务回滚</span></span><br><span class="line">    unlockMissedEntries();</span><br><span class="line">    reset();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//复位操作。</span></span><br><span class="line">    clearOnCommit = <span class="keyword">false</span>;</span><br><span class="line">    entriesToAddOnCommit.clear();</span><br><span class="line">    entriesMissedInCache.clear();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flushPendingEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//遍历事务管理器中待提交的缓存</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Object, Object&gt; entry : entriesToAddOnCommit.entrySet()) &#123;</span><br><span class="line">        <span class="comment">//写入到真实的缓存中。</span></span><br><span class="line">      delegate.putObject(entry.getKey(), entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Object entry : entriesMissedInCache) &#123;</span><br><span class="line">        <span class="comment">//把未命中的一起put</span></span><br><span class="line">      <span class="keyword">if</span> (!entriesToAddOnCommit.containsKey(entry)) &#123;</span><br><span class="line">        delegate.putObject(entry, <span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unlockMissedEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Object entry : entriesMissedInCache) &#123;</span><br><span class="line">        <span class="comment">//清空真实缓存区中未命中的缓存。</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        delegate.removeObject(entry);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.warn(<span class="string">"Unexpected exception while notifiying a rollback to the cache adapter."</span></span><br><span class="line">            + <span class="string">"Consider upgrading your cache adapter to the latest version.  Cause: "</span> + e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-6-使用经验">3.6 使用经验</h3><p><strong>二级缓存不能存在一直增多的数据</strong></p><p>由于二级缓存的影响范围不是SqlSession而是namespace，所以二级缓存会在你的应用启动时一直存在直到应用关闭，所以二级缓存中不能存在随着时间数据量越来越大的数据，这样有可能会造成内存空间被占满。</p><p><strong>二级缓存有可能存在脏读的问题（可避免）</strong></p><p>由于二级缓存的作用域为namespace，那么就可以假设这么一个场景，有两个namespace操作一张表，第一个namespace查询该表并回写到内存中，第二个namespace往表中插一条数据，那么第一个namespace的二级缓存是不会清空这个缓存的内容的，在下一次查询中，还会通过缓存去查询，这样会造成数据的不一致。所以当项目里有多个命名空间操作同一张表的时候，最好不要用二级缓存，或者使用二级缓存时避免用两个namespace操作一张表。</p><h1>五、Mybatis插件</h1><h2 id="1、核心原理">1、核心原理</h2><p>插件机制是为了对MyBatis现有体系进行扩展而提供的入口。底层通过动<strong>责任链模式+ JDK动态代理</strong>实现。插件的核心是拦截四个接口的子对象，拦截以后会进入到<code>intercept</code>方法中进行业务的处理，而Invocation对象可以获取到四个接口的具体</p><ul><li>Executor：执行器</li><li>StatementHandler：JDBC处理器</li><li>ParameterHandler：参数处理器</li><li>ResultSetHandler：结果集处理器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意interceptorChain.pluginAll()方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ParameterHandler <span class="title">newParameterHandler</span><span class="params">(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">    ParameterHandler parameterHandler = mappedStatement.getLang().createParameterHandler(mappedStatement, parameterObject, boundSql);</span><br><span class="line">    parameterHandler = (ParameterHandler) interceptorChain.pluginAll(parameterHandler);</span><br><span class="line">    <span class="keyword">return</span> parameterHandler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResultSetHandler <span class="title">newResultSetHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, RowBounds rowBounds, ParameterHandler parameterHandler, ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">    ResultSetHandler resultSetHandler = <span class="keyword">new</span> DefaultResultSetHandler(executor, mappedStatement, parameterHandler, resultHandler, boundSql, rowBounds);</span><br><span class="line">    resultSetHandler = (ResultSetHandler) interceptorChain.pluginAll(resultSetHandler);</span><br><span class="line">    <span class="keyword">return</span> resultSetHandler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> StatementHandler <span class="title">newStatementHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">    StatementHandler statementHandler = <span class="keyword">new</span> RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);</span><br><span class="line">    statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler);</span><br><span class="line">    <span class="keyword">return</span> statementHandler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType, <span class="keyword">boolean</span> autoCommit)</span> </span>&#123;</span><br><span class="line">    executorType = executorType == <span class="keyword">null</span> ? defaultExecutorType : executorType;</span><br><span class="line">    executorType = executorType == <span class="keyword">null</span> ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">    Executor executor;</span><br><span class="line">    <span class="keyword">if</span> (ExecutorType.BATCH == executorType) &#123;</span><br><span class="line">        executor = <span class="keyword">new</span> BatchExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE == executorType) &#123;</span><br><span class="line">        executor = <span class="keyword">new</span> ReuseExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        executor = <span class="keyword">new</span> SimpleExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cacheEnabled) &#123;</span><br><span class="line">        executor = <span class="keyword">new</span> CachingExecutor(executor, autoCommit);</span><br><span class="line">    &#125;</span><br><span class="line">    executor = (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">    <span class="keyword">return</span> executor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Interceptor类核心方法代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">  <span class="comment">//intercept方法:如果自定插件实现Interceptor覆盖intercept方法，</span></span><br><span class="line">  <span class="comment">//这个方法是一个核心方法，里面参数Invocation对象，这个对象可以通过反射调度原来的对象的方法。</span></span><br><span class="line">  <span class="function">Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">  <span class="comment">//target被拦截的对象，它的作用把拦截的target对象变成一个代理对象</span></span><br><span class="line">  <span class="function">Object <span class="title">plugin</span><span class="params">(Object target)</span></span>;</span><br><span class="line">  <span class="comment">//允许plugin在注册的时候，配置插件需要的参数，这个参数可以在mybatsi的核心配置文件中注册插件的时候,一起配置到文件中</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、源码分析">2、源码分析</h2><h3 id="2-1-插件类创建">2.1 插件类创建</h3><p>首先创建自定义插件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Intercepts</span>(&#123;<span class="meta">@Signature</span>(</span><br><span class="line">        type= Executor<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line"><span class="class">        <span class="title">method</span> </span>= <span class="string">"update"</span>,</span><br><span class="line">        args = &#123;MappedStatement<span class="class">.<span class="keyword">class</span>,<span class="title">Object</span>.<span class="title">class</span>&#125;)&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">ExamplePlugin</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">//自定义属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当执行目标方法时会被方法拦截</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object target = invocation.getTarget(); <span class="comment">//被代理对象</span></span><br><span class="line">        Method method = invocation.getMethod(); <span class="comment">//代理方法</span></span><br><span class="line">        Object[] args = invocation.getArgs(); <span class="comment">//方法参数</span></span><br><span class="line">        <span class="comment">// do something ...... 方法拦截前执行代码块</span></span><br><span class="line">        Object result = invocation.proceed();</span><br><span class="line">        <span class="comment">// do something .......方法拦截后执行代码块</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生成代理对象，可自定义生成代理对象，这样就无需配置@Intercepts注解。另外需要自行判断是否为拦截目标接口。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">plugin</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Plugin.wrap(target,<span class="keyword">this</span>);<span class="comment">// 调用通用插件代理生成机器</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置属性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.number = Integer.parseInt(properties.getProperty(<span class="string">"number"</span>, String.valueOf(<span class="number">100</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在config.xml 中添加插件配置，注意配置顺序</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">"org.demo.plugin.ExamplePlugin"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"number"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-2-源码分析">2.2 源码分析</h3><p><strong>构建图</strong></p><p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/20220301/20220301220021.png" alt></p><p><strong>核心代码</strong></p><p>插件对象的创建InterceptorChain</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SqlSessionFactoryBuilder类的build方法</span></span><br><span class="line">XMLConfigBuilder parser = <span class="keyword">new</span> XMLConfigBuilder(inputStream, environment, properties);</span><br></pre></td></tr></table></figure><p><code>XMLConfigBuilder</code>会实例化一个Configuration对象，在创建Configuration对象，会调用构造函数，InterceptorChain对象的创建，就是在Configuration的构造函数中进行了初始化，如<code>InterceptorChain interceptorChain = new InterceptorChain();</code></p><p>进入InterceptorChain 代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorChain</span> </span>&#123;</span><br><span class="line">  <span class="comment">//这个集合很重要</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;Interceptor&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">pluginAll</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//pluginAll方法是把具体的四大接口的具体实现类，生成动态代理的方法。</span></span><br><span class="line">    <span class="keyword">for</span> (Interceptor interceptor : interceptors) &#123;</span><br><span class="line">      target = interceptor.plugin(target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptor</span><span class="params">(Interceptor interceptor)</span> </span>&#123;</span><br><span class="line">    interceptors.add(interceptor);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Interceptor&gt; <span class="title">getInterceptors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Collections.unmodifiableList(interceptors);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在parse()方法解析的时候，parseConfiguration()中解析插件<code>pluginElement(root.evalNode(&quot;plugins&quot;))</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//XMLConfigBuilder类</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pluginElement</span><span class="params">(XNode parent)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//这里循环解析配置文件中的所有定义的插件</span></span><br><span class="line">    <span class="keyword">for</span> (XNode child : parent.getChildren()) &#123;</span><br><span class="line">      String interceptor = child.getStringAttribute(<span class="string">"interceptor"</span>);</span><br><span class="line">      <span class="comment">//如果插件有配置属性。获取到配置的属性，然后把属性的值，注册到Properties对象中</span></span><br><span class="line">      Properties properties = child.getChildrenAsProperties();</span><br><span class="line">      <span class="comment">//同时获取到具体的注册的插件对象</span></span><br><span class="line">      Interceptor interceptorInstance = (Interceptor) resolveClass(interceptor).newInstance();</span><br><span class="line">      <span class="comment">//调用插件，并赋值插件中的属性</span></span><br><span class="line">      interceptorInstance.setProperties(properties);</span><br><span class="line">      <span class="comment">//注册到interceptorChain中</span></span><br><span class="line">      configuration.addInterceptor(interceptorInstance);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Configuration类</span></span><br><span class="line"><span class="comment">//这个集合就是把下面解析的插件，进行注册和收集的容器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptor</span><span class="params">(Interceptor interceptor)</span> </span>&#123;</span><br><span class="line">  interceptorChain.addInterceptor(interceptor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插件的执行流程</p><p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/20220301/20220301220024.png" alt></p><h3 id="2-3-源码总结">2.3 源码总结</h3><p>Mybatis插件使用机制就是：** jdk动态代理＋责任链的设计模式**。插件的运行和注册会分为几个阶段：</p><p>1、<strong>定义阶段</strong>，定义插件类然后实现<code>Interceptor</code>接口，覆盖这个接口三个方法，分别是：<code>plugin</code>方法，<code>interceptor</code>方法，<code>setProperties</code>方法</p><ul><li>intercept方法：如果自定插件实现Interceptor覆盖intercept方法，这个方法是一个核心方法，里面参数Invocation对象，这个对象可以通过反射调度原来的对象的方法。</li><li>plugin方法：target被拦截的对象。它的作用:把拦截的target对象变成一个代理对象</li><li>setProperties方法：允许plugin在注册的时候，配置插件需要的参数，这个参数可以在mybats的核心配置文件中注册插件的时候，一起配置到文件中</li></ul><p>2、<strong>注册阶段</strong>，写入到mybatis配置文件中，如果是spring整合myabtis化，就使用配置类来进行插件的注册</p><p>3、同时在定义的时候，会通过<code>@Intercepts</code>注解和签名，来告诉插件具体要拦截那些类执行的方法，mybatis对四个接口实现类都会进行拦截</p><p>4、<strong>运行和执行阶段</strong>，定义了执行器的插件后，在初始化<code>sqlsession</code>的时候会确定一个执行器，而执行器在创建的时候，会调用<code>executor = (Executor)interceptorChain.pluginAll(executor)</code>。这个方法的作用就是把执行器对象变成一个代理对象，而代理对象的生成，是通过插件的的plugin方法进行生成和创建，具体的话是通过代理类Plugin中的wrap方法创建而生成，生成executor代理对象之后，当代理执行器执行方法的时候，就进入Plugin代理类中invoke方法中进行业务处理</p><h2 id="3、分页插件举例">3、分页插件举例</h2><h3 id="3-1-分页插件原理">3.1 分页插件原理</h3><p>首先设定一个Page类，其包含total、size、index 3个属性，在Mapper接口中声明该参数即表示需要执行自动分页逻辑。总体实现步骤包含3个：</p><ol><li>检测是否满足分页条件</li><li>自动求出当前查询的总行数</li><li>修改原有的SQL语句 ，添加 limit offset 关键字。</li></ol><h3 id="3-2-检测是否满足分页条件">3.2 检测是否满足分页条件</h3><p>分页条件是 1.是否为查询方法，2.查询参数中是否带上Page参数。在intercept 方法中可直接获得拦截目标StatementHandler ，通过它又可以获得BoundSql 里面就包含了SQL 和参数。遍历参数即可获得Page。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 带上分页参数</span></span><br><span class="line">StatementHandler target = (StatementHandler) invocation.getTarget();</span><br><span class="line"><span class="comment">// SQL包 sql、参数、参数映射</span></span><br><span class="line">BoundSql boundSql = target.getBoundSql();</span><br><span class="line">Object parameterObject = boundSql.getParameterObject();</span><br><span class="line">Page page = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (parameterObject <span class="keyword">instanceof</span> Page) &#123;</span><br><span class="line">    page = (Page) parameterObject;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (parameterObject <span class="keyword">instanceof</span> Map) &#123;</span><br><span class="line">    page = (Page) ((Map) parameterObject).values().stream().filter(v -&gt; v <span class="keyword">instanceof</span> Page).findFirst().orElse(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-查询总行数">3.3 查询总行数</h3><p>实现逻辑是 将原查询SQL作为子查询进行包装成子查询，然后用原有参数，还是能过原来的参数处理器进行赋值。关于执行是采用JDBC 原生API实现。MyBatis执行器，从而绕开了一二级缓存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">selectCount</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    StatementHandler target = (StatementHandler) invocation.getTarget();</span><br><span class="line">    <span class="comment">// SQL包 sql、参数、参数映射</span></span><br><span class="line">    String countSql = String.format(<span class="string">"select count(*) from (%s) as _page"</span>, target.getBoundSql().getSql());</span><br><span class="line">    <span class="comment">// JDBC</span></span><br><span class="line">    Connection connection = (Connection) invocation.getArgs()[<span class="number">0</span>];</span><br><span class="line">    PreparedStatement preparedStatement = connection.prepareStatement(countSql);</span><br><span class="line">    target.getParameterHandler().setParameters(preparedStatement);</span><br><span class="line">    ResultSet resultSet = preparedStatement.executeQuery();</span><br><span class="line">    <span class="keyword">if</span> (resultSet.next()) &#123;</span><br><span class="line">        count = resultSet.getInt(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    resultSet.close();</span><br><span class="line">    preparedStatement.close();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-修改原SQL">3.4 修改原SQL</h3><p>最后一项就是修改原来的SQL，前面我是可以拿到BoundSql 的，但它没有提供修改SQL的方法，这里可以采用反射强行为SQL属性赋值。也可以采用MyBatis提供的工具类SystemMetaObject来赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String newSql= String.format(<span class="string">"%s limit %s offset %s"</span>, boundSql.getSql(),page.getSize(),page.getOffset());</span><br><span class="line">SystemMetaObject.forObject(boundSql).setValue(<span class="string">"sql"</span>,newSql);</span><br></pre></td></tr></table></figure><hr><p>参考文章：</p><p><a href="https://www.cnblogs.com/javazhiyin/p/12340498.html" target="_blank" rel="noopener">手把手带你阅读Mybatis源码（一）构造篇</a></p><p><a href="https://www.cnblogs.com/javazhiyin/p/12344651.html" target="_blank" rel="noopener">手把手带你阅读Mybatis源码（二）执行篇</a></p><p><a href="https://www.cnblogs.com/javazhiyin/p/12357397.html" target="_blank" rel="noopener">手把手带你阅读Mybatis源码（三）缓存篇</a></p><p><a href="http://coderead.cn/p/mybatis/doc/index.md" target="_blank" rel="noopener">源码阅读网</a></p><p><a href="https://www.bilibili.com/video/BV1Tp4y1X7FM" target="_blank" rel="noopener">MyBatis源码解析大合集</a></p><p><a href="https://www.bilibili.com/video/BV1J64y1q7V8" target="_blank" rel="noopener">[学相伴飞哥]Mybatis的源码分析-执行过程（一）</a></p>]]></content>
    
    
    <summary type="html">&lt;h1&gt;一、前言&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;MyBatis官方文档：&lt;a href=&quot;https://mybatis.org/mybatis-3/zh/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://mybatis.org/mybatis-3/zh/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1、介绍&quot;&gt;1、介绍&lt;/h2&gt;
&lt;p&gt;对于MyBatis，其工作流程实际上分为两部分：&lt;strong&gt;第一，构建，也就是解析我们写的xml配置，将其变成它所需要的对象。第二，执行，在构建完成的基础上，去执行我们的SQL，完成与Jdbc的交互&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://www.shawn22.xyz/categories/Java/"/>
    
    
    <category term="源码分析" scheme="https://www.shawn22.xyz/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Spring常用工具类</title>
    <link href="https://www.shawn22.xyz/posts/92637ed4.html"/>
    <id>https://www.shawn22.xyz/posts/92637ed4.html</id>
    <published>2022-02-15T02:40:33.000Z</published>
    <updated>2022-03-02T01:44:40.260Z</updated>
    
    <content type="html"><![CDATA[<h1>一、内置工具类</h1><p>内置工具类一般位于<code>org.springframework.util</code>下</p><h2 id="1、断言">1、断言</h2><ul><li>断言是一个逻辑判断，用于检查不应该发生的情况</li><li>Assert 关键字在 JDK1.4 中引入，可通过 JVM 参数<code>-enableassertions</code>开启</li><li>SpringBoot 中提供了 Assert 断言工具类，通常用于数据合法性检查</li></ul><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要求参数 object 必须为非空（Not Null），否则抛出异常，不予放行</span></span><br><span class="line"><span class="comment">// 参数 message 参数用于定制异常信息。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">notNull</span><span class="params">(Object object, String message)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 要求参数必须空（Null），否则抛出异常，不予『放行』。</span></span></span><br><span class="line"><span class="function"><span class="comment">// 和 notNull() 方法断言规则相反</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">isNull</span><span class="params">(Object object, String message)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 要求参数必须为真（True），否则抛出异常，不予『放行』。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">isTrue</span><span class="params">(<span class="keyword">boolean</span> expression, String message)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 要求参数（List/Set）必须非空（Not Empty），否则抛出异常，不予放行</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">notEmpty</span><span class="params">(Collection collection, String message)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 要求参数（String）必须有长度（即，Not Empty），否则抛出异常，不予放行</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hasLength</span><span class="params">(String text, String message)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 要求参数（String）必须有内容（即，Not Blank），否则抛出异常，不予放行</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hasText</span><span class="params">(String text, String message)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 要求参数是指定类型的实例，否则抛出异常，不予放行</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">isInstanceOf</span><span class="params">(Class type, Object obj, String message)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 要求参数 `subType` 必须是参数 superType 的子类或实现类，否则抛出异常，不予放行</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">isAssignable</span><span class="params">(Class superType, Class subType, String message)</span></span></span><br></pre></td></tr></table></figure><h2 id="2、对象、数组、集合">2、对象、数组、集合</h2><h3 id="2-1-ObjectUtils">2.1 ObjectUtils</h3><ul><li>获取对象的基本信息</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取对象的类名。参数为 null 时，返回字符串："null" </span></span><br><span class="line"><span class="function">String <span class="title">nullSafeClassName</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 参数为 null 时，返回 0</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nullSafeHashCode</span><span class="params">(Object object)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 参数为 null 时，返回字符串："null"</span></span></span><br><span class="line"><span class="function">String <span class="title">nullSafeToString</span><span class="params">(<span class="keyword">boolean</span>[] array)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 获取对象 HashCode（十六进制形式字符串）。参数为 null 时，返回 0 </span></span></span><br><span class="line"><span class="function">String <span class="title">getIdentityHexString</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 获取对象的类名和 HashCode。 参数为 null 时，返回字符串："" </span></span></span><br><span class="line"><span class="function">String <span class="title">identityToString</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 相当于 toString()方法，但参数为 null 时，返回字符串：""</span></span></span><br><span class="line"><span class="function">String <span class="title">getDisplayString</span><span class="params">(Object obj)</span></span></span><br></pre></td></tr></table></figure><ul><li>判断工具</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断数组是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">(Object[] array)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 判断参数对象是否是数组</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isArray</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 判断数组中是否包含指定元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsElement</span><span class="params">(Object[] array, Object element)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 相等，或同为 null时，返回 true</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">nullSafeEquals</span><span class="params">(Object o1, Object o2)</span></span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="function"><span class="comment">判断参数对象是否为空，判断标准为：</span></span></span><br><span class="line"><span class="function"><span class="comment">  Optional: Optional.empty()</span></span></span><br><span class="line"><span class="function"><span class="comment">    Array: length == 0</span></span></span><br><span class="line"><span class="function"><span class="comment">CharSequence: length == 0</span></span></span><br><span class="line"><span class="function"><span class="comment">  Collection: Collection.isEmpty()</span></span></span><br><span class="line"><span class="function"><span class="comment">    Map: Map.isEmpty()</span></span></span><br><span class="line"><span class="function"><span class="comment">  */</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">(Object obj)</span></span></span><br></pre></td></tr></table></figure><ul><li>其他工具方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向参数数组的末尾追加新元素，并返回一个新数组</span></span><br><span class="line">&lt;A, O extends A&gt; A[] addObjectToArray(A[] array, O obj)</span><br><span class="line"><span class="comment">// 原生基础类型数组 --&gt; 包装类数组</span></span><br><span class="line">Object[] toObjectArray(Object source)</span><br></pre></td></tr></table></figure><h3 id="2-2-StringUtils">2.2 StringUtils</h3><ul><li>字符串判断工具</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断字符串是否为 null，或 ""。注意，包含空白符的字符串为非空</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">(Object str)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 判断字符串是否是以指定内容结束。忽略大小写</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">endsWithIgnoreCase</span><span class="params">(String str, String suffix)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 判断字符串是否已指定内容开头。忽略大小写</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">startsWithIgnoreCase</span><span class="params">(String str, String prefix)</span> <span class="comment">// 是否包含空白符</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsWhitespace</span><span class="params">(String str)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 判断字符串非空且长度不为 0，即，Not Empty</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasLength</span><span class="params">(CharSequence str)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 判断字符串是否包含实际内容，即非仅包含空白符，也就是 Not Blank</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasText</span><span class="params">(CharSequence str)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 判断字符串指定索引处是否包含一个子串。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">substringMatch</span><span class="params">(CharSequence str, <span class="keyword">int</span> index, CharSequence substring)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 计算一个字符串中指定子串的出现次数</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countOccurrencesOf</span><span class="params">(String str, String sub)</span></span></span><br></pre></td></tr></table></figure><ul><li>字符串操作工具</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找并替换指定子串</span></span><br><span class="line"><span class="function">String <span class="title">replace</span><span class="params">(String inString, String oldPattern, String newPattern)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 去除尾部的特定字符</span></span></span><br><span class="line"><span class="function">String <span class="title">trimTrailingCharacter</span><span class="params">(String str, <span class="keyword">char</span> trailingCharacter)</span> <span class="comment">// 去除头部的特定字符</span></span></span><br><span class="line"><span class="function">String <span class="title">trimLeadingCharacter</span><span class="params">(String str, <span class="keyword">char</span> leadingCharacter)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 去除头部的空白符</span></span></span><br><span class="line"><span class="function">String <span class="title">trimLeadingWhitespace</span><span class="params">(String str)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 去除头部的空白符</span></span></span><br><span class="line"><span class="function">String <span class="title">trimTrailingWhitespace</span><span class="params">(String str)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 去除头部和尾部的空白符</span></span></span><br><span class="line"><span class="function">String <span class="title">trimWhitespace</span><span class="params">(String str)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 删除开头、结尾和中间的空白符</span></span></span><br><span class="line"><span class="function">String <span class="title">trimAllWhitespace</span><span class="params">(String str)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 删除指定子串</span></span></span><br><span class="line"><span class="function">String <span class="title">delete</span><span class="params">(String inString, String pattern)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 删除指定字符（可以是多个）</span></span></span><br><span class="line"><span class="function">String <span class="title">deleteAny</span><span class="params">(String inString, String charsToDelete)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 对数组的每一项执行 trim() 方法</span></span></span><br><span class="line"><span class="function">String[] <span class="title">trimArrayElements</span><span class="params">(String[] array)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 将 URL 字符串进行解码</span></span></span><br><span class="line"><span class="function">String <span class="title">uriDecode</span><span class="params">(String source, Charset charset)</span></span></span><br></pre></td></tr></table></figure><ul><li>路径相关工具方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解析路径字符串，优化其中的 “..” </span></span><br><span class="line"><span class="function">String <span class="title">cleanPath</span><span class="params">(String path)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 解析路径字符串，解析出文件名部分</span></span></span><br><span class="line"><span class="function">String <span class="title">getFilename</span><span class="params">(String path)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 解析路径字符串，解析出文件后缀名</span></span></span><br><span class="line"><span class="function">String <span class="title">getFilenameExtension</span><span class="params">(String path)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 比较两个两个字符串，判断是否是同一个路径。会自动处理路径中的 “..” </span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">pathEquals</span><span class="params">(String path1, String path2)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 删除文件路径名中的后缀部分</span></span></span><br><span class="line"><span class="function">String <span class="title">stripFilenameExtension</span><span class="params">(String path)</span> <span class="comment">// 以 “. 作为分隔符，获取其最后一部分</span></span></span><br><span class="line"><span class="function">String <span class="title">unqualify</span><span class="params">(String qualifiedName)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 以指定字符作为分隔符，获取其最后一部分</span></span></span><br><span class="line"><span class="function">String <span class="title">unqualify</span><span class="params">(String qualifiedName, <span class="keyword">char</span> separator)</span></span></span><br></pre></td></tr></table></figure><h3 id="2-3-CollectionUtils">2.3 CollectionUtils</h3><ul><li>集合判断工具</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断 List/Set 是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">(Collection&lt;?&gt; collection)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 判断 Map 是否为空</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">(Map&lt;?,?&gt; map)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 判断 List/Set 中是否包含某个对象</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsInstance</span><span class="params">(Collection&lt;?&gt; collection, Object element)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 以迭代器的方式，判断 List/Set 中是否包含某个对象</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Iterator&lt;?&gt; iterator, Object element)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 判断 List/Set 是否包含某些对象中的任意一个</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsAny</span><span class="params">(Collection&lt;?&gt; source, Collection&lt;?&gt; candidates)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 判断 List/Set 中的每个元素是否唯一。即 List/Set 中不存在重复元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasUniqueObject</span><span class="params">(Collection&lt;?&gt; collection)</span></span></span><br></pre></td></tr></table></figure><ul><li>集合操作工具</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 Array 中的元素都添加到 List/Set 中</span></span><br><span class="line"><span class="comment">// 将 Properties 中的键值对都添加到 Map 中</span></span><br><span class="line">&lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">mergeArrayIntoCollection</span><span class="params">(Object array, Collection&lt;E&gt; collection)</span>  </span></span><br><span class="line"><span class="function">&lt;K,V&gt; <span class="keyword">void</span> <span class="title">mergePropertiesIntoMap</span><span class="params">(Properties props, Map&lt;K,V&gt; map)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回 List 中最后一个元素</span></span></span><br><span class="line"><span class="function">&lt;T&gt; T <span class="title">lastElement</span><span class="params">(List&lt;T&gt; list)</span>  <span class="comment">// 返回 Set 中最后一个元素</span></span></span><br><span class="line"><span class="function">&lt;T&gt; T <span class="title">lastElement</span><span class="params">(Set&lt;T&gt; set)</span> <span class="comment">// 返回参数 candidates 中第一个存在于参数 source 中的元素</span></span></span><br><span class="line"><span class="function">&lt;E&gt; E <span class="title">findFirstMatch</span><span class="params">(Collection&lt;?&gt; source, Collection&lt;E&gt; candidates)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回 List/Set 中指定类型的元素。</span></span></span><br><span class="line"><span class="function">&lt;T&gt; T <span class="title">findValueOfType</span><span class="params">(Collection&lt;?&gt; collection, Class&lt;T&gt; type)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回 List/Set 中指定类型的元素。如果第一种类型未找到，则查找第二种类型，以此类推</span></span></span><br><span class="line"><span class="function">Object <span class="title">findValueOfType</span><span class="params">(Collection&lt;?&gt; collection, Class&lt;?&gt;[] types)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回 List/Set 中元素的类型</span></span></span><br><span class="line"><span class="function">Class&lt;?&gt; <span class="title">findCommonElementType</span><span class="params">(Collection&lt;?&gt; collection)</span></span></span><br></pre></td></tr></table></figure><h2 id="3、文件、资源、IO-流">3、文件、资源、IO 流</h2><h3 id="3-1-FileCopyUtils">3.1 FileCopyUtils</h3><ul><li>输入</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从文件中读入到字节数组中</span></span><br><span class="line"><span class="keyword">byte</span>[] copyToByteArray(File in)</span><br><span class="line"><span class="comment">// 从输入流中读入到字节数组中</span></span><br><span class="line"><span class="keyword">byte</span>[] copyToByteArray(InputStream in)</span><br><span class="line"><span class="comment">// 从输入流中读入到字符串中</span></span><br><span class="line"><span class="function">String <span class="title">copyToString</span><span class="params">(Reader in)</span></span></span><br></pre></td></tr></table></figure><ul><li>输出</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从字节数组到文件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(<span class="keyword">byte</span>[] in, File out)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 从文件到文件</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copy</span><span class="params">(File in, File out)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 从字节数组到输出流</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(<span class="keyword">byte</span>[] in, OutputStream out)</span> <span class="comment">// 从输入流到输出流</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copy</span><span class="params">(InputStream in, OutputStream out)</span> <span class="comment">// 从输入流到输出流</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copy</span><span class="params">(Reader in, Writer out)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 从字符串到输出流</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(String in, Writer out)</span></span></span><br></pre></td></tr></table></figure><h3 id="3-2-ResourceUtils">3.2 ResourceUtils</h3><ul><li>从资源路径获取文件</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断字符串是否是一个合法的 URL 字符串。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isUrl</span><span class="params">(String resourceLocation)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 获取 URL</span></span></span><br><span class="line"><span class="function"><span class="comment">// 获取文件（在 JAR 包内无法正常使用，需要是一个独立的文件）</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> URL <span class="title">getURL</span><span class="params">(String resourceLocation)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">static</span> File  <span class="title">getFile</span><span class="params">(String resourceLocation)</span></span></span><br></pre></td></tr></table></figure><ul><li>Resource</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件系统资源 D:...</span></span><br><span class="line">FileSystemResource</span><br><span class="line"><span class="comment">// URL 资源，如 file://... http://...</span></span><br><span class="line">UrlResource</span><br><span class="line"><span class="comment">// 类路径下的资源，classpth:...</span></span><br><span class="line">ClassPathResource</span><br><span class="line"><span class="comment">// Web 容器上下文中的资源（jar 包、war 包）</span></span><br><span class="line">ServletContextResource</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断资源是否存在</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">exists</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 从资源中获得 File 对象</span></span></span><br><span class="line"><span class="function">File <span class="title">getFile</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 从资源中获得 URI 对象</span></span></span><br><span class="line"><span class="function">URI <span class="title">getURI</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 从资源中获得 URI 对象</span></span></span><br><span class="line"><span class="function">URL <span class="title">getURL</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 获得资源的 InputStream</span></span></span><br><span class="line"><span class="function">InputStream <span class="title">getInputStream</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 获得资源的描述信息</span></span></span><br><span class="line"><span class="function">String <span class="title">getDescription</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><h3 id="3-3-StreamUtils">3.3 StreamUtils</h3><ul><li>输入</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(<span class="keyword">byte</span>[] in, OutputStream out)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copy</span><span class="params">(InputStream in, OutputStream out)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(String in, Charset charset, OutputStream out)</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">copyRange</span><span class="params">(InputStream in, OutputStream out, <span class="keyword">long</span> start, <span class="keyword">long</span> end)</span></span></span><br></pre></td></tr></table></figure><ul><li>输出</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] copyToByteArray(InputStream in)</span><br><span class="line"><span class="function">String <span class="title">copyToString</span><span class="params">(InputStream in, Charset charset)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 舍弃输入流中的内容</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">drain</span><span class="params">(InputStream in)</span></span></span><br></pre></td></tr></table></figure><h2 id="4、反射、AOP">4、反射、AOP</h2><h3 id="4-1-ReflectionUtils">4.1 ReflectionUtils</h3><ul><li>获取方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在类中查找指定方法</span></span><br><span class="line"><span class="function">Method <span class="title">findMethod</span><span class="params">(Class&lt;?&gt; clazz, String name)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 同上，额外提供方法参数类型作查找条件</span></span></span><br><span class="line"><span class="function">Method <span class="title">findMethod</span><span class="params">(Class&lt;?&gt; clazz, String name, Class&lt;?&gt;... paramTypes)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 获得类中所有方法，包括继承而来的</span></span></span><br><span class="line"><span class="function">Method[] <span class="title">getAllDeclaredMethods</span><span class="params">(Class&lt;?&gt; leafClass)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 在类中查找指定构造方法</span></span></span><br><span class="line"><span class="function">Constructor&lt;T&gt; <span class="title">accessibleConstructor</span><span class="params">(Class&lt;T&gt; clazz, Class&lt;?&gt;... parameterTypes)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 是否是 equals() 方法</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEqualsMethod</span><span class="params">(Method method)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 是否是 hashCode() 方法 </span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isHashCodeMethod</span><span class="params">(Method method)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 是否是 toString() 方法</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isToStringMethod</span><span class="params">(Method method)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 是否是从 Object 类继承而来的方法</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isObjectMethod</span><span class="params">(Method method)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 检查一个方法是否声明抛出指定异常</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">declaresException</span><span class="params">(Method method, Class&lt;?&gt; exceptionType)</span></span></span><br></pre></td></tr></table></figure><ul><li>执行方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行方法</span></span><br><span class="line"><span class="function">Object <span class="title">invokeMethod</span><span class="params">(Method method, Object target)</span>  </span></span><br><span class="line"><span class="function"><span class="comment">// 同上，提供方法参数</span></span></span><br><span class="line"><span class="function">Object <span class="title">invokeMethod</span><span class="params">(Method method, Object target, Object... args)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 取消 Java 权限检查。以便后续执行该私有方法</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeAccessible</span><span class="params">(Method method)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 取消 Java 权限检查。以便后续执行私有构造方法</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeAccessible</span><span class="params">(Constructor&lt;?&gt; ctor)</span></span></span><br></pre></td></tr></table></figure><ul><li>获取字段</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在类中查找指定属性</span></span><br><span class="line"><span class="function">Field <span class="title">findField</span><span class="params">(Class&lt;?&gt; clazz, String name)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 同上，多提供了属性的类型</span></span></span><br><span class="line"><span class="function">Field <span class="title">findField</span><span class="params">(Class&lt;?&gt; clazz, String name, Class&lt;?&gt; type)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 是否为一个 "public static final" 属性</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isPublicStaticFinal</span><span class="params">(Field field)</span></span></span><br></pre></td></tr></table></figure><ul><li>设置字段</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 target 对象的 field 属性值</span></span><br><span class="line"><span class="function">Object <span class="title">getField</span><span class="params">(Field field, Object target)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 设置 target 对象的 field 属性值，值为 value</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setField</span><span class="params">(Field field, Object target, Object value)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 同类对象属性对等赋值</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shallowCopyFieldState</span><span class="params">(Object src, Object dest)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 取消 Java 的权限控制检查。以便后续读写该私有属性</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeAccessible</span><span class="params">(Field field)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 对类的每个属性执行 callback</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doWithFields</span><span class="params">(Class&lt;?&gt; clazz, ReflectionUtils.FieldCallback fc)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 同上，多了个属性过滤功能。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doWithFields</span><span class="params">(Class&lt;?&gt; clazz, ReflectionUtils.FieldCallback fc, </span></span></span><br><span class="line"><span class="function"><span class="params">                  ReflectionUtils.FieldFilter ff)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 同上，但不包括继承而来的属性</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doWithLocalFields</span><span class="params">(Class&lt;?&gt; clazz, ReflectionUtils.FieldCallback fc)</span></span></span><br></pre></td></tr></table></figure><h3 id="4-2-AopUtils">4.2 AopUtils</h3><ul><li>判断代理类型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是不是 Spring 代理对象</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isAopProxy</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 判断是不是 jdk 动态代理对象</span></span></span><br><span class="line"><span class="function"><span class="title">isJdkDynamicProxy</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 判断是不是 CGLIB 代理对象</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isCglibProxy</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><ul><li>获取被代理对象的 class</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取被代理的目标 class</span></span><br><span class="line">Class&lt;?&gt; getTargetClass()</span><br></pre></td></tr></table></figure><h3 id="4-3-AopContext">4.3 AopContext</h3><ul><li>获取当前对象的代理对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">currentProxy</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><h3 id="4-4-AOP举例">4.4 AOP举例</h3><ul><li>演示对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zstu.student;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String field01 = <span class="string">"这是字段1"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String field02 = <span class="string">"这是字段2"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DemoObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DemoObject</span><span class="params">(String field01)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.field01 = field01;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">method01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"无参方法1"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method01</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"有参方法1"</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method02</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"异常方法2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.equals(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>反射举例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"---------- findMethod ----------"</span>);</span><br><span class="line"><span class="comment">// 获取方法</span></span><br><span class="line">Method method1 = ReflectionUtils.findMethod(DemoObject.class, "method01");</span><br><span class="line">Method method2 = ReflectionUtils.findMethod(DemoObject.class, "method02");</span><br><span class="line"><span class="comment">// public java.lang.Object com.zstu.student.DemoObject.method01()</span></span><br><span class="line">System.out.println(method1);</span><br><span class="line">System.out.println(<span class="string">"---------- findField ----------"</span>);</span><br><span class="line"><span class="comment">// 获取属性</span></span><br><span class="line">Field field1 = ReflectionUtils.findField(DemoObject.class, "field01");</span><br><span class="line">Field field2 = ReflectionUtils.findField(DemoObject.class, "field02");</span><br><span class="line"><span class="comment">// private java.lang.String com.zstu.student.DemoObject.field01</span></span><br><span class="line">System.out.println(field1);</span><br><span class="line">System.out.println(<span class="string">"---------- accessibleConstructor ----------"</span>);</span><br><span class="line"><span class="comment">// 获取构造方法</span></span><br><span class="line">Constructor&lt;DemoObject&gt; constructor1 = ReflectionUtils.accessibleConstructor(DemoObject<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">Constructor&lt;DemoObject&gt; constructor2 = ReflectionUtils.accessibleConstructor(DemoObject<span class="class">.<span class="keyword">class</span>, <span class="title">String</span>.<span class="title">class</span>)</span>;</span><br><span class="line"><span class="comment">// [public com.zstu.student.DemoObject(), public com.zstu.student.DemoObject(java.lang.String)]</span></span><br><span class="line">System.out.println(Arrays.toString(<span class="keyword">new</span> String[] &#123; constructor1.toString(), constructor2.toString() &#125;));</span><br><span class="line">System.out.println(<span class="string">"---------- declaresException ----------"</span>);</span><br><span class="line"><span class="comment">// 方法是否存在指定的抛出异常</span></span><br><span class="line"><span class="keyword">assert</span> method2 != <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">boolean</span> existIOException = ReflectionUtils.declaresException(method2, IOException<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="keyword">boolean</span> existException = ReflectionUtils.declaresException(method2, Exception<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="comment">// true - false</span></span><br><span class="line">System.out.println(existIOException + <span class="string">" - "</span> + existException);</span><br><span class="line">System.out.println(<span class="string">"---------- doWithFields ----------"</span>);</span><br><span class="line"><span class="comment">// 返回所有字段，通过回调</span></span><br><span class="line"><span class="comment">//private java.lang.String com.zstu.student.DemoObject.field01</span></span><br><span class="line"><span class="comment">//public static final java.lang.String com.zstu.student.DemoObject.field02</span></span><br><span class="line">ReflectionUtils.doWithFields(DemoObject.class, System.out::println);</span><br><span class="line">System.out.println(<span class="string">"---------- doWithLocalMethods ----------"</span>);</span><br><span class="line"><span class="comment">// 返回当前类所有方法，通过回调</span></span><br><span class="line">ReflectionUtils.doWithLocalMethods(DemoObject.class, System.out::println);</span><br><span class="line">System.out.println(<span class="string">"---------- doWithMethods ----------"</span>);</span><br><span class="line"><span class="comment">// 返回所有方法包括继承类，通过回调</span></span><br><span class="line">ReflectionUtils.doWithMethods(DemoObject.class, System.out::println);</span><br><span class="line">System.out.println(<span class="string">"---------- getAllDeclaredMethods ----------"</span>);</span><br><span class="line"><span class="comment">// 返回所有方法包括继承</span></span><br><span class="line">Method[] methods = ReflectionUtils.getAllDeclaredMethods(DemoObject<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">System.out.println(Arrays.toString(methods));</span><br><span class="line">System.out.println(<span class="string">"---------- getDeclaredMethods ----------"</span>);</span><br><span class="line"><span class="comment">// 返回所有当前类的方法</span></span><br><span class="line">methods = ReflectionUtils.getDeclaredMethods(DemoObject<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">System.out.println(Arrays.toString(methods));</span><br><span class="line">System.out.println(<span class="string">"---------- doWithLocalFields ----------"</span>);</span><br><span class="line"><span class="comment">// 当前类的所有方法，通过回调</span></span><br><span class="line"><span class="comment">// private java.lang.String com.zstu.student.DemoObject.field01</span></span><br><span class="line"><span class="comment">// public static final java.lang.String com.zstu.student.DemoObject.field02</span></span><br><span class="line">ReflectionUtils.doWithLocalFields(DemoObject.class, System.out::println);</span><br><span class="line">System.out.println(<span class="string">"---------- getUniqueDeclaredMethods ----------"</span>);</span><br><span class="line"><span class="comment">// 若在子类重新父类方法则该方法将被移除</span></span><br><span class="line">methods = ReflectionUtils.getUniqueDeclaredMethods(DemoObject<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">System.out.println(Arrays.toString(methods));</span><br><span class="line">System.out.println(<span class="string">"---------- getField ----------"</span>);</span><br><span class="line"><span class="comment">// 获取字段的值</span></span><br><span class="line">Object ret1 = ReflectionUtils.getField(field2, <span class="keyword">new</span> DemoObject());</span><br><span class="line"><span class="comment">// 这是字段2</span></span><br><span class="line">System.out.println(ret1);</span><br><span class="line">System.out.println(<span class="string">"---------- invokeMethod ----------"</span>);</span><br><span class="line"><span class="comment">// 调用方法</span></span><br><span class="line">Object ret2 = ReflectionUtils.invokeMethod(method1, <span class="keyword">new</span> DemoObject());</span><br><span class="line"><span class="comment">// 无参方法1</span></span><br><span class="line">System.out.println(ret2);</span><br><span class="line">System.out.println(<span class="string">"---------- isxxx----------"</span>);</span><br><span class="line"><span class="comment">// 是toString方法吗? true是,false不是</span></span><br><span class="line">boolean isString = ReflectionUtils.isToStringMethod(ReflectionUtils.findMethod(DemoObject.class, "toString"));</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">System.out.println(isString);</span><br><span class="line"><span class="comment">// 是否公共静态final修饰属性吗? true是,false不是</span></span><br><span class="line"><span class="keyword">boolean</span> isPublicStatic = ReflectionUtils.isPublicStaticFinal(field2);</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">System.out.println(isPublicStatic);</span><br><span class="line"><span class="comment">// 是Object类声明的方法吗? true是,false不是</span></span><br><span class="line">boolean isObject = ReflectionUtils.isObjectMethod(ReflectionUtils.findMethod(DemoObject.class, "toString"));</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">System.out.println(isObject);</span><br><span class="line"><span class="comment">// 是equals方法吗? true是,false不是</span></span><br><span class="line">boolean isEquals = ReflectionUtils.isEqualsMethod(ReflectionUtils.findMethod(DemoObject.class, "equals", Object.class));</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">System.out.println(isEquals);</span><br><span class="line"><span class="comment">// 是hashCode方法吗? true是,false不是</span></span><br><span class="line">boolean isHashCode = ReflectionUtils.isHashCodeMethod(ReflectionUtils.findMethod(DemoObject.class, "hashCode"));</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">System.out.println(isHashCode);</span><br><span class="line"><span class="comment">// 清空缓存，每次查询(方法,参数)时都会做缓存。</span></span><br><span class="line">ReflectionUtils.clearCache();</span><br><span class="line"><span class="comment">// 是Cglib重命名的方法吗? TODO test</span></span><br><span class="line"><span class="comment">// ReflectionUtils.isCglibRenamedMethod()</span></span><br></pre></td></tr></table></figure><h1>二、第三方工具类</h1><p>这里推荐的第三方工具类是<strong>Hutool工具类</strong>，里面工具包十分全面，官方网址<a href="https://hutool.cn/docs/#/" target="_blank" rel="noopener">https://hutool.cn/docs/#/</a></p><hr><p>参考转载文章：</p><p><a href="https://juejin.cn/post/7043403364020781064#heading-10" target="_blank" rel="noopener">https://juejin.cn/post/7043403364020781064#heading-10</a></p><p><a href="https://blog.csdn.net/ZG123456h/article/details/122104601" target="_blank" rel="noopener">https://blog.csdn.net/ZG123456h/article/details/122104601</a></p>]]></content>
    
    
    <summary type="html">&lt;h1&gt;一、内置工具类&lt;/h1&gt;
&lt;p&gt;内置工具类一般位于&lt;code&gt;org.springframework.util&lt;/code&gt;下&lt;/p&gt;
&lt;h2 id=&quot;1、断言&quot;&gt;1、断言&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;断言是一个逻辑判断，用于检查不应该发生的情况&lt;/li&gt;
&lt;li&gt;Assert 关键字在 JDK1.4 中引入，可通过 JVM 参数&lt;code&gt;-enableassertions&lt;/code&gt;开启&lt;/li&gt;
&lt;li&gt;SpringBoot 中提供了 Assert 断言工具类，通常用于数据合法性检查&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Java" scheme="https://www.shawn22.xyz/categories/Java/"/>
    
    
    <category term="Spring基础" scheme="https://www.shawn22.xyz/tags/Spring%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java命令行编译打包</title>
    <link href="https://www.shawn22.xyz/posts/aea952f.html"/>
    <id>https://www.shawn22.xyz/posts/aea952f.html</id>
    <published>2022-02-13T11:03:35.000Z</published>
    <updated>2022-03-02T01:44:40.258Z</updated>
    
    <content type="html"><![CDATA[<h1>一、简介</h1><h2 id="1、介绍">1、介绍</h2><p>本文主要记录jar与java相关命令介绍以及Java 命令行编译、执行、打包等操作</p><a id="more"></a><h2 id="2、Jar简介">2、Jar简介</h2><blockquote><p><a href="https://docs.oracle.com/javase/tutorial/deployment/jar/manifestindex.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/tutorial/deployment/jar/manifestindex.html</a></p></blockquote><p>Java归档文件格式(Java Archive, JAR)能够将多个源码、资源等文件打包到一个归档文件中，包括以下几种优点</p><ul><li>安全性<br>可以对整个jar包的内容进行签名。</li><li>减少下载时间<br>如果applet被打包成一个jar文件，那么所有相关的资源就可以在一个HTTP transaction中下载完成，而无需为每一个文件新建一个连接。</li><li>压缩<br>减少了磁盘空间的占用。</li><li>容易扩展<br>通过jar这种格式，可以和容易地将自己的程序打包提供给别人使用。</li><li>包密封(Package Sealing)<br>存储在jar文件中的包可以被密封，来保证版本的一致性。密封可以保证一个包中的所有类都来自同一个jar文件。</li><li>包版本说明<br>一个jar包可以存储关于其内容的信息，包括提供商、版本等。</li><li>可移植性<br>处理jar文件的机制是Java平台核心API的标准模块。</li></ul><h2 id="3、Java命令行">3、Java命令行</h2><h3 id="3-1-jar相关命令">3.1 jar相关命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">jar</span><br><span class="line">用法: jar &#123;ctxui&#125;[vfmn0PMe] [jar-file] [manifest-file] [entry-point] [-C dir] files ...</span><br><span class="line">选项:</span><br><span class="line">    -c  创建新档案</span><br><span class="line">    -t  列出档案目录</span><br><span class="line">    -x  从档案中提取指定的 (或所有) 文件</span><br><span class="line">    -u  更新现有档案</span><br><span class="line">    -v  在标准输出中生成详细输出</span><br><span class="line">    -f  指定档案文件名</span><br><span class="line">    -m  包含指定清单文件中的清单信息</span><br><span class="line">    -n  创建新档案后执行 Pack200 规范化</span><br><span class="line">    -e  为捆绑到可执行 jar 文件的独立应用程序指定应用程序入口点</span><br><span class="line">    -0  仅存储; 不使用任何 ZIP 压缩</span><br><span class="line">    -P  保留文件名中的前导 <span class="string">'/'</span> (绝对路径) 和 <span class="string">".."</span> (父目录) 组件</span><br><span class="line">    -M  不创建条目的清单文件</span><br><span class="line">    -i  为指定的 jar 文件生成索引信息</span><br><span class="line">    -C  更改为指定的目录并包含其中的文件(可以理解为首先<span class="built_in">cd</span>到指定目录)</span><br><span class="line">如果任何文件为目录, 则对其进行递归处理。</span><br><span class="line">清单文件名, 档案文件名和入口点名称的指定顺序与 <span class="string">'m'</span>, <span class="string">'f'</span> 和 <span class="string">'e'</span> 标记的指定顺序相同。</span><br><span class="line"></span><br><span class="line">示例 1: 将两个类文件归档到一个名为 classes.jar 的档案中:</span><br><span class="line">       jar cvf classes.jar Foo.class Bar.class</span><br><span class="line">示例 2: 使用现有的清单文件 <span class="string">'mymanifest'</span> 并将 foo/ 目录中的所有文件归档到 <span class="string">'classes.jar'</span> 中:</span><br><span class="line">       jar cvfm classes.jar mymanifest -C foo/ .</span><br></pre></td></tr></table></figure><p>下面举例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看归档文件的内容</span></span><br><span class="line">jar -vtf HelloWorld.jar</span><br><span class="line"><span class="comment">#解压出其中的META-INF/MANIFEST.MF文件</span></span><br><span class="line">jar -xf HelloWorld.jar META-INF/MANIFEST.MF</span><br><span class="line"><span class="comment">#查看清单文件的内容</span></span><br><span class="line"><span class="built_in">type</span> META-INF\MANIFEST.MF</span><br><span class="line"><span class="comment">#将HelloWorld.class文件打入jar包，不要添加清单文件</span></span><br><span class="line">jar -cvfM HelloWorld.jar HelloWorld.class</span><br><span class="line"><span class="comment">#解压tar文件到当前目录</span></span><br><span class="line">jar -xf HelloWorld.jar</span><br><span class="line"><span class="comment">#创建可以运行的jar包</span></span><br><span class="line">jar -cvfe HelloWorld.jar HelloWorld HelloWorld.class</span><br></pre></td></tr></table></figure><h3 id="3-2-Java相关命令">3.2 Java相关命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">用法: java [-options] class [args...]</span><br><span class="line">           (执行类)</span><br><span class="line">   或  java [-options] -jar jarfile [args...]</span><br><span class="line">           (执行 jar 文件)</span><br><span class="line">其中选项包括:</span><br><span class="line">    -d32          使用 32 位数据模型 (如果可用)</span><br><span class="line">    -d64          使用 64 位数据模型 (如果可用)</span><br><span class="line">    -server       选择 <span class="string">"server"</span> VM</span><br><span class="line">                  默认 VM 是 server.</span><br><span class="line"></span><br><span class="line">    -cp &lt;目录和 zip/jar 文件的类搜索路径&gt;</span><br><span class="line">    -classpath &lt;目录和 zip/jar 文件的类搜索路径&gt;</span><br><span class="line">                  用 ; 分隔的目录, JAR 档案</span><br><span class="line">                  和 ZIP 档案列表, 用于搜索类文件。</span><br><span class="line">    -D&lt;名称&gt;=&lt;值&gt;</span><br><span class="line">                  设置系统属性</span><br><span class="line">    -verbose:[class|gc|jni]</span><br><span class="line">                  启用详细输出</span><br><span class="line">    -version      输出产品版本并退出</span><br><span class="line">    -version:&lt;值&gt;</span><br><span class="line">                  警告: 此功能已过时, 将在</span><br><span class="line">                  未来发行版中删除。</span><br><span class="line">                  需要指定的版本才能运行</span><br><span class="line">    -showversion  输出产品版本并继续</span><br><span class="line">    -jre-restrict-search | -no-jre-restrict-search</span><br><span class="line">                  警告: 此功能已过时, 将在</span><br><span class="line">                  未来发行版中删除。</span><br><span class="line">                  在版本搜索中包括/排除用户专用 JRE</span><br><span class="line">    -? -<span class="built_in">help</span>      输出此帮助消息</span><br><span class="line">    -X            输出非标准选项的帮助</span><br><span class="line">    -ea[:&lt;packagename&gt;...|:&lt;classname&gt;]</span><br><span class="line">    -enableassertions[:&lt;packagename&gt;...|:&lt;classname&gt;]</span><br><span class="line">                  按指定的粒度启用断言</span><br><span class="line">    -da[:&lt;packagename&gt;...|:&lt;classname&gt;]</span><br><span class="line">    -disableassertions[:&lt;packagename&gt;...|:&lt;classname&gt;]</span><br><span class="line">                  禁用具有指定粒度的断言</span><br><span class="line">    -esa | -enablesystemassertions</span><br><span class="line">                  启用系统断言</span><br><span class="line">    -dsa | -disablesystemassertions</span><br><span class="line">                  禁用系统断言</span><br><span class="line">    -agentlib:&lt;libname&gt;[=&lt;选项&gt;]</span><br><span class="line">                  加载本机代理库 &lt;libname&gt;, 例如 -agentlib:hprof</span><br><span class="line">                  另请参阅 -agentlib:jdwp=<span class="built_in">help</span> 和 -agentlib:hprof=<span class="built_in">help</span></span><br><span class="line">    -agentpath:&lt;pathname&gt;[=&lt;选项&gt;]</span><br><span class="line">                  按完整路径名加载本机代理库</span><br><span class="line">    -javaagent:&lt;jarpath&gt;[=&lt;选项&gt;]</span><br><span class="line">                  加载 Java 编程语言代理, 请参阅 java.lang.instrument</span><br><span class="line">    -splash:&lt;imagepath&gt;</span><br><span class="line">                  使用指定的图像显示启动屏幕</span><br></pre></td></tr></table></figure><h1>二、简单编译打包实战</h1><h2 id="1、简单编译执行">1、简单编译执行</h2><p>首先创建好目录已经demo文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/82c5f1b2d1bc435ab1a11515f7e9be5d.png" alt="在这里插入图片描述"><br>编译执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -d target 参数，指定 class 文件生成在 target 目录</span></span><br><span class="line">javac src/com/demo/Hello.java -d target</span><br><span class="line"><span class="comment">#在dos下编译java程序，就要用到classpath这个概念，尤其是在没有设置环境变量的时候，classpath就是存放.class等编译后文件的路径</span></span><br><span class="line"><span class="comment"># -cp target这个参数是把target目录添加到 classpath 目录，成功输出hello</span></span><br><span class="line">java -cp target com.demo.Hello</span><br><span class="line"><span class="comment"># 引入第三方依赖库，用：进行分隔</span></span><br><span class="line">java -cp target:libs/gson-2.8.5.jar com.demo.HelloGson</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/78009b1f03614748a02b3a439fdc564f.png?type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6a2FTGVtb24=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="2、Jar包方式运行">2、Jar包方式运行</h2><h3 id="2-1-普通方式执行">2.1 普通方式执行</h3><p>Java程序打包与执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -C target . 参数，指定把 target 目录下的所有文件打包</span></span><br><span class="line">jar -cvf my.jar -C target .</span><br><span class="line"><span class="comment"># 这里执行java -jar my.jar会报错，因为没有指定入口</span></span><br><span class="line"><span class="comment"># -cp my.jar 把 jar 包添加到 classpath 目录</span></span><br><span class="line"><span class="comment"># com.demo.Hello 说明哪个类是入口</span></span><br><span class="line">java -cp my.jar com.demo.Hello</span><br></pre></td></tr></table></figure><h3 id="2-2-可执行的-jar-包">2.2 可执行的 jar 包</h3><p>可执行jar包可以直接执行，无需指定入口，但是需要创建<code>MANIFEST.MF</code>文件在文件内说明程序入口；<br>一般编写MANIFEST.MF文件只需要用到<strong>Manifest-Version</strong>(MF文件版本号)、<strong>Main-Class</strong>(包含main方法的类)、<strong>Class-Path</strong>(执行这个jar包时的ClassPath，第三方依赖)，详情可以参考<br><a href="https://www.cnblogs.com/EasonJim/p/6485677.html" target="_blank" rel="noopener">MANIFEST.MF文件解释</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#注意最后一样一定要回车，空一行，不然无法识别最后一行的配置</span></span><br><span class="line">Manifest-Version: 1.0 </span><br><span class="line">Main-Class: com.demo.Hello</span><br><span class="line"><span class="comment"># 第三方依赖举例</span></span><br><span class="line">Class-Path: ./ ./lib/commons-collections-3.2.jar ./lib/commons-dbcp-1.2.2.jar</span><br></pre></td></tr></table></figure><p>之后再次打包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加了 m 参数，指定 MANIFEST.MF，这个文件的内容会被添加到 jar 包的清单，用于说明 my.jar 的入口</span></span><br><span class="line">jar -cvfm my.jar MANIFEST.MF -C target .</span><br><span class="line"><span class="comment"># 成功执行</span></span><br><span class="line">java -jar my.jar</span><br></pre></td></tr></table></figure><hr><p>参考文章<br><a href="https://www.cnblogs.com/eoalfj/p/12332808.html" target="_blank" rel="noopener">https://www.cnblogs.com/eoalfj/p/12332808.html</a><br><a href="https://www.jianshu.com/p/61cfa1347894" target="_blank" rel="noopener">https://www.jianshu.com/p/61cfa1347894</a></p>]]></content>
    
    
    <summary type="html">&lt;h1&gt;一、简介&lt;/h1&gt;
&lt;h2 id=&quot;1、介绍&quot;&gt;1、介绍&lt;/h2&gt;
&lt;p&gt;本文主要记录jar与java相关命令介绍以及Java 命令行编译、执行、打包等操作&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://www.shawn22.xyz/categories/Java/"/>
    
    
    <category term="Java基础" scheme="https://www.shawn22.xyz/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Docker常见问题详解</title>
    <link href="https://www.shawn22.xyz/posts/92b713c.html"/>
    <id>https://www.shawn22.xyz/posts/92b713c.html</id>
    <published>2022-02-13T00:33:30.000Z</published>
    <updated>2022-02-13T00:35:14.730Z</updated>
    
    <content type="html"><![CDATA[<h1>一、Docker新增端口映射</h1><h2 id="1、简介">1、简介</h2><p>在<code>docker run</code>创建并运行容器的时候，可以通过<code>-p</code>指定端口映射规则。但是容器一旦生成，就没有一个命令可以直接修改。一般情况下，有两种方式进行映射端口新增或者修改，这里环境是Ubuntu20.04</p><ul><li>新建容器</li><li>修改容器配置文件</li></ul><a id="more"></a><h2 id="2、修改容器两种方式">2、修改容器两种方式</h2><h3 id="2-1-新建容器">2.1 新建容器</h3><p>这种方式最简单，将原有的容器删掉，重新新建一个，新建的时候确定好端口映射；</p><p><strong>优缺点</strong></p><ul><li>优点是简单快捷，在测试环境使用较多</li><li>缺点是每次都要重新配置，操作会比较麻烦</li></ul><h3 id="2-2-修改容器配置文件">2.2 修改容器配置文件</h3><ul><li><strong>查看容器</strong></li></ul><p>其中的hashofthecontainer是docker镜像的hash值，<code>CONTAINER ID</code>就是取了前几位数的值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看docker正在运行的容器</span></span><br><span class="line">docker ps</span><br><span class="line"><span class="comment">#查看某个容器详细信息</span></span><br><span class="line">docker inspect containername</span><br></pre></td></tr></table></figure><ul><li><strong>关闭docker服务</strong></li></ul><p>若不关闭，可能会导致修改完的配置信息，重启后又变回原来的配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop docker.service</span><br></pre></td></tr></table></figure><p>这里可能会报警报，原因是除了docker.service单元文件，还有一个docker.socket单元文件…docker.socket这是用于套接字激活。  该警告意味着：如果你试图连接到docker socket，而docker服务没有运行，系统将自动启动docker。一般不做理会</p><blockquote><p>Warning: Stopping docker.service, but it can still be activated by: docker.socket</p></blockquote><ul><li><strong>修改文件</strong></li></ul><p>容器的配置文件路径<code>/var/lib/docker/containers/[hash_of_the_container]/hostconfig.json</code>，打开配置文件，找到<strong>PortBindings</strong>值，在这个json集合里边追加新端口。当然这两个配置文件还有很多其他信息可以修改，原理相同</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">"PortBindings": &#123;</span><br><span class="line">    "8081/tcp": [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"HostIp"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="attr">"HostPort"</span>: <span class="string">"8081"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    "8085/tcp": [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"HostIp"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="attr">"HostPort"</span>: <span class="string">"8085"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>假如在<code>config.v2.json</code>文件里也记录了端口，也需要同时修改，修改值：<code>Config-&gt;ExposedPorts</code>和<code>NetworkSettings-&gt;Ports</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">"Config": &#123;</span><br><span class="line">    "Hostname": "acf6f980b9d3",</span><br><span class="line">    "Domainname": "",</span><br><span class="line">    "User": "",</span><br><span class="line">    "AttachStdin": false,</span><br><span class="line">    "AttachStdout": false,</span><br><span class="line">    "AttachStderr": false,</span><br><span class="line">    "ExposedPorts": &#123;</span><br><span class="line">      "8081/tcp": &#123;</span><br><span class="line">        </span><br><span class="line">      &#125;,</span><br><span class="line">      "8085/tcp": &#123;</span><br><span class="line">        </span><br><span class="line">      &#125;,</span><br><span class="line">      "8088/tcp": &#123;</span><br><span class="line">        </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">"NetworkSettings": &#123;</span><br><span class="line">    "Ports": &#123;</span><br><span class="line">      "8081/tcp": [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"HostIp"</span>: <span class="string">"0.0.0.0"</span>,</span><br><span class="line">          <span class="attr">"HostPort"</span>: <span class="string">"8081"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"HostIp"</span>: <span class="string">"::"</span>,</span><br><span class="line">          <span class="attr">"HostPort"</span>: <span class="string">"8081"</span></span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      "8085/tcp": [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"HostIp"</span>: <span class="string">"0.0.0.0"</span>,</span><br><span class="line">          <span class="attr">"HostPort"</span>: <span class="string">"8085"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"HostIp"</span>: <span class="string">"::"</span>,</span><br><span class="line">          <span class="attr">"HostPort"</span>: <span class="string">"8085"</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>重启docker服务和容器</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart docker.service</span><br></pre></td></tr></table></figure><p><strong>优缺点</strong></p><ul><li>优点是没有副作用，操作简单</li><li>缺点是需要重启整个docker服务，如果在同一个宿主机上运行着多个容器服务的话，就会影响其他容器服务</li></ul><h1>二、Linux Dockerfile构建后不能正常启动</h1><h2 id="1、问题描述">1、问题描述</h2><p>下面是我自己构建的一个基于Centos8的JDK8docker环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">FROM centos:8</span><br><span class="line">MAINTAINER shawn</span><br><span class="line"><span class="comment">#把java与tomcat添加到容器中，会自动解压</span></span><br><span class="line">ADD jdk-8u161-linux-x64.tar.gz /usr/<span class="built_in">local</span>/</span><br><span class="line"><span class="comment">#设置工作访问时候的WORKDIR路径，登录落脚点</span></span><br><span class="line">WORKDIR /</span><br><span class="line"><span class="comment">#安装vim编辑器</span></span><br><span class="line">RUN yum -y install vim</span><br><span class="line"><span class="comment">#配置java与tomcat环境变量</span></span><br><span class="line">ENV JAVA_HOME /usr/<span class="built_in">local</span>/jdk1.8.0_161</span><br><span class="line">ENV CLASSPATH <span class="variable">$JAVA_HOME</span>/lib/dt.jar:<span class="variable">$JAVA_HOME</span>/lib/tools.jar</span><br><span class="line">ENV PATH <span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin</span><br><span class="line"></span><br><span class="line">RUN ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line">RUN <span class="built_in">echo</span> <span class="string">'Asia/Shanghai'</span> &gt;/etc/timezone</span><br><span class="line">EXPOSE 8081 8088</span><br><span class="line">CMD ehco <span class="string">"构建成功"</span></span><br><span class="line">ENTRYPOINT /bin/bash</span><br></pre></td></tr></table></figure><p>将所需<code>jdk-8u161-linux-x64.tar.gz</code>和<code>Dockerfile</code>文件上传到linux目录，进行构建<code>docker -t lamp:1.0 .</code>，构建完成后，运行容器<code>docker run -d -p 8081:8081 -p 8088:8088 -v /home/shawn/ZHD/dockerdata:/data --name lamp lamp:1.0</code> ，然后发现容器不能正常启动，centos 启动一个容器添加了-d 参数，但是docker ps 或者docker ps -a查看却已经退出了</p><h2 id="2、原因介绍">2、原因介绍</h2><ul><li>docker容器运行必须有一个前台进程， 如果没有前台进程执行，容器认为空闲，就会自行退出</li><li>容器运行的命令如果不是那些一直挂起的命令（ 运行top，tail、循环、tomcat等），就是会自动退出</li><li>这个是 docker 的机制问题</li></ul><h2 id="3、解决法法">3、解决法法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#为docker run添加-it命令</span></span><br><span class="line">docker run -itd -p 8081:8081 -p 8088:8088 -v /home/shawn/dockerdata:/data --name lamp lamp:1.0</span><br></pre></td></tr></table></figure><h1>三、Docker容器设置时区</h1><h2 id="1、问题描述-v2">1、问题描述</h2><p>Docker Hub 中的官方镜像，一般都默认设置为 UTC 时间。而我们位于东八区，在启动容器或构建自己的镜像时，往往需要对时区进行设置</p><h2 id="2、配置过程">2、配置过程</h2><p>这里我的docker环境是Ubuntu，有两种方式进行更改</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#进入运行的容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it lamp /bin/bash</span><br><span class="line"><span class="comment">#查看当前日期</span></span><br><span class="line">date</span><br><span class="line"><span class="comment">#显示结果</span></span><br><span class="line">Tue Jan 11 08:42:26 CST 2022</span><br></pre></td></tr></table></figure><p><strong>第一种</strong>方式在宿主机运行，完成后重启docker容器</p><ul><li>将本地的localtime文件复制到容器中</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp /etc/localtime &#123;容器id&#125;:/etc/localtime</span><br></pre></td></tr></table></figure><ul><li>将本地的<code>/usr/share/zoneinfo/Asia/Shanghai</code>文件复制到容器中</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp  /usr/share/zoneinfo/Asia/Shanghai  &#123;容器id&#125;:/etc/localtime</span><br></pre></td></tr></table></figure><p><strong>第二种</strong>进入容器运行，无需重启容器，若容器内部文件不存在，则还需要使用第一种</p><ul><li>链接宿主机localtime</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br></pre></td></tr></table></figure><p><strong>第三种</strong>在构建dockerfile的时候运行命令</p><hr><p>参考</p><p><a href="https://blog.csdn.net/weixin_43885975/article/details/117809901" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43885975/article/details/117809901</a></p><p><a href="https://blog.csdn.net/jameskaron/article/details/105540549" target="_blank" rel="noopener">https://blog.csdn.net/jameskaron/article/details/105540549</a></p>]]></content>
    
    
    <summary type="html">&lt;h1&gt;一、Docker新增端口映射&lt;/h1&gt;
&lt;h2 id=&quot;1、简介&quot;&gt;1、简介&lt;/h2&gt;
&lt;p&gt;在&lt;code&gt;docker run&lt;/code&gt;创建并运行容器的时候，可以通过&lt;code&gt;-p&lt;/code&gt;指定端口映射规则。但是容器一旦生成，就没有一个命令可以直接修改。一般情况下，有两种方式进行映射端口新增或者修改，这里环境是Ubuntu20.04&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;新建容器&lt;/li&gt;
&lt;li&gt;修改容器配置文件&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.shawn22.xyz/categories/Linux/"/>
    
    
    <category term="docker" scheme="https://www.shawn22.xyz/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Random和ThreadLocalRandom分析简介</title>
    <link href="https://www.shawn22.xyz/posts/f4374131.html"/>
    <id>https://www.shawn22.xyz/posts/f4374131.html</id>
    <published>2022-02-13T00:32:49.000Z</published>
    <updated>2022-02-13T00:35:14.731Z</updated>
    
    <content type="html"><![CDATA[<h1>一、Random类</h1><h2 id="1、简介">1、简介</h2><p>Random 类用于生成伪随机数的流。 该类使用48位种子，其使用线性同余公式进行修改</p><ul><li><code>Math.random()</code>使用起来相对更简单，但不是线程安全的；</li><li><code>java.util.Random</code>的Random类是线程安全的。 但是跨线程的同时使用<code>java.util.Random</code>实例可能会遇到争用，从而导致性能下降。 在多线程设计中考虑使用<code>ThreadLocalRandom</code>类；</li><li><code>java.util.Random</code>的Random不是加密安全的。 考虑使用<code>SecureRandom</code>获取一个加密安全的伪随机数生成器，供安全敏感应用程序使用。</li></ul><a id="more"></a><h2 id="2、Random的构造函数">2、Random的构造函数</h2><ul><li>Random()：创建一个新的随机数生成器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new random number generator. This constructor sets</span></span><br><span class="line"><span class="comment"> * the seed of the random number generator to a value very likely</span></span><br><span class="line"><span class="comment"> * to be distinct from any other invocation of this constructor.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Random</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//System.nanoTime()返回正在运行的Java虚拟机的高分辨率时间源的当前值，以纳秒为单位。</span></span><br><span class="line">    <span class="comment">//这里会调用有参构造函数</span></span><br><span class="line">    <span class="keyword">this</span>(seedUniquifier() ^ System.nanoTime());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">seedUniquifier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 线性同余生成元表  </span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">long</span> current = seedUniquifier.get();</span><br><span class="line">        <span class="keyword">long</span> next = current * <span class="number">181783497276652981L</span>; </span><br><span class="line">        <span class="comment">// 两个很大的数相乘</span></span><br><span class="line">        <span class="keyword">if</span> (seedUniquifier.compareAndSet(current, next))</span><br><span class="line">            <span class="comment">// 这个比较并且交换CAS</span></span><br><span class="line">            <span class="comment">// 比较当前工作内存中的值和主内存中的值，如果这个值是期望的，那么则执行操作！</span></span><br><span class="line">            <span class="comment">//如果不是就一直循环！就是为了保证即使在多线程的环境中返回的也是不同的数</span></span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// atomic 这个是 juc 里面修饰的原子性的 long ，get方法说就是获得这个构造函数里面的值</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLong seedUniquifier</span><br><span class="line">        = <span class="keyword">new</span> AtomicLong(<span class="number">8682522807148012L</span>);</span><br></pre></td></tr></table></figure><ul><li>random(long seed)：使用单个 Long 种子创建一个新的随机数生成器\</li></ul><p>伪随机使用了<strong>线性同余法</strong>(具体可自行查阅资料)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Random</span><span class="params">(<span class="keyword">long</span> seed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getClass() == Random<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">        <span class="title">this</span>.<span class="title">seed</span> </span>= <span class="keyword">new</span> AtomicLong(initialScramble(seed));</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 子类可能重写了这个不考虑</span></span><br><span class="line">        <span class="keyword">this</span>.seed = <span class="keyword">new</span> AtomicLong(); <span class="comment">// 创建一个新的AtomicLong，初始值为 0 </span></span><br><span class="line">        setSeed(seed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//清除nextGaussian()使用的haveNextNextGaussian 标志，</span></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSeed</span><span class="params">(<span class="keyword">long</span> seed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.seed.set(initialScramble(seed));</span><br><span class="line">        haveNextNextGaussian = <span class="keyword">false</span>; </span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">initialScramble</span><span class="params">(<span class="keyword">long</span> seed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (seed ^ multiplier) &amp; mask;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> multiplier = <span class="number">0x5DEECE66DL</span>;</span><br><span class="line">  <span class="comment">// x &amp; [(1L &lt;&lt; 48)–1]与 x（mod 2^48）等价 取低位48位</span></span><br><span class="line">  <span class="comment">// 带符号左移</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> mask = (<span class="number">1L</span> &lt;&lt; <span class="number">48</span>) - <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h2 id="3、next-核心方法">3、next()核心方法</h2><p>Random在多线程的环境是并发安全的，它解决竞争的方式是使用用原子类，本质上上也就是CAS + Volatile保证线程安全</p><p><img src="https://img-blog.csdnimg.cn/d3e9074b210242efa52551d8d11694d5.png#pic_center" alt="在这里插入图片描述"></p><p>在Random类中，有一个AtomicLong的域，用来保存随机种子。其中每次生成随机数时都会根据随机种子做移位操作以得到随机数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Long类型的随机</span></span><br><span class="line"><span class="comment">//long类型在Java中总弄64bit，对next方法的返回值左移32作为long的高位，然后将next方法返回值作为低32位，作为long类型的随机数。</span></span><br><span class="line"><span class="comment">//此处关键之处在于next方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">nextLong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">long</span>)(next(<span class="number">32</span>)) &lt;&lt; <span class="number">32</span>) + next(<span class="number">32</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是next方法的核心，使用seed种子，不断生成新的种子，然后使用CAS将其更新，再返回种子的移位后值。这里不断的循环CAS操作种子，直到成功。可见，Random实现原理主要是利用随机种子采用一定算法进行处理生成随机数，在随机种子的安全保证利用原子类AtomicLong。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> bits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> oldseed, nextseed;</span><br><span class="line">        AtomicLong seed = <span class="keyword">this</span>.seed;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            oldseed = seed.get();</span><br><span class="line">            nextseed = (oldseed * multiplier + addend) &amp; mask;</span><br><span class="line">        &#125; <span class="keyword">while</span> (!seed.compareAndSet(oldseed, nextseed));</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(nextseed &gt;&gt;&gt; (<span class="number">48</span> - bits));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="4、Random在并发下的缺点">4、Random在并发下的缺点</h2><p>虽然Random是线程安全，但是对于并发处理使用原子类AtomicLong在大量竞争时，使用同一个 Random 对象可能会导致线程阻塞，由于很多CAS操作会造成失败，不断的Spin，而造成CPU开销比较大而且吞吐量也会下降。</p><p>这里可以自行多线程测试，可以发现随着线程增加，Random随着竞争越来越激烈，然后耗时越来越多。然而ThreadLocalRandom随着线程数的增加，基本没有变化。所以在大并发的情况下，随机的选择，可以考虑ThreadLocalRandom提升性能。</p><h1>二、ThreadLocalRandom</h1><h2 id="1、简介-v2">1、简介</h2><p><code>ThreadLocalRandom</code>是<code>Random</code>的子类，它是将Seed随机种子隔离到当前线程的随机数生成器，从而解决了<code>Random</code>在Seed上竞争的问题，它的处理思想和<code>ThreadLocal</code>本质相同。</p><p>Unsafe 类内的方法透露着一股 “Unsafe” 的气息，具体表现就是可以直接操作内存，而不做任何安全校验，如果有问题，则会在运行时抛出 <code>Fatal Error</code>，导致整个虚拟机的退出。</p><h2 id="2、原理分析">2、原理分析</h2><h3 id="2-1-ThreadLocalRandom单例模式">2.1 ThreadLocalRandom单例模式</h3><p>从下述代码可以发现<code>ThreadLocalRandom</code>使用了<strong>单例模式</strong>，即在一个Java应用中只有一个ThreadLocalRandom对象。当<code>UNSAFE.getInt(Thread.currentThread(), PROBE)</code>返回0时，就执行<code>localInit()</code>，最后返回单例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个java应用只有一个实例</span></span><br><span class="line"><span class="comment">// ThreadLocalRandom对象通过ThreadLocalRandom.current()获取，之后可以直接返回随机数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ThreadLocalRandom instance = <span class="keyword">new</span> ThreadLocalRandom();</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取ThreadLocalRandom对象实例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThreadLocalRandom <span class="title">current</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (UNSAFE.getInt(Thread.currentThread(), PROBE) == <span class="number">0</span>)</span><br><span class="line">        localInit();</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-Seed随机种子隔离到当前线程">2.2 Seed随机种子隔离到当前线程</h3><p><strong>核心方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//会从 object 对象var1的内存地址偏移var2后的位置读取四个字节作为long型返回</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">getLong</span><span class="params">(Object var1, <span class="keyword">long</span> var2)</span></span>;</span><br><span class="line"><span class="comment">//可以将object对象var1的内存地址偏移var2后的位置后四个字节设置为 var4</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">putLong</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">long</span> var4)</span></span>;</span><br></pre></td></tr></table></figure><p><code>UNSAFE.getInt(Thread.currentThread(), PROBE)</code>是获取当前Thread线程对象中的PROBE。</p><p>首先获取变量名<code>SEED</code>、<code>PROBE</code>等参数相对对象的偏移位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unsafe mechanics</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SEED;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> PROBE;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SECONDARY;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">        Class&lt;?&gt; tk = Thread<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        SEED = UNSAFE.objectFieldOffset</span><br><span class="line">            (tk.getDeclaredField(<span class="string">"threadLocalRandomSeed"</span>));</span><br><span class="line">        PROBE = UNSAFE.objectFieldOffset</span><br><span class="line">            (tk.getDeclaredField(<span class="string">"threadLocalRandomProbe"</span>));</span><br><span class="line">        SECONDARY = UNSAFE.objectFieldOffset</span><br><span class="line">            (tk.getDeclaredField(<span class="string">"threadLocalRandomSecondarySeed"</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当第一次调用<code>ThreadLocalRandom.current()</code>方法时当前线程检测到<code>PROBE</code>未初始化会调用<code>localInit()</code>方法进行初始化，并把<strong>当前线程的seed值和probe值存储在当前线程Thread对象内存地址偏移相对应变量的位置</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">localInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = probeGenerator.addAndGet(PROBE_INCREMENT);</span><br><span class="line">    <span class="keyword">int</span> probe = (p == <span class="number">0</span>) ? <span class="number">1</span> : p; <span class="comment">// skip 0</span></span><br><span class="line">    <span class="keyword">long</span> seed = mix64(seeder.getAndAdd(SEEDER_INCREMENT));</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    UNSAFE.putLong(t, SEED, seed);</span><br><span class="line">    UNSAFE.putInt(t, PROBE, probe);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>threadLocalRandomProbe</code>用于表示当前线程Thread是否初始化，如果是非0，表示其已经初始化。换句话说，该变量就是状态变量，用于标识当前线程Thread是否被初始化。<code>threadLocalRandomSeed</code>从注释中也可以看出，它是当前线程的随机种子。随机种子分散在各个Thread对象中，从而避免了并发时的竞争点。</p><h2 id="3、nextSeed-核心方法">3、nextSeed()核心方法</h2><p><code>nextSeed()</code>生成随机种子用来生成随机数序列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">nextLong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mix64(nextSeed());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为在初始化的时候已经<strong>存储了当前线程的seed值和probe值到相应线程对象内存地址的偏移位置</strong>，调用<code>nextSeed()</code>时直接<strong>从当前线程对象偏移位置处进行获取，并生成下一个随机数种子到该位置</strong>，同时使用了<code>UNSAFE</code>类方法，不同线程间不需要竞争获得seed值，因此可以可以将竞争点隔离</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">nextSeed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t; <span class="keyword">long</span> r; <span class="comment">// read and update per-thread seed</span></span><br><span class="line">    UNSAFE.putLong(t = Thread.currentThread(), SEED,</span><br><span class="line">                   r = UNSAFE.getLong(t, SEED) + GAMMA);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>三、总结</h1><p><code>Random</code>是Java中提供的随机数生成器工具类，但是在大并发的情况下由于其随机种子的竞争会导致吞吐量下降，从而引入<code>ThreadLocalRandom</code>它将竞争点隔离到每个线程中，从而消除了大并发情况下竞争问题，提升了性能。</p><p>并发竞争的整体优化思路：<strong>lock -&gt; cas + volatile -&gt; free lock</strong></p><hr><p>参考文章</p><p><a href="https://mp.weixin.qq.com/s/f-lfqEUNvY6XRmCL-h0Qfg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/f-lfqEUNvY6XRmCL-h0Qfg</a></p><p><a href="https://www.cnblogs.com/lxyit/p/12654374.html" target="_blank" rel="noopener">https://www.cnblogs.com/lxyit/p/12654374.html</a></p><p><a href="https://blog.csdn.net/tyh18226568070/article/details/105884912" target="_blank" rel="noopener">https://blog.csdn.net/tyh18226568070/article/details/105884912</a></p>]]></content>
    
    
    <summary type="html">&lt;h1&gt;一、Random类&lt;/h1&gt;
&lt;h2 id=&quot;1、简介&quot;&gt;1、简介&lt;/h2&gt;
&lt;p&gt;Random 类用于生成伪随机数的流。 该类使用48位种子，其使用线性同余公式进行修改&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Math.random()&lt;/code&gt;使用起来相对更简单，但不是线程安全的；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;java.util.Random&lt;/code&gt;的Random类是线程安全的。 但是跨线程的同时使用&lt;code&gt;java.util.Random&lt;/code&gt;实例可能会遇到争用，从而导致性能下降。 在多线程设计中考虑使用&lt;code&gt;ThreadLocalRandom&lt;/code&gt;类；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;java.util.Random&lt;/code&gt;的Random不是加密安全的。 考虑使用&lt;code&gt;SecureRandom&lt;/code&gt;获取一个加密安全的伪随机数生成器，供安全敏感应用程序使用。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Java" scheme="https://www.shawn22.xyz/categories/Java/"/>
    
    
    <category term="源码分析" scheme="https://www.shawn22.xyz/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot2定时任务</title>
    <link href="https://www.shawn22.xyz/posts/d0a2363e.html"/>
    <id>https://www.shawn22.xyz/posts/d0a2363e.html</id>
    <published>2022-02-13T00:31:42.000Z</published>
    <updated>2022-02-13T00:35:14.734Z</updated>
    
    <content type="html"><![CDATA[<h1>一、介绍</h1><p>SpringBoot可以有两种方式实现定时任务，schedule和schedule，这两种组件都可以和Spring进行整合，区别如下表所示</p><table><thead><tr><th>组件名称</th><th>cron</th><th>持久化</th><th>开发难以程度</th></tr></thead><tbody><tr><td>schedule</td><td>支持</td><td>不支持</td><td>非常简单</td></tr><tr><td>quartz</td><td>支持</td><td>支持</td><td>复杂</td></tr></tbody></table><a id="more"></a><h1>二、Schedule组件</h1><h2 id="1、介绍">1、介绍</h2><p>SpringBoot内置了Sping Schedule定时框架，通过注解驱动方式添加所注解方法到定时任务，根据配置定时信息定时执行</p><h2 id="2、Schedule定时任务实现">2、Schedule定时任务实现</h2><h3 id="2-1-配置线程池">2.1 配置线程池</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line">publicclass ScheduleConfig implements SchedulingConfigurer &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureTasks</span><span class="params">(ScheduledTaskRegistrar taskRegistrar)</span> </span>&#123;</span><br><span class="line">        taskRegistrar.setScheduler(taskExecutor());    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">taskExecutor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Executors.newScheduledThreadPool(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-新建具体任务">2.2 新建具体任务</h3><p>如果想加个开关控制是否启用定时任务，可以使用<code>@ConditionalOnProperty</code>注解，并同时在配置文件中设置<code>scheduling.enabled=false</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="comment">//@ConditionalOnProperty(prefix = "scheduling", name = "enabled", havingValue = "true")</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SbScheduleTask1</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="meta">@Scheduled</span>(cron = <span class="string">"*/2 * * * * ?"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">task1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        log.error(<span class="string">"我是task1111，我需要执行 10s 钟的时间，我的线程的 id == &gt; &#123;&#125;，时间 == &gt;&#123;&#125;"</span>, Thread.currentThread().getId(), <span class="keyword">new</span> Date());</span><br><span class="line">        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        log.error(<span class="string">"task1111 ending ,我的线程的 id == &gt; &#123;&#125; , 时间 == &gt; &#123;&#125;"</span>, Thread.currentThread().getId(), <span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="meta">@Scheduled</span>(cron = <span class="string">"*/4 * * * * ?"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">task2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        log.error(<span class="string">"我是task2222，我需要执行 2s 钟的时间，我的线程的 id == &gt; &#123;&#125;，时间 == &gt;&#123;&#125;"</span>, Thread.currentThread().getId(), <span class="keyword">new</span> Date());</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        log.error(<span class="string">"task2222 ending ,我的线程的 id == &gt; &#123;&#125; , 时间 == &gt; &#123;&#125;"</span>, Thread.currentThread().getId(), <span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-开启Schedule">2.3 开启Schedule</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="comment">// 开启定时任务</span></span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="meta">@MapperScan</span>(basePackages = &#123;<span class="string">"com.shawn.springboot.*.mapper"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduleApplication</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SpringApplication.run(ScheduleApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>三、quartz组件</h1><h2 id="1、介绍-v2">1、介绍</h2><blockquote><p>官方文档：<a href="http://www.quartz-scheduler.org/documentation/2.4.0-SNAPSHOT/tutorials/index.html" target="_blank" rel="noopener">http://www.quartz-scheduler.org/documentation/2.4.0-SNAPSHOT/tutorials/index.html</a></p></blockquote><p>Quartz是一个功能强大的开源任务调度库，几乎可以集成到任何Java应用程序中，无论是超小型的独立应用还是超大型电子商务系统。</p><p>它常用于企业级应用中：</p><ul><li>Driving Process Workflow：当新订单下达，可以安排一个30分钟内触发的任务，检查订单状态。</li><li>System Maintenance：安排每个工作日晚上11点将数据库内容转储到文件的任务。</li><li>Providing reminder services：提供提醒服务。</li></ul><p>Quartz还支持集群模式和对JTA事务。</p><h2 id="2、重要概念">2、重要概念</h2><p><strong>Scheduler</strong> ：和调度程序交互的主要API</p><ul><li>生命周期从SchedulerFactoru创建它开始，到调用shutdown方法结束</li><li>一旦Scheduler创建，任何关于scheduling相关的事，他都为所欲为：添加、删除、列出所有的Jobs和triggers、暂停触发器等</li><li>在start方法之前，不会做任何事情</li></ul><p>**Job：**被调度器调度的任务组件接口，即定时任务执行的方法</p><ul><li>当Job的触发器触发时，调度程序的工作线程将调用execute方法</li><li>该方法接收一个<code>JobExecutionContext</code> 对象，为Job实例提供了丰富的运行时环境信息，比如：scheduler、trigger、jobDataMap、job、calendar、各种time等</li></ul><p><strong>JobDetail</strong> ：用于定义任务</p><ul><li>JobDetail对象由Quartz客户端在将job加入Scheduler提供</li><li>它包含了不同为job设置的属性，还有可以用来为job储存状态信息的JobDataMap</li><li>注意它和Job的区别，它实际上是Job实例的属性。【Job定义如何执行，JobDetail定义有何属性】</li></ul><p><strong>Trigger</strong> ：触发任务执行</p><ul><li>触发器可能具有与之关联的JobDataMap，以便于将特定于触发器触发的参数传递给Job</li><li>Quartz提供了几种不同的触发器，SimpleTrigger和CronTrigger比较常用</li><li>如果你需要一次性执行作业或需要在给定的时间触发一个作业并重复执行N次且有两次执行间有延时delay，SimpleTrigger较为方便</li><li>如果你希望基于类似日期表触发执行任务，CronTrgger推荐使用</li></ul><p><strong>JobBuilder</strong> ：用于构建JobDetail的</p><p><strong>TriggerBuilder</strong> ：用于构建Trigger的</p><h2 id="3、quartz内存配置实战">3、quartz内存配置实战</h2><h3 id="3-1-引入依赖">3.1 引入依赖</h3><p><code>spring-boot-starter-quartz</code>这个依赖是SpringBoot与Quartz的整合</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 实现对 Quartz 的自动化配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-quartz<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-2-创建job">3.2 创建job</h3><p>这里创建了两个job，我们在创建Job的时候，可以实现Job接口，也可以继承QuartzJobBean。</p><p>QuartzJobBean实现了Job，并且定义了公用的execute方法，子类可以继承QuartzJobBean并实现executeInternal方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstJob</span> <span class="keyword">extends</span> <span class="title">QuartzJobBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">executeInternal</span><span class="params">(JobExecutionContext jobExecutionContext)</span> <span class="keyword">throws</span> JobExecutionException </span>&#123;</span><br><span class="line">        String now = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>).format(LocalDateTime.now());</span><br><span class="line">        log.info(<span class="string">"当前的时间: "</span> + now);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//--------------------</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondJob</span> <span class="keyword">extends</span> <span class="title">QuartzJobBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">executeInternal</span><span class="params">(JobExecutionContext jobExecutionContext)</span> <span class="keyword">throws</span> JobExecutionException </span>&#123;</span><br><span class="line">        String now = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>).format(LocalDateTime.now());</span><br><span class="line">        log.info(<span class="string">"SecondJob执行, 当前的时间: "</span> + now);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-调度器Scheduler绑定">3.3 调度器Scheduler绑定</h3><p><strong>自动绑定</strong>，这里使用了SimpleScheduleBuilder</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuartzConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ID = <span class="string">"SUMMERDAY"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JobDetail <span class="title">jobDetail1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> JobBuilder.newJob(FirstJob<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">                .withIdentity(ID + " 01")</span><br><span class="line">                .storeDurably()</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Trigger <span class="title">trigger1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 简单的调度计划的构造器</span></span><br><span class="line">        SimpleScheduleBuilder scheduleBuilder = SimpleScheduleBuilder.simpleSchedule()</span><br><span class="line">                .withIntervalInSeconds(<span class="number">5</span>) <span class="comment">// 频率</span></span><br><span class="line">                .repeatForever(); <span class="comment">// 次数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> TriggerBuilder.newTrigger()</span><br><span class="line">                .forJob(jobDetail1())</span><br><span class="line">                .withIdentity(ID + <span class="string">" 01Trigger"</span>)</span><br><span class="line">                .withSchedule(scheduleBuilder)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>手动绑定</strong>，这里使用了CronScheduleBuilder</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JobInit</span> <span class="keyword">implements</span> <span class="title">ApplicationRunner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ID = <span class="string">"SUMMERDAY"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Scheduler scheduler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(ApplicationArguments args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        JobDetail jobDetail = JobBuilder.newJob(FirstJob<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">                .withIdentity(ID + " 01")</span><br><span class="line">                .storeDurably()</span><br><span class="line">                .build();</span><br><span class="line">        CronScheduleBuilder scheduleBuilder =</span><br><span class="line">                CronScheduleBuilder.cronSchedule(<span class="string">"0/5 * * * * ? *"</span>);</span><br><span class="line">        <span class="comment">// 创建任务触发器</span></span><br><span class="line">        Trigger trigger = TriggerBuilder.newTrigger()</span><br><span class="line">                .forJob(jobDetail)</span><br><span class="line">                .withIdentity(ID + <span class="string">" 01Trigger"</span>)</span><br><span class="line">                .withSchedule(scheduleBuilder)</span><br><span class="line">                .startNow() <span class="comment">//立即執行一次任務</span></span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">// 手动将触发器与任务绑定到调度器内</span></span><br><span class="line">        scheduler.scheduleJob(jobDetail, trigger);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-yml配置">3.4 yml配置</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment"># Quartz 的配置，对应 QuartzProperties 配置类</span></span><br><span class="line">  <span class="attr">quartz:</span></span><br><span class="line">    <span class="attr">job-store-type:</span> <span class="string">memory</span> <span class="comment"># Job 存储器类型。默认为 memory 表示内存，可选 jdbc 使用数据库。</span></span><br><span class="line">    <span class="attr">auto-startup:</span> <span class="literal">true</span> <span class="comment"># Quartz 是否自动启动</span></span><br><span class="line">    <span class="attr">startup-delay:</span> <span class="number">0</span> <span class="comment"># 延迟 N 秒启动</span></span><br><span class="line">    <span class="attr">wait-for-jobs-to-complete-on-shutdown:</span> <span class="literal">true</span> <span class="comment"># 应用关闭时，是否等待定时任务执行完成。默认为 false ，建议设置为 true</span></span><br><span class="line">    <span class="attr">overwrite-existing-jobs:</span> <span class="literal">false</span> <span class="comment"># 是否覆盖已有 Job 的配置</span></span><br><span class="line">    <span class="attr">properties:</span> <span class="comment"># 添加 Quartz Scheduler 附加属性</span></span><br><span class="line">      <span class="attr">org:</span></span><br><span class="line">        <span class="attr">quartz:</span></span><br><span class="line">          <span class="attr">threadPool:</span></span><br><span class="line">            <span class="attr">threadCount:</span> <span class="number">25</span> <span class="comment"># 线程池大小。默认为 10 。</span></span><br><span class="line">            <span class="attr">threadPriority:</span> <span class="number">5</span> <span class="comment"># 线程优先级</span></span><br><span class="line">            <span class="attr">class:</span> <span class="string">org.quartz.simpl.SimpleThreadPool</span> <span class="comment"># 线程池类型</span></span><br></pre></td></tr></table></figure><h2 id="4、Quartz持久化配置">4、Quartz持久化配置</h2><p>Quartz持久化配置提供了两种存储器：</p><table><thead><tr><th>类型</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>RAMJobStore</td><td>不要外部数据库，配置容易，运行速度快</td><td>因为调度程序信息是存储在被分配给 JVM 的内存里面，所以，当应用程序停止运行时，所有调度信息将被丢失。另外因为存储到JVM内存里面，所以可以存储多少个 Job 和 Trigger 将会受到限制</td></tr><tr><td>JDBC 作业存储</td><td>支持集群，因为所有的任务信息都会保存到数据库中，可以控制事物，还有就是如果应用服务器关闭或者重启，任务信息都不会丢失，并且可以恢复因服务器关闭或者重启而导致执行失败的任务</td><td>运行速度的快慢取决与连接数据库的快慢</td></tr></tbody></table><h1>四、cron表达式</h1><h2 id="1、简介">1、简介</h2><blockquote><p>表达式网站：<a href="http://cron.qqe2.com/" target="_blank" rel="noopener">http://cron.qqe2.com/</a></p></blockquote><p>表达式基本公式 <code>* * * * * *</code>七个*分别对应单位为：秒，分，时，日，月，星期，年</p><h2 id="2、字段含义">2、字段含义</h2><table><thead><tr><th>字段</th><th>取值范围</th><th>特殊字符</th></tr></thead><tbody><tr><td>秒</td><td>0~59的整数</td><td>，- * /</td></tr><tr><td>分</td><td>0~59的整数</td><td>，- * /</td></tr><tr><td>时</td><td>0~23的整数</td><td>，- * /</td></tr><tr><td>日</td><td>1~31的整数</td><td>，- * ? / L W</td></tr><tr><td>月</td><td>1~12的整数</td><td>，- * /</td></tr><tr><td>星期</td><td>1<sub>7的整数或者SUN</sub>SAT（1=SUN）</td><td>，- * ? / L #</td></tr><tr><td>年</td><td>1970~2099</td><td>，- * /</td></tr></tbody></table><ul><li>“,” ：表示列出枚举值，例如分钟使用5,20，则表示5和20分钟各执行一次</li><li>“-” ：表示范围，例如分钟使用5-20，表示5-20分钟每分钟触发一次</li><li>&quot;<em>&quot; ：<em>表示匹配该域任意值</em>，例如分钟使用</em>，表示每分钟都会执行一次</li><li>“/” ：表示起始时间开始触发，以后每隔多长时间触发一次，例如秒使用0/3，表示从0开始触发，后每三分钟触发一次</li><li>“?”：只能在日和星期使用，表示匹配任意值，但实际不会；因为日和星期可能会存在冲突，如果想表示每月20号0点执行，则需要写为 0 0 0 20 * ？，星期位必须写为？，虽然概念上*也表示通配</li><li>“L” ：表示最后，只出现在日和星期；例如在星期的5L，表示最后一个星期五触发</li><li>“W” ：表示有效工作日（周一-周五），只出现在日，如果指定的当天在某月刚好为周末，则就近取周五或周一执行</li><li>“LW” ：连用表示每个月最后一个星期五，只在日使用</li><li>“#” ：用于确定第几个星期的星期几，只在星期使用；例如2#3，表示在每月的第三个星期一</li></ul><h2 id="3、常用表达式实例">3、常用表达式实例</h2><ul><li>0/3 * * * * ? ：表示每三秒钟执行一次</li><li>0 0 2 1 * ？ ：表示每月1号凌晨两点执行任务</li><li>0 15 10 ？ * MON-FRI ：表示周一到周五每天早上10：15执行</li><li>0 15 10 ? * 6#3   每月的第三个星期五上午10:15触发</li></ul><hr><p>参考文章</p><p><a href="https://www.cnblogs.com/imyanger/p/11828301.html" target="_blank" rel="noopener">https://www.cnblogs.com/imyanger/p/11828301.html</a></p><p><a href="http://www.quartz-scheduler.org/documentation/2.4.0-SNAPSHOT/tutorials/index.html" target="_blank" rel="noopener">http://www.quartz-scheduler.org/documentation/2.4.0-SNAPSHOT/tutorials/index.html</a></p><p><a href="https://www.iocoder.cn/Spring-Boot/Job/#" target="_blank" rel="noopener">https://www.iocoder.cn/Spring-Boot/Job/#</a></p><p><a href="https://www.cnblogs.com/summerday152/p/14193968.html" target="_blank" rel="noopener">https://www.cnblogs.com/summerday152/p/14193968.html</a></p>]]></content>
    
    
    <summary type="html">&lt;h1&gt;一、介绍&lt;/h1&gt;
&lt;p&gt;SpringBoot可以有两种方式实现定时任务，schedule和schedule，这两种组件都可以和Spring进行整合，区别如下表所示&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;组件名称&lt;/th&gt;
&lt;th&gt;cron&lt;/th&gt;
&lt;th&gt;持久化&lt;/th&gt;
&lt;th&gt;开发难以程度&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;schedule&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;非常简单&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;quartz&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;复杂&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</summary>
    
    
    
    <category term="Java" scheme="https://www.shawn22.xyz/categories/Java/"/>
    
    
    <category term="SpringBoot" scheme="https://www.shawn22.xyz/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Java8本地缓存Caffeine</title>
    <link href="https://www.shawn22.xyz/posts/ecc1debf.html"/>
    <id>https://www.shawn22.xyz/posts/ecc1debf.html</id>
    <published>2022-02-13T00:30:38.000Z</published>
    <updated>2022-02-13T00:35:14.740Z</updated>
    
    <content type="html"><![CDATA[<h1>一、Caffeine介绍</h1><h2 id="1、缓存介绍">1、缓存介绍</h2><p>缓存(Cache)在代码世界中无处不在。从底层的CPU多级缓存，到客户端的页面缓存，处处都存在着缓存的身影。缓存从本质上来说，是一种空间换时间的手段，通过对数据进行一定的空间安排，使得下次进行数据访问时起到加速的效果。就Java而言，其常用的缓存解决方案有很多，例如数据库缓存框架EhCache，分布式缓存Memcached等，这些缓存方案实际上都是为了提升吞吐效率，避免持久层压力过大。</p><p>对于常见缓存类型而言，可以分为<strong>本地缓存</strong>以及<strong>分布式缓存</strong>两种，Caffeine就是一种优秀的本地缓存，而Redis可以用来做分布式缓存</p><a id="more"></a><h2 id="2、Caffeine介绍">2、Caffeine介绍</h2><blockquote><p>Caffeine官方：<a href="https://github.com/ben-manes/caffeine" target="_blank" rel="noopener">https://github.com/ben-manes/caffeine</a></p></blockquote><p>Caffeine是基于Java 1.8的高性能本地缓存库，由Guava改进而来，而且在Spring5开始的默认缓存实现就将Caffeine代替原来的Google Guava，官方说明指出，其缓存命中率已经接近最优值。实际上Caffeine这样的本地缓存和ConcurrentMap很像，即支持并发，并且支持O(1)时间复杂度的数据存取。二者的主要区别在于：</p><ul><li>ConcurrentMap将存储所有存入的数据，直到你显式将其移除；</li><li>Caffeine将通过给定的配置，自动移除“不常用”的数据，以保持内存的合理占用。</li></ul><p>因此，一种更好的理解方式是：<strong>Cache是一种带有存储和移除策略的Map</strong>。</p><p><img src="https://img-blog.csdnimg.cn/af3a97203e5e46e1837e310a12818168.png?type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6a2FTGVtb24=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><h1>二、Caffeine基础</h1><p>使用Caffeine，需要在工程中引入如下依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.ben-manes.caffeine<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>caffeine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--https://mvnrepository.com/artifact/com.github.ben-manes.caffeine/caffeinez找最新版--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="1、缓存加载策略">1、缓存加载策略</h2><h3 id="1-1-Cache手动创建">1.1 Cache手动创建</h3><p>最普通的一种缓存，无需指定加载方式，需要手动调用<code>put()</code>进行加载。需要注意的是<code>put()</code>方法对于已存在的key将进行覆盖，这点和Map的表现是一致的。在获取缓存值时，如果想要在缓存值不存在时，原子地将值写入缓存，则可以调用<code>get(key, k -&gt; value)</code>方法，该方法将避免写入竞争。调用<code>invalidate()</code>方法，将手动移除缓存。</p><p>在多线程情况下，当使用<code>get(key, k -&gt; value)</code>时，如果有另一个线程同时调用本方法进行竞争，则后一线程会被阻塞，直到前一线程更新缓存完成；而若另一线程调用<code>getIfPresent()</code>方法，则会立即返回null，不会被阻塞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Cache&lt;Object, Object&gt; cache = Caffeine.newBuilder()</span><br><span class="line">                <span class="comment">//初始数量</span></span><br><span class="line">                .initialCapacity(<span class="number">10</span>)</span><br><span class="line">                <span class="comment">//最大条数</span></span><br><span class="line">                .maximumSize(<span class="number">10</span>)</span><br><span class="line">                <span class="comment">//expireAfterWrite和expireAfterAccess同时存在时，以expireAfterWrite为准</span></span><br><span class="line">                <span class="comment">//最后一次写操作后经过指定时间过期</span></span><br><span class="line">                .expireAfterWrite(<span class="number">1</span>, TimeUnit.SECONDS)</span><br><span class="line">                <span class="comment">//最后一次读或写操作后经过指定时间过期</span></span><br><span class="line">                .expireAfterAccess(<span class="number">1</span>, TimeUnit.SECONDS)</span><br><span class="line">                <span class="comment">//监听缓存被移除</span></span><br><span class="line">                .removalListener((key, val, removalCause) -&gt; &#123; &#125;)</span><br><span class="line">                <span class="comment">//记录命中</span></span><br><span class="line">                .recordStats()</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        cache.put(<span class="string">"1"</span>,<span class="string">"张三"</span>);</span><br><span class="line">        <span class="comment">//张三</span></span><br><span class="line">        System.out.println(cache.getIfPresent(<span class="string">"1"</span>));</span><br><span class="line">        <span class="comment">//存储的是默认值</span></span><br><span class="line">        System.out.println(cache.get(<span class="string">"2"</span>,o -&gt; <span class="string">"默认值"</span>));</span><br></pre></td></tr></table></figure><h3 id="1-2-Loading-Cache自动创建">1.2 Loading Cache自动创建</h3><p>LoadingCache是一种自动加载的缓存。其和普通缓存不同的地方在于，当缓存不存在/缓存已过期时，若调用<code>get()</code>方法，则会自动调用<code>CacheLoader.load()</code>方法加载最新值。调用<code>getAll()</code>方法将遍历所有的key调用<code>get()</code>，除非实现了<code>CacheLoader.loadAll()</code>方法。使用LoadingCache时，需要指定CacheLoader，并实现其中的<code>load()</code>方法供缓存缺失时自动加载。</p><p>在多线程情况下，当两个线程同时调用<code>get()</code>，则后一线程将被阻塞，直至前一线程更新缓存完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LoadingCache&lt;String, String&gt; loadingCache = Caffeine.newBuilder()</span><br><span class="line">        <span class="comment">//创建缓存或者最近一次更新缓存后经过指定时间间隔，刷新缓存；refreshAfterWrite仅支持LoadingCache</span></span><br><span class="line">        .refreshAfterWrite(<span class="number">10</span>, TimeUnit.SECONDS)</span><br><span class="line">        .expireAfterWrite(<span class="number">10</span>, TimeUnit.SECONDS)</span><br><span class="line">        .expireAfterAccess(<span class="number">10</span>, TimeUnit.SECONDS)</span><br><span class="line">        .maximumSize(<span class="number">10</span>)</span><br><span class="line">        <span class="comment">//根据key查询数据库里面的值，这里是个lamba表达式</span></span><br><span class="line">        .build(key -&gt; <span class="keyword">new</span> Date().toString());</span><br></pre></td></tr></table></figure><h3 id="1-3-Async-Cache异步获取">1.3 Async Cache异步获取</h3><p>AsyncCache是Cache的一个变体，其响应结果均为CompletableFuture，通过这种方式，AsyncCache对异步编程模式进行了适配。默认情况下，缓存计算使用<code>ForkJoinPool.commonPool()</code>作为线程池，如果想要指定线程池，则可以覆盖并实现<code>Caffeine.executor(Executor)</code>方法。<code>synchronous()</code>提供了阻塞直到异步缓存生成完毕的能力，它将以Cache进行返回。</p><p>在多线程情况下，当两个线程同时调用<code>get(key, k -&gt; value)</code>，则会返回<strong>同一个CompletableFuture</strong>对象。由于返回结果本身不进行阻塞，可以根据业务设计自行选择阻塞等待或者非阻塞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">AsyncLoadingCache&lt;String, String&gt; asyncLoadingCache = Caffeine.newBuilder()</span><br><span class="line">        <span class="comment">//创建缓存或者最近一次更新缓存后经过指定时间间隔刷新缓存；仅支持LoadingCache</span></span><br><span class="line">        .refreshAfterWrite(<span class="number">1</span>, TimeUnit.SECONDS)</span><br><span class="line">        .expireAfterWrite(<span class="number">1</span>, TimeUnit.SECONDS)</span><br><span class="line">        .expireAfterAccess(<span class="number">1</span>, TimeUnit.SECONDS)</span><br><span class="line">        .maximumSize(<span class="number">10</span>)</span><br><span class="line">        <span class="comment">//根据key查询数据库里面的值</span></span><br><span class="line">        .buildAsync(key -&gt; &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Date().toString();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//异步缓存返回的是CompletableFuture</span></span><br><span class="line">CompletableFuture&lt;String&gt; future = asyncLoadingCache.get(<span class="string">"1"</span>);</span><br><span class="line">future.thenAccept(System.out::println);</span><br></pre></td></tr></table></figure><h2 id="2、驱逐策略">2、驱逐策略</h2><p>驱逐策略在创建缓存的时候进行指定。常用的有基于容量的驱逐和基于时间的驱逐。</p><p>基于容量的驱逐需要指定缓存容量的最大值，当缓存容量达到最大时，Caffeine将使用LRU策略对缓存进行淘汰；基于时间的驱逐策略如字面意思，可以设置在最后访问/写入一个缓存经过指定时间后，自动进行淘汰。</p><p>驱逐策略可以组合使用，任意驱逐策略生效后，该缓存条目即被驱逐。</p><ul><li>LRU 最近最少使用，淘汰最长时间没有被使用的页面。</li><li>LFU 最不经常使用，淘汰一段时间内使用次数最少的页面</li><li>FIFO 先进先出</li></ul><p><strong>Caffeine有4种缓存淘汰设置</strong></p><ol><li>大小 （LFU算法进行淘汰）</li><li>权重 （大小与权重 只能二选一）</li><li>时间</li><li>引用 （不常用，本文不介绍）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存大小淘汰</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">maximumSizeTest</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Cache&lt;Integer, Integer&gt; cache = Caffeine.newBuilder()</span><br><span class="line">                <span class="comment">//超过10个后会使用W-TinyLFU算法进行淘汰</span></span><br><span class="line">                .maximumSize(<span class="number">10</span>)</span><br><span class="line">                .evictionListener((key, val, removalCause) -&gt; &#123;</span><br><span class="line">                    log.info(<span class="string">"淘汰缓存：key:&#123;&#125; val:&#123;&#125;"</span>, key, val);</span><br><span class="line">                &#125;)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            cache.put(i, i);</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);<span class="comment">//缓存淘汰是异步的</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印还没被淘汰的缓存</span></span><br><span class="line">        System.out.println(cache.asMap());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 权重淘汰</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">maximumWeightTest</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Cache&lt;Integer, Integer&gt; cache = Caffeine.newBuilder()</span><br><span class="line">                <span class="comment">//限制总权重，若所有缓存的权重加起来&gt;总权重就会淘汰权重小的缓存</span></span><br><span class="line">                .maximumWeight(<span class="number">100</span>)</span><br><span class="line">                .weigher((Weigher&lt;Integer, Integer&gt;) (key, value) -&gt; key)</span><br><span class="line">                .evictionListener((key, val, removalCause) -&gt; &#123;</span><br><span class="line">                    log.info(<span class="string">"淘汰缓存：key:&#123;&#125; val:&#123;&#125;"</span>, key, val);</span><br><span class="line">                &#125;)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//总权重其实是=所有缓存的权重加起来</span></span><br><span class="line">        <span class="keyword">int</span> maximumWeight = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            cache.put(i, i);</span><br><span class="line">            maximumWeight += i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"总权重="</span> + maximumWeight);</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);<span class="comment">//缓存淘汰是异步的</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印还没被淘汰的缓存</span></span><br><span class="line">        System.out.println(cache.asMap());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 访问后到期（每次访问都会重置时间，也就是说如果一直被访问就不会被淘汰）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">expireAfterAccessTest</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Cache&lt;Integer, Integer&gt; cache = Caffeine.newBuilder()</span><br><span class="line">                .expireAfterAccess(<span class="number">1</span>, TimeUnit.SECONDS)</span><br><span class="line">                <span class="comment">//可以指定调度程序来及时删除过期缓存项，而不是等待Caffeine触发定期维护</span></span><br><span class="line">                <span class="comment">//若不设置scheduler，则缓存会在下一次调用get的时候才会被动删除</span></span><br><span class="line">                .scheduler(Scheduler.systemScheduler())</span><br><span class="line">                .evictionListener((key, val, removalCause) -&gt; &#123;</span><br><span class="line">                    log.info(<span class="string">"淘汰缓存：key:&#123;&#125; val:&#123;&#125;"</span>, key, val);</span><br><span class="line"></span><br><span class="line">                &#125;)</span><br><span class="line">                .build();</span><br><span class="line">        cache.put(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        System.out.println(cache.getIfPresent(<span class="number">1</span>));</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        System.out.println(cache.getIfPresent(<span class="number">1</span>));<span class="comment">//null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写入后到期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">expireAfterWriteTest</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Cache&lt;Integer, Integer&gt; cache = Caffeine.newBuilder()</span><br><span class="line">                .expireAfterWrite(<span class="number">1</span>, TimeUnit.SECONDS)</span><br><span class="line">                <span class="comment">//可以指定调度程序来及时删除过期缓存项，而不是等待Caffeine触发定期维护</span></span><br><span class="line">                <span class="comment">//若不设置scheduler，则缓存会在下一次调用get的时候才会被动删除</span></span><br><span class="line">                .scheduler(Scheduler.systemScheduler())</span><br><span class="line">                .evictionListener((key, val, removalCause) -&gt; &#123;</span><br><span class="line">                    log.info(<span class="string">"淘汰缓存：key:&#123;&#125; val:&#123;&#125;"</span>, key, val);</span><br><span class="line">                &#125;)</span><br><span class="line">                .build();</span><br><span class="line">        cache.put(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        System.out.println(cache.getIfPresent(<span class="number">1</span>));<span class="comment">//null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、刷新机制">3、刷新机制</h2><p><code>refreshAfterWrite()</code>表示x秒后自动刷新缓存的策略可以配合淘汰策略使用，注意的是刷新机制只支持LoadingCache和AsyncLoadingCache</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> NUM = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refreshAfterWriteTest</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    LoadingCache&lt;Integer, Integer&gt; cache = Caffeine.newBuilder()</span><br><span class="line">            .refreshAfterWrite(<span class="number">1</span>, TimeUnit.SECONDS)</span><br><span class="line">            <span class="comment">//模拟获取数据，每次获取就自增1</span></span><br><span class="line">            .build(integer -&gt; ++NUM);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取ID=1的值，由于缓存里还没有，所以会自动放入缓存</span></span><br><span class="line">    System.out.println(cache.get(<span class="number">1</span>));<span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 延迟2秒后，理论上自动刷新缓存后取到的值是2</span></span><br><span class="line">    <span class="comment">// 但其实不是，值还是1，因为refreshAfterWrite并不是设置了n秒后重新获取就会自动刷新</span></span><br><span class="line">    <span class="comment">// 而是x秒后&amp;&amp;第二次调用getIfPresent的时候才会被动刷新</span></span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    System.out.println(cache.getIfPresent(<span class="number">1</span>));<span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//此时才会刷新缓存，而第一次拿到的还是旧值</span></span><br><span class="line">    System.out.println(cache.getIfPresent(<span class="number">1</span>));<span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、统计">4、统计</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">LoadingCache&lt;String, String&gt; cache = Caffeine.newBuilder()</span><br><span class="line">        <span class="comment">//创建缓存或者最近一次更新缓存后经过指定时间间隔，刷新缓存；refreshAfterWrite仅支持LoadingCache</span></span><br><span class="line">        .refreshAfterWrite(<span class="number">1</span>, TimeUnit.SECONDS)</span><br><span class="line">        .expireAfterWrite(<span class="number">1</span>, TimeUnit.SECONDS)</span><br><span class="line">        .expireAfterAccess(<span class="number">1</span>, TimeUnit.SECONDS)</span><br><span class="line">        .maximumSize(<span class="number">10</span>)</span><br><span class="line">        <span class="comment">//开启记录缓存命中率等信息</span></span><br><span class="line">        .recordStats()</span><br><span class="line">        <span class="comment">//根据key查询数据库里面的值</span></span><br><span class="line">        .build(key -&gt; &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Date().toString();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cache.put(<span class="string">"1"</span>, <span class="string">"shawn"</span>);</span><br><span class="line">cache.get(<span class="string">"1"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * hitCount :命中的次数</span></span><br><span class="line"><span class="comment"> * missCount:未命中次数</span></span><br><span class="line"><span class="comment"> * requestCount:请求次数</span></span><br><span class="line"><span class="comment"> * hitRate:命中率</span></span><br><span class="line"><span class="comment"> * missRate:丢失率</span></span><br><span class="line"><span class="comment"> * loadSuccessCount:成功加载新值的次数</span></span><br><span class="line"><span class="comment"> * loadExceptionCount:失败加载新值的次数</span></span><br><span class="line"><span class="comment"> * totalLoadCount:总条数</span></span><br><span class="line"><span class="comment"> * loadExceptionRate:失败加载新值的比率</span></span><br><span class="line"><span class="comment"> * totalLoadTime:全部加载时间</span></span><br><span class="line"><span class="comment"> * evictionCount:丢失的条数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">System.out.println(cache.stats());</span><br></pre></td></tr></table></figure><h2 id="5、总结">5、总结</h2><p>上述一些策略在创建时都可以进行自由组合，一般情况下有两种方法</p><ul><li><strong>设置 maxSize、refreshAfterWrite，不设置 expireAfterWrite/expireAfterAccess</strong><br>设置expireAfterWrite当缓存过期时会同步加锁获取缓存，所以设置expireAfterWrite时性能较好，但是某些时候会取旧数据,适合允许取到旧数据的场景</li><li><strong>设置 maxSize、expireAfterWrite/expireAfterAccess，不设置 refreshAfterWrite</strong><br>数据一致性好，不会获取到旧数据，但是性能没那么好（对比起来），适合获取数据时不耗时的场景</li></ul><h1>三、SpringBoot整合Caffeine</h1><h2 id="1、-Cacheable相关注解">1、@Cacheable相关注解</h2><h3 id="1-1-相关依赖">1.1 相关依赖</h3><p>如果要使用<code>@Cacheable</code>注解，需要引入相关依赖，并在任一配置类文件上添加<code>@EnableCaching</code>注解</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-2-常用注解">1.2 常用注解</h3><ul><li><code>@Cacheable</code>：表示该方法支持缓存。当调用被注解的方法时，如果对应的键已经存在缓存，则不再执行方法体，而从缓存中直接返回。当方法返回null时，将不进行缓存操作。</li><li><code>@CachePut</code>：表示执行该方法后，其值将作为最新结果更新到缓存中，<strong>每次都会执行该方法</strong>。</li><li><code>@CacheEvict</code>：表示执行该方法后，将触发缓存清除操作。</li><li><code>@Caching</code>：用于组合前三个注解，例如：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Caching</span>(cacheable = <span class="meta">@Cacheable</span>(<span class="string">"CacheConstants.GET_USER"</span>),</span><br><span class="line">         evict = &#123;<span class="meta">@CacheEvict</span>(<span class="string">"CacheConstants.GET_DYNAMIC"</span>,allEntries = <span class="keyword">true</span>)&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">find</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-常用注解属性">1.3 常用注解属性</h3><ul><li><code>cacheNames/value</code>：缓存组件的名字，即cacheManager中缓存的名称。</li><li><code>key</code>：缓存数据时使用的key。默认使用方法参数值，也可以使用<a href="https://docs.spring.io/spring-framework/docs/3.0.x/reference/expressions.html" target="_blank" rel="noopener">SpEL</a>表达式进行编写。</li><li><code>keyGenerator</code>：和key二选一使用。</li><li><code>cacheManager</code>：指定使用的缓存管理器。</li><li><code>condition</code>：在方法执行开始前检查，在符合condition的情况下，进行缓存</li><li><code>unless</code>：在方法执行完成后检查，在符合unless的情况下，不进行缓存</li><li><code>sync</code>：是否使用同步模式。若使用同步模式，在多个线程同时对一个key进行load时，其他线程将被阻塞。</li></ul><h3 id="1-4-缓存同步模式">1.4 缓存同步模式</h3><p>sync开启或关闭，在Cache和LoadingCache中的表现是不一致的：</p><ul><li>Cache中，sync表示是否需要所有线程同步等待</li><li>LoadingCache中，sync表示在读取不存在/已驱逐的key时，是否执行被注解方法</li></ul><h2 id="2、实战">2、实战</h2><h3 id="2-1-引入依赖">2.1 引入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.ben-manes.caffeine<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>caffeine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-2-缓存常量CacheConstants">2.2 缓存常量CacheConstants</h3><p>创建缓存常量类，把公共的常量提取一层，复用，这里也可以通过配置文件加载这些数据，例如<code>@ConfigurationProperties</code>和<code>@Value</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheConstants</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认过期时间（配置类中我使用的时间单位是秒，所以这里如 3*60 为3分钟）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_EXPIRES = <span class="number">3</span> * <span class="number">60</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXPIRES_5_MIN = <span class="number">5</span> * <span class="number">60</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXPIRES_10_MIN = <span class="number">10</span> * <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String GET_USER = <span class="string">"GET:USER"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String GET_DYNAMIC = <span class="string">"GET:DYNAMIC"</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-缓存配置类CacheConfig">2.3 缓存配置类CacheConfig</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Caffeine配置说明：</span></span><br><span class="line"><span class="comment">     * initialCapacity=[integer]: 初始的缓存空间大小</span></span><br><span class="line"><span class="comment">     * maximumSize=[long]: 缓存的最大条数</span></span><br><span class="line"><span class="comment">     * maximumWeight=[long]: 缓存的最大权重</span></span><br><span class="line"><span class="comment">     * expireAfterAccess=[duration]: 最后一次写入或访问后经过固定时间过期</span></span><br><span class="line"><span class="comment">     * expireAfterWrite=[duration]: 最后一次写入后经过固定时间过期</span></span><br><span class="line"><span class="comment">     * refreshAfterWrite=[duration]: 创建缓存或者最近一次更新缓存后经过固定的时间间隔，刷新缓存</span></span><br><span class="line"><span class="comment">     * weakKeys: 打开key的弱引用</span></span><br><span class="line"><span class="comment">     * weakValues：打开value的弱引用</span></span><br><span class="line"><span class="comment">     * softValues：打开value的软引用</span></span><br><span class="line"><span class="comment">     * recordStats：开发统计功能</span></span><br><span class="line"><span class="comment">     * 注意：</span></span><br><span class="line"><span class="comment">     * expireAfterWrite和expireAfterAccess同事存在时，以expireAfterWrite为准。</span></span><br><span class="line"><span class="comment">     * maximumSize和maximumWeight不可以同时使用</span></span><br><span class="line"><span class="comment">     * weakValues和softValues不可以同时使用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheManager <span class="title">cacheManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SimpleCacheManager cacheManager = <span class="keyword">new</span> SimpleCacheManager();</span><br><span class="line">        List&lt;CaffeineCache&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//循环添加枚举类中自定义的缓存，可以自定义</span></span><br><span class="line">        <span class="keyword">for</span> (CacheEnum cacheEnum : CacheEnum.values()) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> CaffeineCache(cacheEnum.getName(),</span><br><span class="line">                    Caffeine.newBuilder()</span><br><span class="line">                            .initialCapacity(<span class="number">50</span>)</span><br><span class="line">                            .maximumSize(<span class="number">1000</span>)</span><br><span class="line">                            .expireAfterAccess(cacheEnum.getExpires(), TimeUnit.SECONDS)</span><br><span class="line">                            .build()));</span><br><span class="line">        &#125;</span><br><span class="line">        cacheManager.setCaches(list);</span><br><span class="line">        <span class="keyword">return</span> cacheManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-调用缓存">2.4 调用缓存</h3><p>这里要注意的是Cache和@Transactional一样也使用了代理，类内调用将失效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * value：缓存key的前缀。</span></span><br><span class="line"><span class="comment"> * key：缓存key的后缀。</span></span><br><span class="line"><span class="comment"> * sync：设置如果缓存过期是不是只放一个请求去请求数据库，其他请求阻塞，默认是false（根据个人需求）。</span></span><br><span class="line"><span class="comment"> * unless：不缓存空值,这里不使用，会报错</span></span><br><span class="line"><span class="comment"> * 查询用户信息类</span></span><br><span class="line"><span class="comment"> * 如果需要加自定义字符串，需要用单引号</span></span><br><span class="line"><span class="comment"> * 如果查询为null，也会被缓存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Cacheable</span>(value = CacheConstants.GET_USER,key = <span class="string">"'user'+#userId"</span>,sync = <span class="keyword">true</span>)</span><br><span class="line"><span class="meta">@CacheEvict</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> UserEntity <span class="title">getUserByUserId</span><span class="params">(Integer userId)</span></span>&#123;</span><br><span class="line">    UserEntity userEntity = userMapper.findById(userId);</span><br><span class="line">    System.out.println(<span class="string">"查询了数据库"</span>);</span><br><span class="line">    <span class="keyword">return</span> userEntity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>参考文章</p><p><a href="https://juejin.cn/post/6991751225125371911" target="_blank" rel="noopener">https://juejin.cn/post/6991751225125371911</a></p><p><a href="https://ghh3809.github.io/2021/05/31/caffeine/" target="_blank" rel="noopener">https://ghh3809.github.io/2021/05/31/caffeine/</a></p><p><a href="https://github.com/ben-manes/caffeine" target="_blank" rel="noopener">https://github.com/ben-manes/caffeine</a></p>]]></content>
    
    
    <summary type="html">&lt;h1&gt;一、Caffeine介绍&lt;/h1&gt;
&lt;h2 id=&quot;1、缓存介绍&quot;&gt;1、缓存介绍&lt;/h2&gt;
&lt;p&gt;缓存(Cache)在代码世界中无处不在。从底层的CPU多级缓存，到客户端的页面缓存，处处都存在着缓存的身影。缓存从本质上来说，是一种空间换时间的手段，通过对数据进行一定的空间安排，使得下次进行数据访问时起到加速的效果。就Java而言，其常用的缓存解决方案有很多，例如数据库缓存框架EhCache，分布式缓存Memcached等，这些缓存方案实际上都是为了提升吞吐效率，避免持久层压力过大。&lt;/p&gt;
&lt;p&gt;对于常见缓存类型而言，可以分为&lt;strong&gt;本地缓存&lt;/strong&gt;以及&lt;strong&gt;分布式缓存&lt;/strong&gt;两种，Caffeine就是一种优秀的本地缓存，而Redis可以用来做分布式缓存&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://www.shawn22.xyz/categories/Java/"/>
    
    
    <category term="SpringBoot" scheme="https://www.shawn22.xyz/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Supervisor+Dockerfile编译jdk镜像</title>
    <link href="https://www.shawn22.xyz/posts/75d2cdb9.html"/>
    <id>https://www.shawn22.xyz/posts/75d2cdb9.html</id>
    <published>2022-02-13T00:29:50.000Z</published>
    <updated>2022-02-13T00:35:14.735Z</updated>
    
    <content type="html"><![CDATA[<h1>一、Bash 脚本 set 命令</h1><h2 id="1、介绍">1、介绍</h2><p><code>set</code>命令是 Bash 脚本的重要环节，却常常被忽视，导致脚本的安全性和可维护性出问题。Bash 执行脚本的时候，会创建一个新的 Shell，若执行过程有错误，Bash 会忽略这个错误，继续往下执行，Bash 只是显示有错误，并没有终止执行。直接运行<code>set</code>，会显示所有的环境变量和 Shell 函数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#显示所有的环境变量</span></span><br><span class="line"><span class="built_in">set</span></span><br><span class="line"><span class="comment">#查看环境变量字节数</span></span><br><span class="line"><span class="built_in">set</span> | wc -l</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="2、set常用命令">2、set常用命令</h2><h3 id="2-1-set-u">2.1 set -u</h3><blockquote><p>执行脚本的时候，如果遇到不存在的变量，Bash 默认忽略它</p></blockquote><p><code>set -u</code>就用来改变这种行为，脚本在头部加上它，遇到不存在的变量就会报错，并停止执行；</p><p><code>-u</code>还有另一种写法<code>-o nounset</code>，两者是等价的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"><span class="built_in">set</span> -u</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line"><span class="built_in">echo</span> bar</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#运行结果</span></span><br><span class="line">$ bash script.sh</span><br><span class="line">bash: script.sh:行4: a: 未绑定的变量</span><br></pre></td></tr></table></figure><h3 id="2-2-set-x">2.2 set -x</h3><blockquote><p>默认情况下，脚本执行后，屏幕只显示运行结果，没有其他内容。如果多个命令连续执行，它们的运行结果就会连续输出。有时会分不清，某一段内容是什么命令产生的</p></blockquote><p><code>set -x</code>用来在运行结果之前，先输出执行的那一行命令</p><p><code>-x</code>还有另一种写法<code>-o xtrace</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"><span class="built_in">set</span> -x</span><br><span class="line"><span class="built_in">echo</span> bar</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#运行结果，没运行一条语句会显示一条</span></span><br><span class="line">$ bash script.sh</span><br><span class="line">+ <span class="built_in">echo</span> bar</span><br><span class="line">bar</span><br></pre></td></tr></table></figure><h3 id="2-3-set-e">2.3 set -e</h3><blockquote><p>设置该变量后，脚本只要发生错误，就终止执行</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line">foo</span><br><span class="line"><span class="built_in">echo</span> bar</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#执行结果，脚本发送错误，停止执行</span></span><br><span class="line">$ bash script.sh</span><br><span class="line">script.sh:行4: foo: 未找到命令</span><br></pre></td></tr></table></figure><p><code>set -e</code>根据返回值来判断，一个命令是否运行失败。但是，某些命令的非零返回值可能不表示失败，或者开发者希望在命令失败的情况下，脚本继续执行下去。这时可以暂时关闭<code>set -e</code>，该命令执行结束后，再重新打开<code>set -e</code>；</p><p><code>set +e</code>表示关闭<code>-e</code>选项，<code>set -e</code>表示重新打开<code>-e</code>选项。</p><p><code>-e</code>还有另一种写法<code>-o errexit</code></p><h3 id="2-4-set-o-pipefail">2.4 set -o pipefail</h3><blockquote><p><code>set -e</code>有一个例外情况，就是不适用于管道命令。所谓管道命令，就是多个子命令通过管道运算符（<code>|</code>）组合成为一个大的命令。Bash 会把最后一个子命令的返回值，作为整个命令的返回值。也就是说，只要最后一个子命令不失败，管道命令总是会执行成功，因此它后面命令依然会执行，<code>set -e</code>就失效了。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"><span class="built_in">set</span> -eo pipefail</span><br><span class="line">foo | <span class="built_in">echo</span> a</span><br><span class="line"><span class="built_in">echo</span> bar</span><br></pre></td></tr></table></figure><h3 id="2-5-总结">2.5 总结</h3><p>一般情况下，<code>set</code>命令的上面这四个参数，一般都放在一起使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 写法一</span></span><br><span class="line"><span class="built_in">set</span> -euxo pipefail</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写法二</span></span><br><span class="line"><span class="built_in">set</span> -eux</span><br><span class="line"><span class="built_in">set</span> -o pipefail</span><br><span class="line"></span><br><span class="line"><span class="comment">#运行bash命令</span></span><br><span class="line">bash -euxo pipefail script.sh</span><br></pre></td></tr></table></figure><h1>二、Supervisor实践</h1><blockquote><p>官网介绍：<a href="http://supervisord.org/" target="_blank" rel="noopener">http://supervisord.org/</a></p></blockquote><h2 id="1、介绍-v2">1、介绍</h2><p>Supervisor是用Python开发的一套通用的进程管理程序，能将一个普通的命令行进程变为后台daemon，并监控进程状态，异常退出时能自动重启。它是通过fork/exec的方式把这些被管理的进程当作supervisor的子进程来启动，这样只要在supervisor的配置文件中，把要管理的进程的可执行文件的路径写进去即可。也实现当子进程挂掉的时候，父进程可以准确获取子进程挂掉的信息的，可以选择是否自己启动和报警。supervisor还提供了一个功能，可以为supervisord或者每个子进程，设置一个非root的user，这个user就可以管理它对应的进程。</p><h2 id="2、Supervisor安装">2、Supervisor安装</h2><blockquote><p><a href="http://supervisord.org/installing.html" target="_blank" rel="noopener">官方安装文档</a></p></blockquote><p>建议用系统工具安装，开机会自动启动，Centos 用 <code>yum</code>，Ubuntu 用 <code>apt-get</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install supervisor</span><br><span class="line">apt install supervisor</span><br></pre></td></tr></table></figure><p>第二种方式用pip安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install supervisor</span><br></pre></td></tr></table></figure><h2 id="3、配置文件说明">3、配置文件说明</h2><blockquote><p><a href="http://supervisord.org/configuration.html" target="_blank" rel="noopener">http://supervisord.org/configuration.html</a></p></blockquote><h3 id="3-1-介绍">3.1 介绍</h3><ul><li>supervisor配置文件：<code>/etc/supervisord.conf</code><br>使用<code>echo_supervisord_conf &gt; supervisord.conf</code>生成默认配置文件<br>注：supervisor的配置文件默认是不全的，不过在大部分默认的情况下，上面说的基本功能已经满足。</li><li>子进程配置文件路径：<code>/etc/supervisord.d/</code><br>注：默认子进程配置文件为ini格式，在<code>/etc/supervisord.conf </code>中 <code>[include]</code> 配置 <code>/etc/supervisord.d/*.ini</code></li></ul><h3 id="3-2-supervisor-conf配置文件说明">3.2 supervisor.conf配置文件说明</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">[unix_http_server]</span><br><span class="line">file=/tmp/supervisor.sock   ;UNIX socket 文件，supervisorctl 会使用</span><br><span class="line">;chmod=0700                 ;socket文件的mode，默认是0700</span><br><span class="line">;chown=nobody:nogroup       ;socket文件的owner，格式：uid:gid</span><br><span class="line"> </span><br><span class="line">;[inet_http_server]         ;HTTP服务器，提供web管理界面</span><br><span class="line">;port=127.0.0.1:9001        ;Web管理后台运行的IP和端口，如果开放到公网，需要注意安全性</span><br><span class="line">;username=user              ;登录管理后台的用户名</span><br><span class="line">;password=123               ;登录管理后台的密码</span><br><span class="line"> </span><br><span class="line">[supervisord]</span><br><span class="line">logfile=/tmp/supervisord.log ;日志文件，默认是 <span class="variable">$CWD</span>/supervisord.log</span><br><span class="line">logfile_maxbytes=50MB        ;日志文件大小，超出会rotate，默认 50MB，如果设成0，表示不限制大小</span><br><span class="line">logfile_backups=10           ;日志文件保留备份数量默认10，设为0表示不备份</span><br><span class="line">loglevel=info                ;日志级别，默认info，其它: debug,warn,trace</span><br><span class="line">pidfile=/tmp/supervisord.pid ;pid 文件</span><br><span class="line">nodaemon=<span class="literal">false</span>               ;是否在前台启动，默认是<span class="literal">false</span>，即以 daemon 的方式启动</span><br><span class="line">minfds=1024                  ;可以打开的文件描述符的最小值，默认 1024</span><br><span class="line">minprocs=200                 ;可以打开的进程数的最小值，默认 200</span><br><span class="line"> </span><br><span class="line">[supervisorctl]</span><br><span class="line">serverurl=unix:///tmp/supervisor.sock ;通过UNIX socket连接supervisord，路径与unix_http_server部分的file一致</span><br><span class="line">;serverurl=http://127.0.0.1:9001 ; 通过HTTP的方式连接supervisord</span><br><span class="line"> </span><br><span class="line">; [program:xx]是被管理的进程配置参数，xx是进程的名称</span><br><span class="line">[program:xx]</span><br><span class="line"><span class="built_in">command</span>=/opt/apache-tomcat-8.0.35/bin/catalina.sh run  ; 程序启动命令</span><br><span class="line">autostart=<span class="literal">true</span>       ; 在supervisord启动的时候也自动启动</span><br><span class="line">startsecs=10         ; 启动10秒后没有异常退出，就表示进程正常启动了，默认为1秒</span><br><span class="line">autorestart=<span class="literal">true</span>     ; 程序退出后自动重启,可选值：[unexpected,<span class="literal">true</span>,<span class="literal">false</span>]，默认为unexpected，表示进程意外杀死后才重启</span><br><span class="line">startretries=3       ; 启动失败自动重试次数，默认是3</span><br><span class="line">user=tomcat          ; 用哪个用户启动进程，默认是root</span><br><span class="line">priority=999         ; 进程启动优先级，默认999，值小的优先启动</span><br><span class="line">redirect_stderr=<span class="literal">true</span> ; 把stderr重定向到stdout，默认<span class="literal">false</span></span><br><span class="line">stdout_logfile_maxbytes=20MB  ; stdout 日志文件大小，默认50MB</span><br><span class="line">stdout_logfile_backups = 20   ; stdout 日志文件备份数，默认是10</span><br><span class="line">; stdout 日志文件，需要注意当指定目录不存在时无法正常启动，所以需要手动创建目录（supervisord 会自动创建日志文件）</span><br><span class="line">stdout_logfile=/opt/apache-tomcat-8.0.35/logs/catalina.out</span><br><span class="line">stopasgroup=<span class="literal">false</span>     ;默认为<span class="literal">false</span>,进程被杀死时，是否向这个进程组发送stop信号，包括子进程</span><br><span class="line">killasgroup=<span class="literal">false</span>     ;默认为<span class="literal">false</span>，向进程组发送<span class="built_in">kill</span>信号，包括子进程</span><br><span class="line"> </span><br><span class="line">;包含其它配置文件</span><br><span class="line">[include]</span><br><span class="line">files = relative/directory/*.ini    ;可以指定一个或多个以.ini结束的配置文件</span><br></pre></td></tr></table></figure><h3 id="3-3-子进程配置文件说明">3.3 子进程配置文件说明</h3><p>给需要管理的子进程(程序)编写一个配置文件，放在<code>/etc/supervisor.d/</code>目录下，以<code>.ini</code>作为扩展名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#项目名</span></span><br><span class="line">[program:blog]</span><br><span class="line"><span class="comment">#脚本目录</span></span><br><span class="line">directory=/opt/bin</span><br><span class="line"><span class="comment">#脚本执行命令</span></span><br><span class="line"><span class="built_in">command</span>=/usr/bin/python /opt/bin/test.py</span><br><span class="line"></span><br><span class="line"><span class="comment">#supervisor启动的时候是否随着同时启动，默认True</span></span><br><span class="line">autostart=<span class="literal">true</span></span><br><span class="line"><span class="comment">#当程序exit的时候，这个program不会自动重启,默认unexpected，设置子进程挂掉后自动重启的情况，有三个选项，false,unexpected和true。如果为false的时候，无论什么情况下，都不会被重新启动，如果为unexpected，只有当进程的退出码不在下面的exitcodes里面定义的</span></span><br><span class="line">autorestart=<span class="literal">false</span></span><br><span class="line"><span class="comment">#这个选项是子进程启动多少秒之后，此时状态如果是running，则我们认为启动成功了。默认值为1</span></span><br><span class="line">startsecs=1</span><br><span class="line"></span><br><span class="line"><span class="comment">#脚本运行的用户身份 </span></span><br><span class="line">user = <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#日志输出 </span></span><br><span class="line">stderr_logfile=/tmp/blog_stderr.log </span><br><span class="line">stdout_logfile=/tmp/blog_stdout.log </span><br><span class="line"><span class="comment">#把stderr重定向到stdout，默认 false</span></span><br><span class="line">redirect_stderr = <span class="literal">true</span></span><br><span class="line"><span class="comment">#stdout日志文件大小，默认 50MB</span></span><br><span class="line">stdout_logfile_maxbytes = 20MB</span><br><span class="line"><span class="comment">#stdout日志文件备份数</span></span><br><span class="line">stdout_logfile_backups = 20</span><br></pre></td></tr></table></figure><h2 id="4、supervisor命令说明">4、supervisor命令说明</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#首先要启动服务器</span></span><br><span class="line"><span class="comment">#unix:///var/run/supervisor.sock no such file表示满意启动服务器</span></span><br><span class="line">supervisord -c /etc/supervisord.conf</span><br><span class="line">systemctl stop supervisor.service</span><br><span class="line"></span><br><span class="line">supervisorctl status        <span class="comment">#查看所有进程的状态</span></span><br><span class="line">supervisorctl stop es       <span class="comment">#停止es</span></span><br><span class="line">supervisorctl start es      <span class="comment">#启动es</span></span><br><span class="line">supervisorctl restart       <span class="comment">#重启es</span></span><br><span class="line">supervisorctl update        <span class="comment">#配置文件修改后使用该命令加载新的配置</span></span><br><span class="line">supervisorctl reload        <span class="comment">#重新启动配置中的所有程序</span></span><br><span class="line"><span class="comment">#还可以直接进入shell交互界面</span></span><br><span class="line">supervisorctl</span><br></pre></td></tr></table></figure><p>子进程状态图，用status可以查看</p><p><img src="https://img-blog.csdnimg.cn/img_convert/9022c2547398cfa739bc5408d11ac1f2.png" alt></p><h1>三、Dockerfile编译jdk实例</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">FROM openjdk:19-slim-buster</span><br><span class="line">USER root</span><br><span class="line"><span class="comment">#DEBIAN_FRONTEND这个环境变量，告知操作系统应该从哪儿获得用户输入。如果设置为”noninteractive”，你就可以直接运行命令，</span></span><br><span class="line"><span class="comment">#而无需向用户请求输入（所有操作都是非交互式的）。这在运行apt-get命令的时候格外有用</span></span><br><span class="line">ENV DEBIAN_FRONTEND noninteractive</span><br><span class="line">ADD ./supervisord.conf /tmp/supervisord_add.conf</span><br><span class="line">RUN <span class="built_in">set</span> -ex \</span><br><span class="line">&amp;&amp; apt-get update\</span><br><span class="line">&amp;&amp; apt-get install -y python-pip \</span><br><span class="line">&amp;&amp; pip install supervisor \</span><br><span class="line">&amp;&amp; echo_supervisord_conf &gt; /etc/supervisord.conf \</span><br><span class="line">&amp;&amp; cat /tmp/supervisord_add.conf &gt;&gt; /etc/supervisord.conf \</span><br><span class="line">&amp;&amp; mkdir -p /var/<span class="built_in">log</span>/lamp \</span><br><span class="line">&amp;&amp; rm /tmp/supervisord_add.conf</span><br><span class="line">&amp;&amp; ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line">CMD [<span class="string">"supervisord"</span>,<span class="string">"-c"</span>,<span class="string">"/etc/supervisord.conf"</span>]</span><br></pre></td></tr></table></figure><p>这里使用supervisor来管理后台进程，和shell脚本差不多，但是这个功能更强大</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置成不要后台运行supervisor进程，对于容器来说就是一个前台进程</span></span><br><span class="line">nodaemon=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 把stderr重定向到stdout，默认false</span></span><br><span class="line">redirect_stderr=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 声明新程序的代码块</span></span><br><span class="line">[program:student]</span><br><span class="line"><span class="comment"># 用于启动在该代码块中声明的程序的命令</span></span><br><span class="line"><span class="built_in">command</span>=java -Dfile.encoding=utf-8 -jar /opt/lamp/student.jar --server.port=8080</span><br><span class="line">stdout_logfile=/var/<span class="built_in">log</span>/lamp/student.log</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1&gt;一、Bash 脚本 set 命令&lt;/h1&gt;
&lt;h2 id=&quot;1、介绍&quot;&gt;1、介绍&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;set&lt;/code&gt;命令是 Bash 脚本的重要环节，却常常被忽视，导致脚本的安全性和可维护性出问题。Bash 执行脚本的时候，会创建一个新的 Shell，若执行过程有错误，Bash 会忽略这个错误，继续往下执行，Bash 只是显示有错误，并没有终止执行。直接运行&lt;code&gt;set&lt;/code&gt;，会显示所有的环境变量和 Shell 函数&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#显示所有的环境变量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;set&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#查看环境变量字节数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;set&lt;/span&gt; | wc -l&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.shawn22.xyz/categories/Linux/"/>
    
    
    <category term="docker" scheme="https://www.shawn22.xyz/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot @Async异步多线程</title>
    <link href="https://www.shawn22.xyz/posts/22f5facd.html"/>
    <id>https://www.shawn22.xyz/posts/22f5facd.html</id>
    <published>2022-02-13T00:29:23.000Z</published>
    <updated>2022-02-13T00:35:14.732Z</updated>
    
    <content type="html"><![CDATA[<h1>一、简介</h1><h2 id="1、概念">1、概念</h2><p><strong>同步：</strong> 同步就是整个处理过程顺序执行，当各个过程都执行完毕，并返回结果。<br><strong>异步：</strong> 异步调用则是只是发送了调用的指令，调用者无需等待被调用的方法完全执行完毕；而是继续执行下面的流程。</p><a id="more"></a><h2 id="2、异步多线程概述">2、异步多线程概述</h2><p>在实际项目开发中很多业务场景需要使用异步去完成，比如消息通知，日志记录等常用的功能都可以通过异步去执行，提高效率。一般来说，完成异步操作一般有两种，<code>消息队列MQ</code>和线程池处理<code>ThreadPoolExecutor</code>，而在<code>Spring4</code>以后提供的对ThreadPoolExecutor封装的线程池<code>ThreadPoolTaskExecutor</code>，直接在方法上使用注解启用<code>@Async</code>，即可方便的使用异步线程（这里不要忘记在任一Configuration文件加上<code>@EnableAsync</code>打开注解功能）</p><h2 id="3、Spring已实现线程池">3、Spring已实现线程池</h2><ul><li><code>SimpleAsyncTaskExecutor</code>：不是真的线程池，这个类不重用线程，默认每次调用都会创建一个新的线程。</li><li><code>SyncTaskExecutor</code>：这个类没有实现异步调用，只是一个同步操作。只适用于不需要多线程的地方。</li><li><code>ConcurrentTaskExecutor</code>：Executor的适配类，不推荐使用。如果ThreadPoolTaskExecutor不满足要求时，才用考虑使用这个类。</li><li><code>SimpleThreadPoolTaskExecutor</code>：是Quartz的SimpleThreadPool的类。线程池同时被quartz和非quartz使用，才需要使用此类。</li><li><code>ThreadPoolTaskExecutor</code> ：最常使用，推荐。其实质是对<code>java.util.concurrent.ThreadPoolExecutor</code>的包装。</li></ul><h2 id="4、异步方法">4、异步方法</h2><blockquote><p>参考：<a href="https://blog.csdn.net/lemon_TT/article/details/121561663" target="_blank" rel="noopener">Java8异步编程</a></p></blockquote><ul><li>最简单的异步调用，返回值为void</li><li>带参数的异步调用，异步方法可以传入参数</li><li>存在返回值，常调用返回Future</li></ul><h1>二、@Async默认线程池</h1><h2 id="1、默认-Async异步调用例子">1、默认@Async异步调用例子</h2><h3 id="1-1-开启异步任务">1.1 开启异步任务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-在方法上标记异步调用">1.2 在方法上标记异步调用</h3><p>增加一个service类，用来做积分处理。  @Async添加在方法上，代表该方法为异步处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScoreService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ScoreService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addScore</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//TODO 模拟睡5秒，用于赠送积分处理</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>*<span class="number">5</span>);</span><br><span class="line">            logger.info(<span class="string">"--------------处理积分--------------------"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、默认线程池弊端">2、默认线程池弊端</h2><h3 id="2-1-Executors弊端">2.1 Executors弊端</h3><p>在线程池应用中，参考阿里巴巴java开发规范：线程池不允许使用Executors去创建，不允许使用系统默认的线程池，推荐通过<strong>ThreadPoolExecutor</strong>的方式，这样的处理方式让开发的工程师更加明确线程池的运行规则，规避资源耗尽的风险。Executors各个方法的弊端：</p><ul><li><code>newFixedThreadPool</code>和<code>newSingleThreadExecutor</code>：主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至OOM</li><li><code>newCachedThreadPool</code>和<code>newScheduledThreadPool</code>：主要问题是线程数最大数是<code>Integer.MAX_VALUE</code>，可能会创建数量非常多的线程，甚至OOM</li></ul><h3 id="2-2-Async弊端">2.2 @Async弊端</h3><p><code>@Async</code>默认异步配置使用的是<code>SimpleAsyncTaskExecutor</code>，该线程池默认来一个任务创建一个线程，若系统中不断的创建线程，最终会导致系统占用内存过高，引发OutOfMemoryError错误。</p><p>针对线程创建问题，SimpleAsyncTaskExecutor提供了限流机制，通过concurrencyLimit属性来控制开关，当<code>concurrencyLimit&gt;=0</code>时开启限流机制，默认关闭限流机制即<code>concurrencyLimit=-1</code>，当关闭情况下，会不断创建新的线程来处理任务。基于默认配置，SimpleAsyncTaskExecutor并不是严格意义的线程池，达不到线程复用的功能</p><h1>三、@Async自定义线程池</h1><h2 id="1、介绍">1、介绍</h2><p>自定义线程池，可对系统中线程池更加细粒度的控制，方便调整线程池大小配置，线程执行异常控制和处理。在设置系统自定义线程池代替默认线程池时，虽可通过多种模式设置，但替换默认线程池最终产生的线程池有且只能设置一个（不能设置多个类继承AsyncConfigurer）。自定义线程池有如下模式：</p><ul><li>重新实现接口AsyncConfigurer</li><li>继承AsyncConfigurerSupport</li><li>配置由自定义的TaskExecutor替代内置的任务执行器</li></ul><p>通过查看Spring源码关于<code>@Async</code>的默认调用规则，会优先查询源码中实现AsyncConfigurer这个接口的类，实现这个接口的类为AsyncConfigurerSupport。**但默认配置的线程池和异步处理方法均为空，所以，无论是继承或者重新实现接口，都需指定一个线程池。**且重新实现 <code>public Executor getAsyncExecutor()</code>方法。</p><h2 id="2、Spring自定义异步线程池几种方式">2、Spring自定义异步线程池几种方式</h2><h3 id="2-1-配置application-yml">2.1 配置application.yml</h3><p>这里我使用了配置文件注入的方式，首先配置好配置文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置核心线程数</span></span><br><span class="line"><span class="attr">async:</span></span><br><span class="line">  <span class="attr">executor:</span></span><br><span class="line">    <span class="attr">thread:</span></span><br><span class="line">      <span class="attr">core_pool_size:</span> <span class="number">5</span></span><br><span class="line">      <span class="comment"># 配置最大线程数</span></span><br><span class="line">      <span class="attr">max_pool_size:</span> <span class="number">5</span></span><br><span class="line">      <span class="comment"># 配置队列大小</span></span><br><span class="line">      <span class="attr">queue_capacity:</span> <span class="number">999</span></span><br><span class="line">      <span class="comment"># 配置线程最大空闲时间</span></span><br><span class="line">      <span class="attr">keep_alive_seconds:</span> <span class="number">60</span></span><br><span class="line">      <span class="comment"># 配置线程池中的线程的名称前缀</span></span><br><span class="line">      <span class="attr">name:</span></span><br><span class="line">        <span class="attr">prefix:</span> <span class="string">test-async-</span></span><br></pre></td></tr></table></figure><h3 id="2-2-实现接口AsyncConfigurer">2.2 实现接口AsyncConfigurer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorConfig1</span> <span class="keyword">implements</span> <span class="title">AsyncConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ExecutorConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;async.executor.thread.core_pool_size&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> corePoolSize;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;async.executor.thread.max_pool_size&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxPoolSize;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;async.executor.thread.queue_capacity&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> queueCapacity;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;async.executor.thread.keep_alive_seconds&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> keepAliveSeconds;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;async.executor.thread.name.prefix&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String namePrefix;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"asyncServiceExecutor"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">asyncServiceExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"开启SpringBoot的线程池！"</span>);</span><br><span class="line"></span><br><span class="line">        ThreadPoolTaskExecutor executor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置核心线程数</span></span><br><span class="line">        executor.setCorePoolSize(corePoolSize);</span><br><span class="line">        <span class="comment">// 设置最大线程数，只有在缓冲队列满了之后才会申请超过核心线程数的线程</span></span><br><span class="line">        executor.setMaxPoolSize(maxPoolSize);</span><br><span class="line">        <span class="comment">// 设置缓冲队列大小</span></span><br><span class="line">        executor.setQueueCapacity(queueCapacity);</span><br><span class="line">        <span class="comment">// 设置线程的最大空闲时间，超过了核心线程数之外的线程，在空闲时间到达之后会被销毁</span></span><br><span class="line">        executor.setKeepAliveSeconds(keepAliveSeconds);</span><br><span class="line">        <span class="comment">// 设置线程名字的前缀，设置好了之后可以方便我们定位处理任务所在的线程池</span></span><br><span class="line">        executor.setThreadNamePrefix(namePrefix);</span><br><span class="line">        <span class="comment">// 设置拒绝策略：当线程池达到最大线程数时，如何处理新任务</span></span><br><span class="line">        <span class="comment">// CALLER_RUNS：在添加到线程池失败时会由主线程自己来执行这个任务，</span></span><br><span class="line">        <span class="comment">// 当线程池没有处理能力的时候，该策略会直接在execute方法的调用线程中运行被拒绝的任务；如果执行程序已被关闭，则会丢弃该任务</span></span><br><span class="line">        executor.setRejectedExecutionHandler(<span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程池初始化</span></span><br><span class="line">        executor.initialize();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">getAsyncExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> asyncServiceExecutor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AsyncUncaughtExceptionHandler <span class="title">getAsyncUncaughtExceptionHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (ex, method, params) -&gt; logger.error(String.format(<span class="string">"执行异步任务'%s'"</span>, method), ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-继承AsyncConfigurerSupport">2.3 <strong>继承AsyncConfigurerSupport</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorConfig2</span> <span class="keyword">extends</span> <span class="title">AsyncConfigurerSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ExecutorConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;async.executor.thread.core_pool_size&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> corePoolSize;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;async.executor.thread.max_pool_size&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxPoolSize;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;async.executor.thread.queue_capacity&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> queueCapacity;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;async.executor.thread.keep_alive_seconds&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> keepAliveSeconds;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;async.executor.thread.name.prefix&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String namePrefix;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"asyncServiceExecutor"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">asyncServiceExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"开启SpringBoot的线程池！"</span>);</span><br><span class="line"></span><br><span class="line">        ThreadPoolTaskExecutor executor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置核心线程数</span></span><br><span class="line">        executor.setCorePoolSize(corePoolSize);</span><br><span class="line">        <span class="comment">// 设置最大线程数，只有在缓冲队列满了之后才会申请超过核心线程数的线程</span></span><br><span class="line">        executor.setMaxPoolSize(maxPoolSize);</span><br><span class="line">        <span class="comment">// 设置缓冲队列大小</span></span><br><span class="line">        executor.setQueueCapacity(queueCapacity);</span><br><span class="line">        <span class="comment">// 设置线程的最大空闲时间，超过了核心线程数之外的线程，在空闲时间到达之后会被销毁</span></span><br><span class="line">        executor.setKeepAliveSeconds(keepAliveSeconds);</span><br><span class="line">        <span class="comment">// 设置线程名字的前缀，设置好了之后可以方便我们定位处理任务所在的线程池</span></span><br><span class="line">        executor.setThreadNamePrefix(namePrefix);</span><br><span class="line">        <span class="comment">// 设置拒绝策略：当线程池达到最大线程数时，如何处理新任务</span></span><br><span class="line">        <span class="comment">// CALLER_RUNS：在添加到线程池失败时会由主线程自己来执行这个任务，</span></span><br><span class="line">        <span class="comment">// 当线程池没有处理能力的时候，该策略会直接在execute方法的调用线程中运行被拒绝的任务；如果执行程序已被关闭，则会丢弃该任务</span></span><br><span class="line">        executor.setRejectedExecutionHandler(<span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程池初始化</span></span><br><span class="line">        executor.initialize();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">getAsyncExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> asyncServiceExecutor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AsyncUncaughtExceptionHandler <span class="title">getAsyncUncaughtExceptionHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (ex, method, params) -&gt; logger.error(String.format(<span class="string">"执行异步任务'%s'"</span>, method), ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-配置自定义的TaskExecutor">2.4 <strong>配置自定义的TaskExecutor</strong></h3><p>由于AsyncConfigurer的默认线程池在源码中为空，Spring通过<code>beanFactory.getBean(TaskExecutor.class)</code>先查看是否有线程池，未配置时，通过<code>beanFactory.getBean(DEFAULT_TASK_EXECUTOR_BEAN_NAME, Executor.class)</code>，又查询是否存在默认名称为TaskExecutor的线程池。</p><p>因此在替换默认的线程池时，需设置默认的线程池名称为<strong>TaskExecutor</strong>，这样的模式，最终底层为<code>TaskExecutor.class</code>，在替换默认的线程池时，可不指定线程池名称。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorConfig3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ExecutorConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;async.executor.thread.core_pool_size&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> corePoolSize;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;async.executor.thread.max_pool_size&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxPoolSize;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;async.executor.thread.queue_capacity&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> queueCapacity;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;async.executor.thread.keep_alive_seconds&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> keepAliveSeconds;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;async.executor.thread.name.prefix&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String namePrefix;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name = AsyncExecutionAspectSupport.DEFAULT_TASK_EXECUTOR_BEAN_NAME)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">taskExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"开启SpringBoot的线程池！"</span>);</span><br><span class="line"></span><br><span class="line">        ThreadPoolTaskExecutor executor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置核心线程数</span></span><br><span class="line">        executor.setCorePoolSize(corePoolSize);</span><br><span class="line">        <span class="comment">// 设置最大线程数，只有在缓冲队列满了之后才会申请超过核心线程数的线程</span></span><br><span class="line">        executor.setMaxPoolSize(maxPoolSize);</span><br><span class="line">        <span class="comment">// 设置缓冲队列大小</span></span><br><span class="line">        executor.setQueueCapacity(queueCapacity);</span><br><span class="line">        <span class="comment">// 设置线程的最大空闲时间，超过了核心线程数之外的线程，在空闲时间到达之后会被销毁</span></span><br><span class="line">        executor.setKeepAliveSeconds(keepAliveSeconds);</span><br><span class="line">        <span class="comment">// 设置线程名字的前缀，设置好了之后可以方便我们定位处理任务所在的线程池</span></span><br><span class="line">        executor.setThreadNamePrefix(namePrefix);</span><br><span class="line">        <span class="comment">// 设置拒绝策略：当线程池达到最大线程数时，如何处理新任务</span></span><br><span class="line">        <span class="comment">// CALLER_RUNS：在添加到线程池失败时会由主线程自己来执行这个任务，</span></span><br><span class="line">        <span class="comment">// 当线程池没有处理能力的时候，该策略会直接在execute方法的调用线程中运行被拒绝的任务；如果执行程序已被关闭，则会丢弃该任务</span></span><br><span class="line">        executor.setRejectedExecutionHandler(<span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程池初始化</span></span><br><span class="line">        executor.initialize();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"myTask"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">taskExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"开启SpringBoot的线程池！"</span>);</span><br><span class="line"></span><br><span class="line">        ThreadPoolTaskExecutor executor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置核心线程数</span></span><br><span class="line">        executor.setCorePoolSize(corePoolSize);</span><br><span class="line">        <span class="comment">// 设置最大线程数，只有在缓冲队列满了之后才会申请超过核心线程数的线程</span></span><br><span class="line">        executor.setMaxPoolSize(maxPoolSize);</span><br><span class="line">        <span class="comment">// 设置缓冲队列大小</span></span><br><span class="line">        executor.setQueueCapacity(queueCapacity);</span><br><span class="line">        <span class="comment">// 设置线程的最大空闲时间，超过了核心线程数之外的线程，在空闲时间到达之后会被销毁</span></span><br><span class="line">        executor.setKeepAliveSeconds(keepAliveSeconds);</span><br><span class="line">        <span class="comment">// 设置线程名字的前缀，设置好了之后可以方便我们定位处理任务所在的线程池</span></span><br><span class="line">        executor.setThreadNamePrefix(namePrefix);</span><br><span class="line">        <span class="comment">// 设置拒绝策略：当线程池达到最大线程数时，如何处理新任务</span></span><br><span class="line">        <span class="comment">// CALLER_RUNS：在添加到线程池失败时会由主线程自己来执行这个任务，</span></span><br><span class="line">        <span class="comment">// 当线程池没有处理能力的时候，该策略会直接在execute方法的调用线程中运行被拒绝的任务；如果执行程序已被关闭，则会丢弃该任务</span></span><br><span class="line">        executor.setRejectedExecutionHandler(<span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程池初始化</span></span><br><span class="line">        executor.initialize();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-多线程">2.5 多线程</h3><p><code>@Async</code>注解使用系统默认或者自定义的线程池(代替默认线程池)，也可在项目中设置多个线程池，在异步调用时，指明需要调用的线程池名称，如<code>@Async(&quot;mytask&quot;)</code>。</p><p>参考文章</p><p><a href="https://mp.weixin.qq.com/s/ACJgGFofD9HAYqW4u8qJUw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/ACJgGFofD9HAYqW4u8qJUw</a></p><p><a href="https://juejin.cn/post/6970927877348917261#heading-0" target="_blank" rel="noopener">https://juejin.cn/post/6970927877348917261#heading-0</a></p><p><a href="https://www.cnblogs.com/kenx/p/15268311.html" target="_blank" rel="noopener">https://www.cnblogs.com/kenx/p/15268311.html</a></p>]]></content>
    
    
    <summary type="html">&lt;h1&gt;一、简介&lt;/h1&gt;
&lt;h2 id=&quot;1、概念&quot;&gt;1、概念&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;同步：&lt;/strong&gt; 同步就是整个处理过程顺序执行，当各个过程都执行完毕，并返回结果。&lt;br&gt;
&lt;strong&gt;异步：&lt;/strong&gt; 异步调用则是只是发送了调用的指令，调用者无需等待被调用的方法完全执行完毕；而是继续执行下面的流程。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://www.shawn22.xyz/categories/Java/"/>
    
    
    <category term="SpringBoot" scheme="https://www.shawn22.xyz/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Java集合框架</title>
    <link href="https://www.shawn22.xyz/posts/9753a2e.html"/>
    <id>https://www.shawn22.xyz/posts/9753a2e.html</id>
    <published>2022-02-03T13:49:44.000Z</published>
    <updated>2022-02-13T00:35:14.742Z</updated>
    
    <content type="html"><![CDATA[<p># Java集合框架</p><h1>一、简介</h1><h2 id="1、集合框架介绍">1、集合框架介绍</h2><p>Java集合框架提供了一套性能优良，使用方便的接口和类，他们位于<code>java.util</code>包中。容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对(两个对象)的映射表</p><p><img src="https://img-blog.csdnimg.cn/2a3f97c930a241468c0288110fec73ee.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6a2FTGVtb24=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><a id="more"></a><h2 id="2、相关容器介绍">2、相关容器介绍</h2><h3 id="2-1-Set相关">2.1 Set相关</h3><ul><li><strong>TreeSet</strong><br>基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)</li><li><strong>HashSet</strong><br>基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。</li><li><strong>LinkedHashSet</strong><br>具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序。</li></ul><h3 id="2-2-List相关">2.2 List相关</h3><ul><li><strong>ArrayList</strong><br>基于动态数组实现，支持随机访问。</li><li><strong>Vector</strong><br>和 ArrayList 类似，但它是线程安全的。</li><li><strong>LinkedList</strong><br>基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。</li></ul><h3 id="2-3-Queue相关">2.3 Queue相关</h3><ul><li><strong>LinkedList</strong><br>可以实现双向队列。</li><li><strong>PriorityQueue</strong><br>基于堆结构实现，可以用它来实现优先队列。</li></ul><h3 id="2-4-Map相关">2.4 Map相关</h3><ul><li><strong>TreeMap</strong><br>基于红黑树实现。</li><li><strong>HashMap</strong><br>基于哈希表实现。</li><li><strong>HashTable</strong><br>和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程可以同时写入 HashTable 并且不会导致数据不一致。它是遗留类，不应该去使用它。现在可以使用 <code>ConcurrentHashMap</code> 来支持线程安全，并且 <code>ConcurrentHashMap</code> 的效率会更高，因为 <code>ConcurrentHashMap</code> 引入了分段锁。</li><li><strong>LinkedHashMap</strong><br>使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用(LRU)顺序</li></ul><h2 id="3、集合重点👏">3、集合重点👏</h2><ul><li>Collection 接口存储一组不唯一，无序的对象</li><li>List 接口存储一组不唯一，有序的对象。</li><li>Set 接口存储一组唯一，无序的对象</li><li>Map 接口存储一组键值对象，提供key到value的映射</li><li>ArrayList实现了长度可变的数组，在内存中分配连续的空间。遍历元素和随机访问元素的效率比较高</li><li>LinkedList采用链表存储方式。插入、删除元素时效率比较高</li><li>HashSet采用哈希算法实现的Set</li><li>HashSet的底层是用HashMap实现的，因此查询效率较高，由于采用hashCode算法直接确定 元素的内存地址，增删效率高</li></ul><h1>二、ArrayList分析</h1><h2 id="1、ArrayList使用">1、ArrayList使用</h2><table><thead><tr><th><strong>方法</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>boolean add(Object o)</td><td>在列表的末尾顺序添加元素，起始索引位置从0开始</td></tr><tr><td>void add(int index, Object o)</td><td>在指定的索引位置添加元素，<strong>索引位置必须介于0和列表中元素个数之间</strong></td></tr><tr><td>int size()</td><td>返回列表中的元素个数</td></tr><tr><td>Object get(int index)</td><td>返回指定索引位置处的元素。<strong>取出的元素是Object类型，使用前品要进行益制类型转换</strong></td></tr><tr><td>boolean contains(Object o)</td><td>判断列表中是否存在指定元素</td></tr><tr><td>boolean remove(Object o)</td><td>从列表中删除元素</td></tr><tr><td>Object remove(int index）</td><td>从列表中删除指定位置元素，起始索引位量从0开始</td></tr></tbody></table><h2 id="2、ArrayList介绍">2、ArrayList介绍</h2><ul><li>ArrayList是可以动态增长和缩减的索引序列，它是基于数组实现的List类</li><li>该类封装了一个动态再分配的Object[]数组，每一个类对象都有一个capacity[容量]属性，表示它们所封装的Object[]数组的长度，当向ArrayList中添加元素时，该属性值会自动增加。如果想ArrayList中添加大量元素，可使用ensureCapacity方法一次性增加capacity，可以减少增加重分配的次数提高性能</li><li>ArrayList的用法和Vector向类似，但是Vector是一个较老的集合，具有很多缺点，不建议使用</li></ul><p>另外，ArrayList和Vector的区别是：ArrayList是线程不安全的，当多条线程访问同一个ArrayList集合时，程序需要手动保证该集合的同步性，而Vector则是线程安全的。</p><h2 id="3、源码分析">3、源码分析</h2><h3 id="3-1-继承结构与层次关系">3.1 继承结构与层次关系</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/ec45eadf515445c28c1b8643a1254e7a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6a2FTGVtb24=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>这里简单解释一下几个接口</p><ul><li><strong>RandomAccess接口</strong><br>这个是一个标记性接口，通过查看api文档，它的作用就是用来快速随机存取，有关效率的问题，在实现了该接口的话，那么使用普通的for循环来遍历，性能更高，例如ArrayList。而没有实现该接口的话，使用Iterator来迭代，这样性能更高，例如linkedList。所以这个标记性只是为了 让我们知道我们用什么样的方式去获取数据性能更好。</li><li><strong>Cloneable接口</strong><br>实现了该接口，就可以使用Object.Clone()方法了。</li><li><strong>Serializable接口</strong><br>实现该序列化接口，表明该类可以被序列化。什么是序列化？简单的说，就是能够从类变成字节流传输，然后还能从字节流变成原来的类。</li></ul><p><em>这里的继承结构可通过IDEA中Navigate&gt;Type Hierarchy查看</em></p><p><img src="https://img-blog.csdnimg.cn/ff0b03ec39644c5f9de723084544781a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6a2FTGVtb24=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><h3 id="3-2-属性">3.2 属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本号</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8683452581122892189L</span>;</span><br><span class="line"><span class="comment">//缺省容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//空对象数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="comment">//缺省空对象数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="comment">//存储的数组元素</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"><span class="comment">//实际元素大小，默认为0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="comment">//最大数组容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br></pre></td></tr></table></figure><h3 id="3-3-构造方法">3.3 构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造具有指定初始容量的空列表</span></span><br><span class="line"><span class="comment"> * 如果指定的初始容量为负，则为IllegalArgumentException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认空数组的大小为10</span></span><br><span class="line"><span class="comment"> * ArrayList中储存数据的其实就是一个数组，这个数组就是elementData</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 按照集合迭代器返回元素的顺序构造包含指定集合的元素的列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 转换为数组</span></span><br><span class="line">        <span class="comment">//每个集合的toarray()的实现方法不一样，所以需要判断一下，如果不是Object[].class类型，那么久需要使用ArrayList中的方法去改造一下。</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[]<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            <span class="title">elementData</span> </span>= Arrays.copyOf(elementData, size, Object[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则就用空数组代替</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-自动扩容✨">3.4 自动扩容✨</h3><p>每当向数组中添加元素时，都要去检查添加后元素的个数是否会超出当前数组的长度，如果超出，数组将会进行扩容，以满足添加数据的需求。数组扩容通过一个公开的方法<code>ensureCapacity(int minCapacity)</code>来实现。<strong>在实际添加大量元素前</strong>，我也可以使用<code>ensureCapacity</code>来手动增加ArrayList实例的容量，以减少递增式再分配的数量。</p><p>数组进行扩容时，会将**老数组中的元素重新拷贝一份到新的数组中，每次数组容量的增长大约是其原容量的1.5倍。**这种操作的代价是很高的，因此在实际使用时，我们应该尽量避免数组容量的扩张。当我们可预知要保存的元素的多少时，要在构造ArrayList实例时，就指定其容量，以避免数组扩容的发生。或者根据实际需求，<strong>通过调用ensureCapacity方法来手动增加ArrayList实例的容量</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断初始化的elementData是不是空的数组，也就是没有长度</span></span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="comment">//因为如果是空的话，minCapacity=size+1；其实就是等于1，空的数组没有长度就存放不了</span></span><br><span class="line">        <span class="comment">//所以就将minCapacity变成10，也就是默认大小，但是在这里，还没有真正的初始化这个elementData的大小</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//确认实际的容量，上面只是将minCapacity=10，这个方法就是真正的判断elementData是否够用</span></span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//minCapacity如果大于了实际elementData的长度，那么就说明elementData数组的长度不够用</span></span><br><span class="line">    <span class="comment">/*第一种情况：由于elementData初始化时是空的数组，那么第一次add的时候，</span></span><br><span class="line"><span class="comment">    minCapacity=size+1；也就minCapacity=1，在上一个方法(确定内部容量ensureCapacityInternal)</span></span><br><span class="line"><span class="comment">    就会判断出是空的数组，就会给将minCapacity=10，到这一步为止，还没有改变elementData的大小。</span></span><br><span class="line"><span class="comment">    第二种情况：elementData不是空的数组了，那么在add的时候，minCapacity=size+1；也就是</span></span><br><span class="line"><span class="comment">    minCapacity代表着elementData中增加之后的实际数据个数，拿着它判断elementData的length</span></span><br><span class="line"><span class="comment">    是否够用，如果length不够用，那么肯定要扩大容量，不然增加的这个元素就会溢出。*/</span> </span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ArrayList核心的方法，能扩展数组大小的真正秘密。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将扩充前的elementData大小给oldCapacity</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">//newCapacity就是1.5倍的oldCapacity</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">/*这句话就是适应于elementData就空数组的时候，length=0，那么oldCapacity=0，newCapacity=0，</span></span><br><span class="line"><span class="comment">    所以这个判断成立，在这里就是真正的初始化elementData的大小了，就是为10.前面的工作都是准备工作。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="comment">//如果newCapacity超过了最大的容量限制，就调用hugeCapacity，也就是将能给的最大值给newCapacity</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">//新的容量大小已经确定好就copy数组，改变容量大小。</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用来赋最大值</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="comment">//如果minCapacity都大于MAX_ARRAY_SIZE，那么就Integer.MAX_VALUE返回，反之将MAX_ARRAY_SIZE返回。</span></span><br><span class="line">    <span class="comment">//相当于给ArrayList上了两层防护</span></span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-add-方法">3.5 add()方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加一个特定的元素到list的末尾。</span></span><br><span class="line"><span class="comment"> * 先size+1判断数组容量是否够用，最后加入元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts the specified element at the specified position in this</span></span><br><span class="line"><span class="comment"> * list. Shifts the element currently at that position (if any) and</span></span><br><span class="line"><span class="comment"> * any subsequent elements to the right (adds one to their indices).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index index at which the specified element is to be inserted</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element element to be inserted</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//检查index也就是插入的位置是否合理。</span></span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    <span class="comment">//检查容量是否够用，不够就自动扩容</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">//这个方法就是用来在插入元素之后，要将index之后的元素都往后移一位</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                     size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当调用add()方法时，实际函数调用：</p><p><strong>add→ensureCapacityInternal→ensureExplicitCapacity(→grow→hugeCapacity)</strong></p><p>例如刚开始初始化一个空数组后add一个值，会首先进行自动扩容<br><img src="https://img-blog.csdnimg.cn/ddc8a1b63e08439aa5b9e7703ec55287.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6a2FTGVtb24=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><h3 id="3-6-trimToSize">3.6 trimToSize()</h3><p>将底层数组的容量调整为当前列表保存的实际元素的大小的功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (size &lt; elementData.length) &#123;</span><br><span class="line">        elementData = (size == <span class="number">0</span>)</span><br><span class="line">          ? EMPTY_ELEMENTDATA</span><br><span class="line">          : Arrays.copyOf(elementData, size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-7-remove-方法">3.7 remove()方法</h3><p><code>remove()</code>方法也有两个版本，一个是<code>remove(int index)</code>删除指定位置的元素，另一个是<code>remove(Object o)</code>删除第一个满足<code>o.equals(elementData[index])</code>的元素。删除操作是<code>add()</code>操作的逆过程，需要将删除点之后的元素向前移动一个位置。需要注意的是为了让GC起作用，必须显式的为最后一个位置赋<code>null</code>值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] = <span class="keyword">null</span>; <span class="comment">//清除该位置的引用，让GC起作用</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="3-8-其他方法">3.8 其他方法</h3><p>这里简单介绍了核心方法，其他方法查看源码可以很快了解</p><h3 id="3-9-Fail-Fast机制">3.9 Fail-Fast机制</h3><p>ArrayList采用了快速失败的机制，通过记录<code>modCount</code>参数来实现。在面对并发的修改时，迭代器很快就会完全失败，并抛出<code>ConcurrentModificationException</code>异常，而不是冒着在将来某个不确定时间发生任意不确定行为的风险</p><h2 id="4、总结">4、总结</h2><ul><li>ArrayList可以存放null</li><li>ArrayList本质上就是一个elementData数组</li><li>ArrayList区别于数组的地方在于能够自动扩展大小，其中关键的方法就是gorw()方法</li><li>ArrayList中removeAll(collection c)和clear()的区别就是removeAll可以删除批量指定的元素，而clear是全是删除集合中的元素</li><li>ArrayList由于本质是数组，所以它在数据的查询方面会很快，而在插入删除这些方面，性能下降很多，有移动很多数据才能达到应有的效果</li><li>ArrayList实现了RandomAccess，所以在遍历它的时候推荐使用for循环</li></ul><h1>三、LinkedList分析</h1><h2 id="1、LinkedList使用">1、LinkedList使用</h2><table><thead><tr><th><strong>方法名</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>void addFirst(Object o)</td><td>在列表的首部添加元素</td></tr><tr><td>void addLast(Object o)</td><td>在列表的未尾添加元素</td></tr><tr><td>Object getFirst()</td><td>返回列表中的第一个元素</td></tr><tr><td>Object getLast()</td><td>返回列表中的最后一个元素</td></tr><tr><td>Object removeFirst()</td><td>删除并返回列表中的第一个元素</td></tr><tr><td>Object removeLast()</td><td>删除并返回列表中的最后一个元素</td></tr></tbody></table><h2 id="2、LinkedList介绍">2、LinkedList介绍</h2><p><code>LinkedList</code>同时实现了List接口和Deque接口，也就是说它既可以看作一个顺序容器，又可以看作一个队列(Queue)，同时又可以看作一个栈(Stack)。这样看来，LinkedList简直就是个全能冠军。当你需要使用栈或者队列时，可以考虑使用<code>LinkedList</code>，一方面是因为Java官方已经声明不建议使用Stack类，更遗憾的是，Java里根本没有一个叫做Queue_的类(它是个接口名字)。关于栈或队列，现在的首选是<code>ArrayDeque</code>，它有着比<code>LinkedList</code>(当作栈或队列使用时)有着更好的性能。</p><p>LinkedList的实现方式决定了所有跟下标相关的操作都是线性时间，而在首段或者末尾删除元素只需要常数时间。为追求效率LinkedList没有实现同步(synchronized)，如果需要多个线程并发访问，可以先采用<code>Collections.synchronizedList()</code>方法对其进行包装</p><h2 id="3、源码分析-v2">3、源码分析</h2><h3 id="3-1-继承结构与层次">3.1 继承结构与层次</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/c7737a6ae175461ab1369a5ae54f5796.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6a2FTGVtb24=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/b200fe62d3f34c1091d7cceb848e674e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6a2FTGVtb24=,size_18,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><p>这里可以发现LinkedList多了一层<code>AbstractSequentialList</code>的抽象类，这是为了减少实现顺序存取（例如LinkedList）这种类的工作。如果自己想实现顺序存取这种特性的类(就是链表形式)，那么就继承 这个AbstractSequentialList抽象类，如果想像数组那样的随机存取的类，那么就去实现AbstracList抽象类。</p><ul><li><strong>List接口</strong><br>列表add、set等一些对列表进行操作的方法</li><li><strong>Deque接口</strong><br>有队列的各种特性</li><li><strong>Cloneable接口</strong><br>能够复制，使用那个copy方法</li><li><strong>Serializable接口</strong><br>能够序列化。</li><li><strong>没有RandomAccess</strong><br>推荐使用iterator，在其中就有一个foreach，增强的for循环，其中原理也就是iterator，我们在使用的时候，使用foreach或者iterator</li></ul><h3 id="3-2-属性与构造方法">3.2 属性与构造方法</h3><p>transient关键字修饰，这也意味着在序列化时该域是不会序列化的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实际元素个数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//头结点</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"><span class="comment">//尾结点</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    <span class="comment">//将集合c中的各个元素构建成LinkedList链表</span></span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-内部类Node✨">3.3 内部类Node✨</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据前面介绍双向链表就知道这个代表什么了，linkedList的奥秘就在这里</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 数据域（当前节点的值）</span></span><br><span class="line">    E item;</span><br><span class="line">    <span class="comment">//后继</span></span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    <span class="comment">//前驱</span></span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line">    <span class="comment">// 构造函数，赋值前驱后继</span></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-核心方法add-和addAll-✨">3.4 核心方法add()和addAll()✨</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//临时节点l(L的小写)保存last，也就是l指向了最后一个节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="comment">//将e封装为节点，并且e.prev指向了最后一个节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//newNode成为了最后一个节点，所以last指向了它</span></span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//判断是不是一开始链表中就什么都没有，如果没有，则new Node就成为了第一个结点，first和last都指向它</span></span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//正常的在最后一个节点后追加，那么原先的最后一个节点的next就要指向现在真正的 最后一个节点，原先的最后一个节点就变成了倒数第二个节点</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    <span class="comment">//添加一个节点，size自增</span></span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>addAll()</code>有两个重载函数，<code>addAll(Collection&lt;? extends E&gt;)</code>型和<code>addAll(int,Collection&lt;? extends E&gt;)</code>型，我们平时习惯调用的<code>addAll(Collection&lt;?extends E&gt;)</code>型会转化为<code>addAll(int,Collection&lt;? extends&lt;E&gt;)</code>型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> addAll(size, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//检查index这个是否为合理</span></span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line">    <span class="comment">//将集合c转换为Object数组</span></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="comment">//数组a的长度numNew，也就是由多少个元素</span></span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    <span class="keyword">if</span> (numNew == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//如果空的就什么也不做</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    Node&lt;E&gt; pred, succ;</span><br><span class="line">    <span class="comment">//构造方法中传过来的就是index==size</span></span><br><span class="line">    <span class="comment">//情况一：构造方法创建的一个空的链表，那么size=0，last、和first都为null。linkedList中是空的。</span></span><br><span class="line">    <span class="comment">//什么节点都没有。succ=null、pred=last=null</span></span><br><span class="line">    <span class="comment">//情况二：链表中有节点，size就不是为0，first和last都分别指向第一个节点，和最后一个节点，</span></span><br><span class="line">    <span class="comment">//在最后一个节点之后追加元素，就得记录一下最后一个节点是什么，所以把last保存到pred临时节点中。</span></span><br><span class="line">    <span class="comment">//情况三index！=size，说明不是前面两种情况，而是在链表中间插入元素，那么就得知道index上的节点是谁，</span></span><br><span class="line">    <span class="comment">//保存到succ临时节点中，然后将succ的前一个节点保存到pred中，这样保存了这两个节点，就能够准确的插入节点了</span></span><br><span class="line">    <span class="keyword">if</span> (index == size) &#123;</span><br><span class="line">        succ = <span class="keyword">null</span>;</span><br><span class="line">        pred = last;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        succ = node(index);</span><br><span class="line">        pred = succ.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Object o : a) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) E e = (E) o;</span><br><span class="line">        Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pred.next = newNode;</span><br><span class="line">        pred = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (succ == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">/*如果succ==null，说明是情况一或者情况二，</span></span><br><span class="line"><span class="comment">        情况一、构造方法，也就是刚创建的一个空链表，pred已经是newNode了，</span></span><br><span class="line"><span class="comment">        last=newNode，所以linkedList的first、last都指向第一个节点。</span></span><br><span class="line"><span class="comment">        情况二、在最后节后之后追加节点，那么原先的last就应该指向现在的最后一个节点了，</span></span><br><span class="line"><span class="comment">        就是newNode。*/</span></span><br><span class="line">        last = pred;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pred.next = succ;</span><br><span class="line">        succ.prev = pred;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size += numNew;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据引下标找到该结点并返回</span></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断插入的位置在链表前半段或者是后半段</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="comment">//从头结点开始正向遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="comment">//从尾结点开始反向遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-remove">3.5 remove()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*如果我们要移除的值在链表中存在多个一样的值，那么我们</span></span><br><span class="line"><span class="comment">会移除index最小的那个，也就是最先找到的那个值，如果不存在这个值，那么什么也不做</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">////不能传一个null值</span></span><br><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert x != null;</span></span><br><span class="line">    <span class="keyword">final</span> E element = x.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev.next = next;</span><br><span class="line">        x.prev = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next.prev = prev;</span><br><span class="line">        x.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//x的前后指向都为null了，也把item为null，让gc回收它</span></span><br><span class="line">    x.item = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-6-其他方法">3.6 其他方法</h3><p>**get(index)、indexOf(Object o)**等查看源码即可</p><h3 id="3-7-LinkedList的迭代器">3.7 <strong>LinkedList的迭代器</strong></h3><p>在LinkedList中除了有一个Node的内部类外，应该还能看到另外两个内部类，那就是<code>ListItr</code>，还有一个是<code>DescendingIterator</code>内部类</p><p><img src="https://img-blog.csdnimg.cn/3d4c8f02fddf41688e60258f73d4632c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6a2FTGVtb24=,size_19,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*这个类，还是调用的ListItr，作用是封装一下Itr中几个方法，让使用者以正常的思维去写代码，</span></span><br><span class="line"><span class="comment">例如，在从后往前遍历的时候，也是跟从前往后遍历一样，使用next等操作，而不用使用特殊的previous。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">DescendingIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ListItr itr = <span class="keyword">new</span> ListItr(size());</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> itr.hasPrevious();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> itr.previous();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        itr.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、总结-v2">4、总结</h2><ul><li>linkedList本质上是一个双向链表，通过一个Node内部类实现的这种链表结构。linkedList能存储null值</li><li>跟ArrayList相比较，就真正的知道了，LinkedList在删除和增加等操作上性能好，而ArrayList在查询的性能上好，从源码中看，它不存在容量不足的情况</li><li>linkedList不光能够向前迭代，还能像后迭代，并且在迭代的过程中，可以修改值、添加值、还能移除值</li><li>linkedList不光能当链表，还能当队列使用，这个就是因为实现了Deque接口</li></ul><h1>四、List总结</h1><h2 id="1、ArrayList和LinkedList区别">1、ArrayList和LinkedList区别</h2><ul><li>ArrayList底层是用数组实现的顺序表，是随机存取类型，可自动扩增，并且在初始化时，数组的长度是0，只有在增加元素时，长度才会增加。默认是10，不能无限扩增，有上限，在查询操作的时候性能更好</li><li>LinkedList底层是用链表来实现的，是一个双向链表，注意这里不是双向循环链表,顺序存取类型。在源码中，似乎没有元素个数的限制。应该能无限增加下去，直到内存满了在进行删除，增加操作时性能更好。</li></ul><p>两个都是线程不安全的，在iterator时，会发生<strong>fail-fast：快速失效</strong>。</p><h2 id="2、ArrayList和Vector区别">2、ArrayList和Vector区别</h2><ul><li>ArrayList线程不安全，在用iterator，会发生fail-fast</li><li>Vector线程安全，因为在方法前加了Synchronized关键字，也会发生fail-fast</li></ul><h2 id="3、fail-fast和fail-safe区别与情况说明">3、fail-fast和fail-safe区别与情况说明</h2><blockquote><p>在java.util下的集合都是发生fail-fast，而在java.util.concurrent下的发生的都是fail-safe</p></blockquote><ul><li><strong>fail-fast</strong><br>快速失败，例如在arrayList中使用迭代器遍历时，有另外的线程对arrayList的存储数组进行了改变，比 如add、delete等使之发生了结构上的改变，所以Iterator就会快速报一个<code>java.util.ConcurrentModiﬁcationException</code>异常（并发修改异常），这就是快速失败</li><li><strong>fail-safe</strong><br>安全失败，在<code>java.util.concurrent</code>下的类，都是线程安全的类，他们在迭代的过程中，如果有线程进行结构的改变，不会报异常，而是正常遍历，这就是安全失败</li><li><strong>为什么在java.util.concurrent包下对集合有结构的改变却不会报异常？</strong><br>在concurrent下的集合类增加元素的时候使用<code>Arrays.copyOf()</code>来拷贝副本，在副本上增加元素，如果有其他线程在此改变了集合的结构，那也是在副本上的改变，而不是影响到原集合，迭代器还是照常遍历，遍历完之后，改变原引用指向副本，所以总的一句话就是如果在此包下的类进行增加删除，就会出现一个副本。所以能防止fail-fast，这种机制并不会出错，所以我们叫这种现象为fail-safe</li><li><strong>vector也是线程安全的，为什么是fail-fast呢？</strong><br>出现fail-safe是因为他们在实现增删的底层机制不一样，就像上面说的，会有一个副本，而像arrayList、linekdList、verctor等他们底层就是对着真正的引用进行操作，所以才会发生异常</li></ul><h2 id="4、为什么现在都不提倡使用Vector">4、为什么现在都不提倡使用Vector</h2><ul><li>vector实现线程安全的方法是在每个操作方法上加锁，这些锁并不是必须要的，在实际开发中，一般都是通过锁一系列的操作来实现线程安全，也就是说将需要同步的资源放一起加锁来保证线程安全</li><li>如果多个Thread并发执行一个已经加锁的方法，但是在该方法中，又有Vector的存在，Vector<br>本身实现中已经加锁了，那么相当于锁上又加锁，会造成额外的开销</li><li>Vector还有fail-fast的问题，也就是说它也无法保证遍历安全，在 遍历时又得额外加锁，又是额外的开销，还不如直接用arrayList，然后再加锁</li></ul><p>总结：Vector在你不需要进行线程安全的时候，也会给你加锁，也就导致了额外开销，所以在jdk1.5之后就被弃用了，现在如果要用到线程安全的集合，都是从<code>java.util.concurrent</code>包下去拿相应的类。</p><h1>五、HashMap分析</h1><h2 id="1、HashMap介绍">1、HashMap介绍</h2><h3 id="1-1-Java8以前的HashMap">1.1 Java8以前的HashMap</h3><blockquote><p>通过key、value封装成一个entry对象，然后通过key的值来计算该entry的hash值，通过entry的hash 值和数组的长度length来计算出entry放在数组中的哪个位置上面，每次存放都是将entry放在第一个位置。</p></blockquote><p>HashMap实现了Map接口，即允许放入<code>key</code>为<code>null</code>的元素，也允许插入<code>value</code>为<code>null</code>的元素；除该类未实现同步外，其余跟<code>Hashtable</code>大致相同；跟TreeMap不同，该容器不保证元素顺序，根据需要该容器可能会对元素重新哈希，元素的顺序也会被重新打散，因此不同时间迭代同一个HashMap的顺序可能会不同。 根据对冲突的处理方式不同，哈希表有两种实现方式，一种开放地址方式(Open addressing)，另一种是冲突链表方式(Separate chaining with linked lists)。<strong>Java7 HashMap采用的是冲突链表方式</strong>。</p><p><img src="https://img-blog.csdnimg.cn/4e37614a989b4425afc5aa0929257903.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6a2FTGVtb24=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><h3 id="1-2-Java8后的HashMap">1.2 Java8后的HashMap</h3><p>Java8 对 HashMap 进行了一些修改，最大的不同就是利用了红黑树，所以其由 <strong>数组+链表+红黑树</strong> 组成。根据 <strong>Java7 HashMap</strong> 的介绍，我们知道，查找的时候，根据 hash 值我们能够快速定位到数组的具体下标，但是之后的话，需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决于链表的长度为 O(n)。为了降低这部分的开销，在 <strong>Java8</strong> 中，当链表中的元素达到了 8 个时，会将链表转换为<strong>红黑树</strong>，在这些位置进行查找的时候可以降低时间复杂度为 <strong>O(logN)</strong>。<br><img src="https://img-blog.csdnimg.cn/158044daf3244036b2714ff9f72fe4e9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6a2FTGVtb24=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><p>Java7 中使用 Entry 来代表每个 HashMap 中的数据节点，Java8 中使用 Node，基本没有区别，都是 key，value，hash 和 next 这四个属性，不过，Node 只能用于链表的情况，红黑树的情况需要使用 TreeNode</p><h2 id="2、Java8-HashMap源码分析">2、Java8 HashMap源码分析</h2><h3 id="2-1-继承结构与层次">2.1 继承结构与层次</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/a527533fb7d14a3cbabca86c8c64c6ce.png#pic_center" alt="在这里插入图片描述"></p><h3 id="2-2-属性">2.2 属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//序列号</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">362498820763181265L</span>;</span><br><span class="line"><span class="comment">//默认的初始容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"><span class="comment">//最大容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">//默认加载因子</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">//当桶(bucket)上的结点数大于这个值时会转成红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="comment">//当桶(bucket)上的结点数小于这个值时树转链表</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"><span class="comment">//桶中结构转化为红黑树对应的table的最小大小</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"><span class="comment">//存储元素的数组，总是2的幂次倍</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="comment">//存放具体元素的集</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"><span class="comment">//存放元素的个数，注意这个不等于数组的长度</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="comment">//每次扩容和更改map结构的计数器</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"><span class="comment">//临界值，当实际大小(容量*填充因子)超过临界值时，会进行扩容</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"><span class="comment">//填充因子,计算HashMap的实时装载因子的方法为：size/capacity</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure><h3 id="2-3-构造方法">2.3 构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始容量不能小于0，否则报错</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="comment">// 初始容量不能大于最大值，否则为最大值</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="comment">//填充因子不能小于或等于0，不能为非数字</span></span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">         loadFactor);</span><br><span class="line">    <span class="comment">//初始化填充因子                                       </span></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="comment">//初始化threshold大小</span></span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个方法将传进来的参数转变为2的n次方的数值</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义初始容量，加载因子为默认</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用默认的加载因子等字段</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化填充因子</span></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    <span class="comment">//将m中的所有元素添加至HashMap中</span></span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将m的所有元素存入该实例</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = m.size();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//判断table是否已经初始化</span></span><br><span class="line">        <span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">            <span class="comment">//未初始化，s为m的实际元素个数</span></span><br><span class="line">            <span class="keyword">float</span> ft = ((<span class="keyword">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">            <span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                     (<span class="keyword">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="comment">//计算得到的t大于阈值，则初始化阈值</span></span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="comment">//将m中的所有元素添加至HashMap中</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">            K key = e.getKey();</span><br><span class="line">            V value = e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-核心方法✨">2.4 核心方法✨</h3><p><strong>put()方法</strong></p><p>先计算key的hash值，然后根据hash值搜索在table数组中的索引位置，如果table数组在该位置处有元素，则查找是否存在相同的key，若存在则覆盖原来key的value，否则将该元素保存在链表尾部，注意JDK1.7中采用的是头插法，即每次都将冲突的键值对放置在链表头，这样最初的那个键值对最终就会成为链尾，而JDK1.8中使用的是尾插法。此外，若table在该处没有元素，则直接保存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">//第一次put元素时，table数组为空，先调用resize生成一个指定容量的数组</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">//hash值和n-1的与运算结果为桶的位置，如果该位置空就直接放置一个Node</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//如果计算出的bucket不空，即发生哈希冲突，就要进一步判断</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">//判断当前Node的key与要put的key是否相等</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">//判断当前Node是否是红黑树的节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">//以上都不是，说明要new一个Node，加入到链表中</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">              <span class="comment">//在链表尾部插入新节点，注意jdk1.8是在链表尾部插入新节点</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 如果当前链表中的元素大于树化的阈值，进行链表转树的操作</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//在链表中继续判断是否已经存在完全相同的key</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//走到这里，说明本次put是更新一个已存在的键值对的value</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">//在hashMap中，afterNodeAccess方法体为空，交给子类去实现</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">//如果当前size超过临界值，就扩容。注意是先插入节点再扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">//在hashMap中，afterNodeInsertion方法体为空，交给子类去实现</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>resize() 数组扩容</strong></p><p>用于初始化数组或数组扩容，每次扩容后，容量为原来的 2 倍，并进行数据迁移</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123; <span class="comment">// 对应数组扩容</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将数组大小扩大一倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="comment">// 将阈值扩大一倍</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// 对应使用 new HashMap(int initialCapacity) 初始化后，第一次 put 的时候</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">// 对应使用 new HashMap() 初始化后，第一次 put 的时候</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用新的数组大小初始化新的数组</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab; <span class="comment">// 如果是初始化数组，到这里就结束了，返回 newTab 即可</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 开始遍历原数组，进行数据迁移。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 如果该数组位置上只有单个元素，那就简单了，简单迁移这个元素就可以了</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">// 如果是红黑树，具体我们就不展开了</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; </span><br><span class="line">                    <span class="comment">// 这块是处理链表的情况，</span></span><br><span class="line">                    <span class="comment">// 需要将此链表拆成两个链表，放到新的数组中，并且保留原来的先后顺序</span></span><br><span class="line">                    <span class="comment">// loHead、loTail 对应一条链表，hiHead、hiTail 对应另一条链表，代码还是比较简单的</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="comment">// 第一条链表</span></span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="comment">// 第二条链表的新的位置是 j + oldCap，这个很好理解</span></span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>get()过程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断第一个节点是不是就是需要的</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断是否是红黑树</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 链表遍历</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-其他方法">2.5 其他方法</h3><p>HashSet是对HashMap的简单包装，其他还有迭代器等</p><h2 id="3、总结">3、总结</h2><p>关于数组扩容，从putVal源代码中我们可以知道，当插入一个元素的时候size就加1，若size大于threshold的时候，就会进行扩容。假设我们的capacity大小为32，loadFator为0.75，则threshold为24 = 32 * 0.75，此时，插入了25个元素，并且插入的这25个元素都在同一个桶中，桶中的数据结构为红黑树，则还有31个桶是空的，也会进行扩容处理，其实此时，还有31个桶是空的，好像似乎不需要进行扩容处理，但是是需要扩容处理的，因为此时我们的capacity大小可能不适当。我们前面知道，扩容处理会遍历所有的元素，时间复杂度很高；前面我们还知道，经过一次扩容处理后，元素会更加均匀的分布在各个桶中，会提升访问效率。所以说尽量避免进行扩容处理，也就意味着，遍历元素所带来的坏处大于元素在桶中均匀分布所带来的好处。</p><ul><li>HashMap在JDK1.8以前是一个链表散列这样一个数据结构，而在JDK1.8以后是一个数组加链表加红黑树的数据结构</li><li>通过源码的学习，HashMap是一个能快速通过key获取到value值得一个集合，原因是内部使用的是hash查找值得方法</li></ul><p>另外LinkedHashMap是HashMap的直接子类，<strong>二者唯一的区别是LinkedHashMap在HashMap的基础上，采用双向链表(doubly-linked list)的形式将所有</strong><code>**entry**</code><strong>连接起来，这样是为保证元素的迭代顺序跟插入顺序相同</strong></p><h1>六、Collections工具类</h1><h2 id="1、概述">1、概述</h2><p>此类完全由在 collection 上进行操作或返回 collection 的静态方法组成。它包含在 collection 上操作的多态算法，即“包装器”，包装器返回由指定 collection 支持的新 collection，以及少数其他内容。如果为此类的方法所提供的 collection 或类对象为 null，则这些方法都将抛出<code>NullPointerException</code></p><h2 id="2、排序常用方法">2、排序常用方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反转列表中元素的顺序</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(List&lt;?&gt; list)</span></span></span><br><span class="line"><span class="function"><span class="comment">//对List集合元素进行随机排序</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(List&lt;?&gt; list)</span></span></span><br><span class="line"><span class="function"><span class="comment">//根据元素的自然顺序 对指定列表按升序进行排序</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; list)</span></span></span><br><span class="line"><span class="function"><span class="comment">//根据指定比较器产生的顺序对指定列表进行排序</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; list, Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span></span></span><br><span class="line"><span class="function"><span class="comment">//在指定List的指定位置i,j处交换元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(List&lt;?&gt; list, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"><span class="comment">//当distance为正数时，将List集合的后distance个元素“整体”移到前面；当distance为负数时，将list集合的前distance个元素“整体”移到后边。该方法不会改变集合的长度</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(List&lt;?&gt; list, <span class="keyword">int</span> distance)</span></span></span><br></pre></td></tr></table></figure><h2 id="3、查找、替换操作">3、查找、替换操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用二分搜索法搜索指定列表，以获得指定对象在List集合中的索引</span></span><br><span class="line"><span class="comment">//注意：此前必须保证List集合中的元素已经处于有序状态</span></span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(List&lt;? extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt;list, T key)</span></span></span><br><span class="line"><span class="function"><span class="comment">//根据元素的自然顺序，返回给定collection 的最大元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Object <span class="title">max</span><span class="params">(Collection coll)</span></span></span><br><span class="line"><span class="function"><span class="comment">//根据指定比较器产生的顺序，返回给定 collection 的最大元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Object <span class="title">max</span><span class="params">(Collection coll,Comparator comp)</span>:</span></span><br><span class="line"><span class="function"><span class="comment">//根据元素的自然顺序，返回给定collection 的最小元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Object <span class="title">min</span><span class="params">(Collection coll)</span>:</span></span><br><span class="line"><span class="function"><span class="comment">//根据指定比较器产生的顺序，返回给定 collection 的最小元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Object <span class="title">min</span><span class="params">(Collection coll,Comparator comp)</span>:</span></span><br><span class="line"><span class="function"><span class="comment">//使用指定元素替换指定列表中的所有元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title">fill</span><span class="params">(List&lt;? <span class="keyword">super</span> T&gt; list,T obj)</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回指定co1lection中等于指定对象的出现次数</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">frequency</span><span class="params">(collection&lt;?&gt;c,object o)</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回指定源列表中第一次出现指定目标列表的起始位置；如果没有出现这样的列表，则返回-1</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexofsubList</span><span class="params">(List&lt;?&gt;source, List&lt;?&gt;target)</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回指定源列表中最后一次出现指定目标列表的起始位置；如果没有出现这样的列表，则返回-1</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lastIndexofsubList</span><span class="params">(List&lt;?&gt;source,List&lt;?&gt;target)</span></span></span><br><span class="line"><span class="function"><span class="comment">//使用一个新值替换List对象的所有旧值o1dval</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;T&gt; <span class="keyword">boolean</span> <span class="title">replaceA1l</span><span class="params">(list&lt;T&gt; list,T oldval,T newval)</span></span></span><br></pre></td></tr></table></figure><h2 id="4、同步控制">4、同步控制</h2><p>Collectons提供了多个synchronizedXxx()方法，该方法可以将指定集合包装成线程同步的集合，从而解决多线程并发访问集合时的线程安全问题。正如前面介绍的HashSet，TreeSet，arrayList，LinkedList，HashMap，TreeMap都是线程不安全的。Collections提供了多个静态方法可以把他们包装成线程同步的集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回指定 Collection 支持的同步（线程安全的）collection</span></span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">Collection&lt;T&gt; <span class="title">synchronizedCollection</span><span class="params">(Collection&lt;T&gt; c)</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回指定列表支持的同步（线程安全的）列表</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title">synchronizedList</span><span class="params">(List&lt;T&gt; list)</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回由指定映射支持的同步（线程安全的）映射</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;K,V&gt; Map&lt;K,V&gt; <span class="title">synchronizedMap</span><span class="params">(Map&lt;K,V&gt; m)</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回指定 set 支持的同步（线程安全的）set</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;T&gt; Set&lt;T&gt; <span class="title">synchronizedSet</span><span class="params">(Set&lt;T&gt; s)</span></span></span><br></pre></td></tr></table></figure><h2 id="5、Collection设置不可变集合">5、Collection设置不可变集合</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回一个空的、不可变的集合对象，此处的集合既可以是List，也可以是Set，还可以是Map。</span></span><br><span class="line">emptyXxx()</span><br><span class="line"><span class="comment">//返回一个只包含指定对象（只有一个或一个元素）的不可变的集合对象，此处的集合可以是：List，Set，Map。</span></span><br><span class="line">singletonXxx():</span><br><span class="line"><span class="comment">//返回指定集合对象的不可变视图，此处的集合可以是：List，Set，Map</span></span><br><span class="line">unmodifiableXxx()</span><br></pre></td></tr></table></figure><hr><p>参考问题</p><p><a href="https://pdai.tech/md/java/collection/java-collection-all.html" target="_blank" rel="noopener">https://pdai.tech/md/java/collection/java-collection-all.html</a></p><p><a href="https://blog.csdn.net/fuzhongmin05/article/details/104355841" target="_blank" rel="noopener">https://blog.csdn.net/fuzhongmin05/article/details/104355841</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;# Java集合框架&lt;/p&gt;
&lt;h1&gt;一、简介&lt;/h1&gt;
&lt;h2 id=&quot;1、集合框架介绍&quot;&gt;1、集合框架介绍&lt;/h2&gt;
&lt;p&gt;Java集合框架提供了一套性能优良，使用方便的接口和类，他们位于&lt;code&gt;java.util&lt;/code&gt;包中。容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对(两个对象)的映射表&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2a3f97c930a241468c0288110fec73ee.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6a2FTGVtb24=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://www.shawn22.xyz/categories/Java/"/>
    
    
    <category term="Java基础" scheme="https://www.shawn22.xyz/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java IO流</title>
    <link href="https://www.shawn22.xyz/posts/59ae8782.html"/>
    <id>https://www.shawn22.xyz/posts/59ae8782.html</id>
    <published>2022-02-03T13:49:31.000Z</published>
    <updated>2022-02-13T00:35:14.737Z</updated>
    
    <content type="html"><![CDATA[<h1>一、Java IO流基础</h1><h2 id="1、流式输入-输出原理">1、流式输入/输出原理</h2><p>在java程序中，对于数据的输入/输出操作以&quot;流&quot;（stream）方式进行；J2SDK提供了各种各样的&quot;流&quot;类，用以获取不同种类的数据：程序中通过标准的方法输入或输出数据</p><p><img src="https://img-blog.csdnimg.cn/c192f69684c0424685408c7c267311bc.png?type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6a2FTGVtb24=,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><a id="more"></a><h2 id="2、输入流-输出流">2、输入流/输出流</h2><p><img src="https://img-blog.csdnimg.cn/c7beb57475c14405a7c6571a1a5dc416.png?type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6a2FTGVtb24=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><h2 id="3、节点流-处理流">3、节点流/处理流</h2><p><img src="https://img-blog.csdnimg.cn/a65bdfaded0d4e20b87eb1f02b0d3b7b.png?type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6a2FTGVtb24=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><h3 id="3-1-节点流">3.1 节点流</h3><p>节点流就是一根管道直接插到数据源上面，直接读数据源里面的数据，或者是直接往数据源里面写入数据。典型的节点流是文件流：文件的字节输入流（<code>FileInputStream</code>），文件的字节输出流（<code>FileOutputStream</code>），文件的字符输入流（<code>FileReader</code>），文件的字符输出流（<code>FileWriter</code>）</p><p><img src="https://img-blog.csdnimg.cn/f1082502ed5a4c6d8750ea71d32e0e63.png?type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6a2FTGVtb24=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><h3 id="3-2-处理流">3.2 处理流</h3><p>处理流是对一个已存在的流的连接和封装，通过所封装的流的功能调用实现数据读写。<br>如<code>BufferedInputStream、BufferedOutputStream、BufferedReader、BufferedWriter</code>；处理流的构造方法总是要带一个其他的流对象做参数，一个流对象经过其他流的多次包装，称为流的链接</p><p><img src="https://img-blog.csdnimg.cn/30d1990717be48528078e3dd6707f78e.png?type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6a2FTGVtb24=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><h1>二、节点流讲解</h1><h2 id="1、InputStream-输入流">1、InputStream(输入流)</h2><p><img src="https://img-blog.csdnimg.cn/0eb61b98a0d44dacba2a3e54abf4b2c9.png?type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6a2FTGVtb24=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取一个字节并以整数的形式返回（0~255）</span></span><br><span class="line"><span class="comment">//如果返回-1就说明已经到了输入流的末尾</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="comment">//读取一系列字节并存储到一个数组buffer</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回实际读取的字节数，如果读取前己到输入流的末尾，则返回-1</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] buffer)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="comment">//读取1ength个字节</span></span></span><br><span class="line"><span class="function"><span class="comment">//并存储到一个字节数组buffer，从1ength位置开始</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回实际读取的字节数，如果读取前以到输入流的末尾返回-1.</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[]buffer, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="comment">//关闭流释放内存资源</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="comment">//跳过n个字节不读，返回实际跳过的字节数</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">skip</span><span class="params">(<span class="keyword">long</span> n)</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure><h2 id="2、OutputStream-输出流">2、OutputStream(输出流)</h2><p><img src="https://img-blog.csdnimg.cn/f9ef50b335f94a0da3923c7fe6a62354.png?type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6a2FTGVtb24=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向输出流中写入一个字节数据，该字节数据为参数b的低8位</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> b)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="comment">//将一个字节类型的数组中的数据写入输出流</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] b)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="comment">//将一个字节类型的数组中的从指定位置(off）开始的1en个字节写入到输出流</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="comment">//关闭流释放内存资源</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="comment">//将输出流中缓冲的数据全部写出到目的地</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：FilelnputStream和FileOutputStream这两个流都是字节流，都是以一个字节为单位进行输入和输出的。所以对于占用2个字节存储空间的字符来说读取出来时就会显示成乱码</p></blockquote><h2 id="3、Reader流">3、Reader流</h2><p><img src="https://img-blog.csdnimg.cn/d8b880f989f4402a88330070e2d84a33.png?type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6a2FTGVtb24=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取一个字节并以整数的形式返回（0~255）</span></span><br><span class="line"><span class="comment">//如果返回-1就说明已经到了输入流的末尾</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="comment">//读取一系列字节并存储到一个数组buffer</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回实际读取的字节数，如果读取前己到输入流的末尾，则返回-1</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] buffer)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="comment">//读取1ength个字节</span></span></span><br><span class="line"><span class="function"><span class="comment">//并存储到一个字节数组buffer，从1ength位置开始</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回实际读取的字节数，如果读取前以到输入流的末尾返回-1.</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[]buffer, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="comment">//关闭流释放内存资源</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="comment">//跳过n个字节不读，返回实际跳过的字节数</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">skip</span><span class="params">(<span class="keyword">long</span> n)</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure><h2 id="4、Writer流">4、Writer流</h2><p><img src="https://img-blog.csdnimg.cn/b974369c94084ae9a7b0c5009d0cf52a.png?type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6a2FTGVtb24=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向输出流中写入一个字节数据，该字节数据为参数b的低8位</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> b)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="comment">//将一个字节类型的数组中的数据写入输出流</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] b)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="comment">//将一个字节类型的数组中的从指定位置(off）开始的1en个字节写入到输出流</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="comment">//关闭流释放内存资源</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="comment">//将输出流中缓冲的数据全部写出到目的地</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：FileReader和FileWriter这两个流都是字符流，都是以一个字符为单位进行输入和输出的，所以读取和写入占用2个字节的字符时都可以正常地显示出来</p></blockquote><h1>三、 处理流讲解</h1><h2 id="1、缓冲流-Buffering">1、<strong>缓冲流(Buffering)</strong></h2><p>缓冲流要“套接在相应的节点流之上，对读写的数据提供了缓冲的功能，提高了读写的效率，同时增加了一些新的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader(Reader in)</span><br><span class="line">BufferedReader(Reader in, <span class="keyword">int</span> sz)<span class="comment">//sz为自定义缓冲区的大小Bufferedwriter（writer out）</span></span><br><span class="line">Bufferedwriter(Writer out, <span class="keyword">int</span> sz)</span><br><span class="line">BufferedInputstream(Inputstream in)</span><br><span class="line">BufferedInputstream(Inputstream in, <span class="keyword">int</span> size)</span><br><span class="line">Bufferedoutputstream(Inputstream in)</span><br><span class="line">Bufferedoutputstream(Inputstream in <span class="keyword">int</span> size)</span><br></pre></td></tr></table></figure><ul><li>缓冲输入流支持其父类的mark和reset方法</li><li>BufferedReader提供了readLine方法用于读取一行字符串</li><li>BufferedWriter提供了newLine用于写入一个行分隔符</li><li>对于输出的缓冲流，写出的数据会现在内存中缓存，使用flush方法将会使内存中的数据立刻写出</li></ul><p><img src="https://img-blog.csdnimg.cn/2840760fb0924dad954001b3bd004ab6.png?type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6a2FTGVtb24=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><h2 id="2、转换流">2、转换流</h2><ul><li>InputstreamReader 和OutputStreamwriter 用于字节数据到字符数据之间的转换</li><li>InputstreamReader 需要和Inputstream“套接&quot;。</li><li>OutputstreamWriter 需要和Outputstream“套接&quot;。</li><li>转换流在构造时可以指定其编码集合</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Inputstream isr=<span class="keyword">new</span> InputstreamReader(System.in, <span class="string">"ISO8859-1"</span>)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/ed33ddf4f3114a918c3fd4e21b73bc1c.png?type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6a2FTGVtb24=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><h2 id="3、数据流">3、数据流</h2><ul><li>DatalnputStream 和DataOutputStream 分别继承自InputStream和 OutputStream，它属于处理流，需要分别“套接&quot;在Inputstream和OutputStream类型的节点流上</li><li>Datalnputstream 和DataOutputStream 提供了可以存取与机器无关的Java原始类型数据（int，double等）的方法</li><li>DatalnputStream 和DataOutputStream的构造方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DataInputstream(InputStream in)</span><br><span class="line">DataoutputStream(OutputStream out)</span><br></pre></td></tr></table></figure><p>举例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">    ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">    <span class="comment">//在调用构造方法时，首先会在内存里面创建一个ByteArray字节数组</span></span><br><span class="line">    DataOutputStream dos = <span class="keyword">new</span> DataOutputStream(baos);</span><br><span class="line">    <span class="comment">//在输出流的外面套上一层数据流，用来处理int，double类型的数</span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        dos.writeDouble(Math.random());<span class="comment">//把产生的随机数直接写入到字节数组ByteArray中</span></span><br><span class="line">        dos.writeBoolean(<span class="keyword">true</span>);<span class="comment">//布尔类型的数据在内存中就只占一个字节</span></span><br><span class="line">        ByteArrayInputStream bais = <span class="keyword">new</span> ByteArrayInputStream(baos.toByteArray());</span><br><span class="line">        <span class="comment">// 9,九个字节</span></span><br><span class="line">        System.out.println(bais.available());</span><br><span class="line">        DataInputStream dis = <span class="keyword">new</span> DataInputStream(bais);</span><br><span class="line">        System.out.println(dis.readDouble());<span class="comment">//先写进去的就先读出来，调用readDouble()方法读取出写入的随机数</span></span><br><span class="line">        System.out.println(dis.readBoolean());<span class="comment">//后写进去的就后读出来，这里面的读取顺序不能更改位置，否则会打印出不正确的结果</span></span><br><span class="line">        dos.close();</span><br><span class="line">        bais.close();</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、打印流-Print">4、打印流(Print)</h2><ul><li>PrintWriter 和PrintStream都属于输出流，分别针对与字符和字节</li><li>PrintWriter 和PrintStream 提供了重载的print</li><li>Println方法用于多种数据类型的输出</li><li>PrintWriter和PrintStream的输出操作不会抛出异常，用户通过检测错误状态获取错误信息</li><li>PrintWriter 和PrintStream有自动flush功能</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Printwriter(Writer out)</span><br><span class="line">Printwriter(Writer out,<span class="keyword">boolean</span> autoFlush)</span><br><span class="line">Printwriter(OutputStream out)</span><br><span class="line">Printwriter(OutputStream out,<span class="keyword">boolean</span> autoFlush)</span><br><span class="line">Printstream(OutputStream out)</span><br><span class="line">Printstream(OutputStream out,<span class="keyword">boolean</span> autoFlush)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/46b73be4d6294f85892c5a50b4f26abd.png?type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6a2FTGVtb24=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><h2 id="5、对象流-Object">5、对象流(Object)</h2><blockquote><p>直接将Object写入或读出，直接实现Serializable接口的类是JDK自动把这个类的对象序列化，而如果实现public interface Externalizable extends Serializable的类则可以自己控制对象的序列化，建议能让JDK自己控制序列化的就不要让自己去控制</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Shawn</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/1/29 21:01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        T t = <span class="keyword">new</span> T();</span><br><span class="line">        t.k = <span class="number">8</span>;<span class="comment">// 把k的值修改为8</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(</span><br><span class="line">                    <span class="string">"D:/logs/TestObjectIo.txt"</span>);</span><br><span class="line">            ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(fos);</span><br><span class="line">            <span class="comment">// ObjectOutputStream流专门用来处理Object的，在fos流的外面套接ObjectOutputStream流就可以直接把一个Object写进去</span></span><br><span class="line">            oos.writeObject(t);<span class="comment">// 直接把一个t对象写入到指定的文件里面</span></span><br><span class="line">            oos.flush();</span><br><span class="line">            oos.close();</span><br><span class="line">            FileInputStream fis = <span class="keyword">new</span> FileInputStream(</span><br><span class="line">                    <span class="string">"D:/logs/TestObjectIo.txt"</span>);</span><br><span class="line">            ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(fis);</span><br><span class="line">            <span class="comment">// ObjectInputStream专门用来读一个Object的</span></span><br><span class="line">            T tRead = (T) ois.readObject();</span><br><span class="line">            <span class="comment">// 直接把文件里面的内容全部读取出来然后分解成一个Object对象，并使用强制转换成指定类型T</span></span><br><span class="line">            System.out.print(tRead.i + <span class="string">"\t"</span> + tRead.j + <span class="string">"\t"</span> + tRead.d + <span class="string">"\t"</span></span><br><span class="line">                    + tRead.k);</span><br><span class="line">            ois.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 凡是要将一个类的对象序列化成一个字节流就必须实现Serializable接口</span></span><br><span class="line"><span class="comment"> * Serializable接口中没有定义方法，Serializable接口是一个标记性接口，用来给类作标记，只是起到一个标记作用。</span></span><br><span class="line"><span class="comment"> * 这个标记是给编译器看的，编译器看到这个标记之后就可以知道这个类可以被序列化 如果想把某个类的对象序列化，就必须得实现Serializable接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Serializable的意思是可以被序列化的</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">double</span> d = <span class="number">2.3</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">15</span>;</span><br><span class="line">    <span class="comment">// transient int k = 15;</span></span><br><span class="line">    <span class="comment">// 在声明变量时如果加上transient关键字，那么这个变量就会被当作是透明的，即不存在。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>四、总结</h1><p><img src="https://img-blog.csdnimg.cn/1d8d645ceffd4e429ad1e0c59860fcbb.png?type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6a2FTGVtb24=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><hr><p>参考文章</p><p><a href="https://www.cnblogs.com/xdp-gacl/p/3634409.html" target="_blank" rel="noopener">https://www.cnblogs.com/xdp-gacl/p/3634409.html</a></p>]]></content>
    
    
    <summary type="html">&lt;h1&gt;一、Java IO流基础&lt;/h1&gt;
&lt;h2 id=&quot;1、流式输入-输出原理&quot;&gt;1、流式输入/输出原理&lt;/h2&gt;
&lt;p&gt;在java程序中，对于数据的输入/输出操作以&amp;quot;流&amp;quot;（stream）方式进行；J2SDK提供了各种各样的&amp;quot;流&amp;quot;类，用以获取不同种类的数据：程序中通过标准的方法输入或输出数据&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/c192f69684c0424685408c7c267311bc.png?type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6a2FTGVtb24=,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://www.shawn22.xyz/categories/Java/"/>
    
    
    <category term="Java基础" scheme="https://www.shawn22.xyz/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>几种Bean映射工具介绍</title>
    <link href="https://www.shawn22.xyz/posts/ed9e2fb2.html"/>
    <id>https://www.shawn22.xyz/posts/ed9e2fb2.html</id>
    <published>2022-02-03T13:49:17.000Z</published>
    <updated>2022-02-13T00:35:14.738Z</updated>
    
    <content type="html"><![CDATA[<h1>一、介绍</h1><h2 id="1、功能介绍">1、功能介绍</h2><p>在 Java 系统工程开发过程中，都会有各个层之间的对象转换，比如  VO、DTO、PO、VO 等，而如果都是手动<code>get、set</code>又太浪费时间，还可能操作错误，所以选择一个自动化工具会更加方便</p><a id="more"></a><h2 id="2、不同方法与性能对比">2、不同方法与性能对比</h2><p>目前用于对象属性转换有12种，包括普通的<strong>get/set、json2Json、Apache属性拷贝、Spring属性拷贝、bean-mapping、bean-mapping-asm、BeanCopier、Orika、Dozer、ModelMapper、JMapper、MapStruct</strong></p><p><img src="https://img-blog.csdnimg.cn/8e3de2474301425ca45fc896ec5387d0.png?type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6a2FTGVtb24=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><ul><li>Spring 提供的<code>BeanUtils.copyProperties</code> 是大家代码里最常出现的工具类，注意不是 <code>Apache</code> 包下</li><li>手动<code>get、set</code>性能是最好的，另外 <code>MapStruct</code> 性能和操作也很方便，因为它本身就是在编译期生成<code>get、set</code>代码，和我们写<code>get、set</code>一样</li><li>其他一些组件包主要基于 <code>AOP</code>、<code>ASM</code>、<code>CGlib</code>，的技术手段实现的，所以也会有相应的性能损耗<br><img src="https://img-blog.csdnimg.cn/161aabde273244fbbb886a1c916f51fc.png?type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6a2FTGVtb24=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></li></ul><h1>二、转换案例</h1><h2 id="1、源VO和目标VO">1、源VO和目标VO</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源类</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Accessors</span>(chain = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SourceVO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//目标类</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Accessors</span>(chain = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TargetVO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、get-set">2、get/set</h2><p>这种方式也是日常使用的最多的，性能十分优秀，但是操作起来有点麻烦。多个get/set可以通过 Shift+Alt 选中所有属性，Shift+Tab 归并到一列，接下来在使用 Alt 选中这一列，批量操作粘贴 <code>targetVO.set</code> 以及快捷键大写属性首字母，最后切换到结尾补充括号和分号，最终格式化一下就可以了</p><h2 id="3、Json2Json">3、Json2Json</h2><p>把对象转JSON串，再把JSON转另外一个对象，这种方式性能不是很高</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里用了fastjson</span></span><br><span class="line"><span class="comment"> * 两个对象或集合同名属性赋值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectConversion</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从List&lt;A&gt; copy到List&lt;B&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list List&lt;B&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz B</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> List&lt;B&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">copy</span><span class="params">(List&lt;?&gt; list,Class&lt;T&gt; clazz)</span></span>&#123;</span><br><span class="line">        String oldOb = JSON.toJSONString(list);</span><br><span class="line">        <span class="keyword">return</span> JSON.parseArray(oldOb, clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从对象A copy到 对象B</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ob A</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz B.class</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> B</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">copy</span><span class="params">(Object ob, Class&lt;T&gt; clazz)</span></span>&#123;</span><br><span class="line">        String oldOb = JSON.toJSONString(ob);</span><br><span class="line">        <span class="keyword">return</span> JSON.parseObject(oldOb, clazz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        SourceVO sourceVO = <span class="keyword">new</span> SourceVO(<span class="string">"shawn"</span>,<span class="string">"123456"</span>,<span class="number">18</span>);</span><br><span class="line">        TargetVO targetVO = ObjectConversion.copy(sourceVO, TargetVO<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(targetVO);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、Spring-copyProperties✨">4、Spring copyProperties✨</h2><p>这个方法是<strong>反射的属性拷贝</strong>，Spring 提供的 copyProperties 要比 Apache 好用的多，性能和操作都比较好，这个包是<code>org.springframework.beans.BeanUtils</code></p><p>另外这里考虑到<strong>属性不同的字段的拷贝</strong>，还额外创建了一个回调函数进行映射处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//回调函数定义，这里用了java8特性函数式接口</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanCopyUtilCallBack</span> &lt;<span class="title">S</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义默认回调方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">callBack</span><span class="params">(S t, T s)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 定义拷贝工具类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanCopyUtil</span> <span class="keyword">extends</span> <span class="title">BeanUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 集合数据的拷贝</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sources: 数据源类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target: 目标类::new(eg: UserVO::new)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;S, T&gt; <span class="function">List&lt;T&gt; <span class="title">copyListProperties</span><span class="params">(List&lt;S&gt; sources, Supplier&lt;T&gt; target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> copyListProperties(sources, target, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 带回调函数的集合数据的拷贝（可自定义字段拷贝规则）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sources: 数据源类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target: 目标类::new(eg: UserVO::new)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> callBack: 回调函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;S, T&gt; <span class="function">List&lt;T&gt; <span class="title">copyListProperties</span><span class="params">(List&lt;S&gt; sources, Supplier&lt;T&gt; target, BeanCopyUtilCallBack&lt;S, T&gt; callBack)</span> </span>&#123;</span><br><span class="line">        List&lt;T&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(sources.size());</span><br><span class="line">        <span class="keyword">for</span> (S source : sources) &#123;</span><br><span class="line">            T t = target.get();</span><br><span class="line">            copyProperties(source, t);</span><br><span class="line">            list.add(t);</span><br><span class="line">            <span class="keyword">if</span> (callBack != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 回调</span></span><br><span class="line">                callBack.callBack(source, t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的回调函数可以使用Enum枚举进行规范化，最终进行测试，成功拷贝</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ublic <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 单个拷贝</span></span><br><span class="line">        SourceVO sourceBean = <span class="keyword">new</span> SourceVO(<span class="string">"shawn"</span>, <span class="string">"123456"</span>, <span class="number">18</span>);</span><br><span class="line">        TargetVO targetBean = <span class="keyword">new</span> TargetVO();</span><br><span class="line">        BeanUtils.copyProperties(sourceBean,targetBean);</span><br><span class="line">        System.out.println(targetBean);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 列表拷贝</span></span><br><span class="line">        List&lt;SourceVO&gt; sourceVOList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        sourceVOList.add(<span class="keyword">new</span> SourceVO(<span class="string">"shawn"</span>,<span class="string">"123456"</span>,<span class="number">18</span>));</span><br><span class="line">        sourceVOList.add(<span class="keyword">new</span> SourceVO(<span class="string">"shawn1"</span>,<span class="string">"12345678"</span>,<span class="number">20</span>));</span><br><span class="line">        List&lt;TargetVO&gt; targetVOList= BeanCopyUtil.copyListProperties(sourceVOList, TargetVO::<span class="keyword">new</span>,</span><br><span class="line">                (sourceVO,targetVO)-&gt;&#123;</span><br><span class="line">            targetVO.setAge(sourceVO.getAge());</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(targetVOList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、BeanCopier">5、BeanCopier</h2><p>Cglib BeanCopier 的原理与Beanutils 原理不太一样，其主要使用 字节码技术动态生成一个代理类，<strong>代理类实现get 和 set方法</strong>。生成代理类过程存在一定开销，但是一旦生成，我们可以缓存起来重复使用，所有 Cglib 性能相比Beanutils 性能比较好整体性能不错，使用也不复杂</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//工具类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WrapperBeanCopier</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单个对象属性拷贝</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> source 源对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz 目标对象Class</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; 目标对象类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;M&gt; 源对象类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 目标对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T, M&gt; <span class="function">T <span class="title">copyProperties</span><span class="params">(M source, Class&lt;T&gt; clazz)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(source) || Objects.isNull(clazz))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">return</span> copyProperties(source, clazz, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 列表对象拷贝</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sources 源列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz 源列表对象Class</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; 目标列表对象类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;M&gt; 源列表对象类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 目标列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T, M&gt; <span class="function">List&lt;T&gt; <span class="title">copyObjects</span><span class="params">(List&lt;M&gt; sources, Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(sources) || Objects.isNull(clazz) || sources.isEmpty())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        BeanCopier copier = BeanCopier.create(sources.get(<span class="number">0</span>).getClass(), clazz, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> Optional.of(sources)</span><br><span class="line">                .orElse(<span class="keyword">new</span> ArrayList&lt;&gt;())</span><br><span class="line">                .stream().map(m -&gt; copyProperties(m, clazz, copier))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单个对象属性拷贝</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> source 源对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz 目标对象Class</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> copier copier</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; 目标对象类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;M&gt; 源对象类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 目标对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T, M&gt; <span class="function">T <span class="title">copyProperties</span><span class="params">(M source, Class&lt;T&gt; clazz, BeanCopier copier)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == copier)&#123;</span><br><span class="line">            copier = BeanCopier.create(source.getClass(), clazz, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        T t = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t = clazz.newInstance();</span><br><span class="line">            copier.copy(source, t, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 单个拷贝</span></span><br><span class="line">        SourceVO sourceVO = <span class="keyword">new</span> SourceVO(<span class="string">"shawn"</span>, <span class="string">"123456"</span>, <span class="number">18</span>);</span><br><span class="line">        TargetVO targetVO = WrapperBeanCopier.copyProperties(sourceVO, TargetVO<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(targetVO);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 列表拷贝</span></span><br><span class="line">        List&lt;SourceVO&gt; sourceVOList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        sourceVOList.add(<span class="keyword">new</span> SourceVO(<span class="string">"shawn"</span>,<span class="string">"123456"</span>,<span class="number">18</span>));</span><br><span class="line">        sourceVOList.add(<span class="keyword">new</span> SourceVO(<span class="string">"shawn1"</span>,<span class="string">"12345678"</span>,<span class="number">20</span>));</span><br><span class="line">        List&lt;TargetVO&gt; targetVOS = WrapperBeanCopier.copyObjects(sourceVOList, TargetVO<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(targetVOS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要自定义转换，可以使用<code>new Converter()</code>，一旦我们自己打开使用转换器，所有属性复制都需要我们自己来了，否则会导致无法复制。另外这里需要注意的是拷贝对象要去除<code>@Accessors(chain = true)</code>注解，因为该注解会将 <code>setter</code> 方法的返回值由 <code>void</code> 修改为当前对象。这导致 <code>setter</code> 的方法签名改变，最终导致 <code>BeanCopier</code> 无法识别现有的 <code>setter</code> 方法</p><h2 id="6、MapStruct✨✨">6、MapStruct✨✨</h2><blockquote><p>官网文档地址：<a href="https://github.com/mapstruct/mapstruct" target="_blank" rel="noopener">https://github.com/mapstruct/mapstruct</a></p></blockquote><p>MapStruct是一款基于Java注解的对象属性映射工具，在Github上已经有4.5K+Star。使用的时候我们只要在接口中定义好对象属性映射规则，它就能自动生成映射实现类，不使用反射，性能优秀，能实现各种复杂映射。(强烈推荐)</p><p><strong>首先导入Maven依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mapstruct<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mapstruct<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.2.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mapstruct<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mapstruct-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.2.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>创建Bean对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Accessors</span>(chain = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SourceVO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------------------*/</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Accessors</span>(chain = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TargetVO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String pwd;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String birthday;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编写Mapper文件</strong>，实现同名同类型属性、不同名称属性、不同类型属性的映射</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    UserMapper INSTANCE = Mappers.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mapping</span>(target = <span class="string">"pwd"</span>, source = <span class="string">"password"</span>)</span><br><span class="line">    <span class="meta">@Mapping</span>(source = <span class="string">"birthday"</span>,target = <span class="string">"birthday"</span>, dateFormat = <span class="string">"yyyy-MM-dd"</span>)</span><br><span class="line">    <span class="function">TargetVO <span class="title">getTargetVO</span><span class="params">(SourceVO sourceVO)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后直接通过接口中的<code>INSTANCE</code>实例调用转换方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        SourceVO sourceVO = <span class="keyword">new</span> SourceVO(<span class="string">"shawn"</span>, <span class="string">"123456"</span>, <span class="number">18</span>, <span class="keyword">new</span> Date());</span><br><span class="line">        TargetVO targetVO = UserMapper.INSTANCE.getTargetVO(sourceVO);</span><br><span class="line">        System.out.println(targetVO);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实MapStruct的实现原理很简单，就是根据我们在Mapper接口中使用的<code>@Mapper</code>和<code>@Mapping</code>等注解，在运行时生成接口的实现类，我们可以打开项目的<code>target</code>目录查看</p><p>初次之外，MapStruct使用有：</p><ul><li><strong>基本映射、集合映射、子对象映射、合并映射</strong></li><li><strong>使用依赖注入、使用常量/默认值/表达式、映射前后自定义、处理映射异常等</strong></li></ul><blockquote><p>详情可参考：<br><a href="https://blog.csdn.net/zhenghongcs/article/details/121349361" target="_blank" rel="noopener">https://blog.csdn.net/zhenghongcs/article/details/121349361</a><br><a href="https://mapstruct.org/documentation/stable/reference/html/" target="_blank" rel="noopener">https://mapstruct.org/documentation/stable/reference/html/</a></p></blockquote><hr><p>参考文章</p><p><a href="https://mp.weixin.qq.com/s/_QJa5RSxvPBsqXo8yS5-pg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/_QJa5RSxvPBsqXo8yS5-pg</a></p>]]></content>
    
    
    <summary type="html">&lt;h1&gt;一、介绍&lt;/h1&gt;
&lt;h2 id=&quot;1、功能介绍&quot;&gt;1、功能介绍&lt;/h2&gt;
&lt;p&gt;在 Java 系统工程开发过程中，都会有各个层之间的对象转换，比如  VO、DTO、PO、VO 等，而如果都是手动&lt;code&gt;get、set&lt;/code&gt;又太浪费时间，还可能操作错误，所以选择一个自动化工具会更加方便&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://www.shawn22.xyz/categories/Java/"/>
    
    
    <category term="Spring基础" scheme="https://www.shawn22.xyz/tags/Spring%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java方法参数传递</title>
    <link href="https://www.shawn22.xyz/posts/feb80121.html"/>
    <id>https://www.shawn22.xyz/posts/feb80121.html</id>
    <published>2021-12-28T09:41:37.000Z</published>
    <updated>2021-12-28T09:58:52.039Z</updated>
    
    <content type="html"><![CDATA[<h1>一、引言</h1><h2 id="1、描述">1、描述</h2><p>对于C++来说，调用方法时存在<strong>值传递</strong>(新产生的副本不影响原来的)和<strong>引用传递</strong>(会影响原来的值)，那么对于Java呢？</p><a id="more"></a><h2 id="2、Java传递介绍">2、Java传递介绍</h2><p>通过查阅资料，java中不存在引用传递，始终是<strong>值传递</strong>。Java里面传的任何参数都是传的“值的副本”，如果是对象那么传递的是指针的“值的副本”，所以会有以下几种情况：</p><ul><li>8种基本类型，传的是值的副本，在另外的方法里面修改值，当前函数的值都不会改变；</li><li>对于final修饰的包装类对象，且没有提供方法对自身进行修改的对象，比如String、Integer…对变量进行赋值操作实际上是把传进来的引用的副本改变成了一个新的对象的引用，不会影响到原来的引用里面的对象；</li><li>提供方法对自身进行修改的对象，如StringBuffer…对象自身对自身进行改变，引用没有被改变，所以原方法里面的引用也会跟着改变；</li><li>数组名(相当于把数组的头指针的“值的副本”传递进来)，而arr[i]可以理解为是根据地址计算实际的数据位置偏移来操作数组当中的某个元素，所以原方法当中也会跟着改变，如果是直接给arr赋一个新值就相当于重新创建一个新对象了。</li></ul><h1>二、实战验证</h1><h2 id="1、8种基本类型">1、8种基本类型</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Method</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> c = <span class="string">'a'</span>;</span><br><span class="line">        change(a, c);</span><br><span class="line">        <span class="comment">// 输出仍是 1、a</span></span><br><span class="line">        System.out.println(a);</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">char</span> c1)</span> </span>&#123;</span><br><span class="line">        a1 = <span class="number">2</span>;</span><br><span class="line">        c1 = <span class="string">'c'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、final修饰的包装类对象">2、final修饰的包装类对象</h2><p>对于String、Integer等对象会生成新的对象，因此传递到方法时并不会修改原来的值，因为final修饰符表示对象不可变。</p><p>main方法栈中的引用地址name、c传递给方法，因为String等对象不可修改，所以java会重新创建一个对象，此时新生成的对象指向局部变量，因此对原先变量不产生影响<br><img src="https://img-blog.csdnimg.cn/2b242337fa664980b15aff549e3b5c22.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Method</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer a = <span class="number">1</span>;</span><br><span class="line">        String c = <span class="string">"lemon"</span>;</span><br><span class="line">        String name = <span class="keyword">new</span> String(<span class="string">"shawn"</span>);</span><br><span class="line">        change(a, c,name);</span><br><span class="line">        <span class="comment">// 输出仍是 1、lemon、shawn</span></span><br><span class="line">        System.out.println(a);</span><br><span class="line">        System.out.println(c);</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(Integer a1, String c1,String name1)</span> </span>&#123;</span><br><span class="line">        a1 = <span class="number">222</span>;</span><br><span class="line">        c1 = <span class="string">"lemon22"</span>;</span><br><span class="line">        name1 = <span class="keyword">new</span> String(<span class="string">"shawn22"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、提供方法对自身进行修改的对象">3、提供方法对自身进行修改的对象</h2><p>这里举例StringBuilder对象和自定义类对象，传值传过来的是对象地址，对象本身内容可修改，且提供了方法对自身内容进行修改<br><img src="https://img-blog.csdnimg.cn/4054110a4fcb4f64b127c12b01d7839b.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Method</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        stringBuilder.append(<span class="string">"hello "</span>);</span><br><span class="line"></span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        test.setName(<span class="string">"shawn"</span>);</span><br><span class="line">        test.setPassword(<span class="string">"123456"</span>);</span><br><span class="line"></span><br><span class="line">        change(test,stringBuilder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// hello world!</span></span><br><span class="line">        <span class="comment">// Test(name=lemon, password=123456)</span></span><br><span class="line">        System.out.println(stringBuilder);</span><br><span class="line">        System.out.println(test);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(Test test1,StringBuilder stringBuilder1)</span> </span>&#123;</span><br><span class="line">        test1.setName(<span class="string">"lemon"</span>);</span><br><span class="line">        stringBuilder1.append(<span class="string">"world!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1&gt;一、引言&lt;/h1&gt;
&lt;h2 id=&quot;1、描述&quot;&gt;1、描述&lt;/h2&gt;
&lt;p&gt;对于C++来说，调用方法时存在&lt;strong&gt;值传递&lt;/strong&gt;(新产生的副本不影响原来的)和&lt;strong&gt;引用传递&lt;/strong&gt;(会影响原来的值)，那么对于Java呢？&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://www.shawn22.xyz/categories/Java/"/>
    
    
    <category term="Java基础" scheme="https://www.shawn22.xyz/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java字符编码、码点与代码单元</title>
    <link href="https://www.shawn22.xyz/posts/70eb2978.html"/>
    <id>https://www.shawn22.xyz/posts/70eb2978.html</id>
    <published>2021-12-28T09:41:25.000Z</published>
    <updated>2021-12-28T09:58:52.038Z</updated>
    
    <content type="html"><![CDATA[<h1>一、字符编码</h1><h2 id="1、Unicode">1、Unicode</h2><p><strong>Unicode</strong>（<strong>万国码</strong>、<strong>国际码</strong>、<strong>统一码</strong>、<strong>单一码</strong>）是计算机科学领域里的一项业界标准。它对世界上大部分的文字系统进行了整理、编码，使得电脑可以用更为简单的方式来呈现和处理文字。</p><p>Unicode <strong>为世界上所有字符都分配了一个唯一的数字编号</strong>，这个编号范围从 0x000000 到 0x10FFFF (十六进制)，有 110 多万，每个字符都有一个唯一的 Unicode 编号，这个编号一般写成 16 进制，在前面加上 U+。例如：“马”的 Unicode 是U+9A6C。Unicode 就相当于一张表，建立了字符与编号之间的联系。</p><p>所以Unicode**本身只规定了每个字符的数字编号是多少，并没有规定这个编号如何存储。**因此才有了多种字符编码的存储方案，比较常见就是国际通用字符编码utf-8。</p><a id="more"></a><h2 id="2、utf-8、utf-16和utf-32区别">2、utf-8、utf-16和utf-32区别</h2><p><strong>UTF-32</strong>是一种定长编码，使用1个32bit的码元，其值与Unicode编码值相等</p><p><strong>UTF-16</strong>也是一种变长编码，对于一个Unicode字符被编码成1至2个码元，每个码元为16位。在基本多语言平面内的码位UTF-16编码使用1个码元且其值与Unicode是相等的（不需要转换），但在辅助平面内的码位在UTF-16中被编码为一对16bit的码元（即32bit,4字节）</p><p><strong>UTF-8</strong>是一种变长编码，对于一个Unicode的字符被编码成1至4个字节。Unicode编码与UTF-8的编码的对应关系:</p><table><thead><tr><th>Unicode编码</th><th>UTF-8编码(二进制)</th></tr></thead><tbody><tr><td>U+0000 – U+007F</td><td>0xxxxxxx</td></tr><tr><td>U+0080 – U+07FF</td><td>110xxxxx 10xxxxxx</td></tr><tr><td>U+0800 – U+FFFF</td><td>1110xxxx 10xxxxxx 10xxxxxx</td></tr><tr><td>U+10000 – U+10FFFF</td><td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td></tr></tbody></table><p>一个字节的uft8表示的unicode 码范围为(0 ~0x7F)<br>两个字节长度的uft8 表示的unicode码范围为(0x80 ~ 0x07FF)<br>三个字节长度的uft8 表示的unicode码范围为(0x0800 ~ 0xFFFF)<br>四个字节长度的uft8 表示的unicode码范围为( 0x10000 ~ 0x10FFFF)</p><h1>二、码点和代码单元</h1><h2 id="1、码点和代码单元">1、码点和代码单元</h2><p>Java中char数据类型是一个采用UTF-16编码表示Unicode码点的代码单元，最常用的Unicode字符使用一个代码单元就可以表示，而辅助字符则需要一对代码单元表示。</p><p>通俗理解是有些Unicode字符可以用一个char值表示，表示一个码点，一个代码单元；但另外的Unicode字符则需要两个char值来表示，即辅助字符需要用两个char值，但表示一个码点，两个代码单元。</p><h2 id="2、实战理解">2、实战理解</h2><p>字符串中如果有一些非常规字符的话，使用charAt会导致结果不正确</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String test=<span class="string">"🍷Hello"</span>;</span><br><span class="line">        System.out.println(test);</span><br><span class="line">        System.out.println(test.length());<span class="comment">//得到的是代码单元的数量7, 🍷占两个代码单元</span></span><br><span class="line">        System.out.println(test.codePointCount(<span class="number">0</span>,test.length()));<span class="comment">//得到的是码点的数量6</span></span><br><span class="line"></span><br><span class="line">        System.out.println((<span class="keyword">int</span>)test.charAt(<span class="number">2</span>));<span class="comment">//返回第三个的代码单元：得到H的int型</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index=test.offsetByCodePoints(<span class="number">0</span>,<span class="number">1</span>);<span class="comment">//得到第二个码点位置</span></span><br><span class="line">        <span class="keyword">int</span> cp=test.codePointAt(index);<span class="comment">//得到该位置码点int型表示</span></span><br><span class="line">        System.out.println(cp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、遍历字符串">3、遍历字符串</h2><p>对于无非常规字符的字符串，我们可以使用charAt来遍历（代码单元遍历）；而对于非常规字符的字符串，我们就只能遍历码点来实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 也可以实现反向遍历</span></span><br><span class="line">    <span class="comment">// if(Character.isSurrogate(test.charAt((i)))) i--;</span></span><br><span class="line">       String test = <span class="string">"🍷Hello"</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; test.length(); ) &#123;</span><br><span class="line">            <span class="keyword">int</span> cp = test.codePointAt(i);</span><br><span class="line">            <span class="keyword">if</span> (Character.isSupplementaryCodePoint(cp)) i += <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span> i++;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>) cp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String test=<span class="string">"🍷Hello"</span>;</span><br><span class="line">        <span class="keyword">int</span> [] codePoints=test.codePoints().toArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;codePoints.length;i++)&#123;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>)codePoints[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将码点数组转换成字符串</span></span><br><span class="line">        String str=<span class="keyword">new</span> String(codePoints,<span class="number">0</span>,codePoints.length);</span><br><span class="line">        <span class="comment">//🍷Hello</span></span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>《Java核心技术卷一》</p><p><a href="https://blog.csdn.net/hongsong673150343/article/details/88584753" target="_blank" rel="noopener">https://blog.csdn.net/hongsong673150343/article/details/88584753</a></p>]]></content>
    
    
    <summary type="html">&lt;h1&gt;一、字符编码&lt;/h1&gt;
&lt;h2 id=&quot;1、Unicode&quot;&gt;1、Unicode&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Unicode&lt;/strong&gt;（&lt;strong&gt;万国码&lt;/strong&gt;、&lt;strong&gt;国际码&lt;/strong&gt;、&lt;strong&gt;统一码&lt;/strong&gt;、&lt;strong&gt;单一码&lt;/strong&gt;）是计算机科学领域里的一项业界标准。它对世界上大部分的文字系统进行了整理、编码，使得电脑可以用更为简单的方式来呈现和处理文字。&lt;/p&gt;
&lt;p&gt;Unicode &lt;strong&gt;为世界上所有字符都分配了一个唯一的数字编号&lt;/strong&gt;，这个编号范围从 0x000000 到 0x10FFFF (十六进制)，有 110 多万，每个字符都有一个唯一的 Unicode 编号，这个编号一般写成 16 进制，在前面加上 U+。例如：“马”的 Unicode 是U+9A6C。Unicode 就相当于一张表，建立了字符与编号之间的联系。&lt;/p&gt;
&lt;p&gt;所以Unicode**本身只规定了每个字符的数字编号是多少，并没有规定这个编号如何存储。**因此才有了多种字符编码的存储方案，比较常见就是国际通用字符编码utf-8。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://www.shawn22.xyz/categories/Java/"/>
    
    
    <category term="Java基础" scheme="https://www.shawn22.xyz/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java ProcessBuilder类</title>
    <link href="https://www.shawn22.xyz/posts/ddd598d5.html"/>
    <id>https://www.shawn22.xyz/posts/ddd598d5.html</id>
    <published>2021-12-28T09:41:15.000Z</published>
    <updated>2021-12-28T09:58:52.036Z</updated>
    
    <content type="html"><![CDATA[<h1>一、ProcessBuilder基础</h1><h2 id="1、ProcessBuilder类">1、ProcessBuilder类</h2><h3 id="1-1-概述">1.1 概述</h3><p><code>ProcessBuilder</code>类是J2SE 1.5在java.lang中新添加的一个新类，此类用于创建操作系统进程，它提供一种启动和管理进程（也就是应用程序）的方法。在J2SE 1.5之前，都是由<code>Process</code>类处理实现进程的控制管理。</p><p>每个<code> ProcessBuilder</code> 实例管理一个进程属性集，它的<code>start()</code>方法利用这些属性创建一个新的 Process 实例。<code>start()</code>方法可以从同一实例重复调用，以利用相同的或相关的属性创建新的子进程。</p><a id="more"></a><h3 id="1-2-进程属性">1.2 进程属性</h3><ul><li><strong>命令 command</strong><br>表示要调用的外部程序文件及其参数（如果有）。</li><li><strong>环境 environment</strong><br>从变量到值依赖于系统的映射。初始值是当前进程环境的一个副本（请参阅System.getenv()）。</li><li><strong>工作目录 working directory</strong><br>默认值是当前进程的当前工作目录，通常根据系统属性 user.dir 来命名。</li><li><strong>redirectErrorStream属性</strong><br>此属性为 false意思是子进程的标准输出和错误输出被发送给两个独立的流，这些流可以通过 <code>Process.getInputStream()</code> 和 <code>Process.getErrorStream()</code>方法来访问。如果将值设置为 true，标准错误将与标准输出合并，在此情况下，合并的数据可从 Process.getInputStream() 返回的流读取，而从 Process.getErrorStream() 返回的流读取将直接到达文件尾。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ProcessBuilder pb = <span class="keyword">new</span> ProcessBuilder(<span class="string">"myCommand"</span>, <span class="string">"myArg1"</span>, <span class="string">"myArg2"</span>);</span><br><span class="line">Map&lt;String, String&gt; env = pb.environment();</span><br><span class="line">env.put(<span class="string">"VAR1"</span>, <span class="string">"myValue"</span>);</span><br><span class="line">env.remove(<span class="string">"OTHERVAR"</span>);</span><br><span class="line">env.put(<span class="string">"VAR2"</span>, env.get(<span class="string">"VAR1"</span>) + <span class="string">"suffix"</span>);</span><br><span class="line">pb.directory(<span class="string">"myDir"</span>);</span><br><span class="line">Process p = pb.start();</span><br></pre></td></tr></table></figure><h2 id="2、Process类">2、Process类</h2><h3 id="2-1-概述">2.1 概述</h3><p>Process类是一个抽象类（所有的方法均是抽象的），封装了一个进程（即一个执行程序）。</p><p>Process 类提供了执行从进程输入、执行输出到进程、等待进程完成、检查进程的退出状态以及销毁（杀掉）进程的方法。创建的子进程没有自己的终端或控制台。它的所有标准 io（即 stdin、stdout 和 stderr）操作都将通过三个流 (<code>getOutputStream()、getInputStream() 和 getErrorStream()</code>) 重定向到父进程。父进程使用这些流来提供到子进程的输入和获得从子进程的输出。</p><h3 id="2-2-Process抽象类">2.2 Process抽象类</h3><ul><li><strong>destroy()</strong><br>杀掉子进程。</li><li><strong>exitValue()</strong><br>返回子进程的出口值。</li><li><strong>InputStream getErrorStream()</strong><br>获得子进程的错误流。</li><li><strong>InputStream getInputStream()</strong><br>获得子进程的输入流。</li><li><strong>OutputStream getOutputStream()</strong><br>获得子进程的输出流。</li><li><strong>waitFor()</strong><br>导致当前线程等待，如果必要，一直要等到由该 Process 对象表示的进程已经终止</li></ul><p>同时Process对象可以获得进程句柄，从而可以获得进程ID、父进程、子进程等信息</p><h3 id="2-3-创建Process对象方式">2.3 创建Process对象方式</h3><ul><li>使用命令名和命令的参数选项构造ProcessBuilder对象，它的start方法执行命令，启动一个进程，返回一个Process对象</li><li><code>Runtime.exec()</code>方法创建一个本机进程，并返回 Process 子类的一个实例</li></ul><h2 id="3、-ProcessBuilder与Runtime-exec-异同">3、**ProcessBuilder与Runtime.exec()**异同</h2><h3 id="3-1-相同点">3.1 相同点</h3><p><code>ProcessBuilder.start()</code> 和 <code>Runtime.exec()</code> 方法都被用来创建一个操作系统进程（执行命令行操作），并返回 Process 子类的一个实例，该实例可用来控制进程状态并获得相关信息</p><h3 id="3-2-不同点">3.2 不同点</h3><p><code>ProcessBuilder.start()</code> 和 <code>Runtime.exec()</code>传递的参数有所不同</p><p>Runtime.exec()可接受一个单独的字符串，这个字符串是通过空格来分隔可执行命令程序和参数的；也可以接受字符串数组参数。而ProcessBuilder的构造函数是一个字符串列表或者数组。列表中第一个参数是可执行命令程序，其他的是命令行执行是需要的参数。</p><h1>二、<strong>ProcessBuilder</strong>实战</h1><h2 id="1、API介绍">1、API介绍</h2><p><strong>构造方法</strong></p><ul><li><strong>ProcessBuilder(List<String> command)</String></strong><br>利用指定的操作系统程序和参数构造一个进程生成器。</li><li><strong>ProcessBuilder(String… command)</strong><br>利用指定的操作系统程序和参数构造一个进程生成器。</li></ul><p><strong>方法</strong></p><ul><li><strong>command()</strong><br>返回此进程生成器的操作系统程序和参数。</li><li><strong>command(List<String> command)</String></strong><br>设置此进程生成器的操作系统程序和参数。</li><li><strong>command(String… command)</strong><br>设置此进程生成器的操作系统程序和参数。</li><li><strong>directory()</strong><br>返回此进程生成器的工作目录。</li><li><strong>directory(File directory)</strong><br>设置此进程生成器的工作目录。</li><li><strong>environment()</strong><br>返回此进程生成器环境的字符串映射视图。 environment方法获得运行进程的环境变量,得到一个Map,可以修改环境变量</li><li><strong>redirectErrorStream()</strong><br>通知进程生成器是否合并标准错误和标准输出。</li><li><strong>redirectErrorStream(boolean redirectErrorStream)</strong><br>设置此进程生成器的 redirectErrorStream 属性。</li><li><strong>start()</strong><br>使用此进程生成器的属性启动一个新进程。</li></ul><h2 id="2、实战demo">2、实战demo</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Runtime.exec()进行创建</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Process process = Runtime.getRuntime().exec(<span class="string">"ipconfig /all"</span>);</span><br><span class="line">            InputStream is = process.getInputStream();</span><br><span class="line">            InputStreamReader isr =<span class="keyword">new</span> InputStreamReader(is, <span class="string">"gbk"</span>);</span><br><span class="line"></span><br><span class="line">            BufferedReader br = <span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line"></span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(line);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> exitCode = process.waitFor();</span><br><span class="line">            System.out.println(exitCode);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       ProcessBuilder processBuilder = <span class="keyword">new</span> ProcessBuilder();</span><br><span class="line">       <span class="comment">// System.out.println(processBuilder.directory());</span></span><br><span class="line">       <span class="comment">// System.out.println(processBuilder.environment());</span></span><br><span class="line">       <span class="comment">//processBuilder.command("ping","127.0.0.1");</span></span><br><span class="line">       processBuilder.command(<span class="string">"ipconfig"</span>,<span class="string">"/all"</span>);</span><br><span class="line">       <span class="comment">//将标准输入流和错误输入流合并，通过标准输入流读取信息</span></span><br><span class="line">       processBuilder.redirectErrorStream(<span class="keyword">true</span>);</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//启动进程</span></span><br><span class="line">           Process start = processBuilder.start();</span><br><span class="line">           <span class="comment">//获取输入流</span></span><br><span class="line">           InputStream inputStream = start.getInputStream();</span><br><span class="line">           <span class="comment">//转成字符输入流</span></span><br><span class="line">           InputStreamReader inputStreamReader = <span class="keyword">new</span> InputStreamReader(inputStream, <span class="string">"gbk"</span>);</span><br><span class="line">           <span class="keyword">int</span> len = -<span class="number">1</span>;</span><br><span class="line">           <span class="keyword">char</span>[] c = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">           StringBuffer outputString = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">           <span class="comment">//读取进程输入流中的内容</span></span><br><span class="line">           <span class="keyword">while</span> ((len = inputStreamReader.read(c)) != -<span class="number">1</span>) &#123;</span><br><span class="line">               String s = <span class="keyword">new</span> String(c, <span class="number">0</span>, len);</span><br><span class="line">               outputString.append(s);</span><br><span class="line">               System.out.print(s);</span><br><span class="line">           &#125;</span><br><span class="line">           inputStream.close();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ProcessBuilder processBuilder = <span class="keyword">new</span> ProcessBuilder(<span class="string">"cmd"</span>,<span class="string">"/c"</span>,<span class="string">"dir"</span>);</span><br><span class="line">        processBuilder.directory(<span class="keyword">new</span> File(<span class="string">"D:/"</span>));</span><br><span class="line">        Process process = processBuilder.start();</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(process.getInputStream(), <span class="string">"GBK"</span>));</span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1&gt;一、ProcessBuilder基础&lt;/h1&gt;
&lt;h2 id=&quot;1、ProcessBuilder类&quot;&gt;1、ProcessBuilder类&lt;/h2&gt;
&lt;h3 id=&quot;1-1-概述&quot;&gt;1.1 概述&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ProcessBuilder&lt;/code&gt;类是J2SE 1.5在java.lang中新添加的一个新类，此类用于创建操作系统进程，它提供一种启动和管理进程（也就是应用程序）的方法。在J2SE 1.5之前，都是由&lt;code&gt;Process&lt;/code&gt;类处理实现进程的控制管理。&lt;/p&gt;
&lt;p&gt;每个&lt;code&gt; ProcessBuilder&lt;/code&gt; 实例管理一个进程属性集，它的&lt;code&gt;start()&lt;/code&gt;方法利用这些属性创建一个新的 Process 实例。&lt;code&gt;start()&lt;/code&gt;方法可以从同一实例重复调用，以利用相同的或相关的属性创建新的子进程。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://www.shawn22.xyz/categories/Java/"/>
    
    
    <category term="Java基础" scheme="https://www.shawn22.xyz/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java泛型</title>
    <link href="https://www.shawn22.xyz/posts/a14eb637.html"/>
    <id>https://www.shawn22.xyz/posts/a14eb637.html</id>
    <published>2021-12-28T09:41:06.000Z</published>
    <updated>2021-12-28T09:58:52.043Z</updated>
    
    <content type="html"><![CDATA[<h1>一、泛型介绍</h1><h2 id="1、简介">1、简介</h2><blockquote><p>Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许开发者在编译时检测到非法的类型</p></blockquote><p>参数化类型:</p><ul><li>把类型当作是参数一样传递</li><li><code>**&lt;数据类型&gt;**</code> 只能是引用类型</li></ul><p>相关术语：</p><ul><li><code>ArrayList&lt;E&gt;</code>中的<strong>E</strong>称为类型参数变量</li><li><code>ArrayList&lt;Integer&gt;</code>中的<strong>Integer</strong>称为实际类型参数</li><li>整个称为<code>ArrayList&lt;E&gt;</code>泛型类型</li><li>整个<code>ArrayList&lt;Integer&gt;</code>称为参数化的类型ParameterizedType</li></ul><a id="more"></a><h2 id="2、泛型优点">2、泛型优点</h2><ul><li><strong>类型安全</strong>。 泛型的主要目标是提高 Java 程序的类型安全。通过知道使用泛型定义的变量的类型限制，编译器可以在一个高得多的程度上验证类型假设。没有泛型，这些假设就只存在于程序员的头脑中（或者如果幸运的话，还存在于代码注释中）。</li><li><strong>消除强制类型转换</strong>。 泛型的一个附带好处是，消除源代码中的许多强制类型转换。这使得代码更加可读，并且减少了出错机会。</li><li><strong>潜在的性能收益</strong>。 泛型为较大的优化带来可能。在泛型的初始实现中，编译器将强制类型转换（没有泛型的话，程序员会指定这些强制类型转换）插入生成的字节码中。但是更多类型信息可用于编译器这一事实，为未来版本的 JVM 的优化带来可能。由于泛型的实现方式，支持泛型（几乎）不需要 JVM 或类文件更改。所有工作都在编译器中完成，编译器生成类似于没有泛型（和强制类型转换）时所写的代码，只是更能确保类型安全而已。</li></ul><h2 id="3、泛型的定义和使用">3、泛型的定义和使用</h2><ul><li>泛型类</li><li>泛型方法</li><li>泛型接口</li></ul><h1>二、泛型基础</h1><h2 id="1、泛型类与泛型方法">1、泛型类与泛型方法</h2><h3 id="1、泛型类">1、泛型类</h3><p>**泛型类就是把泛型定义在类上，用户使用该类的时候，才把类型明确下来。**这样的话，用户明确了什么类型，该类就代表着什么类型；用户在使用的时候就不用担心强转的问题，运行时转换异常的问题了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建对象并指定元素类型</span></span><br><span class="line">        User&lt;String&gt; tool = <span class="keyword">new</span> User&lt;&gt;();</span><br><span class="line">        tool.setObj(<span class="string">"shawn"</span>);</span><br><span class="line">        String s = tool.getObj();</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        <span class="comment">//创建对象并指定元素类型</span></span><br><span class="line">        User&lt;Integer&gt; objectTool = <span class="keyword">new</span> User&lt;&gt;();</span><br><span class="line">        <span class="comment">//如果我在这个对象里传入的是String类型的,它在编译时期就通过不了了.</span></span><br><span class="line">        objectTool.setObj(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">int</span> i = objectTool.getObj();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1:把泛型定义在类上</span></span><br><span class="line"><span class="comment">    2:类型变量定义在类上,方法中也可以使用</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> T obj;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">getObj</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObj</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.obj = obj;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、泛型方法">2、泛型方法</h3><p>泛型方法与泛型类稍有不同的地方是，类型参数也就是尖括号那一部分是写在返回值前面的。第一个 T 被称为类型参数，而方法中的 T 被称为参数化类型，它不是运行时真正的参数。最后声明的类型参数，其实也是可以当作返回值的类型的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">      <span class="comment">//定义泛型方法</span></span><br><span class="line">      <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">      <span class="comment">// TODO</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="3、泛型类和泛型方法并存">3、泛型类和泛型方法并存</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Test1&lt;String&gt; t = <span class="keyword">new</span> Test1();</span><br><span class="line">        t.testMethod(<span class="string">"shawn"</span>);</span><br><span class="line">        <span class="comment">//注意使用泛型方法并不需要我们显式地用&lt;&gt;声明类型</span></span><br><span class="line">        Integer i = t.testMethod1(<span class="keyword">new</span> Integer(<span class="number">1</span>));</span><br><span class="line">        <span class="comment">// 1</span></span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 泛型类和泛型方法并存，两者的类型参数最好不要同名</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">            <span class="comment">// java.lang.String</span></span><br><span class="line">            System.out.println(t.getClass().getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span>  &lt;E&gt; <span class="function">E <span class="title">testMethod1</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、泛型继承关系">2、泛型继承关系</h2><p>泛型类是拥有泛型这个特性的类，它本质上还是一个Java类，那么它就可以被继承。泛型继承分两种情况</p><ul><li>子类明确泛型类的类型参数变量</li><li>子类不明确泛型类的类型参数变量</li></ul><p>要注意的是实现类的要是重写父类的方法，返回值的类型是要和父类一样的；其次类上声明的泛形只对非静态成员有效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试第一种情况</span></span><br><span class="line">        Inter&lt;String&gt; i = <span class="keyword">new</span> InterImpl();</span><br><span class="line">        i.show(<span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二种情况测试</span></span><br><span class="line">        Inter&lt;String&gt; ii = <span class="keyword">new</span> InterImpl1&lt;&gt;();</span><br><span class="line">        ii.show(<span class="string">"100"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        把泛型定义在接口上</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Inter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(T t)</span></span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 子类明确泛型类的类型参数变量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InterImpl</span> <span class="keyword">implements</span> <span class="title">Inter</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当子类不明确泛型类的类型参数变量时，外界使用子类的时候</span></span><br><span class="line"><span class="comment">     * 也需要传递类型参数变量进来，</span></span><br><span class="line"><span class="comment">     * 在实现类上需要定义出类型参数变量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InterImpl1</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Inter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">            System.out.println(t);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、泛型通配符">3、泛型通配符</h2><h3 id="1、介绍">1、介绍</h3><p>**常用的 T，E，K，V，？**本质上都是通配符，没啥区别，只不过是编码时的一种约定俗成的东西。比如代码中的 T ，我们可以换成 A-Z 之间的任何一个 字母都可以，并不会影响程序的正常运行，但是如果换成其他的字母代替 T ，在可读性上可能会弱一些。<strong>通常情况下，T，E，K，V，？是这样约定的：</strong></p><ul><li>？表示不确定的 java 类型</li><li>T (type) 表示具体的一个java类型</li><li>K V (key value) 分别代表java键值中的Key Value</li><li>E (element) 代表Element</li></ul><h3 id="2、？无界通配符">2、？无界通配符</h3><p>对于不确定或者不关心实际要操作的类型，可以使用无限制通配符（尖括号里一个问号，即 &lt;?&gt; ），表示可以持有任何类型。无限定通配符经常与容器类配合使用，它其中的 ? 其实代表的是未知类型，所以涉及到 ? 时的操作，一定与具体类型无关。</p><h3 id="3、上界通配符-extends-E">3、<strong>上界通配符 &lt; ? extends E&gt;</strong></h3><blockquote><p>上届：用 extends 关键字声明，表示参数化的类型可能是所指定的类型，或者是此类型的子类。</p></blockquote><p>在类型参数中使用 extends 表示这个泛型中的参数必须是 E 或者 E 的子类，这样有两个好处：</p><ul><li>如果传入的类型不是 E 或者 E 的子类，编译不成功</li><li>泛型中可以使用 E 的方法，要不然还得强转成 E 才能使用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> &lt;<span class="title">T</span>,<span class="title">E</span> <span class="keyword">extends</span> <span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">        T value1;</span><br><span class="line">        E value2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> &lt;D,S extends D&gt; <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(D d,S s)</span></span>&#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、下界通配符-super-E">4、<strong>下界通配符 &lt; ? super E&gt;</strong></h3><blockquote><p>下界: 用 super 进行声明，表示参数化的类型可能是所指定的类型，或者是此类型的父类型，直至 Object</p></blockquote><p><strong>在泛型的上限和下限中有一个原则：PECS(Producer Extends Consumer Super)</strong></p><ul><li>带有子类限定的可以从泛型读取【也就是—&gt;(? extend T)】--------&gt;Producer Extends</li><li>带有超类限定的可以从泛型写入【也就是—&gt;(? super T)】--------&gt;Consumer Super</li></ul><h3 id="5、通配符-和泛型方法T区别">5、通配符?和泛型方法T区别</h3><p>使用原则：</p><ul><li>如果<strong>参数之间的类型有依赖关系</strong>，或者返<strong>回值是与参数之间有依赖关系</strong>的。那么就使用<strong>泛型方法</strong></li><li>如果<strong>没有依赖关系</strong>的，就使用<strong>通配符</strong>，通配符会<strong>灵活一些.</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//大多时候，我们都可以使用泛型方法来代替通配符</span></span><br><span class="line"><span class="comment">//使用通配符</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(List&lt;?&gt; list)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用泛型方法</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span>  <span class="title">test2</span><span class="params">(List&lt;T&gt; t)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>两者区别：</strong></p><ul><li>通过 T 来 确保 泛型参数的一致性</li><li>类型参数可以多重限定而通配符不行</li><li>通配符可以使用超类限定而类型参数不行</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类型参数 T 只具有 一种 类型限定方式：</span></span><br><span class="line"><span class="comment">//但是通配符 ? 可以进行 两种限定： </span></span><br><span class="line">T extends A</span><br><span class="line">? extends A</span><br><span class="line">? <span class="keyword">super</span> A</span><br></pre></td></tr></table></figure><h1>三、泛型与虚拟机</h1><h2 id="1、类型擦除">1、类型擦除</h2><p>泛型是 <strong>Java 1.5 <strong>版本才引进的概念，但是泛型代码能够很好地和之前版本的代码很好地兼容。这是因为泛型是</strong>提供给javac编译器使用的</strong>，它用于限定集合的输入类型，让编译器在源代码级别上，即挡住向集合中插入非法数据。但编译器编译完带有泛形的java程序后，<strong>生成的class文件中将不再带有泛形信息</strong>，以此使程序运行效率不受到影响，这个过程称之为“擦除”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 结果为True,因为结果都为List</span></span><br><span class="line">        System.out.println(list.getClass()==list1.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型擦除过程中，原始类型用第一个限定来替换类型变量，如果没有给定限定，就替换为<code>Object</code>。例如<code>User&lt;T&gt;</code>中的类型变量没有显示的限定，就会用<code>Object</code>进行替换；如果声明了<code>User&lt;T extends Comparable&gt;</code>，就会用<code>Comparable</code>替换。</p><h2 id="2、泛型转换重要结论">2、泛型转换重要结论</h2><ul><li>虚拟机中没有泛型，只有普通的类和方法</li><li>所有的类型参数都会替换为它们的限定类型</li><li>会合成桥方法来保持多态</li><li>为保持类型安全性，必要时会插人强制类型转换</li></ul><h2 id="3、泛型局限性">3、泛型局限性</h2><ol><li>不能使用基本类型实例化类型参数</li><li>不能实例化类型参数</li><li>不可以实例化类型变量的数组</li><li>不可以定义泛型类的数组</li><li>不可以对泛型类型进行类型检测/转化</li><li>不可以抛出或捕获泛型异常</li><li>泛型类的静态类型变量/方法无效</li><li>类型擦除引发的冲突</li></ol><hr><p>参考文章</p><p>《Java核心技术卷1》</p><p><a href="https://segmentfault.com/a/1190000014120746" target="_blank" rel="noopener">https://segmentfault.com/a/1190000014120746</a></p><p><a href="https://www.cnblogs.com/jiading/articles/12560549.html" target="_blank" rel="noopener">https://www.cnblogs.com/jiading/articles/12560549.html</a></p><p><a href="https://mp.weixin.qq.com/s/ZxOULsyFt1Iy8HqPW8VOSw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/ZxOULsyFt1Iy8HqPW8VOSw</a></p>]]></content>
    
    
    <summary type="html">&lt;h1&gt;一、泛型介绍&lt;/h1&gt;
&lt;h2 id=&quot;1、简介&quot;&gt;1、简介&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许开发者在编译时检测到非法的类型&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;参数化类型:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;把类型当作是参数一样传递&lt;/li&gt;
&lt;li&gt;&lt;code&gt;**&amp;lt;数据类型&amp;gt;**&lt;/code&gt; 只能是引用类型&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;相关术语：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ArrayList&amp;lt;E&amp;gt;&lt;/code&gt;中的&lt;strong&gt;E&lt;/strong&gt;称为类型参数变量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ArrayList&amp;lt;Integer&amp;gt;&lt;/code&gt;中的&lt;strong&gt;Integer&lt;/strong&gt;称为实际类型参数&lt;/li&gt;
&lt;li&gt;整个称为&lt;code&gt;ArrayList&amp;lt;E&amp;gt;&lt;/code&gt;泛型类型&lt;/li&gt;
&lt;li&gt;整个&lt;code&gt;ArrayList&amp;lt;Integer&amp;gt;&lt;/code&gt;称为参数化的类型ParameterizedType&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Java" scheme="https://www.shawn22.xyz/categories/Java/"/>
    
    
    <category term="Java基础" scheme="https://www.shawn22.xyz/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>JUC并发编程</title>
    <link href="https://www.shawn22.xyz/posts/eb9166f8.html"/>
    <id>https://www.shawn22.xyz/posts/eb9166f8.html</id>
    <published>2021-12-28T09:40:54.000Z</published>
    <updated>2021-12-28T09:58:52.048Z</updated>
    
    <content type="html"><![CDATA[<h1>一、简介</h1><h2 id="1、JUC介绍">1、JUC介绍</h2><p><code>java.util.concurrent</code> 包是在并发编程中使用的工具类，简称JUC，有以下三个包</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.util.concurrent</span><br><span class="line">java.util.concurrent.atomic</span><br><span class="line">java.util.concurrent.locks</span><br></pre></td></tr></table></figure><blockquote><p>JDK8官方在线文档：<a href="https://www.matools.com/api/java8" target="_blank" rel="noopener">https://www.matools.com/api/java8</a></p></blockquote><a id="more"></a><h2 id="2、进程与线程">2、进程与线程</h2><h3 id="2-1-异同介绍">2.1 异同介绍</h3><p><strong>进程</strong>：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动，它是操作系统动态执行的基本单元。在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。</p><p><strong>线程</strong>：通常在一个进程中可以包含若干个线程，一个进程中至少有一个线程，线程可以利用进程所有拥有的资源。在引入线程的操作系统中，通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位，由于线程比进程小，基本上不拥有系统资源，故对它的调度所付出的开销就会小得多，能更高效的提高系统多个程序间并发执行的程度。</p><h3 id="2-2-线程状态">2.2 线程状态</h3><p>线程有6种状态，可以进入<code>Thread.State</code>查看源码分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State &#123; </span><br><span class="line">      <span class="comment">//线程刚创建       </span></span><br><span class="line">      NEW,</span><br><span class="line">      <span class="comment">//在JVM中运行的线程</span></span><br><span class="line">      RUNNABLE,</span><br><span class="line">      <span class="comment">//线程处于阻塞状态，等待监视锁，可以重新进行同步代码块中执行</span></span><br><span class="line">      BLOCKED,</span><br><span class="line">      <span class="comment">//等待状态</span></span><br><span class="line">      WAITING,</span><br><span class="line">      <span class="comment">//调用sleep() join() wait()方法可能导致线程处于等待状态</span></span><br><span class="line">      TIMED_WAITING,</span><br><span class="line">      <span class="comment">//线程执行完毕，已经退出</span></span><br><span class="line">      TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/fb475ee1526946c282bf96a9b1497b43.png" alt></p><h3 id="2-3-线程wait-sleep区别">2.3 线程wait/sleep区别</h3><ul><li><strong>两个方法来自不同的类</strong><br>sleep来自Thread类，wait来自Object类</li><li><strong>释放资源不同(有没有释放锁)</strong><br>sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。sleep(100L)占用cpu，线程休眠100毫秒后继续执行；而wait是无限期的除非用户主动notify()</li><li><strong>使用范围不同</strong><br>wait()、notify()和notifyAll()只能在同步控制方法或者同步控制块里面使用，而sleep()可以在任何地方使用</li><li><strong>是否需要捕获异常</strong><br>sleep()必须捕获异常，而wait()、notify()和notifyAll()不需要捕获异常。</li></ul><h2 id="3、并行与并发">3、并行与并发</h2><p><strong>并发(concurrency)</strong>：在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。</p><p><strong>并行(parallel)</strong>：在同一时刻，有多条指令在多个处理器上同时执行。所以无论从微观还是从宏观来看，二者都是一起执行的。</p><h1>二、Lock接口与synchronized</h1><h2 id="1、synchronized关键字">1、synchronized关键字</h2><p>synchronized 是 Java 中的关键字，是一种<strong>同步锁</strong>（对方法或者代码块中存在共享数据的操作）。同步锁可以是任意对象</p><p><strong>具体修饰的对象有3种方式</strong>：</p><ul><li><strong>修饰代码块</strong><br>被修饰的代码块称为同步语句块，作用的范围是大括号{ }内的内容</li><li><strong>修饰方法</strong><br>作用范围为整个方法，作用对象是调用该代码块的对象（虽然可以修饰方法，但 synchronized 并不属于方法定义的一部分，因此synchronized 关键字不能被继承）</li><li><strong>修饰静态方法</strong><br>作用的范围是整个静态方法，作用的对象是这个类的所有对象（修饰一个类也同理）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">synchronizedTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="comment">//共享资源(临界资源)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * synchronized 修饰实例方法</span></span><br><span class="line"><span class="comment">     * 对静态方法加锁，锁是当前类的class对象锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">10</span>;j++)&#123;</span><br><span class="line">            add();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        synchronizedTest b1=<span class="keyword">new</span> synchronizedTest();</span><br><span class="line">        synchronizedTest b2=<span class="keyword">new</span> synchronizedTest();</span><br><span class="line">        Thread m1=<span class="keyword">new</span> Thread(b1);</span><br><span class="line">        Thread m2=<span class="keyword">new</span> Thread(b2);</span><br><span class="line">        m1.start();</span><br><span class="line">        m2.start();</span><br><span class="line">        m1.join();</span><br><span class="line">        m2.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、Lock接口">2、Lock接口</h2><h3 id="2-1-介绍">2.1 介绍</h3><blockquote><p><code>Lock</code>实现提供比使用<code>synchronized</code>方法和语句可以获得的更广泛的锁定操作。 它们允许更灵活的结构化，可能具有完全不同的属性，并且可以支持多个相关<a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/concurrent/locks/Condition.html" target="_blank" rel="noopener">联的</a>对象<a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/concurrent/locks/Condition.html" target="_blank" rel="noopener"><code>Condition</code></a> 。</p></blockquote><h3 id="2-2-lock常用方法">2.2 lock常用方法</h3><p><code>lock()</code><strong>方法用来获取锁</strong></p><ul><li>如果锁已被其他线程获取，则进行等待</li><li>发生异常不会自动解锁，需用在 try{}catch{}块中进行</li></ul><p><code>Condition 类</code><strong>也可以实现等待/通知模式</strong></p><blockquote><p>关键字 synchronized 与 wait()/notify()这两个方法一起使用可以实现等待/通知模式；Lock 锁的 newContition()方法返回 Condition 对象，Condition 类也可以实现等待/通知模式</p></blockquote><ul><li>await()会使当前线程等待,同时会释放锁,当其他线程调用 signal()时,线程会重新获得锁并继续执行</li><li>signal()用于唤醒一个等待的线程</li><li>signalAll()用于唤醒所有等待的线程(推荐)</li></ul><p><code>unlock()</code><strong>方法用于解锁</strong>(此方法必须在finally中，否则会造成死锁)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">  <span class="comment">//上锁</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">  <span class="comment">//尝试获取锁</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">  <span class="comment">//解锁</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">//可实现等待/通知模式</span></span><br><span class="line">  <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-Lock实战">2.3 Lock实战</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">//票数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">30</span>;</span><br><span class="line">    <span class="comment">//创建可重入锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//卖票方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//lock不能使用try-with-resource方法</span></span><br><span class="line">        <span class="comment">//上锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//判断是否有票</span></span><br><span class="line">            <span class="keyword">if</span>(number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">" ：卖出"</span>+(number--)+<span class="string">" 剩余："</span>+number);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//解锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LockTest ticket = <span class="keyword">new</span> LockTest();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">                    ticket.sale();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,<span class="string">"shawn1"</span>).start();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">                    ticket.sale();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,<span class="string">"shawn2"</span>).start();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">                    ticket.sale();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,<span class="string">"shawn3"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、线程间的通信">3、线程间的通信</h2><p>对于synchronized 来说，自定义同步通信</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object lock1 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object lock2 = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock1.wait();</span><br><span class="line">                <span class="comment">//TODO</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock2.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于Lock来说，可自定义同步通信</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建Lock锁</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建三个condition</span></span><br><span class="line">    <span class="keyword">private</span> Condition c1 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition c2 = lock.newCondition();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//打印5次，参数第几轮</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print5</span><span class="params">(<span class="keyword">int</span> loop)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//上锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            c1.await();</span><br><span class="line">            <span class="comment">//TODO</span></span><br><span class="line">            c2.signal(); <span class="comment">//通知第二个线程</span></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、synchronized与lock的异同">4、<strong>synchronized与lock的异同</strong></h2><ul><li>synchronized是java关键字，内置；而lock不是内置，是一个类，可以实现同步访问且比synchronized中的方法更加丰富</li><li>synchronized不会手动释放锁，而lock需手动释放锁（不解锁会出现死锁，需要在 finally 块中释放锁）</li><li>lock等待锁的线程会相应中断，而synchronized不会相应，只会一直等待</li><li>通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到</li><li>Lock 可以提高多个线程进行读操作的效率（当多个线程竞争的时候）</li></ul><h1>三、多线程锁与并发</h1><h2 id="1、多线程锁结论">1、多线程锁结论</h2><ul><li><strong>对于普通同步方法，锁的是当前实例对象</strong><br>所有的非静态的同步方法用的都是同一把锁—实例对象本身。一个对象里面如果有多个synchronized方法，某个时刻内，只要一个线程去调用其中一个synchronized 方法，其他的线程都要等待。换句话说，在某个时刻内，只能有唯一一个线程去访问这些synchronized方法，锁的是当前对象this，被锁定后，其他的线程都不能进入到当前对象的其他的synchronized方法</li><li><strong>对于静态同步方法，锁的是当前的Class对象</strong><br>所有的静态同步方法用的也是同一把锁—类对象本身</li><li><strong>对于同步方法块，锁是synchronized括号里面的配置对象</strong></li></ul><h2 id="2、并发同步">2、并发同步</h2><h3 id="2-1-JMM介绍">2.1 JMM介绍</h3><blockquote><p>JMM即为JAVA 内存模型（java memorymodel）。因为在<strong>不同的硬件生产商和不同的操作系统</strong>下，内存的访问逻辑有一定的差异，结果就是当你的代码在某个系统环境下运行良好，并且线程安全，但是换了个系统就出现各种问题。Java内存模型，就是为了屏蔽系统和硬件的差异，让一套代码在不同平台下能到达相同的访问结果。JMM从java 5开始的JSR-133发布后，已经成熟和完善起来。<br>JMM规定了内存主要划分为<strong>主内存</strong>和<strong>工作内存</strong>两种。此处的主内存和工作内存跟JVM内存划分（堆、栈、方法区）是在不同的层次上进行的，如果非要对应起来，主内存对应的是Java堆中的对象实例部分，工作内存对应的是栈中的部分区域，从更底层的来说，主内存对应的是硬件的物理内存，工作内存对应的是寄存器和高速缓存。</p></blockquote><p>单线程环境里面确保程序最终执行结果和代码顺序执行的结果一致。处理器在进行重排序时必须要考虑指令之间的数据依赖性；多线程环境中线程交替执行，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的，结果无法预测。<br><img src="https://img-blog.csdnimg.cn/8ccc9947c9ed4ed6943510b5f71bbe42.png" alt></p><h3 id="2-2-volatile">2.2 volatile</h3><p>volitile 是 Java 虚拟机提供的轻量级的同步机制，三大特性：</p><ul><li>保证可见性</li><li><strong>不保证原子性</strong></li><li>禁止指令重排</li></ul><p>volatile 实现了<strong>禁止指令重排优化</strong>，从而避免多线程环境下程序出现乱序执行的现象。通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化。<strong>内存屏障</strong>另外一个作用是强制刷出各种CPU的缓存数据，因此任何CPU上的线程都能读取到这些数据的最新版本。</p><p>而使用volatile的另一好处是相比synchronized来说，volatile更加轻量，运行速度更快</p><h3 id="2-3-JUC原子类工具">2.3 JUC原子类工具</h3><p>在<code>java.util.concurrent.atomic</code>包下有很多使用了高效的机器级指令(而没有使用锁)来保证其他操作的原子性。例如AtomicInteger类提供了incrementAndGet()方法，它以原子方式将一个整数进行自增。具体查看JDK8文档</p><h2 id="3、公平锁与非公平锁">3、公平锁与非公平锁</h2><ul><li><strong>公平锁</strong>：效率相对低</li><li><strong>非公平锁</strong>：效率高，但是线程容易饿死</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查看源码可知ReentrantLock默认是非公平锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、可重入锁">4、可重入锁</h2><p>synchronized和ReentrantLock都是可重入锁</p><ul><li>sychronized是隐式锁，不用手工上锁与解锁，而ReentrantLock为显示锁，需要手工上锁与解锁</li><li>可重入锁也叫递归锁</li><li>可以有效避免死锁</li></ul><h2 id="5、自旋锁-spinlock">5、自旋锁(spinlock)</h2><p>自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU；</p><p>自旋锁的底层是CAS，CAS 的全称为 Compare-And-Swap，它是一条CPU并发原语。它的功能是判断内存某个位置的值是否为预期值，如果是则更改为新的值，整个过程是原子的。</p><p>CAS并发原语体现在JAVA语言中就是 sun.misc.Unsafe类中的各个方法。调用UnSafe类中的CAS方法，JVM会帮我们实现出CAS汇编指令。UnSafe是CAS的核心类，由于Java方法无法直接访问底层系统，需要通过本地（native）方法来访问，UnSafe相当于一个后门，基于该类可以直接操作特定内存的数据，Unsafe类存在于 sun.misc包中，其内部方法操作可以像C的指针一样直接操作内存，因为Java中CAS操作的执行依赖于Unsafe类的方法。</p><h2 id="6、读写锁">6、读写锁</h2><p><strong>独占锁(写锁)</strong>：指该锁一次只能被一个线程锁持有。对于ReentranrLock和 Synchronized 而言都是独占锁</p><p><strong>共享锁(读锁)</strong>：该锁可被多个线程所持有</p><p>ReentrantReadWriteLock其读锁时共享锁，写锁是独占锁，读锁的共享锁可保证并发读是非常高效的</p><h2 id="7、死锁">7、死锁</h2><p>产生死锁主要原因：</p><ul><li>系统资源不足</li><li>进程运行推进的顺序不合适</li><li>资源分配不当</li></ul><p><img src="https://img-blog.csdnimg.cn/f348b7ee0e354487be8d7049eb8e6ed2.png" alt><br>验证是否是死锁：</p><ul><li><code>jps -l</code>类似于linux中的ps -ef查看进程号，定位进程号</li><li><code>jstack 进程号</code>自带的堆栈跟踪工具死锁查看</li></ul><h2 id="8、JUC三大辅助类">8、JUC三大辅助类</h2><p>减少计数<code>CountDownLatch</code></p><p>循环栅栏<code>CyclicBarrier</code></p><p>信号灯<code>Semaphore</code></p><h3 id="8-1-CountDownLatch">8.1 CountDownLatch</h3><blockquote><p>CountDownLatch 类可以设置一个计数器，然后通过 countDown 方法来进行减 1 的操作，使用 await 方法等待计数器不大于 0，然后继续执行 await 方法之后的语句</p></blockquote><p><strong>构造方法</strong></p><p><code>CountDownLatch(int count)</code>构造一个用给定计数初始化的CountDownLatch</p><p><strong>两个常用的主要方法</strong><br><code>await()</code> 使当前线程在锁存器倒计数至零之前一直在等待，除非线程被中断<br><code>countDown()递</code>减锁存器的计数，如果计数达到零，将释放所有等待的线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">//6个同学陆续离开教室之后，班长锁门</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建CountDownLatch对象，设置初始值</span></span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">6</span>);</span><br><span class="line">        <span class="comment">//6个同学陆续离开教室之后</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">" 号同学离开了教室"</span>);</span><br><span class="line">                <span class="comment">//计数  -1</span></span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//等待</span></span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">" 班长锁门走人了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-2-CyclicBarrier">8.2 CyclicBarrier</h3><blockquote><p>CyclicBarrier 的构造方法第一个参数是目标障碍数，每次执行 CyclicBarrier 一次障碍数会加一，如果达到了目标障碍数，才会执行 cyclicBarrier.await()之后的语句。可以将 CyclicBarrier 理解为加 1 操作</p></blockquote><p><strong>构造方法</strong><br><code>CyclicBarrier(int parties，Runnable barrierAction)</code>创建一个新的CyclicBarrier，它将在给定数量的参与者（线程）处于等待状态时启动，并在启动barrier时执行给定的屏障操作，该操作由最后一个进入barrier的线程操作</p><p><strong>常用的方法</strong><br>await()在所有的参与者都已经在此barrier上调用await方法之前一直等待</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建固定值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUMBER = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建CyclicBarrier</span></span><br><span class="line">        CyclicBarrier cyclicBarrier =</span><br><span class="line">                <span class="keyword">new</span> CyclicBarrier(NUMBER,()-&gt;&#123;</span><br><span class="line">                    System.out.println(<span class="string">"集齐7颗龙珠就可以召唤神龙"</span>);</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//集齐七颗龙珠过程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">7</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">" 星龙被收集到了"</span>);</span><br><span class="line">                    <span class="comment">//等待</span></span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-3-Semaphore">8.3 Semaphore</h3><blockquote><p>一个计数信号量，从概念上将，信号量维护了一个许可集，如有必要，在许可可用前会阻塞每一个acquire()，然后在获取该许可。每个release()添加一个许可，从而可能释放一个正在阻塞的获取者。但是，不使用实际的许可对象，Semaphore只对可用许可的号码进行计数，并采取相应的行动</p></blockquote><p><strong>构造方法</strong><br><code>Semaphore(int permits)</code>创建具有给定的许可数和非公平的公平设置的Semapore</p><p><strong>具体方法</strong><br><code>acquire()</code>从此信号量获取一个许可，在提供一个许可前一直将线程阻塞，否则线程被中断<br><code>release()</code>释放一个许可，将其返回给信号量</p><p>设置许可数量Semaphore semaphore = new Semaphore(3)；一般acquire(）都会抛出异常，release在finally中执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建Semaphore，设置许可数量</span></span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//模拟6辆汽车</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//抢占</span></span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">" 抢到了车位"</span>);</span><br><span class="line">                    <span class="comment">//设置随机停车时间</span></span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">5</span>));</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">" ------离开了车位"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//释放</span></span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9、线程局部变量">9、线程局部变量</h2><blockquote><p>ThreadLocal是解决线程安全问题一个很好的思路，它通过为每个线程提供一个独立的变量副本解决了变量并发访问的冲突问题。在很多情况下，ThreadLocal比直接使用synchronized同步机制解决线程安全问题更简单，更方便，且结果程序拥有更高的并发性。</p></blockquote><p>线程间共享变量有风险，而使用ThreadLocal辅助类可以为各个线程提供各自的实例，例如时间格式化类<code>SimpleDateFormat</code>是线程不安全的，并发访问会出现混乱，而使用同步锁开销又很大，这时候就可以使用<code>ThreadLocal</code>是最方便高效的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用ThreadLocal处理simplDateFormat线程不安全</span></span><br><span class="line"><span class="comment"> * SimpleDateFormat在多线程情况下会出现线程不安全的情况，故用ThreadLoacl 处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用了JUC辅助类</span></span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                ThreadLocal&lt;SimpleDateFormat&gt; dateFormat = ThreadLocal.withInitial(() -&gt; <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>));</span><br><span class="line">                String format = dateFormat.get().format(<span class="keyword">new</span> Date());</span><br><span class="line">                System.out.println(format);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">            ).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(end - start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>四、线程安全的集合</h1><h2 id="1、线程不安全集合">1、线程不安全集合</h2><p>平时使用的ArrayList、HashSet、HashMap等方法虽然运行速度快，但是都是现成不安全的集合，在多线程运行时，可能会产生<code>java.util.ConcurrentModificationException</code>并发修改异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建ArrayList集合</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">30</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="comment">//向集合添加内容</span></span><br><span class="line">                <span class="comment">//故障原因add方法没有加锁</span></span><br><span class="line">                list.add(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">8</span>));</span><br><span class="line">                <span class="comment">//从集合获取内容</span></span><br><span class="line">                System.out.println(list);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="2、集合的线程安全类">2、集合的线程安全类</h2><h3 id="2-1-Vector和Hashtable">2.1 Vector和Hashtable</h3><p>通过list和map实现的线程安全类，通过查看源码可发现是在方法中添加了<code>synchronized</code>关键字，现在用的较少(不推荐)</p><h3 id="2-2-Collections">2.2 Collections</h3><p>Collections类中的很多方法都是static静态，其中有一个方法是返回指定列表支持的同步（线程安全的）列表为<code>synchronizedList(List &lt;T&gt; list)</code>，通过包装获得线程安全</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br></pre></td></tr></table></figure><p>此方法也比较古老，很少使用</p><h3 id="2-3-CopyOnWriteArrayList">2.3 CopyOnWriteArrayList</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><p>涉及的底层原理为<strong>写时复制技术</strong>，支持读多写少的并发情况</p><ul><li>读的时候并发（多个线程操作）</li><li>写的时候独立，先复制相同的空间到某个区域，将其写到新区域，旧新合并，并且读新区域（每次加新内容都写到新区域，覆盖合并之前旧区域，读取新区域添加的内容）</li></ul><h3 id="2-4-CopyOnWriteArraySet">2.4 CopyOnWriteArraySet</h3><p>该类是HashSet的实现类，同样使用HashSet类，也会出现线程不安全</p><p><code>Set&lt;String&gt; set = new CopyOnWriteArraySet&lt;&gt;();</code></p><h3 id="2-5-ConcurrentHashMap">2.5 ConcurrentHashMap</h3><p><code>ConcurrentHashMap</code>类是HashMap的实现类，保证线程安全以及效率</p><h2 id="3、阻塞队列">3、阻塞队列</h2><h3 id="3-1-介绍">3.1 介绍</h3><p>与普通队列不同，阻塞队列是<strong>共享队列</strong>（多线程操作），一端输入一端输出，不能无限放队列，满了之后就会进入阻塞，取出也同理，在多线程环境下，程序员不必自己去控制这些细节。阻塞队列有以下几点特点：</p><ul><li>队列是空的，从队列中获取元素的操作将会被阻塞</li><li>当队列是满的，从队列中添加元素的操作将会被阻塞</li><li>试图从空的队列中获取元素的线程将会被阻塞，直到其他线程往空的队列插入新的元素</li><li>试图向已满的队列中添加新元素的线程将会被阻塞，直到其他线程从队列中移除一个或多个元素或者完全清空，使队列变得空闲起来并后续新增</li></ul><h3 id="3-2-阻塞队列种类">3.2 阻塞队列种类</h3><ul><li><p><strong>ArrayBlockingQueue</strong></p><blockquote><p>基于数组的阻塞队列，由数组结构组成的有界阻塞队列</p></blockquote><p>ArrayBlockingQueue在生产者放入数据和消费者获取数据，都是共用同一个锁对象，无法并行</p></li><li><p><strong>LinkedBlockingQueue</strong></p><blockquote><p>基于链表的阻塞队列，由链表结构组成的有界（但大小默认值为integer.MAX_VALUE）阻塞队列</p></blockquote><p>能够高效的处理并发数据的原因，是因为其对于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能</p></li><li><p><strong>DelayQueue</strong></p><blockquote><p>使用优先级队列实现的延迟无界阻塞队列</p></blockquote><p>DelayQueue 中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。DelayQueue 是一个没有大小限制的队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞</p></li><li><p><strong>PriorityBlockingQueue</strong></p><blockquote><p>基于优先级的阻塞队列，支持优先级排序的无界阻塞队列</p></blockquote><p>不会阻塞数据生产者，而只会在没有可消费的数据时，阻塞数据的消费者</p></li><li><p><strong>SynchronousQueue</strong></p><blockquote><p>一种无缓冲的等待队列，相对于有缓冲的 BlockingQueue 来说，少了一个缓冲区不存储元素的阻塞队列，也即单个元素的队列</p></blockquote><p>• 公平模式：SynchronousQueue 会采用公平锁，并配合一个 FIFO 队列来阻塞<br>多余的生产者和消费者，从而体系整体的公平策略；<br>• 非公平模式（SynchronousQueue 默认）：SynchronousQueue 采用非公平锁，同时配合一个 LIFO 队列来管理多余的生产者和消费者</p></li><li><p><strong>LinkedTransferQueue</strong></p><blockquote><p>由链表结构组成的无界阻塞 TransferQueue 队列，由链表组成的无界阻塞队列</p></blockquote><p>预占模式，意思就是消费者线程取元素时，如果队列不为空，则直接取走数据，若队列为空，生成一个节点（节点元素为 null）入队，消费者线程被等待在这个节点上，生产者线程入队时发现有一个元素为 null 的节点，生产者线程就不入队了，直接就将元素填充到该节点，并唤醒该节点等待的线程，被唤醒的消费者线程取走元素，从调用的方法返回</p></li><li><p><strong>LinkedBlockingDeque</strong></p><blockquote><p>由链表组成的双向阻塞队列</p></blockquote><ul><li>插入元素时: 如果当前队列已满将会进入阻塞状态，一直等到队列有空的位置时再该元素插入，该操作可以通过设置超时参数，超时后返回 false 表示操作失败，也可以不设置超时参数一直阻塞，中断后抛出 InterruptedException异常</li><li>读取元素时: 如果当前队列为空会阻塞住直到队列不为空然后返回元素，同样可以通过设置超时参数</li></ul></li></ul><h3 id="3-3-阻塞队列常用API">3.3 阻塞队列常用API</h3><table><thead><tr><th>方法类型</th><th>抛出异常</th><th>特殊值</th><th>阻塞</th><th>超时</th></tr></thead><tbody><tr><td>插入方法</td><td>add(e)</td><td>offer(e)</td><td>put(e)</td><td>offer(e,time.unit)</td></tr><tr><td>移除方法</td><td>remove()</td><td>poll()</td><td>take()</td><td>poll(time.unit)</td></tr><tr><td>检查方法</td><td>element()</td><td>peek()</td><td>不可用</td><td>不可用</td></tr></tbody></table><p><strong>抛出异常</strong></p><ul><li>当阻塞队列满时，再往队列里add插入元素会抛llegalstateException.Queue full</li><li>当阻塞队列空时，再往队列里remove移除元素会抛NoSuchElementException</li></ul><p><strong>特殊值</strong></p><ul><li>插入方法，成功ture失败false</li><li>移除方法，成功返回出队列的元素，队列里没有就返回null</li></ul><p><strong>阻塞</strong></p><ul><li>当阻塞队列满时，生产者线程继续往队列里put元素，队列会一直阻塞生产者线程直到put数据or响应中断退出</li><li>当阻塞队列空时，消费者线程试图从队列里take元素，队列会一直阻塞消费者线程直到队列可用</li></ul><p><strong>超时退出</strong></p><ul><li>当阻塞队列满时，队列会阻塞生产者线程一定时间，超过限时后生产者线程会退出</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//举例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 队列大小</span></span><br><span class="line">        ArrayBlockingQueue blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        System.out.println(blockingQueue.add(<span class="string">"a"</span>));</span><br><span class="line">        System.out.println(blockingQueue.add(<span class="string">"b"</span>));</span><br><span class="line">        System.out.println(blockingQueue.add(<span class="string">"c"</span>));</span><br><span class="line">        System.out.println(blockingQueue.element()); <span class="comment">// 检测队列队首元素！</span></span><br><span class="line">        <span class="comment">// public E remove()  返回值E，就是移除的值</span></span><br><span class="line">        System.out.println(blockingQueue.remove());  <span class="comment">//a</span></span><br><span class="line">        System.out.println(blockingQueue.remove());  <span class="comment">//b</span></span><br><span class="line">        System.out.println(blockingQueue.remove());  <span class="comment">//c </span></span><br><span class="line">        <span class="comment">// java.util.NoSuchElementException</span></span><br><span class="line">        System.out.println(blockingQueue.remove());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1>五、线程池与异步计算</h1><h2 id="1、Java线程池">1、Java线程池</h2><h3 id="1-1-Java线程池概述">1.1 Java线程池概述</h3><p><strong>线程池（英语：thread pool）</strong>：一种线程使用模式。线程过多会带来调度开销，进而影响缓存局部性和整体性能。而线程池维护着多个线程，等待着监督管理者分配可并发执行的任务。这避免了在处理短时间任务时创建与销毁线程的代价。线程池不仅能够保证内核的充分利用，还能防止过分调度</p><p><strong>特点：</strong></p><ul><li>降低资源消耗: 通过重复利用已创建的线程降低线程创建和销毁造成的销耗。</li><li>提高响应速度: 当任务到达时，任务可以不需要等待线程创建就能立即执行。</li><li>提高线程的可管理性: 线程是稀缺资源，如果无限制的创建，不仅会销耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul><p><strong>具体架构:</strong><br>Java 中的线程池是通过 Executor 框架实现的，该框架中用到了 Executor，Executors，ExecutorService，ThreadPoolExecutor 这几个类。Java提供了一个工厂类来构造我们需要的线程池，这个工厂类就是 Executors 。这里主要讲4个创建线程池的方法，即</p><ul><li>newCachedThreadPool()</li><li>newFixedThreadPool(int nThreads)</li><li>newScheduledThreadPool(int corePoolSize)</li><li>newSingleThreadExecutor()</li></ul><h3 id="1-2-newCachedThreadPool">1.2 newCachedThreadPool()</h3><p>创建缓存线程池。缓存的意思就是这个线程池会<strong>根据需要创建新的线程</strong>，在有新任务的时候会优先使用先前创建出的线程。线程一旦创建了就一直在这个池子里面了，执行完任务后后续还有任务需要会<strong>重用这个线程</strong>，若是<strong>线程不够用了再去新建线程</strong>，60秒线程空闲就会被回收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每次发布任务前根据奇偶不同等待一段时间，如1s，这样就会创建两个线程</span></span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行任务</span></span><br><span class="line">    cachedThreadPool.execute(() -&gt; System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + index));</span><br></pre></td></tr></table></figure><p>注意这里的线程池是<strong>无限大的</strong>，并没有规定他的大小</p><h3 id="1-3-newFixedThreadPool-int-nThreads">1.3 newFixedThreadPool(int nThreads)</h3><p>创建定长线程池，参数是线程池的大小。也就是说，在同一时间执行的线程数量只能是 nThreads 这么多，这个线程池可以有效的控制最大并发数从而防止占用过多资源。超出的线程会放在线程池的一个<strong>无界队列里等待</strong>其他线程执行完。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><h3 id="1-4-newScheduledThreadPool-int-corePoolSize">1.4 newScheduledThreadPool(int corePoolSize)</h3><p>第3个坏处线程池的坏处就是缺乏定时执行功能，这个Scheduled代表是支持的，这个线程池也是定长的，参数 corePoolSize 就是线程池的大小，即在空闲状态下要保留在池中的线程数量。而要实现调度需要使用这个线程池的 schedule() 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 三秒后执行</span></span><br><span class="line">scheduledExecutorService.schedule(() -&gt; System.out.println(Thread.currentThread().getName() + <span class="string">": 我会在3秒后执行。"</span>),</span><br><span class="line">                <span class="number">3</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><h3 id="1-5-newSingleThreadExecutor">1.5 newSingleThreadExecutor()</h3><p>创建<strong>单线程池</strong>，只使用<strong>一个线程</strong>来执行任务。但是它与 <code>newFixedThreadPool(1, threadFactory)</code> 不同，它会<strong>保证创建的这个线程池不会被重新配置为使用其他的线程</strong>，也就是说这个线程池里的线程始终如一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br></pre></td></tr></table></figure><h3 id="1-6-线程池的拒绝策略">1.6 线程池的拒绝策略</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RejectedExecutionHandler rejected = <span class="keyword">null</span>;</span><br><span class="line">rejected = <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy();<span class="comment">//默认，队列满了丢任务，抛出异常</span></span><br><span class="line">rejected = <span class="keyword">new</span> ThreadPoolExecutor.DiscardPolicy();<span class="comment">//队列满了丢任务，不抛出异常[如果允许任务丢失这是最好的]</span></span><br><span class="line">rejected = <span class="keyword">new</span> ThreadPoolExecutor.DiscardOldestPolicy();<span class="comment">//将最早进入队列的任务删，之后再尝试加入队列</span></span><br><span class="line">rejected = <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy();<span class="comment">//如果添加到线程池失败，那么主线程会自己去执行该任务，回退</span></span><br></pre></td></tr></table></figure><h3 id="1-7-自定义线程池">1.7 自定义线程池</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// public ThreadPoolExecutor(int corePoolSize,</span></span><br><span class="line">        <span class="comment">// int maximumPoolSize,</span></span><br><span class="line">        <span class="comment">// long keepAliveTime,</span></span><br><span class="line">        <span class="comment">// TimeUnit unit,</span></span><br><span class="line">        <span class="comment">// BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line">        <span class="comment">// ThreadFactory threadFactory,</span></span><br><span class="line">        <span class="comment">// RejectedExecutionHandler handler);  </span></span><br><span class="line"></span><br><span class="line">ExecutorService threadPool = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                <span class="number">2</span>,</span><br><span class="line">                <span class="number">5</span>,</span><br><span class="line">                <span class="number">2L</span>,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>),</span><br><span class="line">                Executors.defaultThreadFactory(),</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy()</span><br><span class="line">        );</span><br></pre></td></tr></table></figure><h3 id="1-8-线程池的关闭">1.8 线程池的关闭</h3><p>线程池启动后需要手动关闭，否则会一直不结束</p><ul><li><code>shutdown()</code> : 将线程池状态置成 <code>SHUTDOWN</code>，此时<strong>不再接受新的任务</strong>，<strong>等待线程池中已有任务执行完成后结束</strong>；</li><li><code>shutdownNow()</code> : 将线程池状态置成 <code>SHUTDOWN</code>，将线程池中<strong>所有线程中断</strong>（调用线程的 <code>interrupt()</code> 操作），清空队列，并返回<strong>正在等待执行的任务列表</strong>。</li></ul><p>并且它还提供了查看线程池是否关闭和是否终止的方法，分别为 <code>isShutdown()</code> 和 <code>isTerminated()</code> 。</p><h2 id="2、Fork与Join分支">2、Fork与Join分支</h2><blockquote><p>从JDK1.7开始，Java提供Fork/Join框架用于并行执行任务，它的思想就是讲一个大任务分割成若干小任 务，最终汇总每个小任务的结果得到这个大任务的结果。**工作窃取（work-stealing）**算法是指某个线程从其他队列里窃取任务来执行，率先完成任务的线程会去未完成任务的线程对应的队列里窃取一个任务来执行，被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行。</p></blockquote><p><strong>核心类</strong></p><p><strong>ForkJoinPool</strong>：WorkQueue是一个ForkJoinPool中的内部类，它是线程池中线程的工作队列的一个封装，支持任务窃取。<strong>ForkJoinTask</strong> 需要通过 ForkJoinPool 来执行</p><p><strong>主要方法</strong></p><ul><li><code>fork()</code> 在当前线程运行的线程池中安排一个异步执行。简单的理解就是再创建一个子任务。</li><li><code>join()</code> 当任务完成的时候返回计算结果。</li><li><code>invoke() </code>开始执行任务，如果必要，等待计算完成。</li></ul><p><strong>子类Recursive：递归</strong></p><ul><li><strong>RecursiveAction</strong>：用于没有返回结果的任务</li><li><strong>RecursiveTask</strong>：用于有返回结果的任务</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拆分差值不能超过10，计算10以内运算</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer VALUE = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> begin ;<span class="comment">//拆分开始值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end;<span class="comment">//拆分结束值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> result ; <span class="comment">//返回结果</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建有参数构造</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyTask</span><span class="params">(<span class="keyword">int</span> begin,<span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.begin = begin;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拆分和合并过程</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断相加两个数值是否大于10</span></span><br><span class="line">        <span class="keyword">if</span>((end-begin)&lt;=VALUE) &#123;</span><br><span class="line">            <span class="comment">//相加操作</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt;=end; i++) &#123;</span><br><span class="line">                result = result+i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//进一步拆分</span></span><br><span class="line">            <span class="comment">//获取中间值</span></span><br><span class="line">            <span class="keyword">int</span> middle = (begin+end)/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">//拆分左边</span></span><br><span class="line">            MyTask task01 = <span class="keyword">new</span> MyTask(begin,middle);</span><br><span class="line">            <span class="comment">//拆分右边</span></span><br><span class="line">            MyTask task02 = <span class="keyword">new</span> MyTask(middle+<span class="number">1</span>,end);</span><br><span class="line">            <span class="comment">//调用方法拆分</span></span><br><span class="line">            task01.fork();</span><br><span class="line">            task02.fork();</span><br><span class="line">            <span class="comment">//合并结果</span></span><br><span class="line">            result = task01.join()+task02.join();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//创建MyTask对象</span></span><br><span class="line">        MyTask myTask = <span class="keyword">new</span> MyTask(<span class="number">0</span>,<span class="number">100</span>);</span><br><span class="line">        <span class="comment">//创建分支合并池对象</span></span><br><span class="line">        ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        ForkJoinTask&lt;Integer&gt; forkJoinTask = forkJoinPool.submit(myTask);</span><br><span class="line">        <span class="comment">//获取最终合并之后结果</span></span><br><span class="line">        Integer result = forkJoinTask.invoke();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        <span class="comment">//关闭池对象</span></span><br><span class="line">        forkJoinPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、异步回调">3、异步回调</h2><h3 id="3-1-函数式接口简介">3.1 函数式接口简介</h3><p>函数式接口可以参考<a href="https://blog.csdn.net/lemon_TT/article/details/119415154" target="_blank" rel="noopener">java8常用新特性</a>，这里主要介绍几种函数式接口，Callable、Runnable、Future、CompletableFuture和FutureTask</p><h3 id="3-2-Callable和Runnable异同">3.2 Callable和Runnable异同</h3><p>两个接口的定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>相同点</strong></p><p>都是接口，都可以编写多线程程序，都可以通过线程池启动线程</p><p><strong>不同点</strong></p><p>Runnable没有返回值，Callable可以返回执行结果，是个泛型；Callable接口的call()方法允许抛出异常；而Runnable接口的run()方法的异常只能在内部消化，不能继续上抛；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Min</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Max</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="meta">@SneakyThrows</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        executorService.submit(<span class="keyword">new</span> Min());</span><br><span class="line">        executorService.submit(<span class="keyword">new</span> Max());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-Future类">3.3 Future类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Since:1.5</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//取消任务的执行,参数指定是否立即中断任务执行，或者等等任务结束</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line">    <span class="comment">//任务是否已经取消,任务正常完成前将其取消，则返回 true</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//任务是否已经完成。需要注意的是如果任务正常终止、异常或取消，都将返回true</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//等待任务执行结束，然后获得V类型的结果。InterruptedException 线程被中断异常， ExecutionException任务执行异常,如果任务被取消，还会抛出CancellationException</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line">    <span class="comment">//同上面的get功能一样，多了设置超时时间。超时会抛出TimeoutException</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般情况下，我们会结合Callable和Future一起使用，通过ExecutorService的submit方法执行Callable，并返回Future。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException, TimeoutException </span>&#123;</span><br><span class="line">       ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line">       <span class="comment">//Lambda 是一个 callable， 提交后便立即执行，这里返回的是 FutureTask 实例</span></span><br><span class="line">       Future&lt;String&gt; future = executor.submit(() -&gt; &#123;</span><br><span class="line">           System.out.println(<span class="string">"running task"</span>);</span><br><span class="line">           Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">           <span class="keyword">return</span> <span class="string">"return task"</span>;</span><br><span class="line">       &#125;);</span><br><span class="line">       future.get(<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>当然Future模式也有它的缺点，它没有提供通知的机制，我们无法得知Future什么时候完成。如果要在<code>future.get()</code>的地方等待future返回的结果，那只能通过<code>isDone()</code>轮询查询。</p><h3 id="3-4-CompletableFuture类">3.4 CompletableFuture类</h3><blockquote><p><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html</a></p></blockquote><p>CompletableFuture能够将回调放到与任务不同的线程中执行，也能将回调作为继续执行的同步函数，在与任务相同的线程中执行。它避免了传统回调最大的问题，那就是能够将控制流分离到不同的事件处理器中。CompletableFuture弥补了Future模式的缺点。在异步的任务完成后，需要用其结果继续操作时，无需等待。可以直接通过thenAccept、thenApply、thenCompose等方式将前面异步处理的结果交给另外一个异步事件处理线程来处理。</p><p><code>CompletableFuture</code>的静态工厂方法，其中<code>runAsync</code> 和<code> supplyAsync</code> 方法的区别是<code>runAsync</code>返回的<code>CompletableFuture</code>是没有返回值的。</p><table><thead><tr><th><strong>方法名</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>runAsync(Runnable runnable)</td><td>使用ForkJoinPool.commonPool()作为它的线程池执行异步代码</td></tr><tr><td>runAsync(Runnable runnable, Executor executor)</td><td>使用指定的thread pool执行异步代码</td></tr><tr><td>supplyAsync(Supplier supplier)</td><td>使用ForkJoinPool.commonPool()作为它的线程池执行异步代码，异步操作有返回值</td></tr><tr><td>supplyAsync(Supplier supplier, Executor executor)</td><td>使用指定的thread pool执行异步代码，异步操作有返回值</td></tr><tr><td>allOf(CompletableFuture&lt;?&gt;… cfs)</td><td>等待所有任务完成，构造后CompletableFuture完成</td></tr><tr><td>anyOf(CompletableFuture&lt;?&gt;… cfs)</td><td>只要有一个任务完成，构造后CompletableFuture就完成</td></tr></tbody></table><p>对于变量的方法，常用有这几种方法</p><table><thead><tr><th><strong>方法名</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>complete(T t)</td><td>完成异步执行的话返回执行结果，若不是返回设置的值</td></tr><tr><td>completeExceptionally(Throwable ex)</td><td>完成异步执行的话返回执行结果，若不是返回一个异常</td></tr><tr><td>thenApply(Function&lt;? super T,? extends U&gt; fn)</td><td>返回一个新的CompletionStage，当这个阶段正常完成时，它将以这个阶段的结果作为所提供函数的参数执行</td></tr><tr><td>thenAccept(Consumer&lt;? super T&gt; action)</td><td>返回一个新的CompletionStage，当这个阶段正常完成时，返回为void</td></tr><tr><td>handle(BiFunction&lt;? super T, Throwable, ? extends U&gt; fn)</td><td>处理结果或错误，生成一个新结果返回</td></tr><tr><td>whenCompleteAsync(BiConsumer&lt;? super T, ? super Throwable&gt; action)</td><td>处理结果或错误，返回为void</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException, TimeoutException </span>&#123;</span><br><span class="line">        CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; <span class="string">"Hello"</span>);</span><br><span class="line">        <span class="comment">//在这里执行返回值为World</span></span><br><span class="line">        <span class="comment">// future.complete("World");</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在这里执行结果为Hello</span></span><br><span class="line">        future.complete(<span class="string">"World"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//get() 方法会抛出经检查的异常，可被捕获，自定义处理或者直接抛出。join() 会抛出未经检查的异常。</span></span><br><span class="line">            System.out.println(future.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//thenApplyhello shawn</span></span><br><span class="line"><span class="comment">// thenAccept shawn</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    <span class="comment">//thenApply</span></span><br><span class="line">    CompletableFuture&lt;String&gt; cfuture =</span><br><span class="line">            CompletableFuture.supplyAsync(() -&gt; <span class="string">"shawn"</span>).thenApply(data -&gt; <span class="string">"hello "</span>+ data);</span><br><span class="line">    System.out.println(<span class="string">"thenApply"</span> + cfuture.get());</span><br><span class="line">    <span class="comment">//thenAccept</span></span><br><span class="line">    CompletableFuture.supplyAsync(() -&gt; <span class="string">"thenAccept shawn"</span>).thenAccept(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-FutureTask">3.5 FutureTask</h3><blockquote><p><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/FutureTask.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/FutureTask.html</a></p></blockquote><p>Future是一个接口，是无法生成一个实例的，所以又有了FutureTask。FutureTask实现了RunnableFuture接口，RunnableFuture接口又实现了Runnable接口和Future接口。所以FutureTask既可以被当做Runnable来执行，也可以被当做Future来获取Callable的返回结果。</p>]]></content>
    
    
    <summary type="html">&lt;h1&gt;一、简介&lt;/h1&gt;
&lt;h2 id=&quot;1、JUC介绍&quot;&gt;1、JUC介绍&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;java.util.concurrent&lt;/code&gt; 包是在并发编程中使用的工具类，简称JUC，有以下三个包&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;java.util.concurrent&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;java.util.concurrent.atomic&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;java.util.concurrent.locks&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;JDK8官方在线文档：&lt;a href=&quot;https://www.matools.com/api/java8&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.matools.com/api/java8&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Java" scheme="https://www.shawn22.xyz/categories/Java/"/>
    
    
    <category term="Java基础" scheme="https://www.shawn22.xyz/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java注解与反射</title>
    <link href="https://www.shawn22.xyz/posts/20d0a84c.html"/>
    <id>https://www.shawn22.xyz/posts/20d0a84c.html</id>
    <published>2021-12-28T09:40:45.000Z</published>
    <updated>2021-12-28T09:58:52.044Z</updated>
    
    <content type="html"><![CDATA[<h1>一、注解Annotation</h1><h2 id="1、注解介绍">1、注解介绍</h2><ul><li>Annotation 是从JDK5.0开始引入的新技术</li><li>Annotation不是程序本身，但可以对程序作出解释(和注释差不多) ，也可以被其他程序(编译器等)读取</li><li>Annotation注解是以<code>@注解名</code>在代码中存在的，还可以添加一些参数值 , 例如:<code>@SuppressWarnings(value=&quot;unchecked&quot;)</code></li><li>Annotation可以附加在package , class , method , ﬁeld 等上面 , 相当于给他们添加了额外的辅助信息，我们可以通过反射机制实现对这些元数据的访问</li></ul><a id="more"></a><h2 id="2、内置注解">2、内置注解</h2><p><strong>@Override</strong>定义在 java.lang.Override中 ，此注释只适用于修辞方法, 表示一个方法声明打算重写超类中的另一个方法声明；</p><p><strong>@Deprecated</strong>定义在java.lang.Deprecated中 ，此注释可以用于修辞方法 ，属性 ， 类 ，表示不鼓励程序员使用这样的元素 ，通常是因为它很危险或者存在更好的选择或者已经过时 ；</p><p><strong>@SuppressWarnings</strong>定义在java.lang.SuppressWarnings中，用来抑制编译时的警告信息。与前两个注释有所不同，你需要添加一个参数才能正确使用，这些参数都是已经定义好了的，我们选择性的使用就好了 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 还有很多类型</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"all"</span>)</span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="meta">@SuppressWarnings</span>(value=&#123;<span class="string">"unchecked"</span>,<span class="string">"deprecation"</span>&#125;)</span><br></pre></td></tr></table></figure><h2 id="3、元注解">3、元注解</h2><blockquote><p>元注解的作用就是负责注解其他注解 ， Java定义了4个标准的meta-annotation类型，他们被用来提供对其他annotation类型作说明；这四种类型在<strong>java.lang.annotation</strong>包中可以找到 (<code>@Target</code> , <code>@Retention</code> , <code>@Documented </code>, <code>@Inherited</code> )</p></blockquote><p><strong>@Target</strong></p><p>描述注解的使用范围(即被描述的注解可以用在什么地方) ；ElementType类中存在常数<code>ANNOTATION_TYPE</code>，<code>CONSTRUCTOR</code>，<code>FIELD</code>，<code>LOCAL_VARIABLE</code>，<code>METHOD</code>，<code>PACKAGE</code>，<code>PARAMETER</code>，<code>TYPE</code>，和<code>TYPE_PARAMETER</code></p><p><strong>@Retention</strong></p><p>需要在什么级别保存该注释信息 , 用于描述注解的生命周期(SOURCE &lt; CLASS &lt; RUNTIME)</p><ul><li><code>RetentionPolicy.SOURCE</code>注释将被编译器丢弃 ；</li><li><code>RetentionPolicy.CLASS</code>注释将由编译器记录在类文件中，但不需要在运行时由VM保留。这是默认行为；</li><li><code>RetentionPolicy.RUNTIME</code>注释将由编译器记录在类文件中，并且由VM在运行时保留，因此可以反射地读取它们。</li></ul><p><strong>@Document</strong></p><p>说明该注解将被包含在javadoc中@Inherited：说明子类可以继承父类中的该注解</p><p><strong>@Inherited</strong></p><p>说明子类可以继承父类中的该注解</p><h2 id="4、自定义注解">4、自定义注解</h2><p>使用 @interface自定义注解时, 自动继承了<strong>java.lang.annotation.Annotation</strong>接口</p><ul><li><code>@interface</code>用来声明一个注解，格式：<code>public @interface 注解名 {定义内容 }</code></li><li>注解的每一个方法实际上是声明了一个配置参数</li><li>方法的名称就是参数的名称</li><li>返回值类型就是参数的类型 (返回值只能是基本类型Class ，String ，enum)</li><li>可以通过default来声明参数的默认值</li><li>如果只有一个参数成员 , 一般参数名为value</li><li>注解元素必须要有值，我们定义注解元素时，经常使用空字符串0作为默认值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">annotationTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示定义</span></span><br><span class="line">    <span class="meta">@MyAnnotation</span>(value = <span class="string">"value"</span>,name = <span class="string">"shawn"</span>,age = <span class="number">18</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 默认名字一般是value</span></span><br><span class="line">    <span class="meta">@MyAnnotation</span>(<span class="string">"shawn"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义一个注解，其中用到了四个元注解</span></span><br><span class="line"><span class="meta">@Target</span>(value = &#123;ElementType.TYPE,ElementType.METHOD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(value = RetentionPolicy.RUNTIME) <span class="comment">//一般自定义注解，都选择RUNTIME;</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation&#123;</span><br><span class="line">    <span class="comment">// 参数类型，参数名</span></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">age</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>二、反射Refection</h1><h2 id="1、静态-VS-动态语言">1、静态 VS 动态语言</h2><p><strong>动态语言</strong>是一类在运行时可以改变其结构的语言：例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。通俗点说就是在运行时代码可以根据某些条件改变自身结构。主要动态语言：Object-C、C#、JavaScript、PHP、Python等。</p><p><strong>静态语言</strong>与动态语言相对应的，运行时结构不可变的语言就是静态语言。如Java、C、C++。Java不是动态语言，但Java可以称之为“准动态语言”。即Java有一定的动态性，我们可以利用反射机制获得类似动态语言的特性。Java的动态性让编程的时候更加灵活！</p><h2 id="2、反射概述">2、反射概述</h2><h3 id="1、概述">1、概述</h3><p>反射机制允许程序在执行期间借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在加载了类之后，在堆内存的方法区中，就产生了一个Class类型的对象（一个类只有一个Class对象）</span></span><br><span class="line"><span class="comment">// 该对象包含了完整的类的结构信息。我们可以通过该对象来看到类的完整的结构</span></span><br><span class="line"><span class="comment">// 这个对象就像是一个镜子一样，透过镜子看到类的结构，因此成为反射</span></span><br><span class="line">Class c = Class.forName(<span class="string">"java.lang.String"</span>);</span><br></pre></td></tr></table></figure><p><strong>正常方式</strong>：引入需要的&quot;包类&quot;名称&gt;通过new实例化&gt;取得实例化对象</p><p><strong>反射方式</strong>：实例化对象&gt;getClass()对象方法&gt;得到完整的&quot;包类&quot;名称</p><h3 id="2、功能与优缺点">2、功能与优缺点</h3><p><strong>反射有以下几点功能(不局限以下几点)：</strong></p><ul><li>在运行时判断任意一个对象所属的类</li><li>在运行时构造任意一个类的对象</li><li>在运行时判断任意一个类所具有的成员变量和方法</li><li>在运行时获取泛型信息</li><li>在运行时调用任意一个对象的成员变量和方法</li><li>在运行时处理注解</li><li>生成动态代理</li></ul><p><strong>反射优缺点：</strong></p><ul><li>优点：可以在运行时获得类的各种内容，进行反编译，对于Java这种先编译再运行的特点，能够让我们很方便的创建灵活的代码，这些代码可以在运行时进行装配，不用在组件之间进行代码之间的链接。</li><li>缺点：反射会消耗一定的系统资源，假如不需要动态的创建对象的时候，就不要使用反射；反射调用方法的时候可以忽略权限的检查，因此可能会破坏封装性而导致安全问题</li></ul><h2 id="3、反射Class类">3、反射Class类</h2><h3 id="1、Class详解">1、Class详解</h3><p><strong>Class类</strong>对于每个类而言，JRE都为其保留了一个不变的Class类型的对象。一个Class对象包含了特定某个结构的有关信息</p><ul><li>Class 本身也是一个类</li><li>Class 对象只能由系统建立对象</li><li>一个加载的类在 JVM 中只会有一个Class实例</li><li>一个Class对象对应的是一个加载到JVM中的一个.class文件每个类的实例都会记得自己是由哪个 Class 实例所生成</li><li>通过Class可以完整地得到一个类中的所有被加载的结构</li><li>Class类是Reﬂection的根源，针对任何你想动态加载、运行的类，唯有先获得相应的Class对象</li></ul><h3 id="2、反射常用API">2、反射常用API</h3><p><code>Class类</code> 代表类的实体，在运行的Java应用程序中表示类和接口</p><p><code>Field类</code> 代表类的成员变量（成员变量也称为类的属性）</p><p><code>Method类</code> 代表类的方法</p><p><code>Constructor类</code> 代表类的构造方法</p><ul><li><code>getField</code>、<code>getMethod</code>和<code>getCostructor</code>方法可以 获得指定名字的域、方法和构造器。</li><li><code>getFields</code>、<code>getMethods</code>和<code>getCostructors</code>方法可以 获得类提供的public域、方法和构造器数组，其中包括超类的共有成员。</li><li><code>getDeclatedFields</code>、<code>getDeclatedMethods</code>和<code>getDeclaredConstructors</code>方法可以 获得类中声明的全部域、方法和构造器，其中包括私有和受保护的成员，但不包括超类的成员。</li></ul><table><thead><tr><th><strong>方法名</strong></th><th><strong>功能说明</strong></th></tr></thead><tbody><tr><td>static ClassforName(String name)</td><td>返回指定类名name的Class对象</td></tr><tr><td>Object newInstance()</td><td>调用缺省构造函数，返回Class对象的一个实例</td></tr><tr><td>getName()</td><td>返回此Class对象所表示的实体（类，接口，数组类或void）的名称。</td></tr><tr><td>Class getSuperClass()</td><td>返回当前Class对象的父类的Class对象</td></tr><tr><td>Class[] getinterfaces()</td><td>获取当前Class对象的接口</td></tr><tr><td>ClassLoader getClassLoader()</td><td>返回该类的类加载器</td></tr><tr><td>Constructor[] getConstructors()</td><td>返回一个包含某些Constructor对象的数组</td></tr><tr><td>Method getMothed(String name,Class… T)</td><td>返回一个Method对象，此对象的形参类型为paramType</td></tr><tr><td>Field[] getDeclaredFields()</td><td>返回Field对象的一个数组</td></tr></tbody></table><h3 id="3、获取Class类的多种方式">3、<strong>获取Class类的多种方式</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 若已知是具体的类，通过类的class属性获取，该方法最为安全可靠，程序性能最高：</span></span><br><span class="line">Class clazz1 = Person<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"><span class="comment">// 已知某个类的实例，调用该实例的getClass()方法获取Class对象：</span></span><br><span class="line">Class clazz2 = Person.getClass();</span><br><span class="line"><span class="comment">// 已知一个类的全名，且该类在类路径中，可通过Class类的静态方法forName()获取：</span></span><br><span class="line">Class clazz3 = Class.forName(…);</span><br><span class="line"><span class="comment">// 内置基本数据类型的包装类可以直接用</span></span><br><span class="line">Class clazz4 = Integer.TYPE;</span><br><span class="line"><span class="comment">// 还可以利用ClassLoader加载器</span></span><br></pre></td></tr></table></figure><p><strong>哪些类型可以有Class对象</strong></p><ul><li>class：外部类，成员(成员内部类，静态内部类)，局部内部类，匿名内部类</li><li>interface：接口</li><li>[]：数组</li><li>enum：枚举</li><li>annotation：注解@interface</li><li>primitive type：基本数据类型</li><li>void</li></ul><h2 id="4、Java内存模型">4、Java内存模型</h2><h3 id="1、Java内存划分">1、Java内存划分</h3><p><img src="https://gitee.com/LXT2017/Picbed/raw/master/noteimg/image.png" alt></p><h3 id="2、类的加载过程">2、类的加载过程</h3><p><strong>加载</strong></p><ul><li>将<strong>class</strong>文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构， 然后生成一个代表这个类的<strong>java.lang.Class</strong>对象.</li></ul><p>**链接：**将Java类的二进制代码合并到JVM的运行状态之中的过程。</p><ul><li>验证：确保加载的类信息符合JVM规范，没有安全方面的问题</li><li>准备：正式为类变量（static）分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配。</li><li>解析：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程。</li></ul><p><strong>初始化</strong></p><ul><li>执行类构造器()方法的过程。类构造器()方法是由编译期自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的。（类构造器是构造类信息的，不是构造该类对象的构造器）。</li><li>当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。</li><li>虚拟机会保证一个类的()方法在多线程环境中被正确加锁和同步</li></ul><p><img src="https://gitee.com/LXT2017/Picbed/raw/master/noteimg/image_1.png" alt></p><h3 id="3、分析类初始化">3、分析类初始化</h3><p><strong>类的主动引用</strong>（一定会发生类的初始化）</p><ul><li>当虚拟机启动，先初始化main方法所在的类</li><li>new一个类的对象</li><li>调用类的静态成员（除了ﬁnal常量）和静态方法</li><li>使用java.lang.reﬂect包的方法对类进行反射调用</li><li>当初始化一个类，如果其父类没有被初始化，则先会初始化它的父类</li></ul><p><strong>类的被动引用</strong>（不会发生类的初始化）</p><ul><li>当访问一个静态域时，只有真正声明这个域的类才会被初始化。如：当通过子类引用父类的静 态变量，不会导致子类初始化</li><li>通过数组定义类引用，不会触发此类的初始化</li><li>引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池中了）</li></ul><h3 id="4、类加载器的作用">4、类加载器的作用</h3><ul><li>类加载的作用：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口。</li><li>类缓存：标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间。不过JVM垃圾回收机制可以回收这些Class对象</li></ul><p><img src="https://gitee.com/LXT2017/Picbed/raw/master/noteimg/image_3.png" alt></p><ul><li>类加载器作用是用来把类(class)装载进内存的。JVM 规范定义了如下类型的类的加载器</li></ul><p><img src="https://gitee.com/LXT2017/Picbed/raw/master/noteimg/image_2.png" alt></p><h2 id="5、反射创建">5、反射创建</h2><h3 id="1、获取类加载器">1、获取类加载器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zstu.sso;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestUser</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//获取系统类的加载器</span></span><br><span class="line">        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">        System.out.println(systemClassLoader);<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取系统类的加载器的父类加载器---&gt;扩展类加载器</span></span><br><span class="line">        ClassLoader parent = systemClassLoader.getParent();</span><br><span class="line">        System.out.println(parent);<span class="comment">//sun.misc.Launcher$ExtClassLoader@1540e19d</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取扩展类加载器的父类加载器---&gt;根加载器(c/c++)</span></span><br><span class="line">        ClassLoader parent1 = parent.getParent();</span><br><span class="line">        System.out.println(parent1);<span class="comment">//null</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//测试当前类是哪个加载器加载的：系统类加载器</span></span><br><span class="line">        ClassLoader classLoader = Class.forName(<span class="string">"com.zstu.sso.TestUser"</span>).getClassLoader();</span><br><span class="line">        System.out.println(classLoader);<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//测试JDK内置的类是谁加载的：根加载器</span></span><br><span class="line">        classLoader = Class.forName(<span class="string">"java.lang.Object"</span>).getClassLoader();</span><br><span class="line">        System.out.println(classLoader);<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//如何获得系统类加载器可以加载的路径</span></span><br><span class="line">        System.out.println(System.getProperty(<span class="string">"java.class.path"</span>));<span class="comment">//各种jdk/jre/jar包路径</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、获取类的运行时结构">2、获取类的运行时结构</h3><p>通过反射获取运行时类的完整结构：Field,Method,Constructor,Superclass,Interface,Annotation；另外反射获取内部类是需要用<code>$</code>隔开</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zstu.sso;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestUser</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, </span></span><br><span class="line"><span class="function">            NoSuchMethodException, NoSuchFieldException, </span></span><br><span class="line"><span class="function">            InvocationTargetException, IllegalAccessException, </span></span><br><span class="line"><span class="function">            InstantiationException </span>&#123;</span><br><span class="line">        Class user = Class.forName(<span class="string">"com.zstu.sso.User"</span>);</span><br><span class="line">        <span class="comment">//获得类的名字</span></span><br><span class="line">        System.out.println(user.getName());</span><br><span class="line">        System.out.println(user.getSimpleName());</span><br><span class="line">        System.out.println(<span class="string">"=============================="</span>);</span><br><span class="line">        <span class="comment">//获得类的属性</span></span><br><span class="line">        <span class="comment">//user.getFields()只能找到类的public属性</span></span><br><span class="line">        Field[] fields = user.getDeclaredFields(); <span class="comment">//找到全部属性</span></span><br><span class="line">        <span class="keyword">for</span>(Field field:fields) &#123;</span><br><span class="line">            System.out.println(field);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获得类的指定属性</span></span><br><span class="line">        Field field = user.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line">        System.out.println(field);</span><br><span class="line">        System.out.println(<span class="string">"=============================="</span>);</span><br><span class="line">        <span class="comment">//获得类的方法</span></span><br><span class="line">        Method[] methods = user.getMethods(); <span class="comment">//获得本类以及父类的所有public方法</span></span><br><span class="line">        <span class="keyword">for</span>(Method method:methods)&#123;</span><br><span class="line">            System.out.println(<span class="string">"所有的方法："</span>+method);</span><br><span class="line">        &#125;</span><br><span class="line">        methods = user.getDeclaredMethods(); <span class="comment">//获得本类的所有方法(包含私有方法)</span></span><br><span class="line">        <span class="keyword">for</span>(Method method:methods)&#123;</span><br><span class="line">            System.out.println(<span class="string">"本类的方法："</span>+method);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取指定方法</span></span><br><span class="line">        Method test = user.getDeclaredMethod(<span class="string">"test"</span>,<span class="keyword">null</span>);</span><br><span class="line">        Method test1 = user.getDeclaredMethod(<span class="string">"test1"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(test);</span><br><span class="line">        System.out.println(test1);</span><br><span class="line">        System.out.println(<span class="string">"=============================="</span>);</span><br><span class="line">        <span class="comment">//获取类的构造器</span></span><br><span class="line">        Constructor[] constructors = user.getConstructors(); <span class="comment">//获得public的构造器</span></span><br><span class="line">        <span class="keyword">for</span> (Constructor constructor : constructors) &#123;</span><br><span class="line">            System.out.println(<span class="string">"public构造器："</span>+constructor);</span><br><span class="line">        &#125;</span><br><span class="line">        constructors = user.getDeclaredConstructors(); <span class="comment">//获得所有构造器</span></span><br><span class="line">        <span class="keyword">for</span> (Constructor constructor : constructors) &#123;</span><br><span class="line">            System.out.println(<span class="string">"所有的构造器："</span>+constructor);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获得指定的构造器</span></span><br><span class="line">        Constructor constructor = user.getDeclaredConstructor(String<span class="class">.<span class="keyword">class</span>, <span class="title">String</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        System.out.println(constructor);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用某个实例化类的方法，会抛出InvocationTargetException, IllegalAccessException,InstantiationException</span></span><br><span class="line">        test.invoke(user.newInstance());</span><br><span class="line">        test1.invoke(user.newInstance(),<span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我执行了test的方法啦"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">(String test1)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我执行了test1的方法啦，内容是"</span> + test1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、动态创建对象执行方法">3、动态创建对象执行方法</h3><ul><li>可以通过Class对象创建该类的对象，然后执行该类的方法</li><li>如何利用反射机制动态创建对象：<ol><li>调用Class对象的**newInstance()**方法，要求类必须有一个无参数的构造器，而且类的构造器的访问权限足够；</li><li>当类没有无参的构造器的时候，只要在操作的过程中明确指定类中的构造器即可创建对象，步骤如下：首先，通过Class对象获取本类的指定形参类型的构造器；第二步，向构造器的形参中传递一个对象数组进去，里面包含了构造器所需的各个参数；第三步，通过Constructor实例化对象；</li></ol></li><li>通过**Object invoke(Object obj,Object[] args)**调用指定的方法：<ol><li>Object对应原方法的返回值，若原方法无返回值，此时返回null；</li><li>若原方法为静态方法，则obj参数可以为null；</li><li>若原方法形参列表为空，则args参数可以为null；</li><li>（★）若原方法声明为private，则在调用invoke方法之前，需要先调用**setAccessible(true)**方法，即可访问private的方法；另外反射执行的速度比普通方式要慢很多，如果非得要用反射，而且是多次用的情况下，可以通过关闭检测来提高速度</li></ol></li></ul><h3 id="4、setAccessible">4、setAccessible</h3><ul><li>Method和Field、Constructor对象都有setAccessible()方法。</li><li>setAccessible作用是启动和禁用访问安全检查的开关。</li><li>参数值为true则指示反射的对象在使用时应该取消Java语言访问检查。</li><li>提高反射的效率。如果代码中必须用反射，而该句代码需要频繁的被调用，那么请设置为true。</li><li>使得原本无法访问的私有成员也可以访问</li><li>参数值为false则指示反射的对象应该实施Java语言访问检查</li></ul><h1>三、反射实战</h1><blockquote><p>java8在线参考文档：<a href="https://docs.oracle.com/javase/8/docs/api/" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/</a></p></blockquote><h2 id="1、获取泛型信息">1、获取泛型信息</h2><p>对于泛型，Java采用泛型擦除的机制来引入泛型，Java中的泛型仅仅是给编译器javac使用的，确保数据的安全性和免去强制类型转换的问题，但是，一旦编译成功，所有和泛型有关的类型全部擦除；但是泛型的信息，还是会在加载的过程中存储在Class中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zstu.sso;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestUser</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException </span>&#123;</span><br><span class="line">        <span class="comment">//通过反射获取方法参数泛型</span></span><br><span class="line">        <span class="comment">//第一步：获取指定的方法</span></span><br><span class="line">        Method method = User.class.getDeclaredMethod("test", Map.class, List.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二步：获取该方法的参数泛型</span></span><br><span class="line">        Type[] genericParameterTypes = method.getGenericParameterTypes();<span class="comment">//通过方法获得参数泛型</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//第三步：遍历该方法的参数泛型</span></span><br><span class="line">        <span class="keyword">for</span> (Type genericParameterType : genericParameterTypes) &#123;</span><br><span class="line">            System.out.println(<span class="string">"方法参数类型"</span>+genericParameterType);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断该参数泛型是否为参数化类型，若是，则获取其中的实际类型参数</span></span><br><span class="line">            <span class="keyword">if</span>(genericParameterType <span class="keyword">instanceof</span> ParameterizedType)&#123; <span class="comment">//判断是不是参数化类型</span></span><br><span class="line">                Type[] actualTypeArguments = ((ParameterizedType) genericParameterType).getActualTypeArguments();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (Type actualTypeArgument : actualTypeArguments) &#123;</span><br><span class="line">                    System.out.println(actualTypeArgument);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"====================="</span>);</span><br><span class="line">        <span class="comment">//通过反射获取方法返回值泛型</span></span><br><span class="line">        method = User.class.getDeclaredMethod("test1",null);</span><br><span class="line">        Type genericReturnType = method.getGenericReturnType();<span class="comment">//通过方法获得返回值泛型</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(genericReturnType <span class="keyword">instanceof</span> ParameterizedType)&#123;</span><br><span class="line">            Type[] actualTypeArguments = ((ParameterizedType) genericReturnType).getActualTypeArguments();</span><br><span class="line">            <span class="keyword">for</span> (Type actualTypeArgument : actualTypeArguments) &#123;</span><br><span class="line">                System.out.println(actualTypeArgument);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我执行了test的方法啦"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Map&lt;String, String&gt; map,List&lt;String&gt; list)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我执行了test1的方法啦，内容是"</span> + map + list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、获取注解信息">2、获取注解信息</h2><p>在类上、字段和方法上的注解都可以通过反射进行读取，不过要注意抛出的异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zstu.sso;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">annotationTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException, NoSuchMethodException,</span></span><br><span class="line"><span class="function">            InstantiationException, IllegalAccessException, InvocationTargetException </span>&#123;</span><br><span class="line">        Class c1 = Class.forName(<span class="string">"com.zstu.sso.MyAnnotationClass"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过反射获取类的注解</span></span><br><span class="line">        Annotation[] classAnnotations = c1.getAnnotations();</span><br><span class="line">        <span class="keyword">for</span> (Annotation annotation : classAnnotations) &#123;</span><br><span class="line">            System.out.println(annotation); <span class="comment">//@com.zstu.sso.MyAnnotation(name=, value=这是类, age=0)</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得指定注解的value值</span></span><br><span class="line">        MyAnnotation classAnnotation = (MyAnnotation)c1.getAnnotation(MyAnnotation<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        String value = classAnnotation.value();</span><br><span class="line">        System.out.println(value); <span class="comment">//这是类</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得类内部字段的指定注解</span></span><br><span class="line">        Field field = c1.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line">        MyAnnotation fieldAnnotation = field.getAnnotation(MyAnnotation<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(fieldAnnotation.value());<span class="comment">//field</span></span><br><span class="line">        System.out.println(fieldAnnotation.age());<span class="comment">//18</span></span><br><span class="line">        System.out.println(fieldAnnotation.name());<span class="comment">//这是字段</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得类内部方法的指定注解</span></span><br><span class="line">        Method method = c1.getDeclaredMethod(<span class="string">"test"</span>);</span><br><span class="line">        MyAnnotation methodAnnotation = method.getAnnotation(MyAnnotation<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(methodAnnotation.value());<span class="comment">//method</span></span><br><span class="line">        System.out.println(methodAnnotation.age());<span class="comment">//18</span></span><br><span class="line">        System.out.println(methodAnnotation.name());<span class="comment">//这是方法</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁用访问安全检查的开关</span></span><br><span class="line">        method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        method.invoke(c1.newInstance());<span class="comment">// 运行了test方法</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认名字一般是value</span></span><br><span class="line"><span class="meta">@MyAnnotation</span>(<span class="string">"这是类"</span>)</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAnnotationClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MyAnnotation</span>(value = <span class="string">"field"</span>,name = <span class="string">"这是字段"</span>,age = <span class="number">18</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="comment">// 显示定义</span></span><br><span class="line">    <span class="meta">@MyAnnotation</span>(value = <span class="string">"method"</span>,name = <span class="string">"这是方法"</span>,age = <span class="number">18</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"运行了test方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义一个注解，其中用到了四个元注解</span></span><br><span class="line"><span class="meta">@Target</span>(value = &#123;ElementType.TYPE,ElementType.METHOD,ElementType.FIELD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(value = RetentionPolicy.RUNTIME) <span class="comment">//一般自定义注解，都选择RUNTIME;</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation&#123;</span><br><span class="line">    <span class="comment">// 参数类型，参数名</span></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">age</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>参考资料</p><p><a href="https://www.bilibili.com/video/BV1p4411P7V3" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1p4411P7V3</a></p>]]></content>
    
    
    <summary type="html">&lt;h1&gt;一、注解Annotation&lt;/h1&gt;
&lt;h2 id=&quot;1、注解介绍&quot;&gt;1、注解介绍&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Annotation 是从JDK5.0开始引入的新技术&lt;/li&gt;
&lt;li&gt;Annotation不是程序本身，但可以对程序作出解释(和注释差不多) ，也可以被其他程序(编译器等)读取&lt;/li&gt;
&lt;li&gt;Annotation注解是以&lt;code&gt;@注解名&lt;/code&gt;在代码中存在的，还可以添加一些参数值 , 例如:&lt;code&gt;@SuppressWarnings(value=&amp;quot;unchecked&amp;quot;)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Annotation可以附加在package , class , method , ﬁeld 等上面 , 相当于给他们添加了额外的辅助信息，我们可以通过反射机制实现对这些元数据的访问&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Java" scheme="https://www.shawn22.xyz/categories/Java/"/>
    
    
    <category term="Java基础" scheme="https://www.shawn22.xyz/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Vue Axios请求封装</title>
    <link href="https://www.shawn22.xyz/posts/cbf77484.html"/>
    <id>https://www.shawn22.xyz/posts/cbf77484.html</id>
    <published>2021-12-28T09:40:36.000Z</published>
    <updated>2021-12-28T09:58:52.040Z</updated>
    
    <content type="html"><![CDATA[<h1>一、介绍</h1><p>对axios进行封装以及将API接口按业务模块统一管理，有助于我们简化代码，方便后期维护；也可以方便的统一对请求API进行修改</p><a id="more"></a><h1>二、Vue实战</h1><blockquote><p><a href="https://javasoho.com/axios/index.html" target="_blank" rel="noopener">https://javasoho.com/axios/index.html</a><br><a href="https://github.com/axios/axios" target="_blank" rel="noopener">https://github.com/axios/axios</a></p></blockquote><p><img src="https://img-blog.csdnimg.cn/814b5e1a301e42a19d65ebd80dd62dc3.png" alt></p><h2 id="1、Axios全局配置文件">1、Axios全局配置文件</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Message &#125; <span class="keyword">from</span> <span class="string">'element-ui'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建axios实例</span></span><br><span class="line"><span class="keyword">const</span> service = axios.create(&#123;</span><br><span class="line">    baseURL: <span class="string">'http://localhost:8090'</span>, <span class="comment">// api 的 base_url</span></span><br><span class="line">    timeout: <span class="number">20000</span> <span class="comment">// 请求超时时间</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// request拦截器</span></span><br><span class="line">service.interceptors.request.use(</span><br><span class="line">    config =&gt; &#123;</span><br><span class="line">        <span class="comment">//每次请求之前判断vuex中是否存在token</span></span><br><span class="line">        <span class="comment">//如果存在，则统一在http请求的header上都加上token，以便后台根据token判断当前登陆情况</span></span><br><span class="line">        <span class="comment">//即使本地存在token，也有可能过期，所以需要对返回状态进行判断</span></span><br><span class="line">        <span class="keyword">const</span> token = localStorage.getItem(<span class="string">"token"</span>);</span><br><span class="line">        <span class="keyword">if</span> (token &amp;&amp; (config.headers.Authorization = token)) &#123;</span><br><span class="line">          config.headers[<span class="string">'Authorization'</span>] = token; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> config</span><br><span class="line">    &#125;,</span><br><span class="line">    error =&gt; &#123;</span><br><span class="line">        <span class="comment">// Do something with request error</span></span><br><span class="line">        <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// response 拦截器</span></span><br><span class="line">service.interceptors.response.use(</span><br><span class="line">    response =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> res = response.data</span><br><span class="line">        <span class="keyword">if</span> (res.code &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            Message(&#123;</span><br><span class="line">                message: res.message,</span><br><span class="line">                type: <span class="string">'error'</span>,</span><br><span class="line">                duration: <span class="number">5</span> * <span class="number">1000</span></span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="string">'error'</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 注意：这里务必要返回配置对象，否则请求就停在这里出不去了</span></span><br><span class="line">            <span class="keyword">return</span> response.data</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    error =&gt; &#123;</span><br><span class="line">        Message(&#123;</span><br><span class="line">            message: error.message,</span><br><span class="line">            type: <span class="string">'error'</span>,</span><br><span class="line">            duration: <span class="number">5</span> * <span class="number">1000</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">// 如果请求出错了（还没有发出去）会进入这里</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 响应拦截器</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> service</span><br></pre></td></tr></table></figure><h2 id="2、设置统一API管理">2、设置统一API管理</h2><p>这里注意的是@代表的是src目录，同时配置接口后要记得返回</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> request <span class="keyword">from</span> <span class="string">'@/utils/request'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//查询订单列表</span></span><br><span class="line">  list() &#123;</span><br><span class="line">    <span class="keyword">return</span> request(&#123;</span><br><span class="line">      url: <span class="string">'/api/order-info/list'</span>,</span><br><span class="line">      method: <span class="string">'get'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  queryOrderStatus(orderNo) &#123;</span><br><span class="line">    <span class="keyword">return</span> request(&#123;</span><br><span class="line">      url: <span class="string">'/api/order-info/query-order-status/'</span> + orderNo,</span><br><span class="line">      method: <span class="string">'get'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、业务逻辑">3、业务逻辑</h2><p>最后在业务逻辑处理页面进行调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> orderInfoApi <span class="keyword">from</span> <span class="string">"../api/orderInfo"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">methods: &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示订单列表</span></span><br><span class="line">    showOrderList()&#123;</span><br><span class="line">      orderInfoApi.list().then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.list = response.data.list;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1&gt;一、介绍&lt;/h1&gt;
&lt;p&gt;对axios进行封装以及将API接口按业务模块统一管理，有助于我们简化代码，方便后期维护；也可以方便的统一对请求API进行修改&lt;/p&gt;</summary>
    
    
    
    
    <category term="Vue" scheme="https://www.shawn22.xyz/tags/Vue/"/>
    
  </entry>
  
</feed>
