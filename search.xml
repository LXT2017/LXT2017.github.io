<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MyBatis源码分析</title>
    <url>/posts/9a55ed5d.html</url>
    <content><![CDATA[<h1>MyBatis源码分析</h1>
<h1>一、前言</h1>
<blockquote>
<p>MyBatis官方文档：<a href="https://mybatis.org/mybatis-3/zh/" target="_blank" rel="noopener">https://mybatis.org/mybatis-3/zh/</a></p>
</blockquote>
<h2 id="1、介绍">1、介绍</h2>
<p>对于MyBatis，其工作流程实际上分为两部分：<strong>第一，构建，也就是解析我们写的xml配置，将其变成它所需要的对象。第二，执行，在构建完成的基础上，去执行我们的SQL，完成与Jdbc的交互</strong></p>
<a id="more"></a>
<h2 id="2、快速上手">2、快速上手</h2>
<p>数据库配置如<a href="https://blog.csdn.net/lemon_TT/article/details/114846109" target="_blank" rel="noopener">Mybatis学习笔记</a>一样，我的项目结构如下图所示</p>
<p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/20220301/20220301215805.png" alt></p>
<p>创建<code>mybatis-config.xml</code>文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span> =<span class="string">"db.properties"</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 使用驼峰命名法 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"mapUnderscoreToCamelCase"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 开启日志--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"logImpl"</span> <span class="attr">value</span>=<span class="string">"STDOUT_LOGGING"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--别名设置，默认是包名，当然也可以每个路径名做一个别名映射 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"org.demo.po"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.driver&#125;"</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 将我们写好的sql映射文件（EmployeeMapper.xml）一定要注册到全局配置文件（mybatis-config.xml）中 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--这里填写resource下的路径--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"mappers/EmployeeMapper.xml"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>创建<code>db.properties</code>外部文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jdbc.driver=com.mysql.cj.jdbc.Driver</span><br><span class="line">jdbc.url=jdbc:mysql:<span class="comment">//localhost:3306/learnmybatis?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=root</span><br></pre></td></tr></table></figure>
<p>创建<code>EmployeeMapper.xml</code>文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这里修改自己的mapper --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"test"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--resultType别名大小写都可，因为最后会统一变成小写，同时源码已经内置了很多别名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getEmp"</span> <span class="attr">resultType</span>=<span class="string">"Employee"</span>&gt;</span></span><br><span class="line">        select * from employee</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>创建测试文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 加载mybatis框架主配置文件</span></span><br><span class="line">    String resource = <span class="string">"mybatis-config.xml"</span>;</span><br><span class="line">    InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">    <span class="comment">// 读取解析配置文件内容，创建SqlSessionFacory</span></span><br><span class="line">    SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">    <span class="comment">// 获取sqlSession对象</span></span><br><span class="line">    SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">    <span class="comment">// 这种操作不推荐，推荐使用mapper代理方式，后面有提到</span></span><br><span class="line">    <span class="comment">// 执行数据库操作</span></span><br><span class="line">    List&lt;Employee&gt; list = sqlSession.selectList(<span class="string">"test.getEmp"</span>);</span><br><span class="line">    System.out.println(list);</span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    sqlSession.close();</span><br><span class="line">    <span class="comment">// sqlSession.commit();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>二、Mybatis的构建</h1>
<h2 id="1、核心流程">1、核心流程</h2>
<h3 id="1-1-介绍">1.1 介绍</h3>
<p>Configuration 是整个MyBatis的配置体系集中管理中心，前面所学Executor、StatementHandler、Cache、MappedStatement…等绝大部分组件都是由它直接或间接的创建和管理。其主要作用如下</p>
<ul>
<li>存储全局配置信息，其来源于settings（设置）</li>
<li>初始化并维护全局基础组件
<ul>
<li>typeAliases（类型别名）</li>
<li>typeHandlers（类型处理器）</li>
<li>plugins（插件）</li>
<li>environments（环境配置）</li>
<li>cache(二级缓存空间)</li>
</ul>
</li>
<li>初始化并维护MappedStatement</li>
<li>组件构造器,并基于插件进行增强
<ul>
<li>newExecutor（执行器）</li>
<li>newStatementHandler（JDBC处理器）</li>
<li>newResultSetHandler（结果集处理器）</li>
<li>newParameterHandler（参数处理器）</li>
</ul>
</li>
</ul>
<p>Configuration 配置信息来源于xml和注解，每个文件和注解都是由若干个配置元素组成，并呈现嵌套关系，总体关系如下图所示，关于各配置的使用请参见官网给出文档：<a href="https://mybatis.org/mybatis-3/zh/configuration.html#properties" target="_blank" rel="noopener">https://mybatis.org/mybatis-3/zh/configuration.html#properties</a></p>
<p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/20220301/20220301215814.png" alt></p>
<p>无论是xml 注解这些配置元素最弱都要被转换成JAVA配置属性或对象组件来承载。其对应关系如下：</p>
<ul>
<li>全配置(config.xml) 由Configuration对像属性承载</li>
<li>sql映射&lt;select|insert…&gt; 或@Select 等由MappedStatement对象承载</li>
<li>缓存&lt;cache…&gt; 或@CacheNamespace 由Cache对象承载</li>
<li>结果集映射 由ResultMap 对象承载</li>
</ul>
<p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/20220301/20220301215817.png" alt></p>
<h3 id="1-2-配置文件解析">1.2 配置文件解析</h3>
<ul>
<li>XMLConfigBuilder :解析config.xml文件，会直接创建一个configuration对象，用于解析全局配置</li>
<li>XMLMapperBuilder ：解析Mapper.xml文件，内容包含等</li>
<li>MapperBuilderAssistant：Mapper.xml解析辅助，在一个Mapper.xml中Cache是对Statement（sql声明）共享的，共享组件的分配即由该解析实现</li>
<li>XMLStatementBuilder：SQL映射解析 即&lt;select|update|insert|delete&gt; 元素解析成MapperStatement</li>
<li>SqlSourceBuilder：Sql数据源解析,将声明的SQL解析可执行的SQL</li>
<li>XMLScriptBuilder：解析动态SQL数据源当中所设置 SqlNode脚本集</li>
</ul>
<p><strong>XML文件解析流程</strong></p>
<p>整体解析流程是从XmlConfigBuilder 开始，然后逐步向内解析，直到解析完所有节点。我们通过一个MappedStatement 解析过程即可了解到期整体解析流程</p>
<p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/20220301/20220301215820.png" alt></p>
<p><strong>注解配置解析</strong></p>
<p>注解解析底层实现是通过反射获取Mapper接口当中注解元素实现。有两种方式一种是直接指定接口名，一种是指定包名然后自动扫描包下所有的接口类。这些逻辑均由Mapper注册器(MapperRegistry)实现。其接收一个接口类参数，并基于该参数创建针对该接口的动态代理工厂，然后解析内部方法注解生成每个MapperStatement 最后添加至Configuration 完成解析。</p>
<p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/20220301/20220301215824.png" alt></p>
<h3 id="1-3-源码分析">1.3 源码分析</h3>
<p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/20220301/20220301215833.png" alt></p>
<p>进入build方法，可以看见代码将xml文件传入并返回了一个SqlSessionFactory对象，而这个对象是使用构造者模式创建的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(InputStream inputStream, String environment, Properties properties)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 开始解析配置文件，这里先生产一个解析对象</span></span><br><span class="line">    XMLConfigBuilder parser = <span class="keyword">new</span> XMLConfigBuilder(inputStream, environment, properties);</span><br><span class="line">    <span class="keyword">return</span> build(parser.parse());</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error building SqlSession."</span>, e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ErrorContext.instance().reset();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      inputStream.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      <span class="comment">// Intentionally ignore. Prefer previous error.</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在进入build对象的<code>parse()</code>方法，<strong>这个方法初始化Configuration对象，并且解析xml文件，把解析内容放入到Configuration对象中</strong>。其中就包括别名的映射，在初始化阶段别名映射会自动注册一些常用的别名，如果我们自己也配置也自动注册到Configuration对象的TypeAliasRegistry的TYPE_ALIASES的map中，并且把数据源和事务解析以后放入到Environment，给后续的执行提供数据链接和事务管理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Configuration <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//查看该文件是否已经解析过</span></span><br><span class="line">  <span class="keyword">if</span> (parsed) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Each XMLConfigBuilder can only be used once."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果没有解析过，则继续往下解析，并且将标识符置为true</span></span><br><span class="line">  parsed = <span class="keyword">true</span>;</span><br><span class="line">  <span class="comment">//解析&lt;configuration&gt;节点，即从根节点开始解析，名字必须是configuration</span></span><br><span class="line">  parseConfiguration(parser.evalNode(<span class="string">"/configuration"</span>));</span><br><span class="line">  <span class="keyword">return</span> configuration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在进入<code>parseConfiguration()</code>方法，可以看到这个方法已经在解析<code>&lt;configuration&gt;</code>下的节点了，例如<code>&lt;settings&gt;</code>,<code>&lt;typeAliases&gt;</code>,<code>&lt;environments&gt;</code>和<code>&lt;mappers&gt;</code>等，同时返回了<code>Configuration</code>对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// root即是完整的xml内容</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseConfiguration</span><span class="params">(XNode root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//解析&lt;Configuration&gt;下的节点</span></span><br><span class="line">    propertiesElement(root.evalNode(<span class="string">"properties"</span>));</span><br><span class="line">    <span class="comment">//&lt;settings&gt;</span></span><br><span class="line">    Properties settings = settingsAsProperties(root.evalNode(<span class="string">"settings"</span>));</span><br><span class="line">    loadCustomVfs(settings);</span><br><span class="line">    loadCustomLogImpl(settings);</span><br><span class="line">    <span class="comment">// 别名&lt;typeAliases&gt;解析</span></span><br><span class="line">    <span class="comment">// 所谓别名其实就是把你指定的别名对应的class存储在一个Map当中</span></span><br><span class="line">    typeAliasesElement(root.evalNode(<span class="string">"typeAliases"</span>));</span><br><span class="line">    <span class="comment">//插件 &lt;plugins&gt;</span></span><br><span class="line">    pluginElement(root.evalNode(<span class="string">"plugins"</span>));</span><br><span class="line">    <span class="comment">//自定义实例化对象的行为&lt;objectFactory&gt;</span></span><br><span class="line">    objectFactoryElement(root.evalNode(<span class="string">"objectFactory"</span>));</span><br><span class="line">    <span class="comment">//MateObject   方便反射操作实体类的对象</span></span><br><span class="line">    objectWrapperFactoryElement(root.evalNode(<span class="string">"objectWrapperFactory"</span>));</span><br><span class="line">    reflectorFactoryElement(root.evalNode(<span class="string">"reflectorFactory"</span>));</span><br><span class="line">    settingsElement(settings);</span><br><span class="line">    <span class="comment">// read it after objectFactory and objectWrapperFactory issue #631</span></span><br><span class="line">    <span class="comment">//&lt;environments&gt;</span></span><br><span class="line">    environmentsElement(root.evalNode(<span class="string">"environments"</span>));</span><br><span class="line">    databaseIdProviderElement(root.evalNode(<span class="string">"databaseIdProvider"</span>));</span><br><span class="line">    <span class="comment">// typeHandlers</span></span><br><span class="line">    typeHandlerElement(root.evalNode(<span class="string">"typeHandlers"</span>));</span><br><span class="line">    <span class="comment">//主要 &lt;mappers&gt; 指向我们存放SQL的xxxxMapper.xml文件</span></span><br><span class="line">    mapperElement(root.evalNode(<span class="string">"mappers"</span>));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Error parsing SQL Mapper Configuration. Cause: "</span> + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2、Configuration对象详解">2、Configuration对象详解</h2>
<h3 id="2-1-配置文件dataSource-内容替换">2.1 配置文件dataSource 内容替换</h3>
<p>对于<code>db.properties</code>替代，在<code>parseConfiguration()</code>方法中的<code>propertiesElement(root.evalNode(&quot;properties&quot;));</code>就是对外部配置文件的替换修改，它首先形成Properties对象对其替换</p>
<p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/20220301/20220301215837.png" alt></p>
<h3 id="2-2-typeAliasesElement别名设置">2.2 typeAliasesElement别名设置</h3>
<p>Mybatis别名设置若存在<package>标签，则mapper.xml别名默认是类名(忽略大小写)，同时将其存放于<code>TYPE_ALIASES</code>这个HashMap中，同时里面已经存在很多内置别名，可以直接使用</package></p>
<p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/20220301/20220301215840.png" alt></p>
<p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/20220301/20220301215844.png" alt></p>
<h3 id="2-3-数据库相关内容载入">2.3 数据库相关内容载入</h3>
<p><code>environmentsElement(root.evalNode(&quot;environments&quot;));</code>方法将数据库相关信息配置(例如事务，数据库账号密码等)存入enviroment对象，最终和configuration相关联存入其对象中</p>
<p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/20220301/20220301215846.png" alt></p>
<h3 id="2-4-mapper解析-重要✨">2.4 mapper解析(重要✨)</h3>
<p><code>mybatis-config.xml</code>文件中我们一定会写一个叫做<mappers>的标签，这个标签中的<code>&lt;mapper&gt;</code>节点存放了我们对数据库进行操作的SQL语句，这里就详细详解一下mapper的执行过程</mappers></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 通过包名，这里要求xml和mapoper包在同一包下 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"org.demo.po"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 通过配置文件路径，多个文件可以通过*Mapper.xml通配符 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"mappers/EmployeeMapper.xml"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 通过Java全限定类名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">"org.demo.mapper.EmployeeMapper.java"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 通过url 通常是mapper不在本地时用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">url</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这是<code>&lt;mappers&gt;</code>标签的几种配置方式，通过这几种配置方式，可以帮助我们更容易理解mappers的解析</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mapperElement</span><span class="params">(XNode parent)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//遍历解析mappers下的节点</span></span><br><span class="line">      <span class="keyword">for</span> (XNode child : parent.getChildren()) &#123;</span><br><span class="line">      <span class="comment">//首先解析package节点</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="string">"package"</span>.equals(child.getName())) &#123;</span><br><span class="line">        <span class="comment">//获取包名</span></span><br><span class="line">        String mapperPackage = child.getStringAttribute(<span class="string">"name"</span>);</span><br><span class="line">        configuration.addMappers(mapperPackage);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果不存在package节点，那么扫描mapper节点</span></span><br><span class="line">        <span class="comment">//resource/url/mapperClass三个值只能有一个值是有值的</span></span><br><span class="line">        String resource = child.getStringAttribute(<span class="string">"resource"</span>);</span><br><span class="line">        String url = child.getStringAttribute(<span class="string">"url"</span>);</span><br><span class="line">        String mapperClass = child.getStringAttribute(<span class="string">"class"</span>);</span><br><span class="line">        <span class="comment">//优先级 resource&gt;url&gt;mapperClass</span></span><br><span class="line">        <span class="keyword">if</span> (resource != <span class="keyword">null</span> &amp;&amp; url == <span class="keyword">null</span> &amp;&amp; mapperClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果mapper节点中的resource不为空</span></span><br><span class="line">          ErrorContext.instance().resource(resource);</span><br><span class="line">           <span class="comment">//那么直接加载resource指向的XXXMapper.xml文件为字节流</span></span><br><span class="line">          InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">          <span class="comment">//通过XMLMapperBuilder解析XXXMapper.xml，可以看到这里构建的XMLMapperBuilde还传入了configuration,所以之后肯定是会将mapper封装到configuration对象中去的。</span></span><br><span class="line">          XMLMapperBuilder mapperParser = <span class="keyword">new</span> XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());</span><br><span class="line">          <span class="comment">//解析</span></span><br><span class="line">          mapperParser.parse();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resource == <span class="keyword">null</span> &amp;&amp; url != <span class="keyword">null</span> &amp;&amp; mapperClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">//如果url!=null，那么通过url解析</span></span><br><span class="line">          ErrorContext.instance().resource(url);</span><br><span class="line">          InputStream inputStream = Resources.getUrlAsStream(url);</span><br><span class="line">          XMLMapperBuilder mapperParser = <span class="keyword">new</span> XMLMapperBuilder(inputStream, configuration, url, configuration.getSqlFragments());</span><br><span class="line">          mapperParser.parse();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resource == <span class="keyword">null</span> &amp;&amp; url == <span class="keyword">null</span> &amp;&amp; mapperClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果mapperClass!=null，那么通过加载类构造Configuration</span></span><br><span class="line">          Class&lt;?&gt; mapperInterface = Resources.classForName(mapperClass);</span><br><span class="line">          configuration.addMapper(mapperInterface);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果都不满足  则直接抛异常  如果配置了两个或三个  直接抛异常</span></span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"A mapper element may only specify a url, resource or class, but not more than one."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/20220301/20220301215854.png" alt></p>
<p>我们的配置文件中写的是通过resource来加载<code>mapper.xml</code>的，所以会通过<code>XMLMapperBuilder</code>来进行解析，我们在进去它的<code>parse()</code>方法。在这个parse()方法中，调用了一个<code>configuationElement</code>代码，用于解析<code>XXXMapper.xml</code>文件中的各种节点，包括<code>&lt;cache&gt;</code>、<code>&lt;cache-ref&gt;</code>、<code>&lt;paramaterMap&gt;</code>（已过时）、<code>&lt;resultMap&gt;</code>、<code>&lt;sql&gt;</code>、还有增删改查节点，和上面相同的是，我们也挑一个主要的来说，因为解析过程都大同小异。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//判断文件是否之前解析过</span></span><br><span class="line">  <span class="keyword">if</span> (!configuration.isResourceLoaded(resource)) &#123;</span><br><span class="line">      <span class="comment">//解析mapper文件节点（主要）(下面贴了代码)</span></span><br><span class="line">    configurationElement(parser.evalNode(<span class="string">"/mapper"</span>));</span><br><span class="line">    configuration.addLoadedResource(resource);</span><br><span class="line">    <span class="comment">//绑定Namespace里面的Class对象</span></span><br><span class="line">    bindMapperForNamespace();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//重新解析之前解析不了的节点，先不看，最后填坑。</span></span><br><span class="line">  parsePendingResultMaps();</span><br><span class="line">  parsePendingCacheRefs();</span><br><span class="line">  parsePendingStatements();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//解析mapper文件里面的节点</span></span><br><span class="line"><span class="comment">// 拿到里面配置的配置项 最终封装成一个MapperedStatemanet</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">configurationElement</span><span class="params">(XNode context)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//获取命名空间 namespace，这个很重要，后期mybatis会通过这个动态代理我们的Mapper接口</span></span><br><span class="line">    String namespace = context.getStringAttribute(<span class="string">"namespace"</span>);</span><br><span class="line">    <span class="keyword">if</span> (namespace == <span class="keyword">null</span> || namespace.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">        <span class="comment">//如果namespace为空则抛一个异常</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Mapper's namespace cannot be empty"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    builderAssistant.setCurrentNamespace(namespace);</span><br><span class="line">    <span class="comment">//解析缓存节点</span></span><br><span class="line">    cacheRefElement(context.evalNode(<span class="string">"cache-ref"</span>));</span><br><span class="line">    cacheElement(context.evalNode(<span class="string">"cache"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析parameterMap（过时）和resultMap  &lt;resultMap&gt;&lt;/resultMap&gt;</span></span><br><span class="line">    parameterMapElement(context.evalNodes(<span class="string">"/mapper/parameterMap"</span>));</span><br><span class="line">    resultMapElements(context.evalNodes(<span class="string">"/mapper/resultMap"</span>));</span><br><span class="line">    <span class="comment">//解析&lt;sql&gt;节点 </span></span><br><span class="line">    <span class="comment">//&lt;sql id="staticSql"&gt;select * from test&lt;/sql&gt; （可重用的代码段）</span></span><br><span class="line">    <span class="comment">//&lt;select&gt; &lt;include refid="staticSql"&gt;&lt;/select&gt;</span></span><br><span class="line">    sqlElement(context.evalNodes(<span class="string">"/mapper/sql"</span>));</span><br><span class="line">    <span class="comment">//解析增删改查节点&lt;select&gt; &lt;insert&gt; &lt;update&gt; &lt;delete&gt;</span></span><br><span class="line">    buildStatementFromContext(context.evalNodes(<span class="string">"select|insert|update|delete"</span>));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Error parsing Mapper XML. The XML location is '"</span> + resource + <span class="string">"'. Cause: "</span> + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里解析其中一项举例，解析增删改查节点<select> <insert> <update> <delete>，进入<code>buildStatementFromContext(context.evalNodes(&quot;select|insert|update|delete&quot;));</code>方法</delete></update></insert></select></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildStatementFromContext</span><span class="params">(List&lt;XNode&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (configuration.getDatabaseId() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      buildStatementFromContext(list, configuration.getDatabaseId());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//解析xml</span></span><br><span class="line">    buildStatementFromContext(list, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildStatementFromContext</span><span class="params">(List&lt;XNode&gt; list, String requiredDatabaseId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (XNode context : list) &#123;</span><br><span class="line">    <span class="keyword">final</span> XMLStatementBuilder statementParser = <span class="keyword">new</span> XMLStatementBuilder(configuration, builderAssistant, context, requiredDatabaseId);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//解析xml节点</span></span><br><span class="line">      statementParser.parseStatementNode();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IncompleteElementException e) &#123;</span><br><span class="line">      <span class="comment">//xml语句有问题时 存储到集合中 等解析完能解析的再重新解析</span></span><br><span class="line">      configuration.addIncompleteStatement(statementParser);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进入<code>statementParser.parseStatementNode();</code>方法，解析里面的xml节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseStatementNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取&lt;select id="xxx"&gt;中的id</span></span><br><span class="line">    String id = context.getStringAttribute(<span class="string">"id"</span>);</span><br><span class="line">    <span class="comment">//获取databaseId 用于多数据库，这里为null</span></span><br><span class="line">    String databaseId = context.getStringAttribute(<span class="string">"databaseId"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!databaseIdMatchesCurrent(id, databaseId, <span class="keyword">this</span>.requiredDatabaseId)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取节点名  select update delete insert</span></span><br><span class="line">    String nodeName = context.getNode().getNodeName();</span><br><span class="line">    <span class="comment">//根据节点名，得到SQL操作的类型</span></span><br><span class="line">    SqlCommandType sqlCommandType = SqlCommandType.valueOf(nodeName.toUpperCase(Locale.ENGLISH));</span><br><span class="line">    <span class="comment">//判断是否是查询</span></span><br><span class="line">    <span class="keyword">boolean</span> isSelect = sqlCommandType == SqlCommandType.SELECT;</span><br><span class="line">    <span class="comment">//是否刷新缓存 默认:增删改刷新 查询不刷新</span></span><br><span class="line">    <span class="keyword">boolean</span> flushCache = context.getBooleanAttribute(<span class="string">"flushCache"</span>, !isSelect);</span><br><span class="line">    <span class="comment">//是否使用二级缓存 默认值:查询使用 增删改不使用</span></span><br><span class="line">    <span class="keyword">boolean</span> useCache = context.getBooleanAttribute(<span class="string">"useCache"</span>, isSelect);</span><br><span class="line">    <span class="comment">//是否需要处理嵌套查询结果 group by</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 三组数据 分成一个嵌套的查询结果</span></span><br><span class="line">    <span class="keyword">boolean</span> resultOrdered = context.getBooleanAttribute(<span class="string">"resultOrdered"</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Include Fragments before parsing</span></span><br><span class="line">    XMLIncludeTransformer includeParser = <span class="keyword">new</span> XMLIncludeTransformer(configuration, builderAssistant);</span><br><span class="line">    <span class="comment">//替换Includes标签为对应的sql标签里面的值</span></span><br><span class="line">    includeParser.applyIncludes(context.getNode());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取parameterType名</span></span><br><span class="line">    String parameterType = context.getStringAttribute(<span class="string">"parameterType"</span>);</span><br><span class="line">    <span class="comment">//获取parameterType的Class</span></span><br><span class="line">    Class&lt;?&gt; parameterTypeClass = resolveClass(parameterType);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析配置的自定义脚本语言驱动 这里为null</span></span><br><span class="line">    String lang = context.getStringAttribute(<span class="string">"lang"</span>);</span><br><span class="line">    LanguageDriver langDriver = getLanguageDriver(lang);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parse selectKey after includes and remove them.</span></span><br><span class="line">    <span class="comment">//解析selectKey</span></span><br><span class="line">    processSelectKeyNodes(id, parameterTypeClass, langDriver);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parse the SQL (pre: &lt;selectKey&gt; and &lt;include&gt; were parsed and removed)</span></span><br><span class="line">    <span class="comment">//设置主键自增规则</span></span><br><span class="line">    KeyGenerator keyGenerator;</span><br><span class="line">    String keyStatementId = id + SelectKeyGenerator.SELECT_KEY_SUFFIX;</span><br><span class="line">    keyStatementId = builderAssistant.applyCurrentNamespace(keyStatementId, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (configuration.hasKeyGenerator(keyStatementId)) &#123;</span><br><span class="line">        keyGenerator = configuration.getKeyGenerator(keyStatementId);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        keyGenerator = context.getBooleanAttribute(<span class="string">"useGeneratedKeys"</span>,</span><br><span class="line">                configuration.isUseGeneratedKeys() &amp;&amp; SqlCommandType.INSERT.equals(sqlCommandType))</span><br><span class="line">                ? Jdbc3KeyGenerator.INSTANCE : NoKeyGenerator.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/************************************************************************************/</span></span><br><span class="line">    <span class="comment">//解析Sql（重要）  根据sql文本来判断是否需要动态解析 如果没有动态sql语句且 只有#&#123;&#125;的时候 直接静态解析使用?占位 当有 $&#123;&#125; 不解析</span></span><br><span class="line">    SqlSource sqlSource = langDriver.createSqlSource(configuration, context, parameterTypeClass);</span><br><span class="line">    <span class="comment">//获取StatementType，可以理解为Statement和PreparedStatement</span></span><br><span class="line">    StatementType statementType = StatementType.valueOf(context.getStringAttribute(<span class="string">"statementType"</span>, StatementType.PREPARED.toString()));</span><br><span class="line">    <span class="comment">//没用过</span></span><br><span class="line">    Integer fetchSize = context.getIntAttribute(<span class="string">"fetchSize"</span>);</span><br><span class="line">    <span class="comment">//超时时间</span></span><br><span class="line">    Integer timeout = context.getIntAttribute(<span class="string">"timeout"</span>);</span><br><span class="line">    <span class="comment">//已过时</span></span><br><span class="line">    String parameterMap = context.getStringAttribute(<span class="string">"parameterMap"</span>);</span><br><span class="line">    <span class="comment">//获取返回值类型名</span></span><br><span class="line">    String resultType = context.getStringAttribute(<span class="string">"resultType"</span>);</span><br><span class="line">    <span class="comment">//获取返回值烈性的Class</span></span><br><span class="line">    Class&lt;?&gt; resultTypeClass = resolveClass(resultType);</span><br><span class="line">    <span class="comment">//获取resultMap的id</span></span><br><span class="line">    String resultMap = context.getStringAttribute(<span class="string">"resultMap"</span>);</span><br><span class="line">    <span class="comment">//获取结果集类型</span></span><br><span class="line">    String resultSetType = context.getStringAttribute(<span class="string">"resultSetType"</span>);</span><br><span class="line">    ResultSetType resultSetTypeEnum = resolveResultSetType(resultSetType);</span><br><span class="line">    <span class="keyword">if</span> (resultSetTypeEnum == <span class="keyword">null</span>) &#123;</span><br><span class="line">        resultSetTypeEnum = configuration.getDefaultResultSetType();</span><br><span class="line">    &#125;</span><br><span class="line">    String keyProperty = context.getStringAttribute(<span class="string">"keyProperty"</span>);</span><br><span class="line">    String keyColumn = context.getStringAttribute(<span class="string">"keyColumn"</span>);</span><br><span class="line">    String resultSets = context.getStringAttribute(<span class="string">"resultSets"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将刚才获取到的属性，封装成MappedStatement对象（代码贴在下面）</span></span><br><span class="line">    builderAssistant.addMappedStatement(id, sqlSource, statementType, sqlCommandType,</span><br><span class="line">            fetchSize, timeout, parameterMap, parameterTypeClass, resultMap, resultTypeClass,</span><br><span class="line">            resultSetTypeEnum, flushCache, useCache, resultOrdered,</span><br><span class="line">            keyGenerator, keyProperty, keyColumn, databaseId, langDriver, resultSets);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体的MappedStatement对象，这里每一个方法id对应存储一个MappedStatement对象，这样在执行的时候就可以直接通过id获得映射的MappedStatement对象了，即可以直接执行获取mysql结果了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将刚才获取到的属性，封装成MappedStatement对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MappedStatement <span class="title">addMappedStatement</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        String id,</span></span></span><br><span class="line"><span class="function"><span class="params">        SqlSource sqlSource,</span></span></span><br><span class="line"><span class="function"><span class="params">        StatementType statementType,</span></span></span><br><span class="line"><span class="function"><span class="params">        SqlCommandType sqlCommandType,</span></span></span><br><span class="line"><span class="function"><span class="params">        Integer fetchSize,</span></span></span><br><span class="line"><span class="function"><span class="params">        Integer timeout,</span></span></span><br><span class="line"><span class="function"><span class="params">        String parameterMap,</span></span></span><br><span class="line"><span class="function"><span class="params">        Class&lt;?&gt; parameterType,</span></span></span><br><span class="line"><span class="function"><span class="params">        String resultMap,</span></span></span><br><span class="line"><span class="function"><span class="params">        Class&lt;?&gt; resultType,</span></span></span><br><span class="line"><span class="function"><span class="params">        ResultSetType resultSetType,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> flushCache,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> useCache,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> resultOrdered,</span></span></span><br><span class="line"><span class="function"><span class="params">        KeyGenerator keyGenerator,</span></span></span><br><span class="line"><span class="function"><span class="params">        String keyProperty,</span></span></span><br><span class="line"><span class="function"><span class="params">        String keyColumn,</span></span></span><br><span class="line"><span class="function"><span class="params">        String databaseId,</span></span></span><br><span class="line"><span class="function"><span class="params">        LanguageDriver lang,</span></span></span><br><span class="line"><span class="function"><span class="params">        String resultSets)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unresolvedCacheRef) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IncompleteElementException(<span class="string">"Cache-ref not yet resolved"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//id = namespace</span></span><br><span class="line">    id = applyCurrentNamespace(id, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">boolean</span> isSelect = sqlCommandType == SqlCommandType.SELECT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过构造者模式+链式变成，构造一个MappedStatement的构造者</span></span><br><span class="line">    MappedStatement.Builder statementBuilder = <span class="keyword">new</span> MappedStatement.Builder(configuration, id, sqlSource, sqlCommandType)</span><br><span class="line">            .resource(resource)</span><br><span class="line">            .fetchSize(fetchSize)</span><br><span class="line">            .timeout(timeout)</span><br><span class="line">            .statementType(statementType)</span><br><span class="line">            .keyGenerator(keyGenerator)</span><br><span class="line">            .keyProperty(keyProperty)</span><br><span class="line">            .keyColumn(keyColumn)</span><br><span class="line">            .databaseId(databaseId)</span><br><span class="line">            .lang(lang)</span><br><span class="line">            .resultOrdered(resultOrdered)</span><br><span class="line">            .resultSets(resultSets)</span><br><span class="line">            .resultMaps(getStatementResultMaps(resultMap, resultType, id))</span><br><span class="line">            .resultSetType(resultSetType)</span><br><span class="line">            .flushCacheRequired(valueOrDefault(flushCache, !isSelect))</span><br><span class="line">            .useCache(valueOrDefault(useCache, isSelect))</span><br><span class="line">            .cache(currentCache);</span><br><span class="line"></span><br><span class="line">    ParameterMap statementParameterMap = getStatementParameterMap(parameterMap, parameterType, id);</span><br><span class="line">    <span class="keyword">if</span> (statementParameterMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">        statementBuilder.parameterMap(statementParameterMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过构造者构造MappedStatement</span></span><br><span class="line">    MappedStatement statement = statementBuilder.build();</span><br><span class="line">    <span class="comment">//将MappedStatement对象封装到Configuration对象中</span></span><br><span class="line">    configuration.addMappedStatement(statement);</span><br><span class="line">    <span class="keyword">return</span> statement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/20220301/20220301215905.png" alt></p>
<h2 id="3、动态SQL构建">3、动态SQL构建</h2>
<h3 id="3-1-动态SQL解析">3.1 动态SQL解析</h3>
<ul>
<li>if</li>
<li>choose (when, otherwise)</li>
<li>trim (where, set)</li>
<li>foreach</li>
</ul>
<p><strong>OGNL表达示</strong></p>
<p>OGNL全称是对象导航图语言(Object Graph Navigation Language)是一种JAVA表达示语言，可以方便的存取对象属和方法，已用于逻辑判断。其支持<strong>以下特性</strong>：获取属性属性值，以及子属性值进行逻辑计；表达示中可直接调用方法(如果是无参方法，可以省略括号)；通过下标访问数组或集合；遍历集合</p>
<h3 id="3-2-动态SQL脚本">3.2 动态SQL脚本</h3>
<p>每个动态元素都会有一个与之对应的脚本类，即会产生许多SqlNode脚本如<code>if</code> 对应<code>ifSqlNode</code>、<code>forEarch</code>对应<code>ForEachSqlNode</code> 以此类推下去。同时脚本之间是呈现嵌套关系的，比如<code>if</code>元素中会包含一个<code>MixedSqlNode</code> ，而<code>MixedSqlNode</code>下又会包含1至1至多个其它节点，最后组成一课脚本语法树。最后SqlNode的接口非常简单，就只有一个<code>apply</code>方法，方法的作用就是执行当前脚本节点逻辑，并把结果应用到<code>DynamicContext</code>当中去。</p>
<p>这里要注意下面三个脚本</p>
<ul>
<li><code>StaticTextSqlNode</code> 表示一段纯静态文本如： <code>select * from user</code></li>
<li><code>TextSqlNode</code> 表示一个通过参数拼装的文本如：<code>select * from ${user}</code></li>
<li><code>MixedSqlNode</code> 表示多个节点的集合</li>
</ul>
<p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/20220301/20220301215908.png" alt></p>
<h3 id="3-3-SqlSource（SQL数据源）">3.3 SqlSource（SQL数据源）</h3>
<p>SqlSource 是基于XML解析而来，解析的底层是使用Dom4j 把XML解析成一个个子节点，在通过 <strong>XMLScriptBuilder</strong> 遍历这些子节点最后生成对应的Sql源。在上层定义上每个Sql映射（MappedStatement）中都会包含一个SqlSource 用来获取可执行Sql（<code>BoundSql</code>）。SqlSource又分为原生SQL源与动态SQL源，以及第三方源</p>
<p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/20220301/20220301215911.png" alt></p>
<ul>
<li>roviderSqlSource ：第三方法SQL源，每次获取SQL都会基于参数动态创建静态数据源，然后在创建BoundSql</li>
<li>DynamicSqlSource：动态SQL源包含了SQL脚本，每次获取SQL都会基于参数又及脚本，动态创建创建BoundSql</li>
<li>RawSqlSource：不包含任何动态元素，原生文本的SQL。但这个SQL是不能直接执行的，需要转换成BoundSql</li>
<li>StaticSqlSource：包含可执行的SQL，以及参数映射，可直接生成BoundSql。前面三个数据源都要先创建StaticSqlSource然后才创建BoundSql</li>
</ul>
<h3 id="3-4-源码流程">3.4 源码流程</h3>
<p>生成SQL语句代码，首先这里会通过<code>&lt;select&gt;</code>节点获取到我们的SQL语句，假设SQL语句中只有<code>${}</code>，那么直接就什么都不做，在运行的时候直接进行赋值。而如果扫描到了<code>#{}</code>字符串之后，会进行替换，将<code>#{}</code>替换为 <code>?</code>。</p>
<p>这里会生成一个GenericTokenParser，这个对象可以传入一个openToken和closeToken，如果是<code>#{}</code>，那么openToken就是<code>#{</code>，closeToken就是 <code>}</code>，然后通过parse方法中的<code>handler.handleToken()</code>方法进行替换。在这之前由于已经进行过SQL是否含有<code>#{}</code>的判断了，所以在这里如果是只有<code>${}</code>，那么handler就是BindingTokenParser的实例化对象，如果存在<code>#{}</code>，那么handler就是<code>ParameterMappingTokenHandler</code>的实例化对象。</p>
<p><code>mapperElement()</code> &gt; <code>mapperParser.parse()</code>  &gt; 进入XMLMapperBuilder类 <code>configurationElement() </code>&gt; <code>buildStatementFromContext()</code> &gt; <code>buildStatementFromContext()</code> &gt; <code>statementParser.parseStatementNode();</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//XMLStatementBuilder类parseStatementNode方法</span></span><br><span class="line"><span class="comment">//解析Sql（重要）根据sql文本来判断是否需要动态解析 如果没有动态sql语句且 只有#&#123;&#125;的时候 直接静态解析使用?占位 当有 $&#123;&#125; 不解析</span></span><br><span class="line">SqlSource sqlSource = langDriver.createSqlSource(configuration, context, parameterTypeClass);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*进入createSqlSource方法*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SqlSource <span class="title">createSqlSource</span><span class="params">(Configuration configuration, XNode script, Class&lt;?&gt; parameterType)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//进入这个构造</span></span><br><span class="line">    XMLScriptBuilder builder = <span class="keyword">new</span> XMLScriptBuilder(configuration, script, parameterType);</span><br><span class="line">    <span class="comment">//进入parseScriptNode</span></span><br><span class="line">    <span class="keyword">return</span> builder.parseScriptNode();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">进入这个方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SqlSource <span class="title">parseScriptNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//#</span></span><br><span class="line">    <span class="comment">//会先解析一遍</span></span><br><span class="line">    MixedSqlNode rootSqlNode = parseDynamicTags(context);</span><br><span class="line">    SqlSource sqlSource;</span><br><span class="line">    <span class="keyword">if</span> (isDynamic) &#123;</span><br><span class="line">      <span class="comment">//如果是$&#123;&#125;会直接不解析，等待执行的时候直接赋值</span></span><br><span class="line">      sqlSource = <span class="keyword">new</span> DynamicSqlSource(configuration, rootSqlNode);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//用占位符方式来解析  #&#123;&#125; --&gt; ?</span></span><br><span class="line">      sqlSource = <span class="keyword">new</span> RawSqlSource(configuration, rootSqlNode, parameterType);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sqlSource;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> MixedSqlNode <span class="title">parseDynamicTags</span><span class="params">(XNode node)</span> </span>&#123;</span><br><span class="line">    List&lt;SqlNode&gt; contents = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//获取select标签下的子标签</span></span><br><span class="line">    NodeList children = node.getNode().getChildNodes();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; children.getLength(); i++) &#123;</span><br><span class="line">      XNode child = node.newXNode(children.item(i));</span><br><span class="line">      <span class="keyword">if</span> (child.getNode().getNodeType() == Node.CDATA_SECTION_NODE || child.getNode().getNodeType() == Node.TEXT_NODE) &#123;</span><br><span class="line">          <span class="comment">//如果是查询</span></span><br><span class="line">        <span class="comment">//获取原生SQL语句 这里是 select * from test where id = #&#123;id&#125;</span></span><br><span class="line">        String data = child.getStringBody(<span class="string">""</span>);</span><br><span class="line">        TextSqlNode textSqlNode = <span class="keyword">new</span> TextSqlNode(data);</span><br><span class="line">        <span class="comment">//检查sql是否是$&#123;&#125;</span></span><br><span class="line">        <span class="keyword">if</span> (textSqlNode.isDynamic()) &#123;</span><br><span class="line">            <span class="comment">//如果是$&#123;&#125;那么直接不解析</span></span><br><span class="line">          contents.add(textSqlNode);</span><br><span class="line">          isDynamic = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果不是，则直接生成静态SQL</span></span><br><span class="line">            <span class="comment">//#&#123;&#125; -&gt; ?</span></span><br><span class="line">          contents.add(<span class="keyword">new</span> StaticTextSqlNode(data));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (child.getNode().getNodeType() == Node.ELEMENT_NODE) &#123; <span class="comment">// issue #628</span></span><br><span class="line">          <span class="comment">//如果是增删改</span></span><br><span class="line">        String nodeName = child.getNode().getNodeName();</span><br><span class="line">        NodeHandler handler = nodeHandlerMap.get(nodeName);</span><br><span class="line">        <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Unknown element &lt;"</span> + nodeName + <span class="string">"&gt; in SQL statement."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        handler.handleNode(child, contents);</span><br><span class="line">        isDynamic = <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MixedSqlNode(contents);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>进入<code>sqlSource = new RawSqlSource()</code>&gt;<code>sqlSourceParser.parse()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*从上面的代码段到这一段中间需要经过很多代码，就不一段一段贴了*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SqlSource <span class="title">parse</span><span class="params">(String originalSql, Class&lt;?&gt; parameterType, Map&lt;String, Object&gt; additionalParameters)</span> </span>&#123;</span><br><span class="line">    ParameterMappingTokenHandler handler = <span class="keyword">new</span> ParameterMappingTokenHandler(configuration, parameterType, additionalParameters);</span><br><span class="line">    <span class="comment">//这里会生成一个GenericTokenParser，传入#&#123;&#125;作为开始和结束，然后调用其parse方法，即可将#&#123;&#125;换为 ?</span></span><br><span class="line">    GenericTokenParser parser = <span class="keyword">new</span> GenericTokenParser(<span class="string">"#&#123;"</span>, <span class="string">"&#125;"</span>, handler);</span><br><span class="line">    <span class="comment">//这里可以解析#&#123;&#125; 将其替换为?</span></span><br><span class="line">    String sql = parser.parse(originalSql);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StaticSqlSource(configuration, sql, handler.getParameterMappings());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//经过一段复杂的解析过程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">parse</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (text == <span class="keyword">null</span> || text.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// search open token</span></span><br><span class="line">    <span class="keyword">int</span> start = text.indexOf(openToken);</span><br><span class="line">    <span class="keyword">if</span> (start == -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> text;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>[] src = text.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> offset = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span> StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    StringBuilder expression = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//遍历里面所有的#&#123;&#125; select ?  ,#&#123;id1&#125; $&#123;&#125;</span></span><br><span class="line">    <span class="keyword">while</span> (start &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (start &gt; <span class="number">0</span> &amp;&amp; src[start - <span class="number">1</span>] == <span class="string">'\') &#123;</span></span><br><span class="line"><span class="string">        // this open token is escaped. remove the backslash and continue.</span></span><br><span class="line"><span class="string">        builder.append(src, offset, start - offset - 1).append(openToken);</span></span><br><span class="line"><span class="string">        offset = start + openToken.length();</span></span><br><span class="line"><span class="string">      &#125; else &#123;</span></span><br><span class="line"><span class="string">        // found open token. let'</span>s search close token.</span><br><span class="line">        <span class="keyword">if</span> (expression == <span class="keyword">null</span>) &#123;</span><br><span class="line">          expression = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          expression.setLength(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        builder.append(src, offset, start - offset);</span><br><span class="line">        offset = start + openToken.length();</span><br><span class="line">        <span class="keyword">int</span> end = text.indexOf(closeToken, offset);</span><br><span class="line">        <span class="keyword">while</span> (end &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (end &gt; offset &amp;&amp; src[end - <span class="number">1</span>] == <span class="string">'\') &#123;</span></span><br><span class="line"><span class="string">            // this close token is escaped. remove the backslash and continue.</span></span><br><span class="line"><span class="string">            expression.append(src, offset, end - offset - 1).append(closeToken);</span></span><br><span class="line"><span class="string">            offset = end + closeToken.length();</span></span><br><span class="line"><span class="string">            end = text.indexOf(closeToken, offset);</span></span><br><span class="line"><span class="string">          &#125; else &#123;</span></span><br><span class="line"><span class="string">            expression.append(src, offset, end - offset);</span></span><br><span class="line"><span class="string">            break;</span></span><br><span class="line"><span class="string">          &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        if (end == -1) &#123;</span></span><br><span class="line"><span class="string">          // close token was not found.</span></span><br><span class="line"><span class="string">          builder.append(src, start, src.length - start);</span></span><br><span class="line"><span class="string">          offset = src.length;</span></span><br><span class="line"><span class="string">        &#125; else &#123;</span></span><br><span class="line"><span class="string">            //使用占位符 ?</span></span><br><span class="line"><span class="string">            //注意handler.handleToken()方法，这个方法是核心</span></span><br><span class="line"><span class="string">          builder.append(handler.handleToken(expression.toString()));</span></span><br><span class="line"><span class="string">          offset = end + closeToken.length();</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">      start = text.indexOf(openToken, offset);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    if (offset &lt; src.length) &#123;</span></span><br><span class="line"><span class="string">      builder.append(src, offset, src.length - offset);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    return builder.toString();</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//BindingTokenParser 的handleToken</span></span><br><span class="line"><span class="string">//当扫描到$&#123;&#125;的时候调用此方法  其实就是不解析 在运行时候在替换成具体的值</span></span><br><span class="line"><span class="string">@Override</span></span><br><span class="line"><span class="string">public String handleToken(String content) &#123;</span></span><br><span class="line"><span class="string">  this.isDynamic = true;</span></span><br><span class="line"><span class="string">  return null;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">//ParameterMappingTokenHandler的handleToken</span></span><br><span class="line"><span class="string">//全局扫描#&#123;id&#125; 字符串之后  会把里面所有 #&#123;&#125; 调用handleToken 替换为?</span></span><br><span class="line"><span class="string">@Override</span></span><br><span class="line"><span class="string">public String handleToken(String content) &#123;</span></span><br><span class="line"><span class="string">      parameterMappings.add(buildParameterMapping(content));</span></span><br><span class="line"><span class="string">      return "?";</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="4、构建总结">4、构建总结</h2>
<h3 id="4-1-总结">4.1 总结</h3>
<p>MyBatis需要做的就是，先判断这个节点是用来干什么的，然后再获取这个节点的id、parameterType、resultType等属性，封装成一个MappedStatement对象，由于这个对象很复杂，所以MyBatis使用了构造者模式来构造这个对象，最后当MappedStatement对象构造完成后，将其封装到Configuration对象中。</p>
<p><strong>MyBatis需要对配置文件进行解析，最终会解析成一个Configuration对象</strong></p>
<ul>
<li>Configuration对象，保存了mybatis-config.xml的配置信息。</li>
<li>MappedStatement，保存了XXXMapper.xml的配置信息。</li>
</ul>
<p>但是最终MappedStatement对象会封装到Configuration对象中，合二为一，成为一个单独的对象，也就是Configuration</p>
<p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/20220301/20220301215916.png" alt></p>
<h3 id="4-2-面试回答">4.2 面试回答</h3>
<p>我在开发xxxx项目的时候、使用Mybatis开发项目，我对Mybatis的认识是:它其实是一个orm持久层框架，其实就对jdbc一个封装而得的框架，使用好处其实就可以把jdbc从连接开辟事务管理以及连接关闭和sql执行，对数据的映射pojo整个过程进行一个封装而已。它的整个执行的过程:</p>
<ul>
<li>首先会引入mybatis依赖，然后会定义个xml核心配置文件放入类路径resouces，这个文件里面就描述了数据源、mapper映射、别名的映射、数据类型转换、插件、属性配置等。定义好以后，那么接下就是创建一个SqlSessionFactory对象，但是在创建这个对象之前，我们会进行xml文件的解析，解析过程中会使用SqlSessionFacotoryBuilder里面提供了一个build方法。这个方法的做了一个非常核心的事情:初始化Configuration对象，并且把对应类的属性的对象全部初始化，并且解析核心xml文件</li>
<li>把解析核心的xml配置文件的内容放入到Configuration对象中属性中，其中就包括别名的映射，在初始化阶段别名映射会自动注册一些常用的别名。如果我们自己也配置也会自动注册到<br>
Configuration对象的TypeAliasRegistry的map中</li>
<li>并且把在配置文件中的数据源和事务解析以后放入到Environment，给后续的执行，提供数据链接和事务管理</li>
<li>然后在解析xxxMapper.xml配置文件，根据配置文件解析的规则，会解析里面对应的节点。比如:&lt;select&lt;update&lt;insert &lt;delete&lt;dql &lt;cache&lt;cache-ref &lt;resultMap等，然后把每个解析的节点放入到一个叫MapperStament对象，sql语句就放入到这个对象SqlSource中</li>
<li>并且把解析的每一个节点对应的MapperStatment同时放入到Configuration全局的<br>
Map (mapperedStatments）中，以节点的id和命名空间+id做为key，以MapperStatement对象做value，给后续执行提供一个参考和方向</li>
</ul>
<h1>三、Mybatis的执行</h1>
<h2 id="1、SqlSession对象生成">1、SqlSession对象生成</h2>
<h3 id="1-1-Xml对象直接生成">1.1 Xml对象直接生成</h3>
<p><strong>核心</strong></p>
<p>将SqlSessionFactoryBuilder中通过build方法创建和装配好Configuration对象通过构造函数进行下传，传递到SqlSession中，最后开辟SqlSession会话对象</p>
<p><strong>源码分析</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 加载mybatis框架主配置文件</span></span><br><span class="line">    String resource = <span class="string">"mybatis-config.xml"</span>;</span><br><span class="line">    InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">    <span class="comment">// 读取解析配置文件内容，创建SqlSessionFacory</span></span><br><span class="line">    SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">    <span class="comment">/*---------开始注入执行------------*/</span></span><br><span class="line">    <span class="comment">// 获取sqlSession对象</span></span><br><span class="line">    SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">    <span class="comment">// 执行数据库操作</span></span><br><span class="line">    List&lt;Employee&gt; list = sqlSession.selectList(<span class="string">"test.getEmp"</span>);</span><br><span class="line">    System.out.println(list);</span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里进入<code>SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);</code>方法后，Configuration是<code>DefaultSqlSessionFactory</code>的一个属性。而<code>SqlSessionFactoryBuilder</code>在<code>build</code>方法中实际上就是调用XMLConfigBuilder对xml文件进行解析生成<code>Configuration</code>对象，然后注入到SqlSessionFactory中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(InputStream inputStream, String environment, Properties properties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//解析config.xml(mybatis解析xml是用的  java dom)     dom4j sax...</span></span><br><span class="line">      XMLConfigBuilder parser = <span class="keyword">new</span> XMLConfigBuilder(inputStream, environment, properties);</span><br><span class="line">      <span class="comment">//parse(): 解析config.xml里面的节点</span></span><br><span class="line">      <span class="keyword">return</span> build(parser.parse());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error building SqlSession."</span>, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      ErrorContext.instance().reset();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        inputStream.close();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// Intentionally ignore. Prefer previous error.</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(Configuration config)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//注入到SqlSessionFactory</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSessionFactory(config);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultSqlSessionFactory</span><span class="params">(Configuration configuration)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.configuration = configuration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过调用<code>sqlSessionFactory.openSession();</code>方法来获取<code>SqlSession</code>对象，而openSession中实际上就是<strong>对SqlSession做了进一步的加工封装，包括增加了事务、执行器等</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SqlSession <span class="title">openSessionFromDataSource</span><span class="params">(ExecutorType execType, TransactionIsolationLevel level, <span class="keyword">boolean</span> autoCommit)</span> </span>&#123;</span><br><span class="line">    Transaction tx = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//对SqlSession对象进行进一步加工封装</span></span><br><span class="line">        <span class="keyword">final</span> Environment environment = configuration.getEnvironment();</span><br><span class="line">        <span class="keyword">final</span> TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);</span><br><span class="line">        tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);</span><br><span class="line">        <span class="keyword">final</span> Executor executor = configuration.newExecutor(tx, execType);</span><br><span class="line">        <span class="comment">//构建SqlSession对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSession(configuration, executor, autoCommit);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        closeTransaction(tx); <span class="comment">// may have fetched a connection so lets call close()</span></span><br><span class="line">        <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error opening session.  Cause: "</span> + e, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-mapper-代理对象的生成">1.2 mapper 代理对象的生成</h3>
<p>首先需要修改部分文件内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建EmployeeMapper、代理mapper </span></span><br><span class="line"><span class="keyword">package</span> org.demo.mapper;</span><br><span class="line"><span class="keyword">import</span> org.demo.po.Employee;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EmployeeMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;Employee&gt; <span class="title">getEmp</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同时修改EmployeeMapper.xml的命名空间namespace为</span></span><br><span class="line"><span class="comment">//&lt;mapper namespace="org.demo.mapper.EmployeeMapper"&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//最后修改测试类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 加载mybatis框架主配置文件</span></span><br><span class="line">    String resource = <span class="string">"mybatis-config.xml"</span>;</span><br><span class="line">    InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">    <span class="comment">// 读取解析配置文件内容，创建SqlSessionFacory</span></span><br><span class="line">    SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">    <span class="comment">// 获取sqlSession对象</span></span><br><span class="line">    SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">    <span class="comment">//获取Mapper</span></span><br><span class="line">    EmployeeMapper mapper = sqlSession.getMapper(EmployeeMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">// 执行数据库操作</span></span><br><span class="line">    List&lt;Employee&gt; list = mapper.getEmp();</span><br><span class="line">    System.out.println(list);</span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>源码分析</strong></p>
<p>从SqlSession的getMapper()方法进入，可以看到这里mapperProxyFactory对象会从一个叫做knownMappers的对象中以<strong>type</strong>为key取出值，这个knownMappers是一个HashMap，存放了我们的EmployeeMapper对象，而这里的type，就是我们上面写的Mapper接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//getMapper方法最终会调用到这里，这个是MapperRegistry的getMapper方法</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//MapperProxyFactory  在解析的时候会生成一个map  map中会有我们的DemoMapper的Class</span></span><br><span class="line">    <span class="keyword">final</span> MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);</span><br><span class="line">    <span class="keyword">if</span> (mapperProxyFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Type "</span> + type + <span class="string">" is not known to the MapperRegistry."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> mapperProxyFactory.newInstance(sqlSession);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Error getting mapper instance. Cause: "</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于knownMappers生成，在configuration对象在解析的时候，会调用parse()方法，这个方法内部有一个<code>bindMapperForNamespace</code>方法，而就是这个方法帮我们完成了knownMappers的生成，并且将我们的Mapper接口put进去</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//判断文件是否之前解析过</span></span><br><span class="line">    <span class="keyword">if</span> (!configuration.isResourceLoaded(resource)) &#123;</span><br><span class="line">        <span class="comment">//解析mapper文件</span></span><br><span class="line">      configurationElement(parser.evalNode(<span class="string">"/mapper"</span>));</span><br><span class="line">      configuration.addLoadedResource(resource);</span><br><span class="line">      <span class="comment">//这里：绑定Namespace里面的Class对象*</span></span><br><span class="line">      bindMapperForNamespace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重新解析之前解析不了的节点</span></span><br><span class="line">    parsePendingResultMaps();</span><br><span class="line">    parsePendingCacheRefs();</span><br><span class="line">    parsePendingStatements();</span><br><span class="line">  &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bindMapperForNamespace</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String namespace = builderAssistant.getCurrentNamespace();</span><br><span class="line">    <span class="keyword">if</span> (namespace != <span class="keyword">null</span>) &#123;</span><br><span class="line">      Class&lt;?&gt; boundType = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        boundType = Resources.classForName(namespace);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (boundType != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!configuration.hasMapper(boundType)) &#123;</span><br><span class="line">          configuration.addLoadedResource(<span class="string">"namespace:"</span> + namespace);</span><br><span class="line">            <span class="comment">//这里将接口class传入</span></span><br><span class="line">          configuration.addMapper(boundType);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addMapper</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (type.isInterface()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (hasMapper(type)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Type "</span> + type + <span class="string">" is already known to the MapperRegistry."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">boolean</span> loadCompleted = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//这里将接口信息put进konwMappers。</span></span><br><span class="line">        knownMappers.put(type, <span class="keyword">new</span> MapperProxyFactory&lt;&gt;(type));</span><br><span class="line">        MapperAnnotationBuilder parser = <span class="keyword">new</span> MapperAnnotationBuilder(config, type);</span><br><span class="line">        parser.parse();</span><br><span class="line">        loadCompleted = <span class="keyword">true</span>;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!loadCompleted) &#123;</span><br><span class="line">          knownMappers.remove(type);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在getMapper之后，获取到的是一个Class，之后的代码就简单了，就是生成标准的代理类了，调用newInstance()方法。到这里，就完成了<strong>代理对象</strong>（<strong>MapperProxy</strong>）的创建，很明显的，MyBatis的底层就是对我们的接口进行代理类的实例化，从而操作数据库。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//首先会调用这个newInstance方法</span></span><br><span class="line">    <span class="comment">//动态代理逻辑在MapperProxy里面</span></span><br><span class="line">    <span class="keyword">final</span> MapperProxy&lt;T&gt; mapperProxy = <span class="keyword">new</span> MapperProxy&lt;&gt;(sqlSession, mapperInterface, methodCache);</span><br><span class="line">    <span class="comment">//通过这里调用下面的newInstance方法</span></span><br><span class="line">    <span class="keyword">return</span> newInstance(mapperProxy);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">newInstance</span><span class="params">(MapperProxy&lt;T&gt; mapperProxy)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//jdk自带的动态代理</span></span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), <span class="keyword">new</span> Class[] &#123; mapperInterface &#125;, mapperProxy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看动态代理调用的方法逻辑，进入MapperProxy类，发现实现了<strong>InvocationHandler</strong>接口。</p>
<p>在方法开始代理之前，首先会先判断是否调用了Object类的方法，如果是，那么MyBatis不会去改变其行为，直接返回，如果是默认方法，则绑定到代理对象中然后调用，如果都不是，那么就是我们定义的mapper接口方法了，那么就开始执行。执行方法需要一个<strong>MapperMethod</strong>对象，这个对象是MyBatis执行方法逻辑使用的，MyBatis这里获取MapperMethod对象的方式是，首先去<strong>方法缓存</strong>中看看是否已经存在了，如果不存在则new一个然后存入缓存中，因为创建代理对象是十分消耗资源的操作。总而言之，这里会得到一个MapperMethod对象，然后通过MapperMethod的excute()方法，来真正地执行逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperProxy</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InvocationHandler</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MapperProxy</span><span class="params">(SqlSession sqlSession, Class&lt;T&gt; mapperInterface, Map&lt;Method, MapperMethod&gt; methodCache)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//构造</span></span><br><span class="line">    <span class="keyword">this</span>.sqlSession = sqlSession;</span><br><span class="line">    <span class="keyword">this</span>.mapperInterface = mapperInterface;</span><br><span class="line">    <span class="keyword">this</span>.methodCache = methodCache;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="comment">//这就是一个很标准的JDK动态代理了</span></span><br><span class="line">    <span class="comment">//执行的时候会调用invoke方法</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (Object<span class="class">.<span class="keyword">class</span>.<span class="title">equals</span>(<span class="title">method</span>.<span class="title">getDeclaringClass</span>())) </span>&#123;</span><br><span class="line">          <span class="comment">//判断方法所属的类</span></span><br><span class="line">          <span class="comment">//是不是调用的Object默认的方法</span></span><br><span class="line">          <span class="comment">//如果是  则不代理，不改变原先方法的行为</span></span><br><span class="line">        <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.isDefault()) &#123;</span><br><span class="line">          <span class="comment">//对于默认方法的处理</span></span><br><span class="line">          <span class="comment">//判断是否为default方法，即接口中定义的默认方法。</span></span><br><span class="line">          <span class="comment">//如果是接口中的默认方法则把方法绑定到代理对象中然后调用。</span></span><br><span class="line">          <span class="comment">//这里不详细说</span></span><br><span class="line">        <span class="keyword">if</span> (privateLookupInMethod == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> invokeDefaultMethodJava8(proxy, method, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> invokeDefaultMethodJava9(proxy, method, args);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果不是默认方法，则真正开始执行MyBatis代理逻辑。</span></span><br><span class="line">    <span class="comment">//获取MapperMethod代理对象</span></span><br><span class="line">    <span class="keyword">final</span> MapperMethod mapperMethod = cachedMapperMethod(method);</span><br><span class="line">    <span class="comment">//执行</span></span><br><span class="line">    <span class="keyword">return</span> mapperMethod.execute(sqlSession, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> MapperMethod <span class="title">cachedMapperMethod</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//动态代理会有缓存，computeIfAbsent 如果缓存中有则直接从缓存中拿</span></span><br><span class="line">      <span class="comment">//如果缓存中没有，则new一个然后放入缓存中</span></span><br><span class="line">      <span class="comment">//因为动态代理是很耗资源的</span></span><br><span class="line">    <span class="keyword">return</span> methodCache.computeIfAbsent(method,</span><br><span class="line">        k -&gt; <span class="keyword">new</span> MapperMethod(mapperInterface, method, sqlSession.getConfiguration()));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后执行逻辑，这里首先会判断SQL的类型：SELECT|DELETE|UPDATE|INSERT，判断SQL类型为SELECT之后，就开始判断返回值类型，根据不同的情况做不同的操作。然后开始获取参数&gt;执行SQL</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//execute() 这里是真正执行SQL的地方</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">execute</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断是哪一种SQL语句</span></span><br><span class="line">    Object result;</span><br><span class="line">    <span class="keyword">switch</span> (command.getType()) &#123;</span><br><span class="line">      <span class="keyword">case</span> INSERT: &#123;</span><br><span class="line">        Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = rowCountResult(sqlSession.insert(command.getName(), param));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> UPDATE: &#123;</span><br><span class="line">        Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = rowCountResult(sqlSession.update(command.getName(), param));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> DELETE: &#123;</span><br><span class="line">        Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = rowCountResult(sqlSession.delete(command.getName(), param));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> SELECT:</span><br><span class="line">          <span class="comment">//我们的例子是查询</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">//判断是否有返回值</span></span><br><span class="line">        <span class="keyword">if</span> (method.returnsVoid() &amp;&amp; method.hasResultHandler()) &#123;</span><br><span class="line">            <span class="comment">//无返回值</span></span><br><span class="line">          executeWithResultHandler(sqlSession, args);</span><br><span class="line">          result = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMany()) &#123;</span><br><span class="line">            <span class="comment">//返回值多行 这里调用这个方法</span></span><br><span class="line">          result = executeForMany(sqlSession, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMap()) &#123;</span><br><span class="line">            <span class="comment">//返回Map</span></span><br><span class="line">          result = executeForMap(sqlSession, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsCursor()) &#123;</span><br><span class="line">            <span class="comment">//返回Cursor</span></span><br><span class="line">          result = executeForCursor(sqlSession, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">          result = sqlSession.selectOne(command.getName(), param);</span><br><span class="line">          <span class="keyword">if</span> (method.returnsOptional()</span><br><span class="line">              &amp;&amp; (result == <span class="keyword">null</span> || !method.getReturnType().equals(result.getClass()))) &#123;</span><br><span class="line">            result = Optional.ofNullable(result);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> FLUSH:</span><br><span class="line">        result = sqlSession.flushStatements();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Unknown execution method for: "</span> + command.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span> &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Mapper method '"</span> + command.getName()</span><br><span class="line">          + <span class="string">" attempted to return null from a method with a primitive return type ("</span> + method.getReturnType() + <span class="string">")."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回值多行 这里调用这个方法</span></span><br><span class="line"><span class="keyword">private</span> &lt;E&gt; <span class="function">Object <span class="title">executeForMany</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//返回值多行时执行的方法</span></span><br><span class="line">    List&lt;E&gt; result;</span><br><span class="line">    <span class="comment">//param是我们传入的参数，如果传入的是Map，那么这个实际上就是Map对象</span></span><br><span class="line">    Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">    <span class="keyword">if</span> (method.hasRowBounds()) &#123;</span><br><span class="line">        <span class="comment">//如果有分页</span></span><br><span class="line">      RowBounds rowBounds = method.extractRowBounds(args);</span><br><span class="line">        <span class="comment">//执行SQL的位置</span></span><br><span class="line">      result = sqlSession.selectList(command.getName(), param, rowBounds);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果没有</span></span><br><span class="line">        <span class="comment">//执行SQL的位置</span></span><br><span class="line">      result = sqlSession.selectList(command.getName(), param);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// issue #510 Collections &amp; arrays support</span></span><br><span class="line">    <span class="keyword">if</span> (!method.getReturnType().isAssignableFrom(result.getClass())) &#123;</span><br><span class="line">      <span class="keyword">if</span> (method.getReturnType().isArray()) &#123;</span><br><span class="line">        <span class="keyword">return</span> convertToArray(result);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> convertToDeclaredCollection(sqlSession.getConfiguration(), result);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  获取参数名的方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getNamedParams</span><span class="params">(Object[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> paramCount = names.size();</span><br><span class="line">    <span class="keyword">if</span> (args == <span class="keyword">null</span> || paramCount == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果传过来的参数是空</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hasParamAnnotation &amp;&amp; paramCount == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//如果参数上没有加注解例如@Param，且参数只有一个，则直接返回参数</span></span><br><span class="line">      <span class="keyword">return</span> args[names.firstKey()];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果参数上加了注解，或者参数有多个。</span></span><br><span class="line">          <span class="comment">//那么MyBatis会封装参数为一个Map，但是要注意，由于jdk的原因，我们只能获取到参数下标和参数名，但是参数名会变成arg0,arg1.</span></span><br><span class="line">        <span class="comment">//所以传入多个参数的时候，最好加@Param，否则假设传入多个String，会造成#&#123;&#125;获取不到值的情况</span></span><br><span class="line">      <span class="keyword">final</span> Map&lt;String, Object&gt; param = <span class="keyword">new</span> ParamMap&lt;&gt;();</span><br><span class="line">      <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : names.entrySet()) &#123;</span><br><span class="line">          <span class="comment">//entry.getValue 就是参数名称</span></span><br><span class="line">        param.put(entry.getValue(), args[entry.getKey()]);</span><br><span class="line">        <span class="comment">//如果传很多个String，也可以使用param1，param2.。。</span></span><br><span class="line">        <span class="comment">// add generic param names (param1, param2, ...)</span></span><br><span class="line">        <span class="keyword">final</span> String genericParamName = GENERIC_NAME_PREFIX + String.valueOf(i + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// ensure not to overwrite parameter named with @Param</span></span><br><span class="line">        <span class="keyword">if</span> (!names.containsValue(genericParamName)) &#123;</span><br><span class="line">          param.put(genericParamName, args[entry.getKey()]);</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> param;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="2、执行SQL前述">2、执行SQL前述</h2>
<p>进入<code>sqlSession.selectList(&quot;test.getEmp&quot;);</code>方法，可以发现在调用sqlsession执行的selectList、insert、update、delete的时候，其实就是根据执行的statement名字，到Configuration的mapperStatements对应的map中去找到有没有一个对应的 MapperStatement对象，如果找到就返回这个对象，然后给后续执行一个依据和参考</p>
<p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/20220301/20220301215925.png" alt></p>
<h2 id="3、执行SQL语句——执行器">3、执行SQL语句——执行器</h2>
<h3 id="3-1-执行架构">3.1 执行架构</h3>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/299020451" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/299020451</a></p>
</blockquote>
<p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/20220301/20220301215929.png" alt></p>
<ul>
<li><strong>执行器</strong>：Executor, 处理流程的头部，主要负责缓存、事务、批处理。一个执行可用于执行多条SQL。它和SQL处理器是1对N的关系</li>
<li><strong>Sql处理器</strong>：StatementHandler 用于和JDBC打道，比如基于SQL声明Statement、设置参数、然后就是调用Statement来执行。它只能用于一次SQL的执行</li>
<li><strong>参数处理器</strong>：ParameterHandler，用于解析SQL参数，并基于参数映射，填充至PrepareStatement。同样它只能用于一次SQL的执行</li>
<li><strong>结果集处理器</strong>：ResultSetHandler，用于读取ResultSet 结果集，并基于结果集映射，封装成JAVA对象。他也只用用于一次SQL的执行</li>
</ul>
<h3 id="3-2-执行器Executor">3.2 执行器Executor</h3>
<p>执行器的实现有三种：SimpleExecute、ReuseExecute和BatchExecute，这三种执行器有个抽象的基础执行器BaseExecutor，用于<strong>维护缓存和事务</strong>；此外通过装饰器形式添加了一个缓存执行器CachingExecutor，用于<strong>处理二级缓存</strong></p>
<ul>
<li><strong>SimpleExecute 简单执行器(默认)</strong><br>
SimpleExecutor是执行器的默认实现，主要完成了“执行”功能，在利用StatementHandler 完成。每次调用执行方法 都会构建一个StatementHandler，并预行参数，然后执行<br>
默认情况是executor是CachingExecutor。这个执行器是二级缓存的执行器，如果在配置文件xxxxMapper.xml文件中申明了<code>&lt;cache/&gt;</code>节点的话，就是使用CachingExecutor；如果没有，就会委托SimpleExecutor(默认类型是simple，在configuration创建的时候指定)执行器去执行你的SQL语句，然后这里会执行的结果放入loaclCache一级缓存中。<br>
<img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/20220301/20220301215932.png" alt></li>
<li><strong>ReuseExecute 可重用执行器</strong><br>
ReuseExecutor 区别在于他会将在会话期间内的Statement进行缓存，并使用SQL语句作为Key。所以当执行下一请求的时候，不在重复构建Statement，而是从缓存中取出并设置参数，然后执行(参数不同也可以重用)</li>
<li><strong>BatchExecute 批处理执行器</strong><br>
BatchExecutor 顾名思议，它就是用来作批处理的。但会将所 有SQL请求集中起来，最后调用Executor.flushStatements() 方法时一次性将所有请求发送至数据库</li>
</ul>
<h3 id="3-3-SimpleExecute-简单执行器源码分析-重点✨">3.3 **SimpleExecute **简单执行器源码分析(重点✨)</h3>
<p>执行SQL的核心方法就是selectList，即使是selectOne，底层实际上也是调用了selectList方法，然后取第一个而已</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">selectList</span><span class="params">(String statement, Object parameter, RowBounds rowBounds)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//MappedStatement:解析XML时生成的对象， 解析某一个SQL  会封装成MappedStatement，里面存放了我们所有执行SQL所需要的信息</span></span><br><span class="line">      MappedStatement ms = configuration.getMappedStatement(statement);</span><br><span class="line">      <span class="comment">//查询,通过executor</span></span><br><span class="line">      <span class="keyword">return</span> executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error querying database.  Cause: "</span> + e, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>selectList内部调用了<strong>Executor</strong>对象执行SQL语句，首先进入的是CachingExecutor执行器，若没有开启二级缓存，那么委托简单执行器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="comment">//获取sql语句</span></span><br><span class="line">    BoundSql boundSql = ms.getBoundSql(parameterObject);</span><br><span class="line">    <span class="comment">//生成一个缓存的key  </span></span><br><span class="line">    <span class="comment">//key = ms.id + rowBounds.getOffset()+rowBounds.getOffset()+sql+参数+上下文坏境的id</span></span><br><span class="line">    <span class="comment">//这里是-1954235241:110303602:test.getEmp:0:2147483647:select * from employee:development</span></span><br><span class="line">    CacheKey key = createCacheKey(ms, parameterObject, rowBounds, boundSql);</span><br><span class="line">    <span class="keyword">return</span> query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="comment">//二级缓存查询</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">      <span class="comment">//二级缓存的Cache</span></span><br><span class="line">    Cache cache = ms.getCache();</span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//如果Cache不为空则进入</span></span><br><span class="line">      <span class="comment">//如果有需要的话，就刷新缓存（有些缓存是定时刷新的，需要用到这个）</span></span><br><span class="line">      flushCacheIfRequired(ms);</span><br><span class="line">      <span class="comment">//如果这个statement用到了缓存（二级缓存的作用域是namespace，也可以理解为这里的ms）</span></span><br><span class="line">      <span class="keyword">if</span> (ms.isUseCache() &amp;&amp; resultHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ensureNoOutParams(ms, boundSql);</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        <span class="comment">//先从缓存拿</span></span><br><span class="line">        List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key);</span><br><span class="line">        <span class="keyword">if</span> (list == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果缓存的数据等于空，那么查询数据库</span></span><br><span class="line">          list = delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">          <span class="comment">//查询完毕后将数据放入二级缓存</span></span><br><span class="line">          tcm.putObject(cache, key, list); <span class="comment">// issue #578 and #116</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回</span></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果cache根本就不存在，那么直接查询一级缓存。并委托delegate(默认简单执行器)查询</span></span><br><span class="line">    <span class="keyword">return</span> delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先MyBatis在查询时，不会直接查询数据库，而是会进行<strong>二级缓存</strong>的查询，由于二级缓存的作用域是namespace，也可以理解为一个mapper，所以还会判断一下这个mapper是否开启了二级缓存，如果没有开启，则进入<strong>一级缓存</strong>继续查询。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一级缓存查询</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">"executing a query"</span>).object(ms.getId());</span><br><span class="line">    <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"Executor was closed."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (queryStack == <span class="number">0</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;</span><br><span class="line">      clearLocalCache();</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;E&gt; list;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">//查询栈+1</span></span><br><span class="line">      queryStack++;</span><br><span class="line">      <span class="comment">//一级缓存</span></span><br><span class="line">      list = resultHandler == <span class="keyword">null</span> ? (List&lt;E&gt;) localCache.getObject(key) : <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">//对于存储过程有输出资源的处理</span></span><br><span class="line">        handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//如果缓存为空，则从数据库拿</span></span><br><span class="line">        list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       <span class="comment">//查询栈-1</span></span><br><span class="line">      queryStack--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (queryStack == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (DeferredLoad deferredLoad : deferredLoads) &#123;</span><br><span class="line">        deferredLoad.load();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// issue #601</span></span><br><span class="line">      deferredLoads.clear();</span><br><span class="line">      <span class="keyword">if</span> (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &#123;</span><br><span class="line">        <span class="comment">// issue #482</span></span><br><span class="line">        clearLocalCache();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//结果返回</span></span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果一级缓存localCache里查到了，那么直接就返回结果了，如果一级缓存没有查到结果，那么最终会进入数据库进行查询</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数据库查询</span></span><br><span class="line"><span class="keyword">private</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">queryFromDatabase</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    List&lt;E&gt; list;</span><br><span class="line">    <span class="comment">//先往一级缓存中put一个占位符</span></span><br><span class="line">    localCache.putObject(key, EXECUTION_PLACEHOLDER);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//调用doQuery方法查询数据库</span></span><br><span class="line">      list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      localCache.removeObject(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//往缓存中put真实数据</span></span><br><span class="line">    localCache.putObject(key, list);</span><br><span class="line">    <span class="keyword">if</span> (ms.getStatementType() == StatementType.CALLABLE) &#123;</span><br><span class="line">      localOutputParameterCache.putObject(key, parameter);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//SimpleExecutor类</span></span><br><span class="line"><span class="comment">//真实数据库查询</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Configuration configuration = ms.getConfiguration();</span><br><span class="line">      <span class="comment">//封装，StatementHandler也是MyBatis四大对象之一</span></span><br><span class="line">      StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">      <span class="comment">//#&#123;&#125; -&gt; ? 的SQL在这里初始化</span></span><br><span class="line">      stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">      <span class="comment">//参数赋值完毕之后，才会真正地查询。</span></span><br><span class="line">      <span class="keyword">return</span> handler.query(stmt, resultHandler);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      closeStatement(stmt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结，一级缓存和二级缓存的key是一样的，一级缓存默认开启，二级缓存需要设置开启。这里CacheExecutor使用的是装饰者模式，即在不改变原有类结构和继承的情况下，通过包装原对象去扩展一个新功能。</p>
<p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/20220301/20220301215936.png" alt></p>
<h2 id="4、执行SQL语句——数据库查询">4、执行SQL语句——数据库查询</h2>
<p>执行流程</p>
<p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/20220301/20220301215940.png" alt></p>
<h3 id="4-1-StatementHandler介绍">4.1 StatementHandler介绍</h3>
<p><strong>StatementHandler</strong>即为JDBC处理器，基于JDBC构建JDBC Statement并设置参数，然后执行Sql。每调用会话当中一次SQl，都会有与之相对应的且唯一的Statement实例，一个SQL请求会经过会话，然后是执行器，最由StatementHandler执行jdbc最终到达数据库，这三者之间比例是<strong>1：1：n</strong>。</p>
<p>StatementHandler接口定义了JDBC操作的相关方法如下，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基于JDBC 声明Statement</span></span><br><span class="line"><span class="function">Statement <span class="title">prepare</span><span class="params">(Connection connection, Integer transactionTimeout)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"><span class="comment">// 为Statement 设置方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parameterize</span><span class="params">(Statement statement)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"><span class="comment">// 添加批处理（并非执行）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">batch</span><span class="params">(Statement statement)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"><span class="comment">// 执行update操作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(Statement statement)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"><span class="comment">// 执行query操作</span></span><br><span class="line">&lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> SQLException</span>;</span><br></pre></td></tr></table></figure>
<p><code>StatementHandler </code>有三个子类<code>SimpleStatementHandler</code>、<code>PreparedStatementHandler</code>、<code>CallableStatementHandler</code>，分别对应JDBC中的<strong>Statement</strong>、<strong>PreparedStatement</strong>、<strong>CallableStatement</strong>。</p>
<h3 id="4-2-参数处理和转换">4.2 参数处理和转换</h3>
<p>参数处理即将Java Bean转换成数据类型。总共要经历过三个步骤，<code>ParamNameResolver</code>(参数转换)、<code>ParameterHandler</code>(参数映射)、<code>TypeHandler</code>(参数赋值)</p>
<p><strong>参数转换</strong></p>
<p>所有转换逻辑均在ParamNameResolver中实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Select</span>(<span class="string">"select * from employee where id = #&#123;id&#125;"</span>)</span><br><span class="line"><span class="meta">@Options</span></span><br><span class="line"><span class="function">Employee <span class="title">getEmpById</span><span class="params">(@Param(<span class="string">"id"</span>)</span> Integer id)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>单个参数的情况下且没有设置@param注解会直接转换，勿略SQL中的引用名称</li>
<li>多个参数情况：优先采用@Param中设置的名称，如果没有则用参数序号代替 即&quot;param1、parm2等&quot;</li>
</ul>
<p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/20220301/20220301215943.png" alt></p>
<p><strong>参数映射</strong></p>
<p>映射是指Map中的key如何与SQL中绑定的参数相对应。以下这几种情况</p>
<ul>
<li><strong>单个原始类型</strong>：直接映射，勿略SQL中引用名称</li>
<li><strong>Map类型</strong>：基于Map key映射</li>
<li><strong>Object</strong>：基于属性名称映射,支持嵌套对象属性访问</li>
</ul>
<p><strong>参数赋值</strong></p>
<p>通过<code>TypeHandler </code>为<code>PrepareStatement</code>设置值，通常情况下一般的数据类型MyBatis都有与之相对应的TypeHandler</p>
<h3 id="4-3-结果集封装">4.3 结果集封装</h3>
<blockquote>
<p>MetaObject相当于一个工具类，里面还包括分词器等，可以参考<a href="https://blog.csdn.net/wangbo199308/article/details/120407062" target="_blank" rel="noopener">MetaObject详解</a></p>
</blockquote>
<p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/20220301/20220301215946.png" alt></p>
<p>读取ResultSet数据，并将每一行转换成相对应的对象。用户可在转换的过程当中可以通过<code>ResultContext</code>来控制是否要继续转换，转换后的对象都会暂存在<code>ResultHandler</code>中最后统一封装成list返回给调用方，结果集转换中99%的逻辑<code>DefaultResultSetHandler </code>中实现。整个流程可大致分为以下阶段：</p>
<ul>
<li>读取结果集</li>
<li>遍历结果集当中的行</li>
<li>创建对象</li>
<li>填充属性</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//PreparedStatementHandler，这里是真正查询</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  PreparedStatement ps = (PreparedStatement) statement;</span><br><span class="line">  ps.execute();</span><br><span class="line">  <span class="keyword">return</span> resultSetHandler.&lt;E&gt; handleResultSets(ps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在SQL执行阶段，MyBatis已经完成了对数据的查询，那么现在还存在最后一个问题，那就是结果集处理，换句话来说，就是将结果集封装成对象，这里会创建一个处理结果集的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//DefaultResultSetHandler</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">handleResultSets</span><span class="params">(Statement stmt)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    ErrorContext.instance().activity(<span class="string">"handling results"</span>).object(mappedStatement.getId());</span><br><span class="line">    <span class="comment">//resultMap可以通过多个标签指定多个值，所以存在多个结果集</span></span><br><span class="line">    <span class="keyword">final</span> List&lt;Object&gt; multipleResults = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> resultSetCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//拿到当前第一个结果集</span></span><br><span class="line">    ResultSetWrapper rsw = getFirstResultSet(stmt);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拿到所有的resultMap</span></span><br><span class="line">    List&lt;ResultMap&gt; resultMaps = mappedStatement.getResultMaps();</span><br><span class="line">    <span class="comment">//resultMap的数量</span></span><br><span class="line">    <span class="keyword">int</span> resultMapCount = resultMaps.size();</span><br><span class="line">    validateResultMapsCount(rsw, resultMapCount);</span><br><span class="line">    <span class="comment">//循环处理每一个结果集</span></span><br><span class="line">    <span class="keyword">while</span> (rsw != <span class="keyword">null</span> &amp;&amp; resultMapCount &gt; resultSetCount) &#123;</span><br><span class="line">        <span class="comment">//开始封装结果集 list.get(index) 获取结果集</span></span><br><span class="line">      ResultMap resultMap = resultMaps.get(resultSetCount);</span><br><span class="line">      <span class="comment">//传入resultMap处理结果集 rsw 当前结果集（主线）</span></span><br><span class="line">      handleResultSet(rsw, resultMap, multipleResults, <span class="keyword">null</span>);</span><br><span class="line">      rsw = getNextResultSet(stmt);</span><br><span class="line">      cleanUpAfterHandlingResultSet();</span><br><span class="line">      resultSetCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String[] resultSets = mappedStatement.getResultSets();</span><br><span class="line">    <span class="keyword">if</span> (resultSets != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">while</span> (rsw != <span class="keyword">null</span> &amp;&amp; resultSetCount &lt; resultSets.length) &#123;</span><br><span class="line">        ResultMapping parentMapping = nextResultMaps.get(resultSets[resultSetCount]);</span><br><span class="line">        <span class="keyword">if</span> (parentMapping != <span class="keyword">null</span>) &#123;</span><br><span class="line">          String nestedResultMapId = parentMapping.getNestedResultMapId();</span><br><span class="line">          ResultMap resultMap = configuration.getResultMap(nestedResultMapId);</span><br><span class="line">          handleResultSet(rsw, resultMap, <span class="keyword">null</span>, parentMapping);</span><br><span class="line">        &#125;</span><br><span class="line">        rsw = getNextResultSet(stmt);</span><br><span class="line">        cleanUpAfterHandlingResultSet();</span><br><span class="line">        resultSetCount++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果只有一个结果集，那么从多结果集中取出第一个</span></span><br><span class="line">    <span class="keyword">return</span> collapseSingleResultList(multipleResults);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//处理结果集</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleResultSet</span><span class="params">(ResultSetWrapper rsw, ResultMap resultMap, List&lt;Object&gt; multipleResults, ResultMapping parentMapping)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">   <span class="comment">//处理结果集</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (parentMapping != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handleRowValues(rsw, resultMap, <span class="keyword">null</span>, RowBounds.DEFAULT, parentMapping);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (resultHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">//判断resultHandler是否为空，如果为空建立一个默认的。</span></span><br><span class="line">          <span class="comment">//结果集处理器</span></span><br><span class="line">          DefaultResultHandler defaultResultHandler = <span class="keyword">new</span> DefaultResultHandler(objectFactory);</span><br><span class="line">          <span class="comment">//处理行数据</span></span><br><span class="line">          handleRowValues(rsw, resultMap, defaultResultHandler, rowBounds, <span class="keyword">null</span>);</span><br><span class="line">          multipleResults.add(defaultResultHandler.getResultList());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          handleRowValues(rsw, resultMap, resultHandler, rowBounds, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// issue #228 (close resultsets)</span></span><br><span class="line">      <span class="comment">//关闭结果集</span></span><br><span class="line">      closeResultSet(rsw.getResultSet());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用handleRwoValues()方法进行行数据的处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//处理行数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRowValues</span><span class="params">(ResultSetWrapper rsw, ResultMap resultMap, ResultHandler&lt;?&gt; resultHandler, RowBounds rowBounds, ResultMapping parentMapping)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="comment">//是否存在内嵌的结果集</span></span><br><span class="line">    <span class="keyword">if</span> (resultMap.hasNestedResultMaps()) &#123;</span><br><span class="line">      ensureNoRowBounds();</span><br><span class="line">      checkResultHandler();</span><br><span class="line">      handleRowValuesForNestedResultMap(rsw, resultMap, resultHandler, rowBounds, parentMapping);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//不存在内嵌的结果集</span></span><br><span class="line">      handleRowValuesForSimpleResultMap(rsw, resultMap, resultHandler, rowBounds, parentMapping);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//没有内嵌结果集时调用</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleRowValuesForSimpleResultMap</span><span class="params">(ResultSetWrapper rsw, ResultMap resultMap, ResultHandler&lt;?&gt; resultHandler, RowBounds rowBounds, ResultMapping parentMapping)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    DefaultResultContext&lt;Object&gt; resultContext = <span class="keyword">new</span> DefaultResultContext&lt;&gt;();</span><br><span class="line">    <span class="comment">//获取当前结果集</span></span><br><span class="line">    ResultSet resultSet = rsw.getResultSet();</span><br><span class="line">    skipRows(resultSet, rowBounds);</span><br><span class="line">    <span class="keyword">while</span> (shouldProcessMoreRows(resultContext, rowBounds) &amp;&amp; !resultSet.isClosed() &amp;&amp; resultSet.next()) &#123;</span><br><span class="line">        <span class="comment">//遍历结果集</span></span><br><span class="line">      ResultMap discriminatedResultMap = resolveDiscriminatedResultMap(resultSet, resultMap, <span class="keyword">null</span>);</span><br><span class="line">      <span class="comment">//拿到行数据，将行数据包装成一个Object</span></span><br><span class="line">      Object rowValue = getRowValue(rsw, discriminatedResultMap, <span class="keyword">null</span>);</span><br><span class="line">      storeObject(resultHandler, resultContext, rowValue, parentMapping, resultSet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过每行的结果集，然后将其直接封装成一个Object对象</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">getRowValue</span><span class="params">(ResultSetWrapper rsw, ResultMap resultMap, String columnPrefix)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个空的Map存值</span></span><br><span class="line">    <span class="keyword">final</span> ResultLoaderMap lazyLoader = <span class="keyword">new</span> ResultLoaderMap();</span><br><span class="line">    <span class="comment">//创建一个空对象装行数据</span></span><br><span class="line">    Object rowValue = createResultObject(rsw, resultMap, lazyLoader, columnPrefix);</span><br><span class="line">    <span class="keyword">if</span> (rowValue != <span class="keyword">null</span> &amp;&amp; !hasTypeHandlerForResultObject(rsw, resultMap.getType()))&#123;</span><br><span class="line">        <span class="comment">//通过反射操作返回值</span></span><br><span class="line">        <span class="comment">//此时metaObject.originalObject = rowValue</span></span><br><span class="line">      <span class="keyword">final</span> MetaObject metaObject = configuration.newMetaObject(rowValue);</span><br><span class="line">      <span class="keyword">boolean</span> foundValues = <span class="keyword">this</span>.useConstructorMappings;</span><br><span class="line">      <span class="keyword">if</span> (shouldApplyAutomaticMappings(resultMap, <span class="keyword">false</span>)) &#123;</span><br><span class="line">    <span class="comment">//判断是否需要自动映射，默认自动映射，也可以通过resultMap节点上的autoMapping配置是否自动映射</span></span><br><span class="line">          <span class="comment">//这里是自动映射的操作。</span></span><br><span class="line">        foundValues = applyAutomaticMappings(rsw, resultMap, metaObject, columnPrefix) || foundValues;</span><br><span class="line">      &#125;</span><br><span class="line">      foundValues = applyPropertyMappings(rsw, resultMap, metaObject, lazyLoader, columnPrefix) || foundValues;</span><br><span class="line">      foundValues = lazyLoader.size() &gt; <span class="number">0</span> || foundValues;</span><br><span class="line">      rowValue = foundValues || configuration.isReturnInstanceForEmptyRow() ? rowValue : <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rowValue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在getRowValue中会判断是否是自动映射的，我们这里没有使用ResultMap，所以是自动映射（默认），那么就进入applyAutomaticMappings()方法，而这个方法就会完成对象的封装。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">applyAutomaticMappings</span><span class="params">(ResultSetWrapper rsw, ResultMap resultMap, MetaObject metaObject, String columnPrefix)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">      <span class="comment">//自动映射参数列表</span></span><br><span class="line">    List&lt;UnMappedColumnAutoMapping&gt; autoMapping = createAutomaticMappings(rsw, resultMap, metaObject, columnPrefix);</span><br><span class="line">      <span class="comment">//是否找到了该列</span></span><br><span class="line">    <span class="keyword">boolean</span> foundValues = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!autoMapping.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">      <span class="keyword">for</span> (UnMappedColumnAutoMapping mapping : autoMapping) &#123;</span><br><span class="line">          <span class="comment">//通过列名获取值</span></span><br><span class="line">        <span class="keyword">final</span> Object value = mapping.typeHandler.getResult(rsw.getResultSet(), mapping.column);</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果值不为空，说明找到了该列</span></span><br><span class="line">          foundValues = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span> || (configuration.isCallSettersOnNulls() &amp;&amp; !mapping.primitive)) &#123;</span><br><span class="line">          <span class="comment">// gcode issue #377, call setter on nulls (value is not 'found')</span></span><br><span class="line">            <span class="comment">//在这里赋值</span></span><br><span class="line">          metaObject.setValue(mapping.property, value);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> foundValues;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到这个方法会通过遍历参数列表从而通过<code>metaObject.setValue(mapping.property, value);</code>对返回对象进行赋值，所有的赋值操作在内部都是通过一个叫<code>ObjectWrapper</code>的对象完成的，先看看中代码的<code>metaObject.setValue()</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//MetaObject类，工具类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(String name, Object value)</span> </span>&#123;</span><br><span class="line">    PropertyTokenizer prop = <span class="keyword">new</span> PropertyTokenizer(name);</span><br><span class="line">    <span class="keyword">if</span> (prop.hasNext()) &#123;</span><br><span class="line">      MetaObject metaValue = metaObjectForProperty(prop.getIndexedName());</span><br><span class="line">      <span class="keyword">if</span> (metaValue == SystemMetaObject.NULL_META_OBJECT) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// don't instantiate child path if value is null</span></span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          metaValue = objectWrapper.instantiatePropertyValue(name, prop, objectFactory);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      metaValue.setValue(prop.getChildren(), value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//这个方法最终会调用objectWrapper.set()对结果进行赋值</span></span><br><span class="line">      objectWrapper.set(prop, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>objectWrapper有两个实现：<strong>BeanWrapper</strong>和<strong>MapWrapper</strong>，如果是自定义类型，那么就会调用BeanWrapper的set方法。<strong>MapWrapper</strong>的set方法实际上就是将属性名和属性值放到map的key和value中，而<strong>BeanWrapper</strong>则是使用了反射，调用了Bean的set方法，将值注入。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//MapWrapper的set方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(PropertyTokenizer prop, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prop.getIndex() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      Object collection = resolveCollection(prop, map);</span><br><span class="line">      setCollectionValue(prop, collection, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//实际上就是调用了Map的put方法将属性名和属性值放入map中</span></span><br><span class="line">      map.put(prop.getName(), value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//BeanWrapper的set方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(PropertyTokenizer prop, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prop.getIndex() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      Object collection = resolveCollection(prop, object);</span><br><span class="line">      setCollectionValue(prop, collection, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//在这里赋值，通过反射赋值，调用setXX()方法赋值</span></span><br><span class="line">      setBeanProperty(prop, object, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setBeanProperty</span><span class="params">(PropertyTokenizer prop, Object object, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Invoker method = metaClass.getSetInvoker(prop.getName());</span><br><span class="line">      Object[] params = &#123;value&#125;;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        method.invoke(object, params);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ReflectionException(<span class="string">"Could not set property '"</span> + prop.getName() + <span class="string">"' of '"</span> + object.getClass() + <span class="string">"' with value '"</span> + value + <span class="string">"' Cause: "</span> + t.toString(), t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-4-结果集映射">4.4 结果集映射</h3>
<p>映射是指返回的ResultSet列与Java Bean 属性之间的对应关系。通过ResultMapping进行映射描述，在用ResultMap封装成一个整体，包括手动映射和自动映射</p>
<table>
<thead>
<tr>
<th><strong>property</strong></th>
<th><strong>属性名(必填)</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>column</strong></td>
<td><strong>列名(必填)</strong></td>
</tr>
<tr>
<td>jdbcType</td>
<td>jdbc类型(可自动推导)</td>
</tr>
<tr>
<td>javaType</td>
<td>java类型(可自动推导)</td>
</tr>
<tr>
<td>typeHandler</td>
<td>类型处理器(可自动推导)</td>
</tr>
</tbody>
</table>
<p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/20220301/20220301215952.png" alt></p>
<p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/20220301/20220301215955.png" alt></p>
<h3 id="4-5-懒加载">4.5 懒加载</h3>
<blockquote>
<p><a href="https://wuwenze.com/archives/1052/#%E6%87%92%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84" target="_blank" rel="noopener">懒加载的参考文章之一</a></p>
</blockquote>
<p>懒加载是为了改善在映射结果集解析对象属性时，大量的嵌套子查询的并发效率问题，当设置懒加载后，只有在使用指定属性时才会触发子查询，从而实现分散SQL请求的目的</p>
<p><strong>配置方式</strong></p>
<p>在mybais主配置文件中配置开启<strong>侵入式加载</strong>和<strong>深度加载</strong>，也可以在xml映射文件中配置<code>fetchType</code>，有效值为 <code>lazy</code> 和 <code>eager</code>。 指定属性后，将在映射中忽略全局配置参数 <code>lazyLoadingEnabled</code>，使用属性的值</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置直接延迟加载，默认是false--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"lazyLoadingEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 侵入式延迟加载开关，默认是true --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"aggressiveLazyLoading"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>内部原理</strong></p>
<p>代理过程发生在结果集解析创建对象之后(<code>DefaultResultSetHandler.createResultObject</code>)，如果对应的属性设置了懒加载，则会通过**ProxyFactory **创建代理对象，该对象继承自原对象，然后将对象的值全部拷贝到代理对象，并设置相应<code>MethodHandler</code>（原对象直接抛弃）</p>
<p>通过对Bean的动态代理，重写所有属性的getXxx方法，代理之后Bean会包含一个<strong>MethodHandler</strong>，内部在包含一个<strong>Map</strong>用于存放待执行懒加载，执行前懒加载前会移除。<strong>LoadPair</strong>用于针对反序列化的Bean准备执行环境。<strong>ResultLoader</strong>用于执行加载操作，执行前如果原执行器关闭会创建一个新的。</p>
<p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/20220301/20220301215958.png" alt></p>
<h3 id="4-6-嵌套映射">4.6 嵌套映射</h3>
<p>映射是指返回的ResultSet列与Java Bean 属性之间的对应关系。通过ResultMapping进行映射描述，在用ResultMap封装成一个整体。<strong>映射分为简单映射与复合嵌套映射，联合查询分为一对一查询和一对多查询</strong></p>
<p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/20220301/20220301220000.png" alt></p>
<p><strong>流程说明</strong></p>
<p>所有映射流程的解析都是在DefaultResultSetHandler当中完成。主要方法如下：</p>
<ul>
<li><code>handleRowValuesForNestedResultMap()</code></li>
</ul>
<p>嵌套结果集解析入口，在这里会遍历结果集中所有行。并为每一行创建一个RowKey对象。然后调用getRowValue()获取解析结果对象。最后保存至ResultHandler中(注：调用getRowValue前会基于RowKey获取已解析的对象，然后作为partialObject参数发给getRowValue)</p>
<ul>
<li><code>getRowValue()</code></li>
</ul>
<p>该方法最终会基于当前行生成一个解析好对象。具体职责包括，1.创建对象、2.填充普通属性和3.填充嵌套属性。在解析嵌套属性时会以递归的方式在调用getRowValue获取子对象。最后一步4.基于RowKey 暂存当前解析对象(如果partialObject参数不为空 只会执行 第3步。因为1、2已经执行过了)</p>
<ul>
<li><code>applyNestedResultMappings()</code></li>
</ul>
<p>解析并填充嵌套结果集映射，遍历所有嵌套映射,然后获取其嵌套ResultMap。接着创建RowKey 去获取暂存区的值。然后调用getRowValue 获取属性对象。最后填充至父对象(如果通过RowKey能获取到属性对象，它还是会去调用getRowsValue，因为有可能属下还存在未解析的属性)</p>
<p><strong>MyBatis循环依赖问题</strong></p>
<p>mybatis解决循环依赖主要是利用一级缓存和内置的queryStack标识。mybatis中BaseExecutor执行器对一级缓存进行管控，利用queryStack标识对最终结果进行处理，一级缓存对没有操作的查询缓存key进行空参填充，在嵌套子查询中会判断是否命中一级缓存，然后将其添加到<strong>延迟队列</strong>(非懒加载)，直到整个查询结束再对其进行延迟队列的加载，填充所有数据</p>
<p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/20220301/20220301220004.png" alt></p>
<p>其源码主要在DefaultResultSetHandler类中，方法调用手动映射，具体为<code>applyPropertyMappings</code>&gt;<code>getPropertyMappingValue</code>&gt;<code>getNestedQueryMappingValue</code>&gt;<code>ResultLoader </code>- 结果集加载器&gt;再次进入BaseExecutor的query中，对queryStack进行累加，直到跳出整个查询</p>
<h1>四、Mybatis的缓存</h1>
<h2 id="1、缓存概述">1、缓存概述</h2>
<p>myBatis中存在两个缓存，一级缓存和二级缓存</p>
<ul>
<li><strong>一级缓存</strong>：也叫做会话级缓存，生命周期仅存在于当前会话，不可以直接关关闭。但可以通过<code>flushCache</code>和<code>localCacheScope</code>对其做相应控制。</li>
<li><strong>二级缓存</strong>：也叫应用级缓存，缓存对象存在于整个应用周期，而且可以跨线程使用。</li>
</ul>
<h2 id="2、一级缓存">2、一级缓存</h2>
<h3 id="2-1-缓存命中与清空">2.1 缓存命中与清空</h3>
<p><strong>缓存命中参数</strong></p>
<ul>
<li>SQL与参数相同</li>
<li>同一个会话</li>
<li>相同的MapperStatement ID</li>
<li>RowBounds行范围相同</li>
</ul>
<p><strong>触发清空缓存</strong></p>
<ul>
<li>手动调用clearCache，注意clearLocalCache 不是清空某条具体数据，而是清当前会话下所有一级缓存数据</li>
<li>执行提交回滚(commit、Rolback)</li>
<li>执行任意增删改update</li>
<li>配置flushCache=true</li>
<li>缓存作用域为Statement(即子查询，子查询依赖一级缓存)</li>
</ul>
<h3 id="2-2-集成Spring一级缓存失效">2.2 集成Spring一级缓存失效</h3>
<p>因为Spring 对SqlSession进行了封装，通过SqlSessionTemplae ，使得每次调用Sql，都会重新构建一个SqlSession，解决方法是</p>
<ul>
<li>开启事务，因为一旦开启事务，Spring就不会在执行完SQL之后就销毁SqlSession，因为SqlSession一旦关闭，事务就没了，一旦我们开启事务，在事务期间内，缓存会一直存在</li>
<li>使用二级缓存</li>
</ul>
<p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/20220301/20220301220007.png" alt></p>
<h2 id="3、二级缓存">3、二级缓存</h2>
<h3 id="3-1-简介">3.1 简介</h3>
<p>二级缓存也称作是应用级缓存，与一级缓存不同的，是它的作用范围是整个应用，而且可以跨线程使用。所以二级缓存有更高的命中率，适合缓存一些修改较少的数据，在流程上是先访问二级缓存，在访问一级缓存。二级缓存的更新，必须是在会话提交之后，同时要提交之后才能命中缓存</p>
<h3 id="3-2-二级缓存使用">3.2 二级缓存使用</h3>
<p><strong>缓存空间声明</strong></p>
<p>二级默认缓存默认是不开启的，需要为其声明缓存空间才可以使用，通过**@CacheNamespace** 或 在xml配置**<Cache><strong>。声明之后该缓存为该Mapper所独有，其它Mapper不能访问。如需要多个Mapper共享一个缓存空间可通过</strong>@CacheNamespaceRef <strong>或</strong><cache-ref namespace>**进行引用同一个缓存空间。@CacheNamespace 详细配置见下表：</cache-ref></Cache></p>
<table>
<thead>
<tr>
<th>配置</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>implementation</td>
<td>指定缓存的存储实现类，默认是用HashMap存储在内存当中</td>
</tr>
<tr>
<td>eviction</td>
<td>指定缓存溢出淘汰实现类，默认LRU ，清除最少使用</td>
</tr>
<tr>
<td>flushInterval</td>
<td>设置缓存定时全部清空时间，默认不清空。</td>
</tr>
<tr>
<td>size</td>
<td>指定缓存容量，超出后就会按eviction指定算法进行淘汰</td>
</tr>
<tr>
<td>readWrite</td>
<td>true即通过序列化复制，来保证缓存对象是可读写的，默认true</td>
</tr>
<tr>
<td>blocking</td>
<td>为每个Key的访问添加阻塞锁，防止缓存击穿</td>
</tr>
<tr>
<td>properties</td>
<td>为上述组件，配置额外参数，key对应组件中的字段名。</td>
</tr>
</tbody>
</table>
<p><strong>缓存其它配置</strong></p>
<p>除@CacheNamespace 还可以通过其它参数来控制二级缓存</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>配置域</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>cacheEnabled</td>
<td>在mybatis设置</td>
<td>二级缓存全局开关，默认开启</td>
</tr>
<tr>
<td>useCache</td>
<td>&lt;select</td>
<td>update</td>
</tr>
<tr>
<td>flushCache</td>
<td>&lt;select</td>
<td>update</td>
</tr>
</tbody>
</table>
<p>注意：若<code>*Mapper.xml</code>和<code>mapper</code>接口同时设置SQL查询，并同时配置了缓存，那么两个缓存空间是不一致，需要用缓存引用ref使用同一个缓存空间</p>
<h3 id="3-3-责任链设计">3.3 责任链设计</h3>
<p>这里MyBatis抽像出Cache接口，其只定义了缓存中最基本的功能方法：</p>
<ul>
<li>设置缓存</li>
<li>获取缓存</li>
<li>清除缓存</li>
<li>获取缓存数量</li>
</ul>
<p>然后上述中每一个功能都会对应一个组件类，并基于装饰者加责任链的模式，将各个组件进行串联。在执行缓存的基本功能时，其它的缓存逻辑会沿着这个责任链依次往下传递。</p>
<p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/20220301/20220301220011.png" alt></p>
<h3 id="3-4-执行流程">3.4 执行流程</h3>
<p>原本会话是通过Executor实现SQL调用，这里基于装饰器模式使用CachingExecutor对SQL调用逻辑进行拦截，以嵌入二级缓存相关逻辑。这里SqlSession会话可以对应多个暂存区，而多个暂存区对应一个缓存空间</p>
<p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/20220301/20220301220014.png" alt></p>
<p><strong>查询操作query</strong></p>
<p>当会话调用query() 时，会基于查询语句、参数等数据组成缓存Key，然后尝试从二级缓存中读取数据。读到就直接返回，没有就调用被装饰的Executor去查询数据库，然后在填充至对应的暂存区。</p>
<blockquote>
<p>请注意，这里的查询是实时从缓存空间读取的，而变更，只会记录在暂存区</p>
</blockquote>
<p><strong>更新操作update</strong></p>
<p>当执行update操作时，同样会基于查询的语句和参数组成缓存KEY，然后在执行update之前清空缓存。这里清空只针对暂存区，同时记录清空的标记，以便当会话提交之时，依据该标记去清空二级缓存空间。</p>
<blockquote>
<p>如果在查询操作中配置了flushCache=true ，也会执行相同的操作。</p>
</blockquote>
<p><strong>提交操作commit</strong></p>
<p>当会话执行commit操作后，会将该会话下所有暂存区的变更，更新到对应二级缓存空间去。</p>
<h3 id="3-5-缓存源码事务分析">3.5 缓存源码事务分析</h3>
<p>这个类是MyBatis用于缓存事务管理的类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionalCacheManager</span> </span>&#123;</span><br><span class="line"> <span class="comment">//事务缓存</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Cache, TransactionalCache&gt; transactionalCaches = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">(Cache cache)</span> </span>&#123;</span><br><span class="line">    getTransactionalCache(cache).clear();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(Cache cache, CacheKey key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getTransactionalCache(cache).getObject(key);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Cache cache, CacheKey key, Object value)</span> </span>&#123;</span><br><span class="line">    getTransactionalCache(cache).putObject(key, value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (TransactionalCache txCache : transactionalCaches.values()) &#123;</span><br><span class="line">      txCache.commit();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (TransactionalCache txCache : transactionalCaches.values()) &#123;</span><br><span class="line">      txCache.rollback();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> TransactionalCache <span class="title">getTransactionalCache</span><span class="params">(Cache cache)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> transactionalCaches.computeIfAbsent(cache, TransactionalCache::<span class="keyword">new</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TransactionalCacheManager中封装了一个Map，用于将事务缓存对象缓存起来，这个Map的Key是我们的二级缓存对象，而Value是一个叫做TransactionalCache。</p>
<ul>
<li>其中在getObject()方法中存在两个分支：如果发现缓存中取出的数据为null，那么会把这个key放到<strong>entriesMissedInCache</strong>中，这个对象的主要作用就是将我们<strong>未命中的key</strong>全都保存下来，防止缓存被击穿，并且当我们在缓存中无法查询到数据，那么就有可能到一级缓存和数据库中查询，那么查询过后会调用putObject()方法，这个方法本应该将我们查询到的数据put到真实缓存中，但是现在由于存在事务，所以暂时先放到<strong>entriesToAddOnCommit</strong>中；如果发现缓存中取出的数据不为null，那么会查看<strong>事务提交标识</strong>(<strong>clearOnCommit</strong>)是否为true，如果为true，代表事务已经提交了，之后缓存会被清空，所以返回null，如果为false，那么由于事务还没有被提交，所以返回当前缓存中存的数据</li>
<li>事务提交成功时有以下几步：清空真实缓存、将本地缓存（未提交的事务缓存 entriesToAddOnCommit）刷新到真实缓存、将所有值复位</li>
<li>回滚步骤：清空真实缓存中未命中的缓存、将所有值复位</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionalCache</span> <span class="keyword">implements</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(TransactionalCache<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//真实缓存对象</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Cache delegate;</span><br><span class="line">  <span class="comment">//是否需要清空提交空间的标识</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> clearOnCommit;</span><br><span class="line">  <span class="comment">//所有待提交的缓存</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Object, Object&gt; entriesToAddOnCommit;</span><br><span class="line">  <span class="comment">//未命中的缓存集合，防止击穿缓存，并且如果查询到的数据为null，说明要通过数据库查询，有可能存在数据不一致，都记录到这个地方</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Object&gt; entriesMissedInCache;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TransactionalCache</span><span class="params">(Cache delegate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.delegate = delegate;</span><br><span class="line">    <span class="keyword">this</span>.clearOnCommit = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">this</span>.entriesToAddOnCommit = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">this</span>.entriesMissedInCache = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> delegate.getId();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> delegate.getSize();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// issue #116</span></span><br><span class="line">    Object object = delegate.getObject(key);</span><br><span class="line">    <span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果取出的是空，那么放到未命中缓存，并且在查询数据库之后putObject中将本应该放到真实缓存中的键值对放到待提交事务缓存</span></span><br><span class="line">      entriesMissedInCache.add(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果不为空</span></span><br><span class="line">    <span class="comment">// issue #146</span></span><br><span class="line">    <span class="comment">//查看缓存清空标识是否为false，如果事务提交了就为true，事务提交了会更新缓存，所以返回null。</span></span><br><span class="line">    <span class="keyword">if</span> (clearOnCommit) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果事务没有提交，那么返回原先缓存中的数据，</span></span><br><span class="line">      <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object object)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//如果返回的数据为null，那么有可能到数据库查询，查询到的数据先放置到待提交事务的缓存中</span></span><br><span class="line">      <span class="comment">//本来应该put到缓存中，现在put到待提交事务的缓存中去。</span></span><br><span class="line">    entriesToAddOnCommit.put(key, object);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">removeObject</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//如果事务提交了，那么将清空缓存提交标识设置为true</span></span><br><span class="line">    clearOnCommit = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//清空entriesToAddOnCommit</span></span><br><span class="line">    entriesToAddOnCommit.clear();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (clearOnCommit) &#123;</span><br><span class="line">        <span class="comment">//如果为true，那么就清空缓存。</span></span><br><span class="line">      delegate.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把本地缓存刷新到真实缓存。</span></span><br><span class="line">    flushPendingEntries();</span><br><span class="line">    <span class="comment">//然后将所有值复位。</span></span><br><span class="line">    reset();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//事务回滚</span></span><br><span class="line">    unlockMissedEntries();</span><br><span class="line">    reset();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//复位操作。</span></span><br><span class="line">    clearOnCommit = <span class="keyword">false</span>;</span><br><span class="line">    entriesToAddOnCommit.clear();</span><br><span class="line">    entriesMissedInCache.clear();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flushPendingEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//遍历事务管理器中待提交的缓存</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Object, Object&gt; entry : entriesToAddOnCommit.entrySet()) &#123;</span><br><span class="line">        <span class="comment">//写入到真实的缓存中。</span></span><br><span class="line">      delegate.putObject(entry.getKey(), entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Object entry : entriesMissedInCache) &#123;</span><br><span class="line">        <span class="comment">//把未命中的一起put</span></span><br><span class="line">      <span class="keyword">if</span> (!entriesToAddOnCommit.containsKey(entry)) &#123;</span><br><span class="line">        delegate.putObject(entry, <span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unlockMissedEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Object entry : entriesMissedInCache) &#123;</span><br><span class="line">        <span class="comment">//清空真实缓存区中未命中的缓存。</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        delegate.removeObject(entry);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.warn(<span class="string">"Unexpected exception while notifiying a rollback to the cache adapter."</span></span><br><span class="line">            + <span class="string">"Consider upgrading your cache adapter to the latest version.  Cause: "</span> + e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-6-使用经验">3.6 使用经验</h3>
<p><strong>二级缓存不能存在一直增多的数据</strong></p>
<p>由于二级缓存的影响范围不是SqlSession而是namespace，所以二级缓存会在你的应用启动时一直存在直到应用关闭，所以二级缓存中不能存在随着时间数据量越来越大的数据，这样有可能会造成内存空间被占满。</p>
<p><strong>二级缓存有可能存在脏读的问题（可避免）</strong></p>
<p>由于二级缓存的作用域为namespace，那么就可以假设这么一个场景，有两个namespace操作一张表，第一个namespace查询该表并回写到内存中，第二个namespace往表中插一条数据，那么第一个namespace的二级缓存是不会清空这个缓存的内容的，在下一次查询中，还会通过缓存去查询，这样会造成数据的不一致。所以当项目里有多个命名空间操作同一张表的时候，最好不要用二级缓存，或者使用二级缓存时避免用两个namespace操作一张表。</p>
<h1>五、Mybatis插件</h1>
<h2 id="1、核心原理">1、核心原理</h2>
<p>插件机制是为了对MyBatis现有体系进行扩展而提供的入口。底层通过动<strong>责任链模式+ JDK动态代理</strong>实现。插件的核心是拦截四个接口的子对象，拦截以后会进入到<code>intercept</code>方法中进行业务的处理，而Invocation对象可以获取到四个接口的具体</p>
<ul>
<li>Executor：执行器</li>
<li>StatementHandler：JDBC处理器</li>
<li>ParameterHandler：参数处理器</li>
<li>ResultSetHandler：结果集处理器</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意interceptorChain.pluginAll()方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ParameterHandler <span class="title">newParameterHandler</span><span class="params">(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">    ParameterHandler parameterHandler = mappedStatement.getLang().createParameterHandler(mappedStatement, parameterObject, boundSql);</span><br><span class="line">    parameterHandler = (ParameterHandler) interceptorChain.pluginAll(parameterHandler);</span><br><span class="line">    <span class="keyword">return</span> parameterHandler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResultSetHandler <span class="title">newResultSetHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, RowBounds rowBounds, ParameterHandler parameterHandler, ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">    ResultSetHandler resultSetHandler = <span class="keyword">new</span> DefaultResultSetHandler(executor, mappedStatement, parameterHandler, resultHandler, boundSql, rowBounds);</span><br><span class="line">    resultSetHandler = (ResultSetHandler) interceptorChain.pluginAll(resultSetHandler);</span><br><span class="line">    <span class="keyword">return</span> resultSetHandler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> StatementHandler <span class="title">newStatementHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">    StatementHandler statementHandler = <span class="keyword">new</span> RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);</span><br><span class="line">    statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler);</span><br><span class="line">    <span class="keyword">return</span> statementHandler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType, <span class="keyword">boolean</span> autoCommit)</span> </span>&#123;</span><br><span class="line">    executorType = executorType == <span class="keyword">null</span> ? defaultExecutorType : executorType;</span><br><span class="line">    executorType = executorType == <span class="keyword">null</span> ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">    Executor executor;</span><br><span class="line">    <span class="keyword">if</span> (ExecutorType.BATCH == executorType) &#123;</span><br><span class="line">        executor = <span class="keyword">new</span> BatchExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE == executorType) &#123;</span><br><span class="line">        executor = <span class="keyword">new</span> ReuseExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        executor = <span class="keyword">new</span> SimpleExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cacheEnabled) &#123;</span><br><span class="line">        executor = <span class="keyword">new</span> CachingExecutor(executor, autoCommit);</span><br><span class="line">    &#125;</span><br><span class="line">    executor = (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">    <span class="keyword">return</span> executor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Interceptor类核心方法代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">  <span class="comment">//intercept方法:如果自定插件实现Interceptor覆盖intercept方法，</span></span><br><span class="line">  <span class="comment">//这个方法是一个核心方法，里面参数Invocation对象，这个对象可以通过反射调度原来的对象的方法。</span></span><br><span class="line">  <span class="function">Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">  <span class="comment">//target被拦截的对象，它的作用把拦截的target对象变成一个代理对象</span></span><br><span class="line">  <span class="function">Object <span class="title">plugin</span><span class="params">(Object target)</span></span>;</span><br><span class="line">  <span class="comment">//允许plugin在注册的时候，配置插件需要的参数，这个参数可以在mybatsi的核心配置文件中注册插件的时候,一起配置到文件中</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2、源码分析">2、源码分析</h2>
<h3 id="2-1-插件类创建">2.1 插件类创建</h3>
<p>首先创建自定义插件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Intercepts</span>(&#123;<span class="meta">@Signature</span>(</span><br><span class="line">        type= Executor<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line"><span class="class">        <span class="title">method</span> </span>= <span class="string">"update"</span>,</span><br><span class="line">        args = &#123;MappedStatement<span class="class">.<span class="keyword">class</span>,<span class="title">Object</span>.<span class="title">class</span>&#125;)&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">ExamplePlugin</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">//自定义属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当执行目标方法时会被方法拦截</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object target = invocation.getTarget(); <span class="comment">//被代理对象</span></span><br><span class="line">        Method method = invocation.getMethod(); <span class="comment">//代理方法</span></span><br><span class="line">        Object[] args = invocation.getArgs(); <span class="comment">//方法参数</span></span><br><span class="line">        <span class="comment">// do something ...... 方法拦截前执行代码块</span></span><br><span class="line">        Object result = invocation.proceed();</span><br><span class="line">        <span class="comment">// do something .......方法拦截后执行代码块</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生成代理对象，可自定义生成代理对象，这样就无需配置@Intercepts注解。另外需要自行判断是否为拦截目标接口。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">plugin</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Plugin.wrap(target,<span class="keyword">this</span>);<span class="comment">// 调用通用插件代理生成机器</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置属性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.number = Integer.parseInt(properties.getProperty(<span class="string">"number"</span>, String.valueOf(<span class="number">100</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在config.xml 中添加插件配置，注意配置顺序</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">"org.demo.plugin.ExamplePlugin"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"number"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-2-源码分析">2.2 源码分析</h3>
<p><strong>构建图</strong></p>
<p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/20220301/20220301220021.png" alt></p>
<p><strong>核心代码</strong></p>
<p>插件对象的创建InterceptorChain</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//SqlSessionFactoryBuilder类的build方法</span></span><br><span class="line">XMLConfigBuilder parser = <span class="keyword">new</span> XMLConfigBuilder(inputStream, environment, properties);</span><br></pre></td></tr></table></figure>
<p><code>XMLConfigBuilder</code>会实例化一个Configuration对象，在创建Configuration对象，会调用构造函数，InterceptorChain对象的创建，就是在Configuration的构造函数中进行了初始化，如<code>InterceptorChain interceptorChain = new InterceptorChain();</code></p>
<p>进入InterceptorChain 代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorChain</span> </span>&#123;</span><br><span class="line">  <span class="comment">//这个集合很重要</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;Interceptor&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">pluginAll</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//pluginAll方法是把具体的四大接口的具体实现类，生成动态代理的方法。</span></span><br><span class="line">    <span class="keyword">for</span> (Interceptor interceptor : interceptors) &#123;</span><br><span class="line">      target = interceptor.plugin(target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptor</span><span class="params">(Interceptor interceptor)</span> </span>&#123;</span><br><span class="line">    interceptors.add(interceptor);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Interceptor&gt; <span class="title">getInterceptors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Collections.unmodifiableList(interceptors);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在parse()方法解析的时候，parseConfiguration()中解析插件<code>pluginElement(root.evalNode(&quot;plugins&quot;))</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//XMLConfigBuilder类</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pluginElement</span><span class="params">(XNode parent)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//这里循环解析配置文件中的所有定义的插件</span></span><br><span class="line">    <span class="keyword">for</span> (XNode child : parent.getChildren()) &#123;</span><br><span class="line">      String interceptor = child.getStringAttribute(<span class="string">"interceptor"</span>);</span><br><span class="line">      <span class="comment">//如果插件有配置属性。获取到配置的属性，然后把属性的值，注册到Properties对象中</span></span><br><span class="line">      Properties properties = child.getChildrenAsProperties();</span><br><span class="line">      <span class="comment">//同时获取到具体的注册的插件对象</span></span><br><span class="line">      Interceptor interceptorInstance = (Interceptor) resolveClass(interceptor).newInstance();</span><br><span class="line">      <span class="comment">//调用插件，并赋值插件中的属性</span></span><br><span class="line">      interceptorInstance.setProperties(properties);</span><br><span class="line">      <span class="comment">//注册到interceptorChain中</span></span><br><span class="line">      configuration.addInterceptor(interceptorInstance);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Configuration类</span></span><br><span class="line"><span class="comment">//这个集合就是把下面解析的插件，进行注册和收集的容器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptor</span><span class="params">(Interceptor interceptor)</span> </span>&#123;</span><br><span class="line">  interceptorChain.addInterceptor(interceptor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>插件的执行流程</p>
<p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/20220301/20220301220024.png" alt></p>
<h3 id="2-3-源码总结">2.3 源码总结</h3>
<p>Mybatis插件使用机制就是：** jdk动态代理＋责任链的设计模式**。插件的运行和注册会分为几个阶段：</p>
<p>1、<strong>定义阶段</strong>，定义插件类然后实现<code>Interceptor</code>接口，覆盖这个接口三个方法，分别是：<code>plugin</code>方法，<code>interceptor</code>方法，<code>setProperties</code>方法</p>
<ul>
<li>intercept方法：如果自定插件实现Interceptor覆盖intercept方法，这个方法是一个核心方法，里面参数Invocation对象，这个对象可以通过反射调度原来的对象的方法。</li>
<li>plugin方法：target被拦截的对象。它的作用:把拦截的target对象变成一个代理对象</li>
<li>setProperties方法：允许plugin在注册的时候，配置插件需要的参数，这个参数可以在mybats的核心配置文件中注册插件的时候，一起配置到文件中</li>
</ul>
<p>2、<strong>注册阶段</strong>，写入到mybatis配置文件中，如果是spring整合myabtis化，就使用配置类来进行插件的注册</p>
<p>3、同时在定义的时候，会通过<code>@Intercepts</code>注解和签名，来告诉插件具体要拦截那些类执行的方法，mybatis对四个接口实现类都会进行拦截</p>
<p>4、<strong>运行和执行阶段</strong>，定义了执行器的插件后，在初始化<code>sqlsession</code>的时候会确定一个执行器，而执行器在创建的时候，会调用<code>executor = (Executor)interceptorChain.pluginAll(executor)</code>。这个方法的作用就是把执行器对象变成一个代理对象，而代理对象的生成，是通过插件的的plugin方法进行生成和创建，具体的话是通过代理类Plugin中的wrap方法创建而生成，生成executor代理对象之后，当代理执行器执行方法的时候，就进入Plugin代理类中invoke方法中进行业务处理</p>
<h2 id="3、分页插件举例">3、分页插件举例</h2>
<h3 id="3-1-分页插件原理">3.1 分页插件原理</h3>
<p>首先设定一个Page类，其包含total、size、index 3个属性，在Mapper接口中声明该参数即表示需要执行自动分页逻辑。总体实现步骤包含3个：</p>
<ol>
<li>检测是否满足分页条件</li>
<li>自动求出当前查询的总行数</li>
<li>修改原有的SQL语句 ，添加 limit offset 关键字。</li>
</ol>
<h3 id="3-2-检测是否满足分页条件">3.2 检测是否满足分页条件</h3>
<p>分页条件是 1.是否为查询方法，2.查询参数中是否带上Page参数。在intercept 方法中可直接获得拦截目标StatementHandler ，通过它又可以获得BoundSql 里面就包含了SQL 和参数。遍历参数即可获得Page。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 带上分页参数</span></span><br><span class="line">StatementHandler target = (StatementHandler) invocation.getTarget();</span><br><span class="line"><span class="comment">// SQL包 sql、参数、参数映射</span></span><br><span class="line">BoundSql boundSql = target.getBoundSql();</span><br><span class="line">Object parameterObject = boundSql.getParameterObject();</span><br><span class="line">Page page = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (parameterObject <span class="keyword">instanceof</span> Page) &#123;</span><br><span class="line">    page = (Page) parameterObject;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (parameterObject <span class="keyword">instanceof</span> Map) &#123;</span><br><span class="line">    page = (Page) ((Map) parameterObject).values().stream().filter(v -&gt; v <span class="keyword">instanceof</span> Page).findFirst().orElse(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-查询总行数">3.3 查询总行数</h3>
<p>实现逻辑是 将原查询SQL作为子查询进行包装成子查询，然后用原有参数，还是能过原来的参数处理器进行赋值。关于执行是采用JDBC 原生API实现。MyBatis执行器，从而绕开了一二级缓存。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">selectCount</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    StatementHandler target = (StatementHandler) invocation.getTarget();</span><br><span class="line">    <span class="comment">// SQL包 sql、参数、参数映射</span></span><br><span class="line">    String countSql = String.format(<span class="string">"select count(*) from (%s) as _page"</span>, target.getBoundSql().getSql());</span><br><span class="line">    <span class="comment">// JDBC</span></span><br><span class="line">    Connection connection = (Connection) invocation.getArgs()[<span class="number">0</span>];</span><br><span class="line">    PreparedStatement preparedStatement = connection.prepareStatement(countSql);</span><br><span class="line">    target.getParameterHandler().setParameters(preparedStatement);</span><br><span class="line">    ResultSet resultSet = preparedStatement.executeQuery();</span><br><span class="line">    <span class="keyword">if</span> (resultSet.next()) &#123;</span><br><span class="line">        count = resultSet.getInt(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    resultSet.close();</span><br><span class="line">    preparedStatement.close();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-4-修改原SQL">3.4 修改原SQL</h3>
<p>最后一项就是修改原来的SQL，前面我是可以拿到BoundSql 的，但它没有提供修改SQL的方法，这里可以采用反射强行为SQL属性赋值。也可以采用MyBatis提供的工具类SystemMetaObject来赋值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String newSql= String.format(<span class="string">"%s limit %s offset %s"</span>, boundSql.getSql(),page.getSize(),page.getOffset());</span><br><span class="line">SystemMetaObject.forObject(boundSql).setValue(<span class="string">"sql"</span>,newSql);</span><br></pre></td></tr></table></figure>
<hr>
<p>参考文章：</p>
<p><a href="https://www.cnblogs.com/javazhiyin/p/12340498.html" target="_blank" rel="noopener">手把手带你阅读Mybatis源码（一）构造篇</a></p>
<p><a href="https://www.cnblogs.com/javazhiyin/p/12344651.html" target="_blank" rel="noopener">手把手带你阅读Mybatis源码（二）执行篇</a></p>
<p><a href="https://www.cnblogs.com/javazhiyin/p/12357397.html" target="_blank" rel="noopener">手把手带你阅读Mybatis源码（三）缓存篇</a></p>
<p><a href="http://coderead.cn/p/mybatis/doc/index.md" target="_blank" rel="noopener">源码阅读网</a></p>
<p><a href="https://www.bilibili.com/video/BV1Tp4y1X7FM" target="_blank" rel="noopener">MyBatis源码解析大合集</a></p>
<p><a href="https://www.bilibili.com/video/BV1J64y1q7V8" target="_blank" rel="noopener">[学相伴飞哥]Mybatis的源码分析-执行过程（一）</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring常用工具类</title>
    <url>/posts/92637ed4.html</url>
    <content><![CDATA[<h1>一、内置工具类</h1>
<p>内置工具类一般位于<code>org.springframework.util</code>下</p>
<h2 id="1、断言">1、断言</h2>
<ul>
<li>断言是一个逻辑判断，用于检查不应该发生的情况</li>
<li>Assert 关键字在 JDK1.4 中引入，可通过 JVM 参数<code>-enableassertions</code>开启</li>
<li>SpringBoot 中提供了 Assert 断言工具类，通常用于数据合法性检查</li>
</ul>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 要求参数 object 必须为非空（Not Null），否则抛出异常，不予放行</span></span><br><span class="line"><span class="comment">// 参数 message 参数用于定制异常信息。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">notNull</span><span class="params">(Object object, String message)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 要求参数必须空（Null），否则抛出异常，不予『放行』。</span></span></span><br><span class="line"><span class="function"><span class="comment">// 和 notNull() 方法断言规则相反</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">isNull</span><span class="params">(Object object, String message)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 要求参数必须为真（True），否则抛出异常，不予『放行』。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">isTrue</span><span class="params">(<span class="keyword">boolean</span> expression, String message)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 要求参数（List/Set）必须非空（Not Empty），否则抛出异常，不予放行</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">notEmpty</span><span class="params">(Collection collection, String message)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 要求参数（String）必须有长度（即，Not Empty），否则抛出异常，不予放行</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hasLength</span><span class="params">(String text, String message)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 要求参数（String）必须有内容（即，Not Blank），否则抛出异常，不予放行</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hasText</span><span class="params">(String text, String message)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 要求参数是指定类型的实例，否则抛出异常，不予放行</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">isInstanceOf</span><span class="params">(Class type, Object obj, String message)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 要求参数 `subType` 必须是参数 superType 的子类或实现类，否则抛出异常，不予放行</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">isAssignable</span><span class="params">(Class superType, Class subType, String message)</span></span></span><br></pre></td></tr></table></figure>
<h2 id="2、对象、数组、集合">2、对象、数组、集合</h2>
<h3 id="2-1-ObjectUtils">2.1 ObjectUtils</h3>
<ul>
<li>获取对象的基本信息</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取对象的类名。参数为 null 时，返回字符串："null" </span></span><br><span class="line"><span class="function">String <span class="title">nullSafeClassName</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 参数为 null 时，返回 0</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nullSafeHashCode</span><span class="params">(Object object)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 参数为 null 时，返回字符串："null"</span></span></span><br><span class="line"><span class="function">String <span class="title">nullSafeToString</span><span class="params">(<span class="keyword">boolean</span>[] array)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 获取对象 HashCode（十六进制形式字符串）。参数为 null 时，返回 0 </span></span></span><br><span class="line"><span class="function">String <span class="title">getIdentityHexString</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 获取对象的类名和 HashCode。 参数为 null 时，返回字符串："" </span></span></span><br><span class="line"><span class="function">String <span class="title">identityToString</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 相当于 toString()方法，但参数为 null 时，返回字符串：""</span></span></span><br><span class="line"><span class="function">String <span class="title">getDisplayString</span><span class="params">(Object obj)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>判断工具</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断数组是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">(Object[] array)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 判断参数对象是否是数组</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isArray</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 判断数组中是否包含指定元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsElement</span><span class="params">(Object[] array, Object element)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 相等，或同为 null时，返回 true</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">nullSafeEquals</span><span class="params">(Object o1, Object o2)</span></span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="function"><span class="comment">判断参数对象是否为空，判断标准为：</span></span></span><br><span class="line"><span class="function"><span class="comment">  Optional: Optional.empty()</span></span></span><br><span class="line"><span class="function"><span class="comment">    Array: length == 0</span></span></span><br><span class="line"><span class="function"><span class="comment">CharSequence: length == 0</span></span></span><br><span class="line"><span class="function"><span class="comment">  Collection: Collection.isEmpty()</span></span></span><br><span class="line"><span class="function"><span class="comment">    Map: Map.isEmpty()</span></span></span><br><span class="line"><span class="function"><span class="comment">  */</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">(Object obj)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>其他工具方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 向参数数组的末尾追加新元素，并返回一个新数组</span></span><br><span class="line">&lt;A, O extends A&gt; A[] addObjectToArray(A[] array, O obj)</span><br><span class="line"><span class="comment">// 原生基础类型数组 --&gt; 包装类数组</span></span><br><span class="line">Object[] toObjectArray(Object source)</span><br></pre></td></tr></table></figure>
<h3 id="2-2-StringUtils">2.2 StringUtils</h3>
<ul>
<li>字符串判断工具</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断字符串是否为 null，或 ""。注意，包含空白符的字符串为非空</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">(Object str)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 判断字符串是否是以指定内容结束。忽略大小写</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">endsWithIgnoreCase</span><span class="params">(String str, String suffix)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 判断字符串是否已指定内容开头。忽略大小写</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">startsWithIgnoreCase</span><span class="params">(String str, String prefix)</span> <span class="comment">// 是否包含空白符</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsWhitespace</span><span class="params">(String str)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 判断字符串非空且长度不为 0，即，Not Empty</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasLength</span><span class="params">(CharSequence str)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 判断字符串是否包含实际内容，即非仅包含空白符，也就是 Not Blank</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasText</span><span class="params">(CharSequence str)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 判断字符串指定索引处是否包含一个子串。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">substringMatch</span><span class="params">(CharSequence str, <span class="keyword">int</span> index, CharSequence substring)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 计算一个字符串中指定子串的出现次数</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countOccurrencesOf</span><span class="params">(String str, String sub)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>字符串操作工具</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找并替换指定子串</span></span><br><span class="line"><span class="function">String <span class="title">replace</span><span class="params">(String inString, String oldPattern, String newPattern)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 去除尾部的特定字符</span></span></span><br><span class="line"><span class="function">String <span class="title">trimTrailingCharacter</span><span class="params">(String str, <span class="keyword">char</span> trailingCharacter)</span> <span class="comment">// 去除头部的特定字符</span></span></span><br><span class="line"><span class="function">String <span class="title">trimLeadingCharacter</span><span class="params">(String str, <span class="keyword">char</span> leadingCharacter)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 去除头部的空白符</span></span></span><br><span class="line"><span class="function">String <span class="title">trimLeadingWhitespace</span><span class="params">(String str)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 去除头部的空白符</span></span></span><br><span class="line"><span class="function">String <span class="title">trimTrailingWhitespace</span><span class="params">(String str)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 去除头部和尾部的空白符</span></span></span><br><span class="line"><span class="function">String <span class="title">trimWhitespace</span><span class="params">(String str)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 删除开头、结尾和中间的空白符</span></span></span><br><span class="line"><span class="function">String <span class="title">trimAllWhitespace</span><span class="params">(String str)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 删除指定子串</span></span></span><br><span class="line"><span class="function">String <span class="title">delete</span><span class="params">(String inString, String pattern)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 删除指定字符（可以是多个）</span></span></span><br><span class="line"><span class="function">String <span class="title">deleteAny</span><span class="params">(String inString, String charsToDelete)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 对数组的每一项执行 trim() 方法</span></span></span><br><span class="line"><span class="function">String[] <span class="title">trimArrayElements</span><span class="params">(String[] array)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 将 URL 字符串进行解码</span></span></span><br><span class="line"><span class="function">String <span class="title">uriDecode</span><span class="params">(String source, Charset charset)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>路径相关工具方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解析路径字符串，优化其中的 “..” </span></span><br><span class="line"><span class="function">String <span class="title">cleanPath</span><span class="params">(String path)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 解析路径字符串，解析出文件名部分</span></span></span><br><span class="line"><span class="function">String <span class="title">getFilename</span><span class="params">(String path)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 解析路径字符串，解析出文件后缀名</span></span></span><br><span class="line"><span class="function">String <span class="title">getFilenameExtension</span><span class="params">(String path)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 比较两个两个字符串，判断是否是同一个路径。会自动处理路径中的 “..” </span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">pathEquals</span><span class="params">(String path1, String path2)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 删除文件路径名中的后缀部分</span></span></span><br><span class="line"><span class="function">String <span class="title">stripFilenameExtension</span><span class="params">(String path)</span> <span class="comment">// 以 “. 作为分隔符，获取其最后一部分</span></span></span><br><span class="line"><span class="function">String <span class="title">unqualify</span><span class="params">(String qualifiedName)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 以指定字符作为分隔符，获取其最后一部分</span></span></span><br><span class="line"><span class="function">String <span class="title">unqualify</span><span class="params">(String qualifiedName, <span class="keyword">char</span> separator)</span></span></span><br></pre></td></tr></table></figure>
<h3 id="2-3-CollectionUtils">2.3 CollectionUtils</h3>
<ul>
<li>集合判断工具</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断 List/Set 是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">(Collection&lt;?&gt; collection)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 判断 Map 是否为空</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">(Map&lt;?,?&gt; map)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 判断 List/Set 中是否包含某个对象</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsInstance</span><span class="params">(Collection&lt;?&gt; collection, Object element)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 以迭代器的方式，判断 List/Set 中是否包含某个对象</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Iterator&lt;?&gt; iterator, Object element)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 判断 List/Set 是否包含某些对象中的任意一个</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsAny</span><span class="params">(Collection&lt;?&gt; source, Collection&lt;?&gt; candidates)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 判断 List/Set 中的每个元素是否唯一。即 List/Set 中不存在重复元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasUniqueObject</span><span class="params">(Collection&lt;?&gt; collection)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>集合操作工具</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将 Array 中的元素都添加到 List/Set 中</span></span><br><span class="line"><span class="comment">// 将 Properties 中的键值对都添加到 Map 中</span></span><br><span class="line">&lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">mergeArrayIntoCollection</span><span class="params">(Object array, Collection&lt;E&gt; collection)</span>  </span></span><br><span class="line"><span class="function">&lt;K,V&gt; <span class="keyword">void</span> <span class="title">mergePropertiesIntoMap</span><span class="params">(Properties props, Map&lt;K,V&gt; map)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回 List 中最后一个元素</span></span></span><br><span class="line"><span class="function">&lt;T&gt; T <span class="title">lastElement</span><span class="params">(List&lt;T&gt; list)</span>  <span class="comment">// 返回 Set 中最后一个元素</span></span></span><br><span class="line"><span class="function">&lt;T&gt; T <span class="title">lastElement</span><span class="params">(Set&lt;T&gt; set)</span> <span class="comment">// 返回参数 candidates 中第一个存在于参数 source 中的元素</span></span></span><br><span class="line"><span class="function">&lt;E&gt; E <span class="title">findFirstMatch</span><span class="params">(Collection&lt;?&gt; source, Collection&lt;E&gt; candidates)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回 List/Set 中指定类型的元素。</span></span></span><br><span class="line"><span class="function">&lt;T&gt; T <span class="title">findValueOfType</span><span class="params">(Collection&lt;?&gt; collection, Class&lt;T&gt; type)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回 List/Set 中指定类型的元素。如果第一种类型未找到，则查找第二种类型，以此类推</span></span></span><br><span class="line"><span class="function">Object <span class="title">findValueOfType</span><span class="params">(Collection&lt;?&gt; collection, Class&lt;?&gt;[] types)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回 List/Set 中元素的类型</span></span></span><br><span class="line"><span class="function">Class&lt;?&gt; <span class="title">findCommonElementType</span><span class="params">(Collection&lt;?&gt; collection)</span></span></span><br></pre></td></tr></table></figure>
<h2 id="3、文件、资源、IO-流">3、文件、资源、IO 流</h2>
<h3 id="3-1-FileCopyUtils">3.1 FileCopyUtils</h3>
<ul>
<li>输入</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从文件中读入到字节数组中</span></span><br><span class="line"><span class="keyword">byte</span>[] copyToByteArray(File in)</span><br><span class="line"><span class="comment">// 从输入流中读入到字节数组中</span></span><br><span class="line"><span class="keyword">byte</span>[] copyToByteArray(InputStream in)</span><br><span class="line"><span class="comment">// 从输入流中读入到字符串中</span></span><br><span class="line"><span class="function">String <span class="title">copyToString</span><span class="params">(Reader in)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>输出</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从字节数组到文件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(<span class="keyword">byte</span>[] in, File out)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 从文件到文件</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copy</span><span class="params">(File in, File out)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 从字节数组到输出流</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(<span class="keyword">byte</span>[] in, OutputStream out)</span> <span class="comment">// 从输入流到输出流</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copy</span><span class="params">(InputStream in, OutputStream out)</span> <span class="comment">// 从输入流到输出流</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copy</span><span class="params">(Reader in, Writer out)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 从字符串到输出流</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(String in, Writer out)</span></span></span><br></pre></td></tr></table></figure>
<h3 id="3-2-ResourceUtils">3.2 ResourceUtils</h3>
<ul>
<li>从资源路径获取文件</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断字符串是否是一个合法的 URL 字符串。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isUrl</span><span class="params">(String resourceLocation)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 获取 URL</span></span></span><br><span class="line"><span class="function"><span class="comment">// 获取文件（在 JAR 包内无法正常使用，需要是一个独立的文件）</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> URL <span class="title">getURL</span><span class="params">(String resourceLocation)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">static</span> File  <span class="title">getFile</span><span class="params">(String resourceLocation)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>Resource</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件系统资源 D:...</span></span><br><span class="line">FileSystemResource</span><br><span class="line"><span class="comment">// URL 资源，如 file://... http://...</span></span><br><span class="line">UrlResource</span><br><span class="line"><span class="comment">// 类路径下的资源，classpth:...</span></span><br><span class="line">ClassPathResource</span><br><span class="line"><span class="comment">// Web 容器上下文中的资源（jar 包、war 包）</span></span><br><span class="line">ServletContextResource</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断资源是否存在</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">exists</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 从资源中获得 File 对象</span></span></span><br><span class="line"><span class="function">File <span class="title">getFile</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 从资源中获得 URI 对象</span></span></span><br><span class="line"><span class="function">URI <span class="title">getURI</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 从资源中获得 URI 对象</span></span></span><br><span class="line"><span class="function">URL <span class="title">getURL</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 获得资源的 InputStream</span></span></span><br><span class="line"><span class="function">InputStream <span class="title">getInputStream</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 获得资源的描述信息</span></span></span><br><span class="line"><span class="function">String <span class="title">getDescription</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<h3 id="3-3-StreamUtils">3.3 StreamUtils</h3>
<ul>
<li>输入</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(<span class="keyword">byte</span>[] in, OutputStream out)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copy</span><span class="params">(InputStream in, OutputStream out)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(String in, Charset charset, OutputStream out)</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">copyRange</span><span class="params">(InputStream in, OutputStream out, <span class="keyword">long</span> start, <span class="keyword">long</span> end)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>输出</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] copyToByteArray(InputStream in)</span><br><span class="line"><span class="function">String <span class="title">copyToString</span><span class="params">(InputStream in, Charset charset)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 舍弃输入流中的内容</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">drain</span><span class="params">(InputStream in)</span></span></span><br></pre></td></tr></table></figure>
<h2 id="4、反射、AOP">4、反射、AOP</h2>
<h3 id="4-1-ReflectionUtils">4.1 ReflectionUtils</h3>
<ul>
<li>获取方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在类中查找指定方法</span></span><br><span class="line"><span class="function">Method <span class="title">findMethod</span><span class="params">(Class&lt;?&gt; clazz, String name)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 同上，额外提供方法参数类型作查找条件</span></span></span><br><span class="line"><span class="function">Method <span class="title">findMethod</span><span class="params">(Class&lt;?&gt; clazz, String name, Class&lt;?&gt;... paramTypes)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 获得类中所有方法，包括继承而来的</span></span></span><br><span class="line"><span class="function">Method[] <span class="title">getAllDeclaredMethods</span><span class="params">(Class&lt;?&gt; leafClass)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 在类中查找指定构造方法</span></span></span><br><span class="line"><span class="function">Constructor&lt;T&gt; <span class="title">accessibleConstructor</span><span class="params">(Class&lt;T&gt; clazz, Class&lt;?&gt;... parameterTypes)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 是否是 equals() 方法</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEqualsMethod</span><span class="params">(Method method)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 是否是 hashCode() 方法 </span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isHashCodeMethod</span><span class="params">(Method method)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 是否是 toString() 方法</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isToStringMethod</span><span class="params">(Method method)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 是否是从 Object 类继承而来的方法</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isObjectMethod</span><span class="params">(Method method)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 检查一个方法是否声明抛出指定异常</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">declaresException</span><span class="params">(Method method, Class&lt;?&gt; exceptionType)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>执行方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行方法</span></span><br><span class="line"><span class="function">Object <span class="title">invokeMethod</span><span class="params">(Method method, Object target)</span>  </span></span><br><span class="line"><span class="function"><span class="comment">// 同上，提供方法参数</span></span></span><br><span class="line"><span class="function">Object <span class="title">invokeMethod</span><span class="params">(Method method, Object target, Object... args)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 取消 Java 权限检查。以便后续执行该私有方法</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeAccessible</span><span class="params">(Method method)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 取消 Java 权限检查。以便后续执行私有构造方法</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeAccessible</span><span class="params">(Constructor&lt;?&gt; ctor)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>获取字段</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在类中查找指定属性</span></span><br><span class="line"><span class="function">Field <span class="title">findField</span><span class="params">(Class&lt;?&gt; clazz, String name)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 同上，多提供了属性的类型</span></span></span><br><span class="line"><span class="function">Field <span class="title">findField</span><span class="params">(Class&lt;?&gt; clazz, String name, Class&lt;?&gt; type)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 是否为一个 "public static final" 属性</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isPublicStaticFinal</span><span class="params">(Field field)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>设置字段</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取 target 对象的 field 属性值</span></span><br><span class="line"><span class="function">Object <span class="title">getField</span><span class="params">(Field field, Object target)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 设置 target 对象的 field 属性值，值为 value</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setField</span><span class="params">(Field field, Object target, Object value)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 同类对象属性对等赋值</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shallowCopyFieldState</span><span class="params">(Object src, Object dest)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 取消 Java 的权限控制检查。以便后续读写该私有属性</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeAccessible</span><span class="params">(Field field)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 对类的每个属性执行 callback</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doWithFields</span><span class="params">(Class&lt;?&gt; clazz, ReflectionUtils.FieldCallback fc)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 同上，多了个属性过滤功能。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doWithFields</span><span class="params">(Class&lt;?&gt; clazz, ReflectionUtils.FieldCallback fc, </span></span></span><br><span class="line"><span class="function"><span class="params">                  ReflectionUtils.FieldFilter ff)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 同上，但不包括继承而来的属性</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doWithLocalFields</span><span class="params">(Class&lt;?&gt; clazz, ReflectionUtils.FieldCallback fc)</span></span></span><br></pre></td></tr></table></figure>
<h3 id="4-2-AopUtils">4.2 AopUtils</h3>
<ul>
<li>判断代理类型</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断是不是 Spring 代理对象</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isAopProxy</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 判断是不是 jdk 动态代理对象</span></span></span><br><span class="line"><span class="function"><span class="title">isJdkDynamicProxy</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 判断是不是 CGLIB 代理对象</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isCglibProxy</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>获取被代理对象的 class</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取被代理的目标 class</span></span><br><span class="line">Class&lt;?&gt; getTargetClass()</span><br></pre></td></tr></table></figure>
<h3 id="4-3-AopContext">4.3 AopContext</h3>
<ul>
<li>获取当前对象的代理对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Object <span class="title">currentProxy</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<h3 id="4-4-AOP举例">4.4 AOP举例</h3>
<ul>
<li>演示对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zstu.student;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String field01 = <span class="string">"这是字段1"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String field02 = <span class="string">"这是字段2"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DemoObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DemoObject</span><span class="params">(String field01)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.field01 = field01;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">method01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"无参方法1"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method01</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"有参方法1"</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method02</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"异常方法2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.equals(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>反射举例</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">"---------- findMethod ----------"</span>);</span><br><span class="line"><span class="comment">// 获取方法</span></span><br><span class="line">Method method1 = ReflectionUtils.findMethod(DemoObject.class, "method01");</span><br><span class="line">Method method2 = ReflectionUtils.findMethod(DemoObject.class, "method02");</span><br><span class="line"><span class="comment">// public java.lang.Object com.zstu.student.DemoObject.method01()</span></span><br><span class="line">System.out.println(method1);</span><br><span class="line">System.out.println(<span class="string">"---------- findField ----------"</span>);</span><br><span class="line"><span class="comment">// 获取属性</span></span><br><span class="line">Field field1 = ReflectionUtils.findField(DemoObject.class, "field01");</span><br><span class="line">Field field2 = ReflectionUtils.findField(DemoObject.class, "field02");</span><br><span class="line"><span class="comment">// private java.lang.String com.zstu.student.DemoObject.field01</span></span><br><span class="line">System.out.println(field1);</span><br><span class="line">System.out.println(<span class="string">"---------- accessibleConstructor ----------"</span>);</span><br><span class="line"><span class="comment">// 获取构造方法</span></span><br><span class="line">Constructor&lt;DemoObject&gt; constructor1 = ReflectionUtils.accessibleConstructor(DemoObject<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">Constructor&lt;DemoObject&gt; constructor2 = ReflectionUtils.accessibleConstructor(DemoObject<span class="class">.<span class="keyword">class</span>, <span class="title">String</span>.<span class="title">class</span>)</span>;</span><br><span class="line"><span class="comment">// [public com.zstu.student.DemoObject(), public com.zstu.student.DemoObject(java.lang.String)]</span></span><br><span class="line">System.out.println(Arrays.toString(<span class="keyword">new</span> String[] &#123; constructor1.toString(), constructor2.toString() &#125;));</span><br><span class="line">System.out.println(<span class="string">"---------- declaresException ----------"</span>);</span><br><span class="line"><span class="comment">// 方法是否存在指定的抛出异常</span></span><br><span class="line"><span class="keyword">assert</span> method2 != <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">boolean</span> existIOException = ReflectionUtils.declaresException(method2, IOException<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="keyword">boolean</span> existException = ReflectionUtils.declaresException(method2, Exception<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="comment">// true - false</span></span><br><span class="line">System.out.println(existIOException + <span class="string">" - "</span> + existException);</span><br><span class="line">System.out.println(<span class="string">"---------- doWithFields ----------"</span>);</span><br><span class="line"><span class="comment">// 返回所有字段，通过回调</span></span><br><span class="line"><span class="comment">//private java.lang.String com.zstu.student.DemoObject.field01</span></span><br><span class="line"><span class="comment">//public static final java.lang.String com.zstu.student.DemoObject.field02</span></span><br><span class="line">ReflectionUtils.doWithFields(DemoObject.class, System.out::println);</span><br><span class="line">System.out.println(<span class="string">"---------- doWithLocalMethods ----------"</span>);</span><br><span class="line"><span class="comment">// 返回当前类所有方法，通过回调</span></span><br><span class="line">ReflectionUtils.doWithLocalMethods(DemoObject.class, System.out::println);</span><br><span class="line">System.out.println(<span class="string">"---------- doWithMethods ----------"</span>);</span><br><span class="line"><span class="comment">// 返回所有方法包括继承类，通过回调</span></span><br><span class="line">ReflectionUtils.doWithMethods(DemoObject.class, System.out::println);</span><br><span class="line">System.out.println(<span class="string">"---------- getAllDeclaredMethods ----------"</span>);</span><br><span class="line"><span class="comment">// 返回所有方法包括继承</span></span><br><span class="line">Method[] methods = ReflectionUtils.getAllDeclaredMethods(DemoObject<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">System.out.println(Arrays.toString(methods));</span><br><span class="line">System.out.println(<span class="string">"---------- getDeclaredMethods ----------"</span>);</span><br><span class="line"><span class="comment">// 返回所有当前类的方法</span></span><br><span class="line">methods = ReflectionUtils.getDeclaredMethods(DemoObject<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">System.out.println(Arrays.toString(methods));</span><br><span class="line">System.out.println(<span class="string">"---------- doWithLocalFields ----------"</span>);</span><br><span class="line"><span class="comment">// 当前类的所有方法，通过回调</span></span><br><span class="line"><span class="comment">// private java.lang.String com.zstu.student.DemoObject.field01</span></span><br><span class="line"><span class="comment">// public static final java.lang.String com.zstu.student.DemoObject.field02</span></span><br><span class="line">ReflectionUtils.doWithLocalFields(DemoObject.class, System.out::println);</span><br><span class="line">System.out.println(<span class="string">"---------- getUniqueDeclaredMethods ----------"</span>);</span><br><span class="line"><span class="comment">// 若在子类重新父类方法则该方法将被移除</span></span><br><span class="line">methods = ReflectionUtils.getUniqueDeclaredMethods(DemoObject<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">System.out.println(Arrays.toString(methods));</span><br><span class="line">System.out.println(<span class="string">"---------- getField ----------"</span>);</span><br><span class="line"><span class="comment">// 获取字段的值</span></span><br><span class="line">Object ret1 = ReflectionUtils.getField(field2, <span class="keyword">new</span> DemoObject());</span><br><span class="line"><span class="comment">// 这是字段2</span></span><br><span class="line">System.out.println(ret1);</span><br><span class="line">System.out.println(<span class="string">"---------- invokeMethod ----------"</span>);</span><br><span class="line"><span class="comment">// 调用方法</span></span><br><span class="line">Object ret2 = ReflectionUtils.invokeMethod(method1, <span class="keyword">new</span> DemoObject());</span><br><span class="line"><span class="comment">// 无参方法1</span></span><br><span class="line">System.out.println(ret2);</span><br><span class="line">System.out.println(<span class="string">"---------- isxxx----------"</span>);</span><br><span class="line"><span class="comment">// 是toString方法吗? true是,false不是</span></span><br><span class="line">boolean isString = ReflectionUtils.isToStringMethod(ReflectionUtils.findMethod(DemoObject.class, "toString"));</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">System.out.println(isString);</span><br><span class="line"><span class="comment">// 是否公共静态final修饰属性吗? true是,false不是</span></span><br><span class="line"><span class="keyword">boolean</span> isPublicStatic = ReflectionUtils.isPublicStaticFinal(field2);</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">System.out.println(isPublicStatic);</span><br><span class="line"><span class="comment">// 是Object类声明的方法吗? true是,false不是</span></span><br><span class="line">boolean isObject = ReflectionUtils.isObjectMethod(ReflectionUtils.findMethod(DemoObject.class, "toString"));</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">System.out.println(isObject);</span><br><span class="line"><span class="comment">// 是equals方法吗? true是,false不是</span></span><br><span class="line">boolean isEquals = ReflectionUtils.isEqualsMethod(ReflectionUtils.findMethod(DemoObject.class, "equals", Object.class));</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">System.out.println(isEquals);</span><br><span class="line"><span class="comment">// 是hashCode方法吗? true是,false不是</span></span><br><span class="line">boolean isHashCode = ReflectionUtils.isHashCodeMethod(ReflectionUtils.findMethod(DemoObject.class, "hashCode"));</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">System.out.println(isHashCode);</span><br><span class="line"><span class="comment">// 清空缓存，每次查询(方法,参数)时都会做缓存。</span></span><br><span class="line">ReflectionUtils.clearCache();</span><br><span class="line"><span class="comment">// 是Cglib重命名的方法吗? TODO test</span></span><br><span class="line"><span class="comment">// ReflectionUtils.isCglibRenamedMethod()</span></span><br></pre></td></tr></table></figure>
<h1>二、第三方工具类</h1>
<p>这里推荐的第三方工具类是<strong>Hutool工具类</strong>，里面工具包十分全面，官方网址<a href="https://hutool.cn/docs/#/" target="_blank" rel="noopener">https://hutool.cn/docs/#/</a></p>
<hr>
<p>参考转载文章：</p>
<p><a href="https://juejin.cn/post/7043403364020781064#heading-10" target="_blank" rel="noopener">https://juejin.cn/post/7043403364020781064#heading-10</a></p>
<p><a href="https://blog.csdn.net/ZG123456h/article/details/122104601" target="_blank" rel="noopener">https://blog.csdn.net/ZG123456h/article/details/122104601</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Spring基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java命令行编译打包</title>
    <url>/posts/aea952f.html</url>
    <content><![CDATA[<h1>一、简介</h1>
<h2 id="1、介绍">1、介绍</h2>
<p>本文主要记录jar与java相关命令介绍以及Java 命令行编译、执行、打包等操作</p>
<a id="more"></a>
<h2 id="2、Jar简介">2、Jar简介</h2>
<blockquote>
<p><a href="https://docs.oracle.com/javase/tutorial/deployment/jar/manifestindex.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/tutorial/deployment/jar/manifestindex.html</a></p>
</blockquote>
<p>Java归档文件格式(Java Archive, JAR)能够将多个源码、资源等文件打包到一个归档文件中，包括以下几种优点</p>
<ul>
<li>安全性<br>
可以对整个jar包的内容进行签名。</li>
<li>减少下载时间<br>
如果applet被打包成一个jar文件，那么所有相关的资源就可以在一个HTTP transaction中下载完成，而无需为每一个文件新建一个连接。</li>
<li>压缩<br>
减少了磁盘空间的占用。</li>
<li>容易扩展<br>
通过jar这种格式，可以和容易地将自己的程序打包提供给别人使用。</li>
<li>包密封(Package Sealing)<br>
存储在jar文件中的包可以被密封，来保证版本的一致性。密封可以保证一个包中的所有类都来自同一个jar文件。</li>
<li>包版本说明<br>
一个jar包可以存储关于其内容的信息，包括提供商、版本等。</li>
<li>可移植性<br>
处理jar文件的机制是Java平台核心API的标准模块。</li>
</ul>
<h2 id="3、Java命令行">3、Java命令行</h2>
<h3 id="3-1-jar相关命令">3.1 jar相关命令</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jar</span><br><span class="line">用法: jar &#123;ctxui&#125;[vfmn0PMe] [jar-file] [manifest-file] [entry-point] [-C dir] files ...</span><br><span class="line">选项:</span><br><span class="line">    -c  创建新档案</span><br><span class="line">    -t  列出档案目录</span><br><span class="line">    -x  从档案中提取指定的 (或所有) 文件</span><br><span class="line">    -u  更新现有档案</span><br><span class="line">    -v  在标准输出中生成详细输出</span><br><span class="line">    -f  指定档案文件名</span><br><span class="line">    -m  包含指定清单文件中的清单信息</span><br><span class="line">    -n  创建新档案后执行 Pack200 规范化</span><br><span class="line">    -e  为捆绑到可执行 jar 文件的独立应用程序指定应用程序入口点</span><br><span class="line">    -0  仅存储; 不使用任何 ZIP 压缩</span><br><span class="line">    -P  保留文件名中的前导 <span class="string">'/'</span> (绝对路径) 和 <span class="string">".."</span> (父目录) 组件</span><br><span class="line">    -M  不创建条目的清单文件</span><br><span class="line">    -i  为指定的 jar 文件生成索引信息</span><br><span class="line">    -C  更改为指定的目录并包含其中的文件(可以理解为首先<span class="built_in">cd</span>到指定目录)</span><br><span class="line">如果任何文件为目录, 则对其进行递归处理。</span><br><span class="line">清单文件名, 档案文件名和入口点名称的指定顺序与 <span class="string">'m'</span>, <span class="string">'f'</span> 和 <span class="string">'e'</span> 标记的指定顺序相同。</span><br><span class="line"></span><br><span class="line">示例 1: 将两个类文件归档到一个名为 classes.jar 的档案中:</span><br><span class="line">       jar cvf classes.jar Foo.class Bar.class</span><br><span class="line">示例 2: 使用现有的清单文件 <span class="string">'mymanifest'</span> 并将 foo/ 目录中的所有文件归档到 <span class="string">'classes.jar'</span> 中:</span><br><span class="line">       jar cvfm classes.jar mymanifest -C foo/ .</span><br></pre></td></tr></table></figure>
<p>下面举例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看归档文件的内容</span></span><br><span class="line">jar -vtf HelloWorld.jar</span><br><span class="line"><span class="comment">#解压出其中的META-INF/MANIFEST.MF文件</span></span><br><span class="line">jar -xf HelloWorld.jar META-INF/MANIFEST.MF</span><br><span class="line"><span class="comment">#查看清单文件的内容</span></span><br><span class="line"><span class="built_in">type</span> META-INF\MANIFEST.MF</span><br><span class="line"><span class="comment">#将HelloWorld.class文件打入jar包，不要添加清单文件</span></span><br><span class="line">jar -cvfM HelloWorld.jar HelloWorld.class</span><br><span class="line"><span class="comment">#解压tar文件到当前目录</span></span><br><span class="line">jar -xf HelloWorld.jar</span><br><span class="line"><span class="comment">#创建可以运行的jar包</span></span><br><span class="line">jar -cvfe HelloWorld.jar HelloWorld HelloWorld.class</span><br></pre></td></tr></table></figure>
<h3 id="3-2-Java相关命令">3.2 Java相关命令</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">用法: java [-options] class [args...]</span><br><span class="line">           (执行类)</span><br><span class="line">   或  java [-options] -jar jarfile [args...]</span><br><span class="line">           (执行 jar 文件)</span><br><span class="line">其中选项包括:</span><br><span class="line">    -d32          使用 32 位数据模型 (如果可用)</span><br><span class="line">    -d64          使用 64 位数据模型 (如果可用)</span><br><span class="line">    -server       选择 <span class="string">"server"</span> VM</span><br><span class="line">                  默认 VM 是 server.</span><br><span class="line"></span><br><span class="line">    -cp &lt;目录和 zip/jar 文件的类搜索路径&gt;</span><br><span class="line">    -classpath &lt;目录和 zip/jar 文件的类搜索路径&gt;</span><br><span class="line">                  用 ; 分隔的目录, JAR 档案</span><br><span class="line">                  和 ZIP 档案列表, 用于搜索类文件。</span><br><span class="line">    -D&lt;名称&gt;=&lt;值&gt;</span><br><span class="line">                  设置系统属性</span><br><span class="line">    -verbose:[class|gc|jni]</span><br><span class="line">                  启用详细输出</span><br><span class="line">    -version      输出产品版本并退出</span><br><span class="line">    -version:&lt;值&gt;</span><br><span class="line">                  警告: 此功能已过时, 将在</span><br><span class="line">                  未来发行版中删除。</span><br><span class="line">                  需要指定的版本才能运行</span><br><span class="line">    -showversion  输出产品版本并继续</span><br><span class="line">    -jre-restrict-search | -no-jre-restrict-search</span><br><span class="line">                  警告: 此功能已过时, 将在</span><br><span class="line">                  未来发行版中删除。</span><br><span class="line">                  在版本搜索中包括/排除用户专用 JRE</span><br><span class="line">    -? -<span class="built_in">help</span>      输出此帮助消息</span><br><span class="line">    -X            输出非标准选项的帮助</span><br><span class="line">    -ea[:&lt;packagename&gt;...|:&lt;classname&gt;]</span><br><span class="line">    -enableassertions[:&lt;packagename&gt;...|:&lt;classname&gt;]</span><br><span class="line">                  按指定的粒度启用断言</span><br><span class="line">    -da[:&lt;packagename&gt;...|:&lt;classname&gt;]</span><br><span class="line">    -disableassertions[:&lt;packagename&gt;...|:&lt;classname&gt;]</span><br><span class="line">                  禁用具有指定粒度的断言</span><br><span class="line">    -esa | -enablesystemassertions</span><br><span class="line">                  启用系统断言</span><br><span class="line">    -dsa | -disablesystemassertions</span><br><span class="line">                  禁用系统断言</span><br><span class="line">    -agentlib:&lt;libname&gt;[=&lt;选项&gt;]</span><br><span class="line">                  加载本机代理库 &lt;libname&gt;, 例如 -agentlib:hprof</span><br><span class="line">                  另请参阅 -agentlib:jdwp=<span class="built_in">help</span> 和 -agentlib:hprof=<span class="built_in">help</span></span><br><span class="line">    -agentpath:&lt;pathname&gt;[=&lt;选项&gt;]</span><br><span class="line">                  按完整路径名加载本机代理库</span><br><span class="line">    -javaagent:&lt;jarpath&gt;[=&lt;选项&gt;]</span><br><span class="line">                  加载 Java 编程语言代理, 请参阅 java.lang.instrument</span><br><span class="line">    -splash:&lt;imagepath&gt;</span><br><span class="line">                  使用指定的图像显示启动屏幕</span><br></pre></td></tr></table></figure>
<h1>二、简单编译打包实战</h1>
<h2 id="1、简单编译执行">1、简单编译执行</h2>
<p>首先创建好目录已经demo文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/82c5f1b2d1bc435ab1a11515f7e9be5d.png" alt="在这里插入图片描述"><br>
编译执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -d target 参数，指定 class 文件生成在 target 目录</span></span><br><span class="line">javac src/com/demo/Hello.java -d target</span><br><span class="line"><span class="comment">#在dos下编译java程序，就要用到classpath这个概念，尤其是在没有设置环境变量的时候，classpath就是存放.class等编译后文件的路径</span></span><br><span class="line"><span class="comment"># -cp target这个参数是把target目录添加到 classpath 目录，成功输出hello</span></span><br><span class="line">java -cp target com.demo.Hello</span><br><span class="line"><span class="comment"># 引入第三方依赖库，用：进行分隔</span></span><br><span class="line">java -cp target:libs/gson-2.8.5.jar com.demo.HelloGson</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/78009b1f03614748a02b3a439fdc564f.png?type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6a2FTGVtb24=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h2 id="2、Jar包方式运行">2、Jar包方式运行</h2>
<h3 id="2-1-普通方式执行">2.1 普通方式执行</h3>
<p>Java程序打包与执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -C target . 参数，指定把 target 目录下的所有文件打包</span></span><br><span class="line">jar -cvf my.jar -C target .</span><br><span class="line"><span class="comment"># 这里执行java -jar my.jar会报错，因为没有指定入口</span></span><br><span class="line"><span class="comment"># -cp my.jar 把 jar 包添加到 classpath 目录</span></span><br><span class="line"><span class="comment"># com.demo.Hello 说明哪个类是入口</span></span><br><span class="line">java -cp my.jar com.demo.Hello</span><br></pre></td></tr></table></figure>
<h3 id="2-2-可执行的-jar-包">2.2 可执行的 jar 包</h3>
<p>可执行jar包可以直接执行，无需指定入口，但是需要创建<code>MANIFEST.MF</code>文件在文件内说明程序入口；<br>
一般编写MANIFEST.MF文件只需要用到<strong>Manifest-Version</strong>(MF文件版本号)、<strong>Main-Class</strong>(包含main方法的类)、<strong>Class-Path</strong>(执行这个jar包时的ClassPath，第三方依赖)，详情可以参考<br>
<a href="https://www.cnblogs.com/EasonJim/p/6485677.html" target="_blank" rel="noopener">MANIFEST.MF文件解释</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#注意最后一样一定要回车，空一行，不然无法识别最后一行的配置</span></span><br><span class="line">Manifest-Version: 1.0 </span><br><span class="line">Main-Class: com.demo.Hello</span><br><span class="line"><span class="comment"># 第三方依赖举例</span></span><br><span class="line">Class-Path: ./ ./lib/commons-collections-3.2.jar ./lib/commons-dbcp-1.2.2.jar</span><br></pre></td></tr></table></figure>
<p>之后再次打包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加了 m 参数，指定 MANIFEST.MF，这个文件的内容会被添加到 jar 包的清单，用于说明 my.jar 的入口</span></span><br><span class="line">jar -cvfm my.jar MANIFEST.MF -C target .</span><br><span class="line"><span class="comment"># 成功执行</span></span><br><span class="line">java -jar my.jar</span><br></pre></td></tr></table></figure>
<hr>
<p>参考文章<br>
<a href="https://www.cnblogs.com/eoalfj/p/12332808.html" target="_blank" rel="noopener">https://www.cnblogs.com/eoalfj/p/12332808.html</a><br>
<a href="https://www.jianshu.com/p/61cfa1347894" target="_blank" rel="noopener">https://www.jianshu.com/p/61cfa1347894</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker常见问题详解</title>
    <url>/posts/92b713c.html</url>
    <content><![CDATA[<h1>一、Docker新增端口映射</h1>
<h2 id="1、简介">1、简介</h2>
<p>在<code>docker run</code>创建并运行容器的时候，可以通过<code>-p</code>指定端口映射规则。但是容器一旦生成，就没有一个命令可以直接修改。一般情况下，有两种方式进行映射端口新增或者修改，这里环境是Ubuntu20.04</p>
<ul>
<li>新建容器</li>
<li>修改容器配置文件</li>
</ul>
<a id="more"></a>
<h2 id="2、修改容器两种方式">2、修改容器两种方式</h2>
<h3 id="2-1-新建容器">2.1 新建容器</h3>
<p>这种方式最简单，将原有的容器删掉，重新新建一个，新建的时候确定好端口映射；</p>
<p><strong>优缺点</strong></p>
<ul>
<li>优点是简单快捷，在测试环境使用较多</li>
<li>缺点是每次都要重新配置，操作会比较麻烦</li>
</ul>
<h3 id="2-2-修改容器配置文件">2.2 修改容器配置文件</h3>
<ul>
<li><strong>查看容器</strong></li>
</ul>
<p>其中的hashofthecontainer是docker镜像的hash值，<code>CONTAINER ID</code>就是取了前几位数的值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看docker正在运行的容器</span></span><br><span class="line">docker ps</span><br><span class="line"><span class="comment">#查看某个容器详细信息</span></span><br><span class="line">docker inspect containername</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>关闭docker服务</strong></li>
</ul>
<p>若不关闭，可能会导致修改完的配置信息，重启后又变回原来的配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl stop docker.service</span><br></pre></td></tr></table></figure>
<p>这里可能会报警报，原因是除了docker.service单元文件，还有一个docker.socket单元文件…docker.socket这是用于套接字激活。  该警告意味着：如果你试图连接到docker socket，而docker服务没有运行，系统将自动启动docker。一般不做理会</p>
<blockquote>
<p>Warning: Stopping docker.service, but it can still be activated by: docker.socket</p>
</blockquote>
<ul>
<li><strong>修改文件</strong></li>
</ul>
<p>容器的配置文件路径<code>/var/lib/docker/containers/[hash_of_the_container]/hostconfig.json</code>，打开配置文件，找到<strong>PortBindings</strong>值，在这个json集合里边追加新端口。当然这两个配置文件还有很多其他信息可以修改，原理相同</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"PortBindings": &#123;</span><br><span class="line">    "8081/tcp": [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"HostIp"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="attr">"HostPort"</span>: <span class="string">"8081"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    "8085/tcp": [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"HostIp"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="attr">"HostPort"</span>: <span class="string">"8085"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<p>假如在<code>config.v2.json</code>文件里也记录了端口，也需要同时修改，修改值：<code>Config-&gt;ExposedPorts</code>和<code>NetworkSettings-&gt;Ports</code></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"Config": &#123;</span><br><span class="line">    "Hostname": "acf6f980b9d3",</span><br><span class="line">    "Domainname": "",</span><br><span class="line">    "User": "",</span><br><span class="line">    "AttachStdin": false,</span><br><span class="line">    "AttachStdout": false,</span><br><span class="line">    "AttachStderr": false,</span><br><span class="line">    "ExposedPorts": &#123;</span><br><span class="line">      "8081/tcp": &#123;</span><br><span class="line">        </span><br><span class="line">      &#125;,</span><br><span class="line">      "8085/tcp": &#123;</span><br><span class="line">        </span><br><span class="line">      &#125;,</span><br><span class="line">      "8088/tcp": &#123;</span><br><span class="line">        </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">"NetworkSettings": &#123;</span><br><span class="line">    "Ports": &#123;</span><br><span class="line">      "8081/tcp": [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"HostIp"</span>: <span class="string">"0.0.0.0"</span>,</span><br><span class="line">          <span class="attr">"HostPort"</span>: <span class="string">"8081"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"HostIp"</span>: <span class="string">"::"</span>,</span><br><span class="line">          <span class="attr">"HostPort"</span>: <span class="string">"8081"</span></span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      "8085/tcp": [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"HostIp"</span>: <span class="string">"0.0.0.0"</span>,</span><br><span class="line">          <span class="attr">"HostPort"</span>: <span class="string">"8085"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"HostIp"</span>: <span class="string">"::"</span>,</span><br><span class="line">          <span class="attr">"HostPort"</span>: <span class="string">"8085"</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>重启docker服务和容器</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart docker.service</span><br></pre></td></tr></table></figure>
<p><strong>优缺点</strong></p>
<ul>
<li>优点是没有副作用，操作简单</li>
<li>缺点是需要重启整个docker服务，如果在同一个宿主机上运行着多个容器服务的话，就会影响其他容器服务</li>
</ul>
<h1>二、Linux Dockerfile构建后不能正常启动</h1>
<h2 id="1、问题描述">1、问题描述</h2>
<p>下面是我自己构建的一个基于Centos8的JDK8docker环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM centos:8</span><br><span class="line">MAINTAINER shawn</span><br><span class="line"><span class="comment">#把java与tomcat添加到容器中，会自动解压</span></span><br><span class="line">ADD jdk-8u161-linux-x64.tar.gz /usr/<span class="built_in">local</span>/</span><br><span class="line"><span class="comment">#设置工作访问时候的WORKDIR路径，登录落脚点</span></span><br><span class="line">WORKDIR /</span><br><span class="line"><span class="comment">#安装vim编辑器</span></span><br><span class="line">RUN yum -y install vim</span><br><span class="line"><span class="comment">#配置java与tomcat环境变量</span></span><br><span class="line">ENV JAVA_HOME /usr/<span class="built_in">local</span>/jdk1.8.0_161</span><br><span class="line">ENV CLASSPATH <span class="variable">$JAVA_HOME</span>/lib/dt.jar:<span class="variable">$JAVA_HOME</span>/lib/tools.jar</span><br><span class="line">ENV PATH <span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin</span><br><span class="line"></span><br><span class="line">RUN ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line">RUN <span class="built_in">echo</span> <span class="string">'Asia/Shanghai'</span> &gt;/etc/timezone</span><br><span class="line">EXPOSE 8081 8088</span><br><span class="line">CMD ehco <span class="string">"构建成功"</span></span><br><span class="line">ENTRYPOINT /bin/bash</span><br></pre></td></tr></table></figure>
<p>将所需<code>jdk-8u161-linux-x64.tar.gz</code>和<code>Dockerfile</code>文件上传到linux目录，进行构建<code>docker -t lamp:1.0 .</code>，构建完成后，运行容器<code>docker run -d -p 8081:8081 -p 8088:8088 -v /home/shawn/ZHD/dockerdata:/data --name lamp lamp:1.0</code> ，然后发现容器不能正常启动，centos 启动一个容器添加了-d 参数，但是docker ps 或者docker ps -a查看却已经退出了</p>
<h2 id="2、原因介绍">2、原因介绍</h2>
<ul>
<li>docker容器运行必须有一个前台进程， 如果没有前台进程执行，容器认为空闲，就会自行退出</li>
<li>容器运行的命令如果不是那些一直挂起的命令（ 运行top，tail、循环、tomcat等），就是会自动退出</li>
<li>这个是 docker 的机制问题</li>
</ul>
<h2 id="3、解决法法">3、解决法法</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#为docker run添加-it命令</span></span><br><span class="line">docker run -itd -p 8081:8081 -p 8088:8088 -v /home/shawn/dockerdata:/data --name lamp lamp:1.0</span><br></pre></td></tr></table></figure>
<h1>三、Docker容器设置时区</h1>
<h2 id="1、问题描述-v2">1、问题描述</h2>
<p>Docker Hub 中的官方镜像，一般都默认设置为 UTC 时间。而我们位于东八区，在启动容器或构建自己的镜像时，往往需要对时区进行设置</p>
<h2 id="2、配置过程">2、配置过程</h2>
<p>这里我的docker环境是Ubuntu，有两种方式进行更改</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#进入运行的容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it lamp /bin/bash</span><br><span class="line"><span class="comment">#查看当前日期</span></span><br><span class="line">date</span><br><span class="line"><span class="comment">#显示结果</span></span><br><span class="line">Tue Jan 11 08:42:26 CST 2022</span><br></pre></td></tr></table></figure>
<p><strong>第一种</strong>方式在宿主机运行，完成后重启docker容器</p>
<ul>
<li>将本地的localtime文件复制到容器中</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker cp /etc/localtime &#123;容器id&#125;:/etc/localtime</span><br></pre></td></tr></table></figure>
<ul>
<li>将本地的<code>/usr/share/zoneinfo/Asia/Shanghai</code>文件复制到容器中</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker cp  /usr/share/zoneinfo/Asia/Shanghai  &#123;容器id&#125;:/etc/localtime</span><br></pre></td></tr></table></figure>
<p><strong>第二种</strong>进入容器运行，无需重启容器，若容器内部文件不存在，则还需要使用第一种</p>
<ul>
<li>链接宿主机localtime</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br></pre></td></tr></table></figure>
<p><strong>第三种</strong>在构建dockerfile的时候运行命令</p>
<hr>
<p>参考</p>
<p><a href="https://blog.csdn.net/weixin_43885975/article/details/117809901" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43885975/article/details/117809901</a></p>
<p><a href="https://blog.csdn.net/jameskaron/article/details/105540549" target="_blank" rel="noopener">https://blog.csdn.net/jameskaron/article/details/105540549</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Random和ThreadLocalRandom分析简介</title>
    <url>/posts/f4374131.html</url>
    <content><![CDATA[<h1>一、Random类</h1>
<h2 id="1、简介">1、简介</h2>
<p>Random 类用于生成伪随机数的流。 该类使用48位种子，其使用线性同余公式进行修改</p>
<ul>
<li><code>Math.random()</code>使用起来相对更简单，但不是线程安全的；</li>
<li><code>java.util.Random</code>的Random类是线程安全的。 但是跨线程的同时使用<code>java.util.Random</code>实例可能会遇到争用，从而导致性能下降。 在多线程设计中考虑使用<code>ThreadLocalRandom</code>类；</li>
<li><code>java.util.Random</code>的Random不是加密安全的。 考虑使用<code>SecureRandom</code>获取一个加密安全的伪随机数生成器，供安全敏感应用程序使用。</li>
</ul>
<a id="more"></a>
<h2 id="2、Random的构造函数">2、Random的构造函数</h2>
<ul>
<li>Random()：创建一个新的随机数生成器</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new random number generator. This constructor sets</span></span><br><span class="line"><span class="comment"> * the seed of the random number generator to a value very likely</span></span><br><span class="line"><span class="comment"> * to be distinct from any other invocation of this constructor.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Random</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//System.nanoTime()返回正在运行的Java虚拟机的高分辨率时间源的当前值，以纳秒为单位。</span></span><br><span class="line">    <span class="comment">//这里会调用有参构造函数</span></span><br><span class="line">    <span class="keyword">this</span>(seedUniquifier() ^ System.nanoTime());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">seedUniquifier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 线性同余生成元表  </span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">long</span> current = seedUniquifier.get();</span><br><span class="line">        <span class="keyword">long</span> next = current * <span class="number">181783497276652981L</span>; </span><br><span class="line">        <span class="comment">// 两个很大的数相乘</span></span><br><span class="line">        <span class="keyword">if</span> (seedUniquifier.compareAndSet(current, next))</span><br><span class="line">            <span class="comment">// 这个比较并且交换CAS</span></span><br><span class="line">            <span class="comment">// 比较当前工作内存中的值和主内存中的值，如果这个值是期望的，那么则执行操作！</span></span><br><span class="line">            <span class="comment">//如果不是就一直循环！就是为了保证即使在多线程的环境中返回的也是不同的数</span></span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// atomic 这个是 juc 里面修饰的原子性的 long ，get方法说就是获得这个构造函数里面的值</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLong seedUniquifier</span><br><span class="line">        = <span class="keyword">new</span> AtomicLong(<span class="number">8682522807148012L</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>random(long seed)：使用单个 Long 种子创建一个新的随机数生成器\</li>
</ul>
<p>伪随机使用了<strong>线性同余法</strong>(具体可自行查阅资料)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Random</span><span class="params">(<span class="keyword">long</span> seed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getClass() == Random<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">        <span class="title">this</span>.<span class="title">seed</span> </span>= <span class="keyword">new</span> AtomicLong(initialScramble(seed));</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 子类可能重写了这个不考虑</span></span><br><span class="line">        <span class="keyword">this</span>.seed = <span class="keyword">new</span> AtomicLong(); <span class="comment">// 创建一个新的AtomicLong，初始值为 0 </span></span><br><span class="line">        setSeed(seed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//清除nextGaussian()使用的haveNextNextGaussian 标志，</span></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSeed</span><span class="params">(<span class="keyword">long</span> seed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.seed.set(initialScramble(seed));</span><br><span class="line">        haveNextNextGaussian = <span class="keyword">false</span>; </span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">initialScramble</span><span class="params">(<span class="keyword">long</span> seed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (seed ^ multiplier) &amp; mask;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> multiplier = <span class="number">0x5DEECE66DL</span>;</span><br><span class="line">  <span class="comment">// x &amp; [(1L &lt;&lt; 48)–1]与 x（mod 2^48）等价 取低位48位</span></span><br><span class="line">  <span class="comment">// 带符号左移</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> mask = (<span class="number">1L</span> &lt;&lt; <span class="number">48</span>) - <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h2 id="3、next-核心方法">3、next()核心方法</h2>
<p>Random在多线程的环境是并发安全的，它解决竞争的方式是使用用原子类，本质上上也就是CAS + Volatile保证线程安全</p>
<p><img src="https://img-blog.csdnimg.cn/d3e9074b210242efa52551d8d11694d5.png#pic_center" alt="在这里插入图片描述"></p>
<p>在Random类中，有一个AtomicLong的域，用来保存随机种子。其中每次生成随机数时都会根据随机种子做移位操作以得到随机数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Long类型的随机</span></span><br><span class="line"><span class="comment">//long类型在Java中总弄64bit，对next方法的返回值左移32作为long的高位，然后将next方法返回值作为低32位，作为long类型的随机数。</span></span><br><span class="line"><span class="comment">//此处关键之处在于next方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">nextLong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">long</span>)(next(<span class="number">32</span>)) &lt;&lt; <span class="number">32</span>) + next(<span class="number">32</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下是next方法的核心，使用seed种子，不断生成新的种子，然后使用CAS将其更新，再返回种子的移位后值。这里不断的循环CAS操作种子，直到成功。可见，Random实现原理主要是利用随机种子采用一定算法进行处理生成随机数，在随机种子的安全保证利用原子类AtomicLong。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> bits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> oldseed, nextseed;</span><br><span class="line">        AtomicLong seed = <span class="keyword">this</span>.seed;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            oldseed = seed.get();</span><br><span class="line">            nextseed = (oldseed * multiplier + addend) &amp; mask;</span><br><span class="line">        &#125; <span class="keyword">while</span> (!seed.compareAndSet(oldseed, nextseed));</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(nextseed &gt;&gt;&gt; (<span class="number">48</span> - bits));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="4、Random在并发下的缺点">4、Random在并发下的缺点</h2>
<p>虽然Random是线程安全，但是对于并发处理使用原子类AtomicLong在大量竞争时，使用同一个 Random 对象可能会导致线程阻塞，由于很多CAS操作会造成失败，不断的Spin，而造成CPU开销比较大而且吞吐量也会下降。</p>
<p>这里可以自行多线程测试，可以发现随着线程增加，Random随着竞争越来越激烈，然后耗时越来越多。然而ThreadLocalRandom随着线程数的增加，基本没有变化。所以在大并发的情况下，随机的选择，可以考虑ThreadLocalRandom提升性能。</p>
<h1>二、ThreadLocalRandom</h1>
<h2 id="1、简介-v2">1、简介</h2>
<p><code>ThreadLocalRandom</code>是<code>Random</code>的子类，它是将Seed随机种子隔离到当前线程的随机数生成器，从而解决了<code>Random</code>在Seed上竞争的问题，它的处理思想和<code>ThreadLocal</code>本质相同。</p>
<p>Unsafe 类内的方法透露着一股 “Unsafe” 的气息，具体表现就是可以直接操作内存，而不做任何安全校验，如果有问题，则会在运行时抛出 <code>Fatal Error</code>，导致整个虚拟机的退出。</p>
<h2 id="2、原理分析">2、原理分析</h2>
<h3 id="2-1-ThreadLocalRandom单例模式">2.1 ThreadLocalRandom单例模式</h3>
<p>从下述代码可以发现<code>ThreadLocalRandom</code>使用了<strong>单例模式</strong>，即在一个Java应用中只有一个ThreadLocalRandom对象。当<code>UNSAFE.getInt(Thread.currentThread(), PROBE)</code>返回0时，就执行<code>localInit()</code>，最后返回单例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个java应用只有一个实例</span></span><br><span class="line"><span class="comment">// ThreadLocalRandom对象通过ThreadLocalRandom.current()获取，之后可以直接返回随机数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ThreadLocalRandom instance = <span class="keyword">new</span> ThreadLocalRandom();</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取ThreadLocalRandom对象实例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThreadLocalRandom <span class="title">current</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (UNSAFE.getInt(Thread.currentThread(), PROBE) == <span class="number">0</span>)</span><br><span class="line">        localInit();</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-Seed随机种子隔离到当前线程">2.2 Seed随机种子隔离到当前线程</h3>
<p><strong>核心方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//会从 object 对象var1的内存地址偏移var2后的位置读取四个字节作为long型返回</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">getLong</span><span class="params">(Object var1, <span class="keyword">long</span> var2)</span></span>;</span><br><span class="line"><span class="comment">//可以将object对象var1的内存地址偏移var2后的位置后四个字节设置为 var4</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">putLong</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">long</span> var4)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>UNSAFE.getInt(Thread.currentThread(), PROBE)</code>是获取当前Thread线程对象中的PROBE。</p>
<p>首先获取变量名<code>SEED</code>、<code>PROBE</code>等参数相对对象的偏移位置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Unsafe mechanics</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SEED;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> PROBE;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SECONDARY;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">        Class&lt;?&gt; tk = Thread<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        SEED = UNSAFE.objectFieldOffset</span><br><span class="line">            (tk.getDeclaredField(<span class="string">"threadLocalRandomSeed"</span>));</span><br><span class="line">        PROBE = UNSAFE.objectFieldOffset</span><br><span class="line">            (tk.getDeclaredField(<span class="string">"threadLocalRandomProbe"</span>));</span><br><span class="line">        SECONDARY = UNSAFE.objectFieldOffset</span><br><span class="line">            (tk.getDeclaredField(<span class="string">"threadLocalRandomSecondarySeed"</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当第一次调用<code>ThreadLocalRandom.current()</code>方法时当前线程检测到<code>PROBE</code>未初始化会调用<code>localInit()</code>方法进行初始化，并把<strong>当前线程的seed值和probe值存储在当前线程Thread对象内存地址偏移相对应变量的位置</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">localInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = probeGenerator.addAndGet(PROBE_INCREMENT);</span><br><span class="line">    <span class="keyword">int</span> probe = (p == <span class="number">0</span>) ? <span class="number">1</span> : p; <span class="comment">// skip 0</span></span><br><span class="line">    <span class="keyword">long</span> seed = mix64(seeder.getAndAdd(SEEDER_INCREMENT));</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    UNSAFE.putLong(t, SEED, seed);</span><br><span class="line">    UNSAFE.putInt(t, PROBE, probe);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>threadLocalRandomProbe</code>用于表示当前线程Thread是否初始化，如果是非0，表示其已经初始化。换句话说，该变量就是状态变量，用于标识当前线程Thread是否被初始化。<code>threadLocalRandomSeed</code>从注释中也可以看出，它是当前线程的随机种子。随机种子分散在各个Thread对象中，从而避免了并发时的竞争点。</p>
<h2 id="3、nextSeed-核心方法">3、nextSeed()核心方法</h2>
<p><code>nextSeed()</code>生成随机种子用来生成随机数序列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">nextLong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mix64(nextSeed());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为在初始化的时候已经<strong>存储了当前线程的seed值和probe值到相应线程对象内存地址的偏移位置</strong>，调用<code>nextSeed()</code>时直接<strong>从当前线程对象偏移位置处进行获取，并生成下一个随机数种子到该位置</strong>，同时使用了<code>UNSAFE</code>类方法，不同线程间不需要竞争获得seed值，因此可以可以将竞争点隔离</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">nextSeed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t; <span class="keyword">long</span> r; <span class="comment">// read and update per-thread seed</span></span><br><span class="line">    UNSAFE.putLong(t = Thread.currentThread(), SEED,</span><br><span class="line">                   r = UNSAFE.getLong(t, SEED) + GAMMA);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>三、总结</h1>
<p><code>Random</code>是Java中提供的随机数生成器工具类，但是在大并发的情况下由于其随机种子的竞争会导致吞吐量下降，从而引入<code>ThreadLocalRandom</code>它将竞争点隔离到每个线程中，从而消除了大并发情况下竞争问题，提升了性能。</p>
<p>并发竞争的整体优化思路：<strong>lock -&gt; cas + volatile -&gt; free lock</strong></p>
<hr>
<p>参考文章</p>
<p><a href="https://mp.weixin.qq.com/s/f-lfqEUNvY6XRmCL-h0Qfg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/f-lfqEUNvY6XRmCL-h0Qfg</a></p>
<p><a href="https://www.cnblogs.com/lxyit/p/12654374.html" target="_blank" rel="noopener">https://www.cnblogs.com/lxyit/p/12654374.html</a></p>
<p><a href="https://blog.csdn.net/tyh18226568070/article/details/105884912" target="_blank" rel="noopener">https://blog.csdn.net/tyh18226568070/article/details/105884912</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot2定时任务</title>
    <url>/posts/d0a2363e.html</url>
    <content><![CDATA[<h1>一、介绍</h1>
<p>SpringBoot可以有两种方式实现定时任务，schedule和schedule，这两种组件都可以和Spring进行整合，区别如下表所示</p>
<table>
<thead>
<tr>
<th>组件名称</th>
<th>cron</th>
<th>持久化</th>
<th>开发难以程度</th>
</tr>
</thead>
<tbody>
<tr>
<td>schedule</td>
<td>支持</td>
<td>不支持</td>
<td>非常简单</td>
</tr>
<tr>
<td>quartz</td>
<td>支持</td>
<td>支持</td>
<td>复杂</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h1>二、Schedule组件</h1>
<h2 id="1、介绍">1、介绍</h2>
<p>SpringBoot内置了Sping Schedule定时框架，通过注解驱动方式添加所注解方法到定时任务，根据配置定时信息定时执行</p>
<h2 id="2、Schedule定时任务实现">2、Schedule定时任务实现</h2>
<h3 id="2-1-配置线程池">2.1 配置线程池</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line">publicclass ScheduleConfig implements SchedulingConfigurer &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureTasks</span><span class="params">(ScheduledTaskRegistrar taskRegistrar)</span> </span>&#123;</span><br><span class="line">        taskRegistrar.setScheduler(taskExecutor());    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">taskExecutor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Executors.newScheduledThreadPool(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-新建具体任务">2.2 新建具体任务</h3>
<p>如果想加个开关控制是否启用定时任务，可以使用<code>@ConditionalOnProperty</code>注解，并同时在配置文件中设置<code>scheduling.enabled=false</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="comment">//@ConditionalOnProperty(prefix = "scheduling", name = "enabled", havingValue = "true")</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SbScheduleTask1</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="meta">@Scheduled</span>(cron = <span class="string">"*/2 * * * * ?"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">task1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        log.error(<span class="string">"我是task1111，我需要执行 10s 钟的时间，我的线程的 id == &gt; &#123;&#125;，时间 == &gt;&#123;&#125;"</span>, Thread.currentThread().getId(), <span class="keyword">new</span> Date());</span><br><span class="line">        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        log.error(<span class="string">"task1111 ending ,我的线程的 id == &gt; &#123;&#125; , 时间 == &gt; &#123;&#125;"</span>, Thread.currentThread().getId(), <span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="meta">@Scheduled</span>(cron = <span class="string">"*/4 * * * * ?"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">task2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        log.error(<span class="string">"我是task2222，我需要执行 2s 钟的时间，我的线程的 id == &gt; &#123;&#125;，时间 == &gt;&#123;&#125;"</span>, Thread.currentThread().getId(), <span class="keyword">new</span> Date());</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        log.error(<span class="string">"task2222 ending ,我的线程的 id == &gt; &#123;&#125; , 时间 == &gt; &#123;&#125;"</span>, Thread.currentThread().getId(), <span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-开启Schedule">2.3 开启Schedule</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="comment">// 开启定时任务</span></span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="meta">@MapperScan</span>(basePackages = &#123;<span class="string">"com.shawn.springboot.*.mapper"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduleApplication</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SpringApplication.run(ScheduleApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>三、quartz组件</h1>
<h2 id="1、介绍-v2">1、介绍</h2>
<blockquote>
<p>官方文档：<a href="http://www.quartz-scheduler.org/documentation/2.4.0-SNAPSHOT/tutorials/index.html" target="_blank" rel="noopener">http://www.quartz-scheduler.org/documentation/2.4.0-SNAPSHOT/tutorials/index.html</a></p>
</blockquote>
<p>Quartz是一个功能强大的开源任务调度库，几乎可以集成到任何Java应用程序中，无论是超小型的独立应用还是超大型电子商务系统。</p>
<p>它常用于企业级应用中：</p>
<ul>
<li>Driving Process Workflow：当新订单下达，可以安排一个30分钟内触发的任务，检查订单状态。</li>
<li>System Maintenance：安排每个工作日晚上11点将数据库内容转储到文件的任务。</li>
<li>Providing reminder services：提供提醒服务。</li>
</ul>
<p>Quartz还支持集群模式和对JTA事务。</p>
<h2 id="2、重要概念">2、重要概念</h2>
<p><strong>Scheduler</strong> ：和调度程序交互的主要API</p>
<ul>
<li>生命周期从SchedulerFactoru创建它开始，到调用shutdown方法结束</li>
<li>一旦Scheduler创建，任何关于scheduling相关的事，他都为所欲为：添加、删除、列出所有的Jobs和triggers、暂停触发器等</li>
<li>在start方法之前，不会做任何事情</li>
</ul>
<p>**Job：**被调度器调度的任务组件接口，即定时任务执行的方法</p>
<ul>
<li>当Job的触发器触发时，调度程序的工作线程将调用execute方法</li>
<li>该方法接收一个<code>JobExecutionContext</code> 对象，为Job实例提供了丰富的运行时环境信息，比如：scheduler、trigger、jobDataMap、job、calendar、各种time等</li>
</ul>
<p><strong>JobDetail</strong> ：用于定义任务</p>
<ul>
<li>JobDetail对象由Quartz客户端在将job加入Scheduler提供</li>
<li>它包含了不同为job设置的属性，还有可以用来为job储存状态信息的JobDataMap</li>
<li>注意它和Job的区别，它实际上是Job实例的属性。【Job定义如何执行，JobDetail定义有何属性】</li>
</ul>
<p><strong>Trigger</strong> ：触发任务执行</p>
<ul>
<li>触发器可能具有与之关联的JobDataMap，以便于将特定于触发器触发的参数传递给Job</li>
<li>Quartz提供了几种不同的触发器，SimpleTrigger和CronTrigger比较常用</li>
<li>如果你需要一次性执行作业或需要在给定的时间触发一个作业并重复执行N次且有两次执行间有延时delay，SimpleTrigger较为方便</li>
<li>如果你希望基于类似日期表触发执行任务，CronTrgger推荐使用</li>
</ul>
<p><strong>JobBuilder</strong> ：用于构建JobDetail的</p>
<p><strong>TriggerBuilder</strong> ：用于构建Trigger的</p>
<h2 id="3、quartz内存配置实战">3、quartz内存配置实战</h2>
<h3 id="3-1-引入依赖">3.1 引入依赖</h3>
<p><code>spring-boot-starter-quartz</code>这个依赖是SpringBoot与Quartz的整合</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 实现对 Quartz 的自动化配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-quartz<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="3-2-创建job">3.2 创建job</h3>
<p>这里创建了两个job，我们在创建Job的时候，可以实现Job接口，也可以继承QuartzJobBean。</p>
<p>QuartzJobBean实现了Job，并且定义了公用的execute方法，子类可以继承QuartzJobBean并实现executeInternal方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstJob</span> <span class="keyword">extends</span> <span class="title">QuartzJobBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">executeInternal</span><span class="params">(JobExecutionContext jobExecutionContext)</span> <span class="keyword">throws</span> JobExecutionException </span>&#123;</span><br><span class="line">        String now = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>).format(LocalDateTime.now());</span><br><span class="line">        log.info(<span class="string">"当前的时间: "</span> + now);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//--------------------</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondJob</span> <span class="keyword">extends</span> <span class="title">QuartzJobBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">executeInternal</span><span class="params">(JobExecutionContext jobExecutionContext)</span> <span class="keyword">throws</span> JobExecutionException </span>&#123;</span><br><span class="line">        String now = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>).format(LocalDateTime.now());</span><br><span class="line">        log.info(<span class="string">"SecondJob执行, 当前的时间: "</span> + now);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-调度器Scheduler绑定">3.3 调度器Scheduler绑定</h3>
<p><strong>自动绑定</strong>，这里使用了SimpleScheduleBuilder</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuartzConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ID = <span class="string">"SUMMERDAY"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JobDetail <span class="title">jobDetail1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> JobBuilder.newJob(FirstJob<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">                .withIdentity(ID + " 01")</span><br><span class="line">                .storeDurably()</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Trigger <span class="title">trigger1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 简单的调度计划的构造器</span></span><br><span class="line">        SimpleScheduleBuilder scheduleBuilder = SimpleScheduleBuilder.simpleSchedule()</span><br><span class="line">                .withIntervalInSeconds(<span class="number">5</span>) <span class="comment">// 频率</span></span><br><span class="line">                .repeatForever(); <span class="comment">// 次数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> TriggerBuilder.newTrigger()</span><br><span class="line">                .forJob(jobDetail1())</span><br><span class="line">                .withIdentity(ID + <span class="string">" 01Trigger"</span>)</span><br><span class="line">                .withSchedule(scheduleBuilder)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>手动绑定</strong>，这里使用了CronScheduleBuilder</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JobInit</span> <span class="keyword">implements</span> <span class="title">ApplicationRunner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ID = <span class="string">"SUMMERDAY"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Scheduler scheduler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(ApplicationArguments args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        JobDetail jobDetail = JobBuilder.newJob(FirstJob<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">                .withIdentity(ID + " 01")</span><br><span class="line">                .storeDurably()</span><br><span class="line">                .build();</span><br><span class="line">        CronScheduleBuilder scheduleBuilder =</span><br><span class="line">                CronScheduleBuilder.cronSchedule(<span class="string">"0/5 * * * * ? *"</span>);</span><br><span class="line">        <span class="comment">// 创建任务触发器</span></span><br><span class="line">        Trigger trigger = TriggerBuilder.newTrigger()</span><br><span class="line">                .forJob(jobDetail)</span><br><span class="line">                .withIdentity(ID + <span class="string">" 01Trigger"</span>)</span><br><span class="line">                .withSchedule(scheduleBuilder)</span><br><span class="line">                .startNow() <span class="comment">//立即執行一次任務</span></span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">// 手动将触发器与任务绑定到调度器内</span></span><br><span class="line">        scheduler.scheduleJob(jobDetail, trigger);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-4-yml配置">3.4 yml配置</h3>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment"># Quartz 的配置，对应 QuartzProperties 配置类</span></span><br><span class="line">  <span class="attr">quartz:</span></span><br><span class="line">    <span class="attr">job-store-type:</span> <span class="string">memory</span> <span class="comment"># Job 存储器类型。默认为 memory 表示内存，可选 jdbc 使用数据库。</span></span><br><span class="line">    <span class="attr">auto-startup:</span> <span class="literal">true</span> <span class="comment"># Quartz 是否自动启动</span></span><br><span class="line">    <span class="attr">startup-delay:</span> <span class="number">0</span> <span class="comment"># 延迟 N 秒启动</span></span><br><span class="line">    <span class="attr">wait-for-jobs-to-complete-on-shutdown:</span> <span class="literal">true</span> <span class="comment"># 应用关闭时，是否等待定时任务执行完成。默认为 false ，建议设置为 true</span></span><br><span class="line">    <span class="attr">overwrite-existing-jobs:</span> <span class="literal">false</span> <span class="comment"># 是否覆盖已有 Job 的配置</span></span><br><span class="line">    <span class="attr">properties:</span> <span class="comment"># 添加 Quartz Scheduler 附加属性</span></span><br><span class="line">      <span class="attr">org:</span></span><br><span class="line">        <span class="attr">quartz:</span></span><br><span class="line">          <span class="attr">threadPool:</span></span><br><span class="line">            <span class="attr">threadCount:</span> <span class="number">25</span> <span class="comment"># 线程池大小。默认为 10 。</span></span><br><span class="line">            <span class="attr">threadPriority:</span> <span class="number">5</span> <span class="comment"># 线程优先级</span></span><br><span class="line">            <span class="attr">class:</span> <span class="string">org.quartz.simpl.SimpleThreadPool</span> <span class="comment"># 线程池类型</span></span><br></pre></td></tr></table></figure>
<h2 id="4、Quartz持久化配置">4、Quartz持久化配置</h2>
<p>Quartz持久化配置提供了两种存储器：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>RAMJobStore</td>
<td>不要外部数据库，配置容易，运行速度快</td>
<td>因为调度程序信息是存储在被分配给 JVM 的内存里面，所以，当应用程序停止运行时，所有调度信息将被丢失。另外因为存储到JVM内存里面，所以可以存储多少个 Job 和 Trigger 将会受到限制</td>
</tr>
<tr>
<td>JDBC 作业存储</td>
<td>支持集群，因为所有的任务信息都会保存到数据库中，可以控制事物，还有就是如果应用服务器关闭或者重启，任务信息都不会丢失，并且可以恢复因服务器关闭或者重启而导致执行失败的任务</td>
<td>运行速度的快慢取决与连接数据库的快慢</td>
</tr>
</tbody>
</table>
<h1>四、cron表达式</h1>
<h2 id="1、简介">1、简介</h2>
<blockquote>
<p>表达式网站：<a href="http://cron.qqe2.com/" target="_blank" rel="noopener">http://cron.qqe2.com/</a></p>
</blockquote>
<p>表达式基本公式 <code>* * * * * *</code>七个*分别对应单位为：秒，分，时，日，月，星期，年</p>
<h2 id="2、字段含义">2、字段含义</h2>
<table>
<thead>
<tr>
<th>字段</th>
<th>取值范围</th>
<th>特殊字符</th>
</tr>
</thead>
<tbody>
<tr>
<td>秒</td>
<td>0~59的整数</td>
<td>，- * /</td>
</tr>
<tr>
<td>分</td>
<td>0~59的整数</td>
<td>，- * /</td>
</tr>
<tr>
<td>时</td>
<td>0~23的整数</td>
<td>，- * /</td>
</tr>
<tr>
<td>日</td>
<td>1~31的整数</td>
<td>，- * ? / L W</td>
</tr>
<tr>
<td>月</td>
<td>1~12的整数</td>
<td>，- * /</td>
</tr>
<tr>
<td>星期</td>
<td>1<sub>7的整数或者SUN</sub>SAT（1=SUN）</td>
<td>，- * ? / L #</td>
</tr>
<tr>
<td>年</td>
<td>1970~2099</td>
<td>，- * /</td>
</tr>
</tbody>
</table>
<ul>
<li>“,” ：表示列出枚举值，例如分钟使用5,20，则表示5和20分钟各执行一次</li>
<li>“-” ：表示范围，例如分钟使用5-20，表示5-20分钟每分钟触发一次</li>
<li>&quot;<em>&quot; ：<em>表示匹配该域任意值</em>，例如分钟使用</em>，表示每分钟都会执行一次</li>
<li>“/” ：表示起始时间开始触发，以后每隔多长时间触发一次，例如秒使用0/3，表示从0开始触发，后每三分钟触发一次</li>
<li>“?”：只能在日和星期使用，表示匹配任意值，但实际不会；因为日和星期可能会存在冲突，如果想表示每月20号0点执行，则需要写为 0 0 0 20 * ？，星期位必须写为？，虽然概念上*也表示通配</li>
<li>“L” ：表示最后，只出现在日和星期；例如在星期的5L，表示最后一个星期五触发</li>
<li>“W” ：表示有效工作日（周一-周五），只出现在日，如果指定的当天在某月刚好为周末，则就近取周五或周一执行</li>
<li>“LW” ：连用表示每个月最后一个星期五，只在日使用</li>
<li>“#” ：用于确定第几个星期的星期几，只在星期使用；例如2#3，表示在每月的第三个星期一</li>
</ul>
<h2 id="3、常用表达式实例">3、常用表达式实例</h2>
<ul>
<li>0/3 * * * * ? ：表示每三秒钟执行一次</li>
<li>0 0 2 1 * ？ ：表示每月1号凌晨两点执行任务</li>
<li>0 15 10 ？ * MON-FRI ：表示周一到周五每天早上10：15执行</li>
<li>0 15 10 ? * 6#3   每月的第三个星期五上午10:15触发</li>
</ul>
<hr>
<p>参考文章</p>
<p><a href="https://www.cnblogs.com/imyanger/p/11828301.html" target="_blank" rel="noopener">https://www.cnblogs.com/imyanger/p/11828301.html</a></p>
<p><a href="http://www.quartz-scheduler.org/documentation/2.4.0-SNAPSHOT/tutorials/index.html" target="_blank" rel="noopener">http://www.quartz-scheduler.org/documentation/2.4.0-SNAPSHOT/tutorials/index.html</a></p>
<p><a href="https://www.iocoder.cn/Spring-Boot/Job/#" target="_blank" rel="noopener">https://www.iocoder.cn/Spring-Boot/Job/#</a></p>
<p><a href="https://www.cnblogs.com/summerday152/p/14193968.html" target="_blank" rel="noopener">https://www.cnblogs.com/summerday152/p/14193968.html</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Java8本地缓存Caffeine</title>
    <url>/posts/ecc1debf.html</url>
    <content><![CDATA[<h1>一、Caffeine介绍</h1>
<h2 id="1、缓存介绍">1、缓存介绍</h2>
<p>缓存(Cache)在代码世界中无处不在。从底层的CPU多级缓存，到客户端的页面缓存，处处都存在着缓存的身影。缓存从本质上来说，是一种空间换时间的手段，通过对数据进行一定的空间安排，使得下次进行数据访问时起到加速的效果。就Java而言，其常用的缓存解决方案有很多，例如数据库缓存框架EhCache，分布式缓存Memcached等，这些缓存方案实际上都是为了提升吞吐效率，避免持久层压力过大。</p>
<p>对于常见缓存类型而言，可以分为<strong>本地缓存</strong>以及<strong>分布式缓存</strong>两种，Caffeine就是一种优秀的本地缓存，而Redis可以用来做分布式缓存</p>
<a id="more"></a>
<h2 id="2、Caffeine介绍">2、Caffeine介绍</h2>
<blockquote>
<p>Caffeine官方：<a href="https://github.com/ben-manes/caffeine" target="_blank" rel="noopener">https://github.com/ben-manes/caffeine</a></p>
</blockquote>
<p>Caffeine是基于Java 1.8的高性能本地缓存库，由Guava改进而来，而且在Spring5开始的默认缓存实现就将Caffeine代替原来的Google Guava，官方说明指出，其缓存命中率已经接近最优值。实际上Caffeine这样的本地缓存和ConcurrentMap很像，即支持并发，并且支持O(1)时间复杂度的数据存取。二者的主要区别在于：</p>
<ul>
<li>ConcurrentMap将存储所有存入的数据，直到你显式将其移除；</li>
<li>Caffeine将通过给定的配置，自动移除“不常用”的数据，以保持内存的合理占用。</li>
</ul>
<p>因此，一种更好的理解方式是：<strong>Cache是一种带有存储和移除策略的Map</strong>。</p>
<p><img src="https://img-blog.csdnimg.cn/af3a97203e5e46e1837e310a12818168.png?type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6a2FTGVtb24=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<h1>二、Caffeine基础</h1>
<p>使用Caffeine，需要在工程中引入如下依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.ben-manes.caffeine<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>caffeine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--https://mvnrepository.com/artifact/com.github.ben-manes.caffeine/caffeinez找最新版--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="1、缓存加载策略">1、缓存加载策略</h2>
<h3 id="1-1-Cache手动创建">1.1 Cache手动创建</h3>
<p>最普通的一种缓存，无需指定加载方式，需要手动调用<code>put()</code>进行加载。需要注意的是<code>put()</code>方法对于已存在的key将进行覆盖，这点和Map的表现是一致的。在获取缓存值时，如果想要在缓存值不存在时，原子地将值写入缓存，则可以调用<code>get(key, k -&gt; value)</code>方法，该方法将避免写入竞争。调用<code>invalidate()</code>方法，将手动移除缓存。</p>
<p>在多线程情况下，当使用<code>get(key, k -&gt; value)</code>时，如果有另一个线程同时调用本方法进行竞争，则后一线程会被阻塞，直到前一线程更新缓存完成；而若另一线程调用<code>getIfPresent()</code>方法，则会立即返回null，不会被阻塞。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cache&lt;Object, Object&gt; cache = Caffeine.newBuilder()</span><br><span class="line">                <span class="comment">//初始数量</span></span><br><span class="line">                .initialCapacity(<span class="number">10</span>)</span><br><span class="line">                <span class="comment">//最大条数</span></span><br><span class="line">                .maximumSize(<span class="number">10</span>)</span><br><span class="line">                <span class="comment">//expireAfterWrite和expireAfterAccess同时存在时，以expireAfterWrite为准</span></span><br><span class="line">                <span class="comment">//最后一次写操作后经过指定时间过期</span></span><br><span class="line">                .expireAfterWrite(<span class="number">1</span>, TimeUnit.SECONDS)</span><br><span class="line">                <span class="comment">//最后一次读或写操作后经过指定时间过期</span></span><br><span class="line">                .expireAfterAccess(<span class="number">1</span>, TimeUnit.SECONDS)</span><br><span class="line">                <span class="comment">//监听缓存被移除</span></span><br><span class="line">                .removalListener((key, val, removalCause) -&gt; &#123; &#125;)</span><br><span class="line">                <span class="comment">//记录命中</span></span><br><span class="line">                .recordStats()</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        cache.put(<span class="string">"1"</span>,<span class="string">"张三"</span>);</span><br><span class="line">        <span class="comment">//张三</span></span><br><span class="line">        System.out.println(cache.getIfPresent(<span class="string">"1"</span>));</span><br><span class="line">        <span class="comment">//存储的是默认值</span></span><br><span class="line">        System.out.println(cache.get(<span class="string">"2"</span>,o -&gt; <span class="string">"默认值"</span>));</span><br></pre></td></tr></table></figure>
<h3 id="1-2-Loading-Cache自动创建">1.2 Loading Cache自动创建</h3>
<p>LoadingCache是一种自动加载的缓存。其和普通缓存不同的地方在于，当缓存不存在/缓存已过期时，若调用<code>get()</code>方法，则会自动调用<code>CacheLoader.load()</code>方法加载最新值。调用<code>getAll()</code>方法将遍历所有的key调用<code>get()</code>，除非实现了<code>CacheLoader.loadAll()</code>方法。使用LoadingCache时，需要指定CacheLoader，并实现其中的<code>load()</code>方法供缓存缺失时自动加载。</p>
<p>在多线程情况下，当两个线程同时调用<code>get()</code>，则后一线程将被阻塞，直至前一线程更新缓存完成。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LoadingCache&lt;String, String&gt; loadingCache = Caffeine.newBuilder()</span><br><span class="line">        <span class="comment">//创建缓存或者最近一次更新缓存后经过指定时间间隔，刷新缓存；refreshAfterWrite仅支持LoadingCache</span></span><br><span class="line">        .refreshAfterWrite(<span class="number">10</span>, TimeUnit.SECONDS)</span><br><span class="line">        .expireAfterWrite(<span class="number">10</span>, TimeUnit.SECONDS)</span><br><span class="line">        .expireAfterAccess(<span class="number">10</span>, TimeUnit.SECONDS)</span><br><span class="line">        .maximumSize(<span class="number">10</span>)</span><br><span class="line">        <span class="comment">//根据key查询数据库里面的值，这里是个lamba表达式</span></span><br><span class="line">        .build(key -&gt; <span class="keyword">new</span> Date().toString());</span><br></pre></td></tr></table></figure>
<h3 id="1-3-Async-Cache异步获取">1.3 Async Cache异步获取</h3>
<p>AsyncCache是Cache的一个变体，其响应结果均为CompletableFuture，通过这种方式，AsyncCache对异步编程模式进行了适配。默认情况下，缓存计算使用<code>ForkJoinPool.commonPool()</code>作为线程池，如果想要指定线程池，则可以覆盖并实现<code>Caffeine.executor(Executor)</code>方法。<code>synchronous()</code>提供了阻塞直到异步缓存生成完毕的能力，它将以Cache进行返回。</p>
<p>在多线程情况下，当两个线程同时调用<code>get(key, k -&gt; value)</code>，则会返回<strong>同一个CompletableFuture</strong>对象。由于返回结果本身不进行阻塞，可以根据业务设计自行选择阻塞等待或者非阻塞。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AsyncLoadingCache&lt;String, String&gt; asyncLoadingCache = Caffeine.newBuilder()</span><br><span class="line">        <span class="comment">//创建缓存或者最近一次更新缓存后经过指定时间间隔刷新缓存；仅支持LoadingCache</span></span><br><span class="line">        .refreshAfterWrite(<span class="number">1</span>, TimeUnit.SECONDS)</span><br><span class="line">        .expireAfterWrite(<span class="number">1</span>, TimeUnit.SECONDS)</span><br><span class="line">        .expireAfterAccess(<span class="number">1</span>, TimeUnit.SECONDS)</span><br><span class="line">        .maximumSize(<span class="number">10</span>)</span><br><span class="line">        <span class="comment">//根据key查询数据库里面的值</span></span><br><span class="line">        .buildAsync(key -&gt; &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Date().toString();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//异步缓存返回的是CompletableFuture</span></span><br><span class="line">CompletableFuture&lt;String&gt; future = asyncLoadingCache.get(<span class="string">"1"</span>);</span><br><span class="line">future.thenAccept(System.out::println);</span><br></pre></td></tr></table></figure>
<h2 id="2、驱逐策略">2、驱逐策略</h2>
<p>驱逐策略在创建缓存的时候进行指定。常用的有基于容量的驱逐和基于时间的驱逐。</p>
<p>基于容量的驱逐需要指定缓存容量的最大值，当缓存容量达到最大时，Caffeine将使用LRU策略对缓存进行淘汰；基于时间的驱逐策略如字面意思，可以设置在最后访问/写入一个缓存经过指定时间后，自动进行淘汰。</p>
<p>驱逐策略可以组合使用，任意驱逐策略生效后，该缓存条目即被驱逐。</p>
<ul>
<li>LRU 最近最少使用，淘汰最长时间没有被使用的页面。</li>
<li>LFU 最不经常使用，淘汰一段时间内使用次数最少的页面</li>
<li>FIFO 先进先出</li>
</ul>
<p><strong>Caffeine有4种缓存淘汰设置</strong></p>
<ol>
<li>大小 （LFU算法进行淘汰）</li>
<li>权重 （大小与权重 只能二选一）</li>
<li>时间</li>
<li>引用 （不常用，本文不介绍）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存大小淘汰</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">maximumSizeTest</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Cache&lt;Integer, Integer&gt; cache = Caffeine.newBuilder()</span><br><span class="line">                <span class="comment">//超过10个后会使用W-TinyLFU算法进行淘汰</span></span><br><span class="line">                .maximumSize(<span class="number">10</span>)</span><br><span class="line">                .evictionListener((key, val, removalCause) -&gt; &#123;</span><br><span class="line">                    log.info(<span class="string">"淘汰缓存：key:&#123;&#125; val:&#123;&#125;"</span>, key, val);</span><br><span class="line">                &#125;)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            cache.put(i, i);</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);<span class="comment">//缓存淘汰是异步的</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印还没被淘汰的缓存</span></span><br><span class="line">        System.out.println(cache.asMap());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 权重淘汰</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">maximumWeightTest</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Cache&lt;Integer, Integer&gt; cache = Caffeine.newBuilder()</span><br><span class="line">                <span class="comment">//限制总权重，若所有缓存的权重加起来&gt;总权重就会淘汰权重小的缓存</span></span><br><span class="line">                .maximumWeight(<span class="number">100</span>)</span><br><span class="line">                .weigher((Weigher&lt;Integer, Integer&gt;) (key, value) -&gt; key)</span><br><span class="line">                .evictionListener((key, val, removalCause) -&gt; &#123;</span><br><span class="line">                    log.info(<span class="string">"淘汰缓存：key:&#123;&#125; val:&#123;&#125;"</span>, key, val);</span><br><span class="line">                &#125;)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//总权重其实是=所有缓存的权重加起来</span></span><br><span class="line">        <span class="keyword">int</span> maximumWeight = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            cache.put(i, i);</span><br><span class="line">            maximumWeight += i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"总权重="</span> + maximumWeight);</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);<span class="comment">//缓存淘汰是异步的</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印还没被淘汰的缓存</span></span><br><span class="line">        System.out.println(cache.asMap());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 访问后到期（每次访问都会重置时间，也就是说如果一直被访问就不会被淘汰）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">expireAfterAccessTest</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Cache&lt;Integer, Integer&gt; cache = Caffeine.newBuilder()</span><br><span class="line">                .expireAfterAccess(<span class="number">1</span>, TimeUnit.SECONDS)</span><br><span class="line">                <span class="comment">//可以指定调度程序来及时删除过期缓存项，而不是等待Caffeine触发定期维护</span></span><br><span class="line">                <span class="comment">//若不设置scheduler，则缓存会在下一次调用get的时候才会被动删除</span></span><br><span class="line">                .scheduler(Scheduler.systemScheduler())</span><br><span class="line">                .evictionListener((key, val, removalCause) -&gt; &#123;</span><br><span class="line">                    log.info(<span class="string">"淘汰缓存：key:&#123;&#125; val:&#123;&#125;"</span>, key, val);</span><br><span class="line"></span><br><span class="line">                &#125;)</span><br><span class="line">                .build();</span><br><span class="line">        cache.put(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        System.out.println(cache.getIfPresent(<span class="number">1</span>));</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        System.out.println(cache.getIfPresent(<span class="number">1</span>));<span class="comment">//null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写入后到期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">expireAfterWriteTest</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Cache&lt;Integer, Integer&gt; cache = Caffeine.newBuilder()</span><br><span class="line">                .expireAfterWrite(<span class="number">1</span>, TimeUnit.SECONDS)</span><br><span class="line">                <span class="comment">//可以指定调度程序来及时删除过期缓存项，而不是等待Caffeine触发定期维护</span></span><br><span class="line">                <span class="comment">//若不设置scheduler，则缓存会在下一次调用get的时候才会被动删除</span></span><br><span class="line">                .scheduler(Scheduler.systemScheduler())</span><br><span class="line">                .evictionListener((key, val, removalCause) -&gt; &#123;</span><br><span class="line">                    log.info(<span class="string">"淘汰缓存：key:&#123;&#125; val:&#123;&#125;"</span>, key, val);</span><br><span class="line">                &#125;)</span><br><span class="line">                .build();</span><br><span class="line">        cache.put(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        System.out.println(cache.getIfPresent(<span class="number">1</span>));<span class="comment">//null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3、刷新机制">3、刷新机制</h2>
<p><code>refreshAfterWrite()</code>表示x秒后自动刷新缓存的策略可以配合淘汰策略使用，注意的是刷新机制只支持LoadingCache和AsyncLoadingCache</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> NUM = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refreshAfterWriteTest</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    LoadingCache&lt;Integer, Integer&gt; cache = Caffeine.newBuilder()</span><br><span class="line">            .refreshAfterWrite(<span class="number">1</span>, TimeUnit.SECONDS)</span><br><span class="line">            <span class="comment">//模拟获取数据，每次获取就自增1</span></span><br><span class="line">            .build(integer -&gt; ++NUM);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取ID=1的值，由于缓存里还没有，所以会自动放入缓存</span></span><br><span class="line">    System.out.println(cache.get(<span class="number">1</span>));<span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 延迟2秒后，理论上自动刷新缓存后取到的值是2</span></span><br><span class="line">    <span class="comment">// 但其实不是，值还是1，因为refreshAfterWrite并不是设置了n秒后重新获取就会自动刷新</span></span><br><span class="line">    <span class="comment">// 而是x秒后&amp;&amp;第二次调用getIfPresent的时候才会被动刷新</span></span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    System.out.println(cache.getIfPresent(<span class="number">1</span>));<span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//此时才会刷新缓存，而第一次拿到的还是旧值</span></span><br><span class="line">    System.out.println(cache.getIfPresent(<span class="number">1</span>));<span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4、统计">4、统计</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LoadingCache&lt;String, String&gt; cache = Caffeine.newBuilder()</span><br><span class="line">        <span class="comment">//创建缓存或者最近一次更新缓存后经过指定时间间隔，刷新缓存；refreshAfterWrite仅支持LoadingCache</span></span><br><span class="line">        .refreshAfterWrite(<span class="number">1</span>, TimeUnit.SECONDS)</span><br><span class="line">        .expireAfterWrite(<span class="number">1</span>, TimeUnit.SECONDS)</span><br><span class="line">        .expireAfterAccess(<span class="number">1</span>, TimeUnit.SECONDS)</span><br><span class="line">        .maximumSize(<span class="number">10</span>)</span><br><span class="line">        <span class="comment">//开启记录缓存命中率等信息</span></span><br><span class="line">        .recordStats()</span><br><span class="line">        <span class="comment">//根据key查询数据库里面的值</span></span><br><span class="line">        .build(key -&gt; &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Date().toString();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cache.put(<span class="string">"1"</span>, <span class="string">"shawn"</span>);</span><br><span class="line">cache.get(<span class="string">"1"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * hitCount :命中的次数</span></span><br><span class="line"><span class="comment"> * missCount:未命中次数</span></span><br><span class="line"><span class="comment"> * requestCount:请求次数</span></span><br><span class="line"><span class="comment"> * hitRate:命中率</span></span><br><span class="line"><span class="comment"> * missRate:丢失率</span></span><br><span class="line"><span class="comment"> * loadSuccessCount:成功加载新值的次数</span></span><br><span class="line"><span class="comment"> * loadExceptionCount:失败加载新值的次数</span></span><br><span class="line"><span class="comment"> * totalLoadCount:总条数</span></span><br><span class="line"><span class="comment"> * loadExceptionRate:失败加载新值的比率</span></span><br><span class="line"><span class="comment"> * totalLoadTime:全部加载时间</span></span><br><span class="line"><span class="comment"> * evictionCount:丢失的条数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">System.out.println(cache.stats());</span><br></pre></td></tr></table></figure>
<h2 id="5、总结">5、总结</h2>
<p>上述一些策略在创建时都可以进行自由组合，一般情况下有两种方法</p>
<ul>
<li><strong>设置 maxSize、refreshAfterWrite，不设置 expireAfterWrite/expireAfterAccess</strong><br>
设置expireAfterWrite当缓存过期时会同步加锁获取缓存，所以设置expireAfterWrite时性能较好，但是某些时候会取旧数据,适合允许取到旧数据的场景</li>
<li><strong>设置 maxSize、expireAfterWrite/expireAfterAccess，不设置 refreshAfterWrite</strong><br>
数据一致性好，不会获取到旧数据，但是性能没那么好（对比起来），适合获取数据时不耗时的场景</li>
</ul>
<h1>三、SpringBoot整合Caffeine</h1>
<h2 id="1、-Cacheable相关注解">1、@Cacheable相关注解</h2>
<h3 id="1-1-相关依赖">1.1 相关依赖</h3>
<p>如果要使用<code>@Cacheable</code>注解，需要引入相关依赖，并在任一配置类文件上添加<code>@EnableCaching</code>注解</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="1-2-常用注解">1.2 常用注解</h3>
<ul>
<li><code>@Cacheable</code>：表示该方法支持缓存。当调用被注解的方法时，如果对应的键已经存在缓存，则不再执行方法体，而从缓存中直接返回。当方法返回null时，将不进行缓存操作。</li>
<li><code>@CachePut</code>：表示执行该方法后，其值将作为最新结果更新到缓存中，<strong>每次都会执行该方法</strong>。</li>
<li><code>@CacheEvict</code>：表示执行该方法后，将触发缓存清除操作。</li>
<li><code>@Caching</code>：用于组合前三个注解，例如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Caching</span>(cacheable = <span class="meta">@Cacheable</span>(<span class="string">"CacheConstants.GET_USER"</span>),</span><br><span class="line">         evict = &#123;<span class="meta">@CacheEvict</span>(<span class="string">"CacheConstants.GET_DYNAMIC"</span>,allEntries = <span class="keyword">true</span>)&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">find</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-常用注解属性">1.3 常用注解属性</h3>
<ul>
<li><code>cacheNames/value</code>：缓存组件的名字，即cacheManager中缓存的名称。</li>
<li><code>key</code>：缓存数据时使用的key。默认使用方法参数值，也可以使用<a href="https://docs.spring.io/spring-framework/docs/3.0.x/reference/expressions.html" target="_blank" rel="noopener">SpEL</a>表达式进行编写。</li>
<li><code>keyGenerator</code>：和key二选一使用。</li>
<li><code>cacheManager</code>：指定使用的缓存管理器。</li>
<li><code>condition</code>：在方法执行开始前检查，在符合condition的情况下，进行缓存</li>
<li><code>unless</code>：在方法执行完成后检查，在符合unless的情况下，不进行缓存</li>
<li><code>sync</code>：是否使用同步模式。若使用同步模式，在多个线程同时对一个key进行load时，其他线程将被阻塞。</li>
</ul>
<h3 id="1-4-缓存同步模式">1.4 缓存同步模式</h3>
<p>sync开启或关闭，在Cache和LoadingCache中的表现是不一致的：</p>
<ul>
<li>Cache中，sync表示是否需要所有线程同步等待</li>
<li>LoadingCache中，sync表示在读取不存在/已驱逐的key时，是否执行被注解方法</li>
</ul>
<h2 id="2、实战">2、实战</h2>
<h3 id="2-1-引入依赖">2.1 引入依赖</h3>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.ben-manes.caffeine<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>caffeine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-2-缓存常量CacheConstants">2.2 缓存常量CacheConstants</h3>
<p>创建缓存常量类，把公共的常量提取一层，复用，这里也可以通过配置文件加载这些数据，例如<code>@ConfigurationProperties</code>和<code>@Value</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheConstants</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认过期时间（配置类中我使用的时间单位是秒，所以这里如 3*60 为3分钟）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_EXPIRES = <span class="number">3</span> * <span class="number">60</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXPIRES_5_MIN = <span class="number">5</span> * <span class="number">60</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXPIRES_10_MIN = <span class="number">10</span> * <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String GET_USER = <span class="string">"GET:USER"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String GET_DYNAMIC = <span class="string">"GET:DYNAMIC"</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-缓存配置类CacheConfig">2.3 缓存配置类CacheConfig</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Caffeine配置说明：</span></span><br><span class="line"><span class="comment">     * initialCapacity=[integer]: 初始的缓存空间大小</span></span><br><span class="line"><span class="comment">     * maximumSize=[long]: 缓存的最大条数</span></span><br><span class="line"><span class="comment">     * maximumWeight=[long]: 缓存的最大权重</span></span><br><span class="line"><span class="comment">     * expireAfterAccess=[duration]: 最后一次写入或访问后经过固定时间过期</span></span><br><span class="line"><span class="comment">     * expireAfterWrite=[duration]: 最后一次写入后经过固定时间过期</span></span><br><span class="line"><span class="comment">     * refreshAfterWrite=[duration]: 创建缓存或者最近一次更新缓存后经过固定的时间间隔，刷新缓存</span></span><br><span class="line"><span class="comment">     * weakKeys: 打开key的弱引用</span></span><br><span class="line"><span class="comment">     * weakValues：打开value的弱引用</span></span><br><span class="line"><span class="comment">     * softValues：打开value的软引用</span></span><br><span class="line"><span class="comment">     * recordStats：开发统计功能</span></span><br><span class="line"><span class="comment">     * 注意：</span></span><br><span class="line"><span class="comment">     * expireAfterWrite和expireAfterAccess同事存在时，以expireAfterWrite为准。</span></span><br><span class="line"><span class="comment">     * maximumSize和maximumWeight不可以同时使用</span></span><br><span class="line"><span class="comment">     * weakValues和softValues不可以同时使用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheManager <span class="title">cacheManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SimpleCacheManager cacheManager = <span class="keyword">new</span> SimpleCacheManager();</span><br><span class="line">        List&lt;CaffeineCache&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//循环添加枚举类中自定义的缓存，可以自定义</span></span><br><span class="line">        <span class="keyword">for</span> (CacheEnum cacheEnum : CacheEnum.values()) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> CaffeineCache(cacheEnum.getName(),</span><br><span class="line">                    Caffeine.newBuilder()</span><br><span class="line">                            .initialCapacity(<span class="number">50</span>)</span><br><span class="line">                            .maximumSize(<span class="number">1000</span>)</span><br><span class="line">                            .expireAfterAccess(cacheEnum.getExpires(), TimeUnit.SECONDS)</span><br><span class="line">                            .build()));</span><br><span class="line">        &#125;</span><br><span class="line">        cacheManager.setCaches(list);</span><br><span class="line">        <span class="keyword">return</span> cacheManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-调用缓存">2.4 调用缓存</h3>
<p>这里要注意的是Cache和@Transactional一样也使用了代理，类内调用将失效</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * value：缓存key的前缀。</span></span><br><span class="line"><span class="comment"> * key：缓存key的后缀。</span></span><br><span class="line"><span class="comment"> * sync：设置如果缓存过期是不是只放一个请求去请求数据库，其他请求阻塞，默认是false（根据个人需求）。</span></span><br><span class="line"><span class="comment"> * unless：不缓存空值,这里不使用，会报错</span></span><br><span class="line"><span class="comment"> * 查询用户信息类</span></span><br><span class="line"><span class="comment"> * 如果需要加自定义字符串，需要用单引号</span></span><br><span class="line"><span class="comment"> * 如果查询为null，也会被缓存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Cacheable</span>(value = CacheConstants.GET_USER,key = <span class="string">"'user'+#userId"</span>,sync = <span class="keyword">true</span>)</span><br><span class="line"><span class="meta">@CacheEvict</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> UserEntity <span class="title">getUserByUserId</span><span class="params">(Integer userId)</span></span>&#123;</span><br><span class="line">    UserEntity userEntity = userMapper.findById(userId);</span><br><span class="line">    System.out.println(<span class="string">"查询了数据库"</span>);</span><br><span class="line">    <span class="keyword">return</span> userEntity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>参考文章</p>
<p><a href="https://juejin.cn/post/6991751225125371911" target="_blank" rel="noopener">https://juejin.cn/post/6991751225125371911</a></p>
<p><a href="https://ghh3809.github.io/2021/05/31/caffeine/" target="_blank" rel="noopener">https://ghh3809.github.io/2021/05/31/caffeine/</a></p>
<p><a href="https://github.com/ben-manes/caffeine" target="_blank" rel="noopener">https://github.com/ben-manes/caffeine</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Supervisor+Dockerfile编译jdk镜像</title>
    <url>/posts/75d2cdb9.html</url>
    <content><![CDATA[<h1>一、Bash 脚本 set 命令</h1>
<h2 id="1、介绍">1、介绍</h2>
<p><code>set</code>命令是 Bash 脚本的重要环节，却常常被忽视，导致脚本的安全性和可维护性出问题。Bash 执行脚本的时候，会创建一个新的 Shell，若执行过程有错误，Bash 会忽略这个错误，继续往下执行，Bash 只是显示有错误，并没有终止执行。直接运行<code>set</code>，会显示所有的环境变量和 Shell 函数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#显示所有的环境变量</span></span><br><span class="line"><span class="built_in">set</span></span><br><span class="line"><span class="comment">#查看环境变量字节数</span></span><br><span class="line"><span class="built_in">set</span> | wc -l</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="2、set常用命令">2、set常用命令</h2>
<h3 id="2-1-set-u">2.1 set -u</h3>
<blockquote>
<p>执行脚本的时候，如果遇到不存在的变量，Bash 默认忽略它</p>
</blockquote>
<p><code>set -u</code>就用来改变这种行为，脚本在头部加上它，遇到不存在的变量就会报错，并停止执行；</p>
<p><code>-u</code>还有另一种写法<code>-o nounset</code>，两者是等价的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"><span class="built_in">set</span> -u</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line"><span class="built_in">echo</span> bar</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#运行结果</span></span><br><span class="line">$ bash script.sh</span><br><span class="line">bash: script.sh:行4: a: 未绑定的变量</span><br></pre></td></tr></table></figure>
<h3 id="2-2-set-x">2.2 set -x</h3>
<blockquote>
<p>默认情况下，脚本执行后，屏幕只显示运行结果，没有其他内容。如果多个命令连续执行，它们的运行结果就会连续输出。有时会分不清，某一段内容是什么命令产生的</p>
</blockquote>
<p><code>set -x</code>用来在运行结果之前，先输出执行的那一行命令</p>
<p><code>-x</code>还有另一种写法<code>-o xtrace</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"><span class="built_in">set</span> -x</span><br><span class="line"><span class="built_in">echo</span> bar</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#运行结果，没运行一条语句会显示一条</span></span><br><span class="line">$ bash script.sh</span><br><span class="line">+ <span class="built_in">echo</span> bar</span><br><span class="line">bar</span><br></pre></td></tr></table></figure>
<h3 id="2-3-set-e">2.3 set -e</h3>
<blockquote>
<p>设置该变量后，脚本只要发生错误，就终止执行</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line">foo</span><br><span class="line"><span class="built_in">echo</span> bar</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#执行结果，脚本发送错误，停止执行</span></span><br><span class="line">$ bash script.sh</span><br><span class="line">script.sh:行4: foo: 未找到命令</span><br></pre></td></tr></table></figure>
<p><code>set -e</code>根据返回值来判断，一个命令是否运行失败。但是，某些命令的非零返回值可能不表示失败，或者开发者希望在命令失败的情况下，脚本继续执行下去。这时可以暂时关闭<code>set -e</code>，该命令执行结束后，再重新打开<code>set -e</code>；</p>
<p><code>set +e</code>表示关闭<code>-e</code>选项，<code>set -e</code>表示重新打开<code>-e</code>选项。</p>
<p><code>-e</code>还有另一种写法<code>-o errexit</code></p>
<h3 id="2-4-set-o-pipefail">2.4 set -o pipefail</h3>
<blockquote>
<p><code>set -e</code>有一个例外情况，就是不适用于管道命令。所谓管道命令，就是多个子命令通过管道运算符（<code>|</code>）组合成为一个大的命令。Bash 会把最后一个子命令的返回值，作为整个命令的返回值。也就是说，只要最后一个子命令不失败，管道命令总是会执行成功，因此它后面命令依然会执行，<code>set -e</code>就失效了。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"><span class="built_in">set</span> -eo pipefail</span><br><span class="line">foo | <span class="built_in">echo</span> a</span><br><span class="line"><span class="built_in">echo</span> bar</span><br></pre></td></tr></table></figure>
<h3 id="2-5-总结">2.5 总结</h3>
<p>一般情况下，<code>set</code>命令的上面这四个参数，一般都放在一起使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 写法一</span></span><br><span class="line"><span class="built_in">set</span> -euxo pipefail</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写法二</span></span><br><span class="line"><span class="built_in">set</span> -eux</span><br><span class="line"><span class="built_in">set</span> -o pipefail</span><br><span class="line"></span><br><span class="line"><span class="comment">#运行bash命令</span></span><br><span class="line">bash -euxo pipefail script.sh</span><br></pre></td></tr></table></figure>
<h1>二、Supervisor实践</h1>
<blockquote>
<p>官网介绍：<a href="http://supervisord.org/" target="_blank" rel="noopener">http://supervisord.org/</a></p>
</blockquote>
<h2 id="1、介绍-v2">1、介绍</h2>
<p>Supervisor是用Python开发的一套通用的进程管理程序，能将一个普通的命令行进程变为后台daemon，并监控进程状态，异常退出时能自动重启。它是通过fork/exec的方式把这些被管理的进程当作supervisor的子进程来启动，这样只要在supervisor的配置文件中，把要管理的进程的可执行文件的路径写进去即可。也实现当子进程挂掉的时候，父进程可以准确获取子进程挂掉的信息的，可以选择是否自己启动和报警。supervisor还提供了一个功能，可以为supervisord或者每个子进程，设置一个非root的user，这个user就可以管理它对应的进程。</p>
<h2 id="2、Supervisor安装">2、Supervisor安装</h2>
<blockquote>
<p><a href="http://supervisord.org/installing.html" target="_blank" rel="noopener">官方安装文档</a></p>
</blockquote>
<p>建议用系统工具安装，开机会自动启动，Centos 用 <code>yum</code>，Ubuntu 用 <code>apt-get</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install supervisor</span><br><span class="line">apt install supervisor</span><br></pre></td></tr></table></figure>
<p>第二种方式用pip安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install supervisor</span><br></pre></td></tr></table></figure>
<h2 id="3、配置文件说明">3、配置文件说明</h2>
<blockquote>
<p><a href="http://supervisord.org/configuration.html" target="_blank" rel="noopener">http://supervisord.org/configuration.html</a></p>
</blockquote>
<h3 id="3-1-介绍">3.1 介绍</h3>
<ul>
<li>supervisor配置文件：<code>/etc/supervisord.conf</code><br>
使用<code>echo_supervisord_conf &gt; supervisord.conf</code>生成默认配置文件<br>
注：supervisor的配置文件默认是不全的，不过在大部分默认的情况下，上面说的基本功能已经满足。</li>
<li>子进程配置文件路径：<code>/etc/supervisord.d/</code><br>
注：默认子进程配置文件为ini格式，在<code>/etc/supervisord.conf </code>中 <code>[include]</code> 配置 <code>/etc/supervisord.d/*.ini</code></li>
</ul>
<h3 id="3-2-supervisor-conf配置文件说明">3.2 supervisor.conf配置文件说明</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[unix_http_server]</span><br><span class="line">file=/tmp/supervisor.sock   ;UNIX socket 文件，supervisorctl 会使用</span><br><span class="line">;chmod=0700                 ;socket文件的mode，默认是0700</span><br><span class="line">;chown=nobody:nogroup       ;socket文件的owner，格式：uid:gid</span><br><span class="line"> </span><br><span class="line">;[inet_http_server]         ;HTTP服务器，提供web管理界面</span><br><span class="line">;port=127.0.0.1:9001        ;Web管理后台运行的IP和端口，如果开放到公网，需要注意安全性</span><br><span class="line">;username=user              ;登录管理后台的用户名</span><br><span class="line">;password=123               ;登录管理后台的密码</span><br><span class="line"> </span><br><span class="line">[supervisord]</span><br><span class="line">logfile=/tmp/supervisord.log ;日志文件，默认是 <span class="variable">$CWD</span>/supervisord.log</span><br><span class="line">logfile_maxbytes=50MB        ;日志文件大小，超出会rotate，默认 50MB，如果设成0，表示不限制大小</span><br><span class="line">logfile_backups=10           ;日志文件保留备份数量默认10，设为0表示不备份</span><br><span class="line">loglevel=info                ;日志级别，默认info，其它: debug,warn,trace</span><br><span class="line">pidfile=/tmp/supervisord.pid ;pid 文件</span><br><span class="line">nodaemon=<span class="literal">false</span>               ;是否在前台启动，默认是<span class="literal">false</span>，即以 daemon 的方式启动</span><br><span class="line">minfds=1024                  ;可以打开的文件描述符的最小值，默认 1024</span><br><span class="line">minprocs=200                 ;可以打开的进程数的最小值，默认 200</span><br><span class="line"> </span><br><span class="line">[supervisorctl]</span><br><span class="line">serverurl=unix:///tmp/supervisor.sock ;通过UNIX socket连接supervisord，路径与unix_http_server部分的file一致</span><br><span class="line">;serverurl=http://127.0.0.1:9001 ; 通过HTTP的方式连接supervisord</span><br><span class="line"> </span><br><span class="line">; [program:xx]是被管理的进程配置参数，xx是进程的名称</span><br><span class="line">[program:xx]</span><br><span class="line"><span class="built_in">command</span>=/opt/apache-tomcat-8.0.35/bin/catalina.sh run  ; 程序启动命令</span><br><span class="line">autostart=<span class="literal">true</span>       ; 在supervisord启动的时候也自动启动</span><br><span class="line">startsecs=10         ; 启动10秒后没有异常退出，就表示进程正常启动了，默认为1秒</span><br><span class="line">autorestart=<span class="literal">true</span>     ; 程序退出后自动重启,可选值：[unexpected,<span class="literal">true</span>,<span class="literal">false</span>]，默认为unexpected，表示进程意外杀死后才重启</span><br><span class="line">startretries=3       ; 启动失败自动重试次数，默认是3</span><br><span class="line">user=tomcat          ; 用哪个用户启动进程，默认是root</span><br><span class="line">priority=999         ; 进程启动优先级，默认999，值小的优先启动</span><br><span class="line">redirect_stderr=<span class="literal">true</span> ; 把stderr重定向到stdout，默认<span class="literal">false</span></span><br><span class="line">stdout_logfile_maxbytes=20MB  ; stdout 日志文件大小，默认50MB</span><br><span class="line">stdout_logfile_backups = 20   ; stdout 日志文件备份数，默认是10</span><br><span class="line">; stdout 日志文件，需要注意当指定目录不存在时无法正常启动，所以需要手动创建目录（supervisord 会自动创建日志文件）</span><br><span class="line">stdout_logfile=/opt/apache-tomcat-8.0.35/logs/catalina.out</span><br><span class="line">stopasgroup=<span class="literal">false</span>     ;默认为<span class="literal">false</span>,进程被杀死时，是否向这个进程组发送stop信号，包括子进程</span><br><span class="line">killasgroup=<span class="literal">false</span>     ;默认为<span class="literal">false</span>，向进程组发送<span class="built_in">kill</span>信号，包括子进程</span><br><span class="line"> </span><br><span class="line">;包含其它配置文件</span><br><span class="line">[include]</span><br><span class="line">files = relative/directory/*.ini    ;可以指定一个或多个以.ini结束的配置文件</span><br></pre></td></tr></table></figure>
<h3 id="3-3-子进程配置文件说明">3.3 子进程配置文件说明</h3>
<p>给需要管理的子进程(程序)编写一个配置文件，放在<code>/etc/supervisor.d/</code>目录下，以<code>.ini</code>作为扩展名</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#项目名</span></span><br><span class="line">[program:blog]</span><br><span class="line"><span class="comment">#脚本目录</span></span><br><span class="line">directory=/opt/bin</span><br><span class="line"><span class="comment">#脚本执行命令</span></span><br><span class="line"><span class="built_in">command</span>=/usr/bin/python /opt/bin/test.py</span><br><span class="line"></span><br><span class="line"><span class="comment">#supervisor启动的时候是否随着同时启动，默认True</span></span><br><span class="line">autostart=<span class="literal">true</span></span><br><span class="line"><span class="comment">#当程序exit的时候，这个program不会自动重启,默认unexpected，设置子进程挂掉后自动重启的情况，有三个选项，false,unexpected和true。如果为false的时候，无论什么情况下，都不会被重新启动，如果为unexpected，只有当进程的退出码不在下面的exitcodes里面定义的</span></span><br><span class="line">autorestart=<span class="literal">false</span></span><br><span class="line"><span class="comment">#这个选项是子进程启动多少秒之后，此时状态如果是running，则我们认为启动成功了。默认值为1</span></span><br><span class="line">startsecs=1</span><br><span class="line"></span><br><span class="line"><span class="comment">#脚本运行的用户身份 </span></span><br><span class="line">user = <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#日志输出 </span></span><br><span class="line">stderr_logfile=/tmp/blog_stderr.log </span><br><span class="line">stdout_logfile=/tmp/blog_stdout.log </span><br><span class="line"><span class="comment">#把stderr重定向到stdout，默认 false</span></span><br><span class="line">redirect_stderr = <span class="literal">true</span></span><br><span class="line"><span class="comment">#stdout日志文件大小，默认 50MB</span></span><br><span class="line">stdout_logfile_maxbytes = 20MB</span><br><span class="line"><span class="comment">#stdout日志文件备份数</span></span><br><span class="line">stdout_logfile_backups = 20</span><br></pre></td></tr></table></figure>
<h2 id="4、supervisor命令说明">4、supervisor命令说明</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#首先要启动服务器</span></span><br><span class="line"><span class="comment">#unix:///var/run/supervisor.sock no such file表示满意启动服务器</span></span><br><span class="line">supervisord -c /etc/supervisord.conf</span><br><span class="line">systemctl stop supervisor.service</span><br><span class="line"></span><br><span class="line">supervisorctl status        <span class="comment">#查看所有进程的状态</span></span><br><span class="line">supervisorctl stop es       <span class="comment">#停止es</span></span><br><span class="line">supervisorctl start es      <span class="comment">#启动es</span></span><br><span class="line">supervisorctl restart       <span class="comment">#重启es</span></span><br><span class="line">supervisorctl update        <span class="comment">#配置文件修改后使用该命令加载新的配置</span></span><br><span class="line">supervisorctl reload        <span class="comment">#重新启动配置中的所有程序</span></span><br><span class="line"><span class="comment">#还可以直接进入shell交互界面</span></span><br><span class="line">supervisorctl</span><br></pre></td></tr></table></figure>
<p>子进程状态图，用status可以查看</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/9022c2547398cfa739bc5408d11ac1f2.png" alt></p>
<h1>三、Dockerfile编译jdk实例</h1>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM openjdk:19-slim-buster</span><br><span class="line">USER root</span><br><span class="line"><span class="comment">#DEBIAN_FRONTEND这个环境变量，告知操作系统应该从哪儿获得用户输入。如果设置为”noninteractive”，你就可以直接运行命令，</span></span><br><span class="line"><span class="comment">#而无需向用户请求输入（所有操作都是非交互式的）。这在运行apt-get命令的时候格外有用</span></span><br><span class="line">ENV DEBIAN_FRONTEND noninteractive</span><br><span class="line">ADD ./supervisord.conf /tmp/supervisord_add.conf</span><br><span class="line">RUN <span class="built_in">set</span> -ex \</span><br><span class="line">&amp;&amp; apt-get update\</span><br><span class="line">&amp;&amp; apt-get install -y python-pip \</span><br><span class="line">&amp;&amp; pip install supervisor \</span><br><span class="line">&amp;&amp; echo_supervisord_conf &gt; /etc/supervisord.conf \</span><br><span class="line">&amp;&amp; cat /tmp/supervisord_add.conf &gt;&gt; /etc/supervisord.conf \</span><br><span class="line">&amp;&amp; mkdir -p /var/<span class="built_in">log</span>/lamp \</span><br><span class="line">&amp;&amp; rm /tmp/supervisord_add.conf</span><br><span class="line">&amp;&amp; ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line">CMD [<span class="string">"supervisord"</span>,<span class="string">"-c"</span>,<span class="string">"/etc/supervisord.conf"</span>]</span><br></pre></td></tr></table></figure>
<p>这里使用supervisor来管理后台进程，和shell脚本差不多，但是这个功能更强大</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置成不要后台运行supervisor进程，对于容器来说就是一个前台进程</span></span><br><span class="line">nodaemon=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 把stderr重定向到stdout，默认false</span></span><br><span class="line">redirect_stderr=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 声明新程序的代码块</span></span><br><span class="line">[program:student]</span><br><span class="line"><span class="comment"># 用于启动在该代码块中声明的程序的命令</span></span><br><span class="line"><span class="built_in">command</span>=java -Dfile.encoding=utf-8 -jar /opt/lamp/student.jar --server.port=8080</span><br><span class="line">stdout_logfile=/var/<span class="built_in">log</span>/lamp/student.log</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot @Async异步多线程</title>
    <url>/posts/22f5facd.html</url>
    <content><![CDATA[<h1>一、简介</h1>
<h2 id="1、概念">1、概念</h2>
<p><strong>同步：</strong> 同步就是整个处理过程顺序执行，当各个过程都执行完毕，并返回结果。<br>
<strong>异步：</strong> 异步调用则是只是发送了调用的指令，调用者无需等待被调用的方法完全执行完毕；而是继续执行下面的流程。</p>
<a id="more"></a>
<h2 id="2、异步多线程概述">2、异步多线程概述</h2>
<p>在实际项目开发中很多业务场景需要使用异步去完成，比如消息通知，日志记录等常用的功能都可以通过异步去执行，提高效率。一般来说，完成异步操作一般有两种，<code>消息队列MQ</code>和线程池处理<code>ThreadPoolExecutor</code>，而在<code>Spring4</code>以后提供的对ThreadPoolExecutor封装的线程池<code>ThreadPoolTaskExecutor</code>，直接在方法上使用注解启用<code>@Async</code>，即可方便的使用异步线程（这里不要忘记在任一Configuration文件加上<code>@EnableAsync</code>打开注解功能）</p>
<h2 id="3、Spring已实现线程池">3、Spring已实现线程池</h2>
<ul>
<li><code>SimpleAsyncTaskExecutor</code>：不是真的线程池，这个类不重用线程，默认每次调用都会创建一个新的线程。</li>
<li><code>SyncTaskExecutor</code>：这个类没有实现异步调用，只是一个同步操作。只适用于不需要多线程的地方。</li>
<li><code>ConcurrentTaskExecutor</code>：Executor的适配类，不推荐使用。如果ThreadPoolTaskExecutor不满足要求时，才用考虑使用这个类。</li>
<li><code>SimpleThreadPoolTaskExecutor</code>：是Quartz的SimpleThreadPool的类。线程池同时被quartz和非quartz使用，才需要使用此类。</li>
<li><code>ThreadPoolTaskExecutor</code> ：最常使用，推荐。其实质是对<code>java.util.concurrent.ThreadPoolExecutor</code>的包装。</li>
</ul>
<h2 id="4、异步方法">4、异步方法</h2>
<blockquote>
<p>参考：<a href="https://blog.csdn.net/lemon_TT/article/details/121561663" target="_blank" rel="noopener">Java8异步编程</a></p>
</blockquote>
<ul>
<li>最简单的异步调用，返回值为void</li>
<li>带参数的异步调用，异步方法可以传入参数</li>
<li>存在返回值，常调用返回Future</li>
</ul>
<h1>二、@Async默认线程池</h1>
<h2 id="1、默认-Async异步调用例子">1、默认@Async异步调用例子</h2>
<h3 id="1-1-开启异步任务">1.1 开启异步任务</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-在方法上标记异步调用">1.2 在方法上标记异步调用</h3>
<p>增加一个service类，用来做积分处理。  @Async添加在方法上，代表该方法为异步处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScoreService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ScoreService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addScore</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//TODO 模拟睡5秒，用于赠送积分处理</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>*<span class="number">5</span>);</span><br><span class="line">            logger.info(<span class="string">"--------------处理积分--------------------"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2、默认线程池弊端">2、默认线程池弊端</h2>
<h3 id="2-1-Executors弊端">2.1 Executors弊端</h3>
<p>在线程池应用中，参考阿里巴巴java开发规范：线程池不允许使用Executors去创建，不允许使用系统默认的线程池，推荐通过<strong>ThreadPoolExecutor</strong>的方式，这样的处理方式让开发的工程师更加明确线程池的运行规则，规避资源耗尽的风险。Executors各个方法的弊端：</p>
<ul>
<li><code>newFixedThreadPool</code>和<code>newSingleThreadExecutor</code>：主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至OOM</li>
<li><code>newCachedThreadPool</code>和<code>newScheduledThreadPool</code>：主要问题是线程数最大数是<code>Integer.MAX_VALUE</code>，可能会创建数量非常多的线程，甚至OOM</li>
</ul>
<h3 id="2-2-Async弊端">2.2 @Async弊端</h3>
<p><code>@Async</code>默认异步配置使用的是<code>SimpleAsyncTaskExecutor</code>，该线程池默认来一个任务创建一个线程，若系统中不断的创建线程，最终会导致系统占用内存过高，引发OutOfMemoryError错误。</p>
<p>针对线程创建问题，SimpleAsyncTaskExecutor提供了限流机制，通过concurrencyLimit属性来控制开关，当<code>concurrencyLimit&gt;=0</code>时开启限流机制，默认关闭限流机制即<code>concurrencyLimit=-1</code>，当关闭情况下，会不断创建新的线程来处理任务。基于默认配置，SimpleAsyncTaskExecutor并不是严格意义的线程池，达不到线程复用的功能</p>
<h1>三、@Async自定义线程池</h1>
<h2 id="1、介绍">1、介绍</h2>
<p>自定义线程池，可对系统中线程池更加细粒度的控制，方便调整线程池大小配置，线程执行异常控制和处理。在设置系统自定义线程池代替默认线程池时，虽可通过多种模式设置，但替换默认线程池最终产生的线程池有且只能设置一个（不能设置多个类继承AsyncConfigurer）。自定义线程池有如下模式：</p>
<ul>
<li>重新实现接口AsyncConfigurer</li>
<li>继承AsyncConfigurerSupport</li>
<li>配置由自定义的TaskExecutor替代内置的任务执行器</li>
</ul>
<p>通过查看Spring源码关于<code>@Async</code>的默认调用规则，会优先查询源码中实现AsyncConfigurer这个接口的类，实现这个接口的类为AsyncConfigurerSupport。**但默认配置的线程池和异步处理方法均为空，所以，无论是继承或者重新实现接口，都需指定一个线程池。**且重新实现 <code>public Executor getAsyncExecutor()</code>方法。</p>
<h2 id="2、Spring自定义异步线程池几种方式">2、Spring自定义异步线程池几种方式</h2>
<h3 id="2-1-配置application-yml">2.1 配置application.yml</h3>
<p>这里我使用了配置文件注入的方式，首先配置好配置文件</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置核心线程数</span></span><br><span class="line"><span class="attr">async:</span></span><br><span class="line">  <span class="attr">executor:</span></span><br><span class="line">    <span class="attr">thread:</span></span><br><span class="line">      <span class="attr">core_pool_size:</span> <span class="number">5</span></span><br><span class="line">      <span class="comment"># 配置最大线程数</span></span><br><span class="line">      <span class="attr">max_pool_size:</span> <span class="number">5</span></span><br><span class="line">      <span class="comment"># 配置队列大小</span></span><br><span class="line">      <span class="attr">queue_capacity:</span> <span class="number">999</span></span><br><span class="line">      <span class="comment"># 配置线程最大空闲时间</span></span><br><span class="line">      <span class="attr">keep_alive_seconds:</span> <span class="number">60</span></span><br><span class="line">      <span class="comment"># 配置线程池中的线程的名称前缀</span></span><br><span class="line">      <span class="attr">name:</span></span><br><span class="line">        <span class="attr">prefix:</span> <span class="string">test-async-</span></span><br></pre></td></tr></table></figure>
<h3 id="2-2-实现接口AsyncConfigurer">2.2 实现接口AsyncConfigurer</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorConfig1</span> <span class="keyword">implements</span> <span class="title">AsyncConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ExecutorConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;async.executor.thread.core_pool_size&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> corePoolSize;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;async.executor.thread.max_pool_size&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxPoolSize;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;async.executor.thread.queue_capacity&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> queueCapacity;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;async.executor.thread.keep_alive_seconds&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> keepAliveSeconds;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;async.executor.thread.name.prefix&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String namePrefix;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"asyncServiceExecutor"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">asyncServiceExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"开启SpringBoot的线程池！"</span>);</span><br><span class="line"></span><br><span class="line">        ThreadPoolTaskExecutor executor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置核心线程数</span></span><br><span class="line">        executor.setCorePoolSize(corePoolSize);</span><br><span class="line">        <span class="comment">// 设置最大线程数，只有在缓冲队列满了之后才会申请超过核心线程数的线程</span></span><br><span class="line">        executor.setMaxPoolSize(maxPoolSize);</span><br><span class="line">        <span class="comment">// 设置缓冲队列大小</span></span><br><span class="line">        executor.setQueueCapacity(queueCapacity);</span><br><span class="line">        <span class="comment">// 设置线程的最大空闲时间，超过了核心线程数之外的线程，在空闲时间到达之后会被销毁</span></span><br><span class="line">        executor.setKeepAliveSeconds(keepAliveSeconds);</span><br><span class="line">        <span class="comment">// 设置线程名字的前缀，设置好了之后可以方便我们定位处理任务所在的线程池</span></span><br><span class="line">        executor.setThreadNamePrefix(namePrefix);</span><br><span class="line">        <span class="comment">// 设置拒绝策略：当线程池达到最大线程数时，如何处理新任务</span></span><br><span class="line">        <span class="comment">// CALLER_RUNS：在添加到线程池失败时会由主线程自己来执行这个任务，</span></span><br><span class="line">        <span class="comment">// 当线程池没有处理能力的时候，该策略会直接在execute方法的调用线程中运行被拒绝的任务；如果执行程序已被关闭，则会丢弃该任务</span></span><br><span class="line">        executor.setRejectedExecutionHandler(<span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程池初始化</span></span><br><span class="line">        executor.initialize();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">getAsyncExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> asyncServiceExecutor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AsyncUncaughtExceptionHandler <span class="title">getAsyncUncaughtExceptionHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (ex, method, params) -&gt; logger.error(String.format(<span class="string">"执行异步任务'%s'"</span>, method), ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-继承AsyncConfigurerSupport">2.3 <strong>继承AsyncConfigurerSupport</strong></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorConfig2</span> <span class="keyword">extends</span> <span class="title">AsyncConfigurerSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ExecutorConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;async.executor.thread.core_pool_size&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> corePoolSize;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;async.executor.thread.max_pool_size&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxPoolSize;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;async.executor.thread.queue_capacity&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> queueCapacity;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;async.executor.thread.keep_alive_seconds&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> keepAliveSeconds;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;async.executor.thread.name.prefix&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String namePrefix;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"asyncServiceExecutor"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">asyncServiceExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"开启SpringBoot的线程池！"</span>);</span><br><span class="line"></span><br><span class="line">        ThreadPoolTaskExecutor executor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置核心线程数</span></span><br><span class="line">        executor.setCorePoolSize(corePoolSize);</span><br><span class="line">        <span class="comment">// 设置最大线程数，只有在缓冲队列满了之后才会申请超过核心线程数的线程</span></span><br><span class="line">        executor.setMaxPoolSize(maxPoolSize);</span><br><span class="line">        <span class="comment">// 设置缓冲队列大小</span></span><br><span class="line">        executor.setQueueCapacity(queueCapacity);</span><br><span class="line">        <span class="comment">// 设置线程的最大空闲时间，超过了核心线程数之外的线程，在空闲时间到达之后会被销毁</span></span><br><span class="line">        executor.setKeepAliveSeconds(keepAliveSeconds);</span><br><span class="line">        <span class="comment">// 设置线程名字的前缀，设置好了之后可以方便我们定位处理任务所在的线程池</span></span><br><span class="line">        executor.setThreadNamePrefix(namePrefix);</span><br><span class="line">        <span class="comment">// 设置拒绝策略：当线程池达到最大线程数时，如何处理新任务</span></span><br><span class="line">        <span class="comment">// CALLER_RUNS：在添加到线程池失败时会由主线程自己来执行这个任务，</span></span><br><span class="line">        <span class="comment">// 当线程池没有处理能力的时候，该策略会直接在execute方法的调用线程中运行被拒绝的任务；如果执行程序已被关闭，则会丢弃该任务</span></span><br><span class="line">        executor.setRejectedExecutionHandler(<span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程池初始化</span></span><br><span class="line">        executor.initialize();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">getAsyncExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> asyncServiceExecutor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AsyncUncaughtExceptionHandler <span class="title">getAsyncUncaughtExceptionHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (ex, method, params) -&gt; logger.error(String.format(<span class="string">"执行异步任务'%s'"</span>, method), ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-配置自定义的TaskExecutor">2.4 <strong>配置自定义的TaskExecutor</strong></h3>
<p>由于AsyncConfigurer的默认线程池在源码中为空，Spring通过<code>beanFactory.getBean(TaskExecutor.class)</code>先查看是否有线程池，未配置时，通过<code>beanFactory.getBean(DEFAULT_TASK_EXECUTOR_BEAN_NAME, Executor.class)</code>，又查询是否存在默认名称为TaskExecutor的线程池。</p>
<p>因此在替换默认的线程池时，需设置默认的线程池名称为<strong>TaskExecutor</strong>，这样的模式，最终底层为<code>TaskExecutor.class</code>，在替换默认的线程池时，可不指定线程池名称。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorConfig3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ExecutorConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;async.executor.thread.core_pool_size&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> corePoolSize;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;async.executor.thread.max_pool_size&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxPoolSize;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;async.executor.thread.queue_capacity&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> queueCapacity;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;async.executor.thread.keep_alive_seconds&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> keepAliveSeconds;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;async.executor.thread.name.prefix&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String namePrefix;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name = AsyncExecutionAspectSupport.DEFAULT_TASK_EXECUTOR_BEAN_NAME)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">taskExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"开启SpringBoot的线程池！"</span>);</span><br><span class="line"></span><br><span class="line">        ThreadPoolTaskExecutor executor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置核心线程数</span></span><br><span class="line">        executor.setCorePoolSize(corePoolSize);</span><br><span class="line">        <span class="comment">// 设置最大线程数，只有在缓冲队列满了之后才会申请超过核心线程数的线程</span></span><br><span class="line">        executor.setMaxPoolSize(maxPoolSize);</span><br><span class="line">        <span class="comment">// 设置缓冲队列大小</span></span><br><span class="line">        executor.setQueueCapacity(queueCapacity);</span><br><span class="line">        <span class="comment">// 设置线程的最大空闲时间，超过了核心线程数之外的线程，在空闲时间到达之后会被销毁</span></span><br><span class="line">        executor.setKeepAliveSeconds(keepAliveSeconds);</span><br><span class="line">        <span class="comment">// 设置线程名字的前缀，设置好了之后可以方便我们定位处理任务所在的线程池</span></span><br><span class="line">        executor.setThreadNamePrefix(namePrefix);</span><br><span class="line">        <span class="comment">// 设置拒绝策略：当线程池达到最大线程数时，如何处理新任务</span></span><br><span class="line">        <span class="comment">// CALLER_RUNS：在添加到线程池失败时会由主线程自己来执行这个任务，</span></span><br><span class="line">        <span class="comment">// 当线程池没有处理能力的时候，该策略会直接在execute方法的调用线程中运行被拒绝的任务；如果执行程序已被关闭，则会丢弃该任务</span></span><br><span class="line">        executor.setRejectedExecutionHandler(<span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程池初始化</span></span><br><span class="line">        executor.initialize();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"myTask"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">taskExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"开启SpringBoot的线程池！"</span>);</span><br><span class="line"></span><br><span class="line">        ThreadPoolTaskExecutor executor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置核心线程数</span></span><br><span class="line">        executor.setCorePoolSize(corePoolSize);</span><br><span class="line">        <span class="comment">// 设置最大线程数，只有在缓冲队列满了之后才会申请超过核心线程数的线程</span></span><br><span class="line">        executor.setMaxPoolSize(maxPoolSize);</span><br><span class="line">        <span class="comment">// 设置缓冲队列大小</span></span><br><span class="line">        executor.setQueueCapacity(queueCapacity);</span><br><span class="line">        <span class="comment">// 设置线程的最大空闲时间，超过了核心线程数之外的线程，在空闲时间到达之后会被销毁</span></span><br><span class="line">        executor.setKeepAliveSeconds(keepAliveSeconds);</span><br><span class="line">        <span class="comment">// 设置线程名字的前缀，设置好了之后可以方便我们定位处理任务所在的线程池</span></span><br><span class="line">        executor.setThreadNamePrefix(namePrefix);</span><br><span class="line">        <span class="comment">// 设置拒绝策略：当线程池达到最大线程数时，如何处理新任务</span></span><br><span class="line">        <span class="comment">// CALLER_RUNS：在添加到线程池失败时会由主线程自己来执行这个任务，</span></span><br><span class="line">        <span class="comment">// 当线程池没有处理能力的时候，该策略会直接在execute方法的调用线程中运行被拒绝的任务；如果执行程序已被关闭，则会丢弃该任务</span></span><br><span class="line">        executor.setRejectedExecutionHandler(<span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程池初始化</span></span><br><span class="line">        executor.initialize();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-5-多线程">2.5 多线程</h3>
<p><code>@Async</code>注解使用系统默认或者自定义的线程池(代替默认线程池)，也可在项目中设置多个线程池，在异步调用时，指明需要调用的线程池名称，如<code>@Async(&quot;mytask&quot;)</code>。</p>
<p>参考文章</p>
<p><a href="https://mp.weixin.qq.com/s/ACJgGFofD9HAYqW4u8qJUw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/ACJgGFofD9HAYqW4u8qJUw</a></p>
<p><a href="https://juejin.cn/post/6970927877348917261#heading-0" target="_blank" rel="noopener">https://juejin.cn/post/6970927877348917261#heading-0</a></p>
<p><a href="https://www.cnblogs.com/kenx/p/15268311.html" target="_blank" rel="noopener">https://www.cnblogs.com/kenx/p/15268311.html</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合框架</title>
    <url>/posts/9753a2e.html</url>
    <content><![CDATA[<p># Java集合框架</p>
<h1>一、简介</h1>
<h2 id="1、集合框架介绍">1、集合框架介绍</h2>
<p>Java集合框架提供了一套性能优良，使用方便的接口和类，他们位于<code>java.util</code>包中。容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对(两个对象)的映射表</p>
<p><img src="https://img-blog.csdnimg.cn/2a3f97c930a241468c0288110fec73ee.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6a2FTGVtb24=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<a id="more"></a>
<h2 id="2、相关容器介绍">2、相关容器介绍</h2>
<h3 id="2-1-Set相关">2.1 Set相关</h3>
<ul>
<li><strong>TreeSet</strong><br>
基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)</li>
<li><strong>HashSet</strong><br>
基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。</li>
<li><strong>LinkedHashSet</strong><br>
具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序。</li>
</ul>
<h3 id="2-2-List相关">2.2 List相关</h3>
<ul>
<li><strong>ArrayList</strong><br>
基于动态数组实现，支持随机访问。</li>
<li><strong>Vector</strong><br>
和 ArrayList 类似，但它是线程安全的。</li>
<li><strong>LinkedList</strong><br>
基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。</li>
</ul>
<h3 id="2-3-Queue相关">2.3 Queue相关</h3>
<ul>
<li><strong>LinkedList</strong><br>
可以实现双向队列。</li>
<li><strong>PriorityQueue</strong><br>
基于堆结构实现，可以用它来实现优先队列。</li>
</ul>
<h3 id="2-4-Map相关">2.4 Map相关</h3>
<ul>
<li><strong>TreeMap</strong><br>
基于红黑树实现。</li>
<li><strong>HashMap</strong><br>
基于哈希表实现。</li>
<li><strong>HashTable</strong><br>
和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程可以同时写入 HashTable 并且不会导致数据不一致。它是遗留类，不应该去使用它。现在可以使用 <code>ConcurrentHashMap</code> 来支持线程安全，并且 <code>ConcurrentHashMap</code> 的效率会更高，因为 <code>ConcurrentHashMap</code> 引入了分段锁。</li>
<li><strong>LinkedHashMap</strong><br>
使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用(LRU)顺序</li>
</ul>
<h2 id="3、集合重点👏">3、集合重点👏</h2>
<ul>
<li>Collection 接口存储一组不唯一，无序的对象</li>
<li>List 接口存储一组不唯一，有序的对象。</li>
<li>Set 接口存储一组唯一，无序的对象</li>
<li>Map 接口存储一组键值对象，提供key到value的映射</li>
<li>ArrayList实现了长度可变的数组，在内存中分配连续的空间。遍历元素和随机访问元素的效率比较高</li>
<li>LinkedList采用链表存储方式。插入、删除元素时效率比较高</li>
<li>HashSet采用哈希算法实现的Set</li>
<li>HashSet的底层是用HashMap实现的，因此查询效率较高，由于采用hashCode算法直接确定 元素的内存地址，增删效率高</li>
</ul>
<h1>二、ArrayList分析</h1>
<h2 id="1、ArrayList使用">1、ArrayList使用</h2>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean add(Object o)</td>
<td>在列表的末尾顺序添加元素，起始索引位置从0开始</td>
</tr>
<tr>
<td>void add(int index, Object o)</td>
<td>在指定的索引位置添加元素，<strong>索引位置必须介于0和列表中元素个数之间</strong></td>
</tr>
<tr>
<td>int size()</td>
<td>返回列表中的元素个数</td>
</tr>
<tr>
<td>Object get(int index)</td>
<td>返回指定索引位置处的元素。<strong>取出的元素是Object类型，使用前品要进行益制类型转换</strong></td>
</tr>
<tr>
<td>boolean contains(Object o)</td>
<td>判断列表中是否存在指定元素</td>
</tr>
<tr>
<td>boolean remove(Object o)</td>
<td>从列表中删除元素</td>
</tr>
<tr>
<td>Object remove(int index）</td>
<td>从列表中删除指定位置元素，起始索引位量从0开始</td>
</tr>
</tbody>
</table>
<h2 id="2、ArrayList介绍">2、ArrayList介绍</h2>
<ul>
<li>ArrayList是可以动态增长和缩减的索引序列，它是基于数组实现的List类</li>
<li>该类封装了一个动态再分配的Object[]数组，每一个类对象都有一个capacity[容量]属性，表示它们所封装的Object[]数组的长度，当向ArrayList中添加元素时，该属性值会自动增加。如果想ArrayList中添加大量元素，可使用ensureCapacity方法一次性增加capacity，可以减少增加重分配的次数提高性能</li>
<li>ArrayList的用法和Vector向类似，但是Vector是一个较老的集合，具有很多缺点，不建议使用</li>
</ul>
<p>另外，ArrayList和Vector的区别是：ArrayList是线程不安全的，当多条线程访问同一个ArrayList集合时，程序需要手动保证该集合的同步性，而Vector则是线程安全的。</p>
<h2 id="3、源码分析">3、源码分析</h2>
<h3 id="3-1-继承结构与层次关系">3.1 继承结构与层次关系</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/ec45eadf515445c28c1b8643a1254e7a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6a2FTGVtb24=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>
这里简单解释一下几个接口</p>
<ul>
<li><strong>RandomAccess接口</strong><br>
这个是一个标记性接口，通过查看api文档，它的作用就是用来快速随机存取，有关效率的问题，在实现了该接口的话，那么使用普通的for循环来遍历，性能更高，例如ArrayList。而没有实现该接口的话，使用Iterator来迭代，这样性能更高，例如linkedList。所以这个标记性只是为了 让我们知道我们用什么样的方式去获取数据性能更好。</li>
<li><strong>Cloneable接口</strong><br>
实现了该接口，就可以使用Object.Clone()方法了。</li>
<li><strong>Serializable接口</strong><br>
实现该序列化接口，表明该类可以被序列化。什么是序列化？简单的说，就是能够从类变成字节流传输，然后还能从字节流变成原来的类。</li>
</ul>
<p><em>这里的继承结构可通过IDEA中Navigate&gt;Type Hierarchy查看</em></p>
<p><img src="https://img-blog.csdnimg.cn/ff0b03ec39644c5f9de723084544781a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6a2FTGVtb24=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<h3 id="3-2-属性">3.2 属性</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//版本号</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8683452581122892189L</span>;</span><br><span class="line"><span class="comment">//缺省容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//空对象数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="comment">//缺省空对象数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="comment">//存储的数组元素</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"><span class="comment">//实际元素大小，默认为0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="comment">//最大数组容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-构造方法">3.3 构造方法</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造具有指定初始容量的空列表</span></span><br><span class="line"><span class="comment"> * 如果指定的初始容量为负，则为IllegalArgumentException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认空数组的大小为10</span></span><br><span class="line"><span class="comment"> * ArrayList中储存数据的其实就是一个数组，这个数组就是elementData</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 按照集合迭代器返回元素的顺序构造包含指定集合的元素的列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 转换为数组</span></span><br><span class="line">        <span class="comment">//每个集合的toarray()的实现方法不一样，所以需要判断一下，如果不是Object[].class类型，那么久需要使用ArrayList中的方法去改造一下。</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[]<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            <span class="title">elementData</span> </span>= Arrays.copyOf(elementData, size, Object[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则就用空数组代替</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-4-自动扩容✨">3.4 自动扩容✨</h3>
<p>每当向数组中添加元素时，都要去检查添加后元素的个数是否会超出当前数组的长度，如果超出，数组将会进行扩容，以满足添加数据的需求。数组扩容通过一个公开的方法<code>ensureCapacity(int minCapacity)</code>来实现。<strong>在实际添加大量元素前</strong>，我也可以使用<code>ensureCapacity</code>来手动增加ArrayList实例的容量，以减少递增式再分配的数量。</p>
<p>数组进行扩容时，会将**老数组中的元素重新拷贝一份到新的数组中，每次数组容量的增长大约是其原容量的1.5倍。**这种操作的代价是很高的，因此在实际使用时，我们应该尽量避免数组容量的扩张。当我们可预知要保存的元素的多少时，要在构造ArrayList实例时，就指定其容量，以避免数组扩容的发生。或者根据实际需求，<strong>通过调用ensureCapacity方法来手动增加ArrayList实例的容量</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断初始化的elementData是不是空的数组，也就是没有长度</span></span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="comment">//因为如果是空的话，minCapacity=size+1；其实就是等于1，空的数组没有长度就存放不了</span></span><br><span class="line">        <span class="comment">//所以就将minCapacity变成10，也就是默认大小，但是在这里，还没有真正的初始化这个elementData的大小</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//确认实际的容量，上面只是将minCapacity=10，这个方法就是真正的判断elementData是否够用</span></span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//minCapacity如果大于了实际elementData的长度，那么就说明elementData数组的长度不够用</span></span><br><span class="line">    <span class="comment">/*第一种情况：由于elementData初始化时是空的数组，那么第一次add的时候，</span></span><br><span class="line"><span class="comment">    minCapacity=size+1；也就minCapacity=1，在上一个方法(确定内部容量ensureCapacityInternal)</span></span><br><span class="line"><span class="comment">    就会判断出是空的数组，就会给将minCapacity=10，到这一步为止，还没有改变elementData的大小。</span></span><br><span class="line"><span class="comment">    第二种情况：elementData不是空的数组了，那么在add的时候，minCapacity=size+1；也就是</span></span><br><span class="line"><span class="comment">    minCapacity代表着elementData中增加之后的实际数据个数，拿着它判断elementData的length</span></span><br><span class="line"><span class="comment">    是否够用，如果length不够用，那么肯定要扩大容量，不然增加的这个元素就会溢出。*/</span> </span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ArrayList核心的方法，能扩展数组大小的真正秘密。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将扩充前的elementData大小给oldCapacity</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">//newCapacity就是1.5倍的oldCapacity</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">/*这句话就是适应于elementData就空数组的时候，length=0，那么oldCapacity=0，newCapacity=0，</span></span><br><span class="line"><span class="comment">    所以这个判断成立，在这里就是真正的初始化elementData的大小了，就是为10.前面的工作都是准备工作。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="comment">//如果newCapacity超过了最大的容量限制，就调用hugeCapacity，也就是将能给的最大值给newCapacity</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">//新的容量大小已经确定好就copy数组，改变容量大小。</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用来赋最大值</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="comment">//如果minCapacity都大于MAX_ARRAY_SIZE，那么就Integer.MAX_VALUE返回，反之将MAX_ARRAY_SIZE返回。</span></span><br><span class="line">    <span class="comment">//相当于给ArrayList上了两层防护</span></span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-5-add-方法">3.5 add()方法</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加一个特定的元素到list的末尾。</span></span><br><span class="line"><span class="comment"> * 先size+1判断数组容量是否够用，最后加入元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts the specified element at the specified position in this</span></span><br><span class="line"><span class="comment"> * list. Shifts the element currently at that position (if any) and</span></span><br><span class="line"><span class="comment"> * any subsequent elements to the right (adds one to their indices).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index index at which the specified element is to be inserted</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element element to be inserted</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//检查index也就是插入的位置是否合理。</span></span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    <span class="comment">//检查容量是否够用，不够就自动扩容</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">//这个方法就是用来在插入元素之后，要将index之后的元素都往后移一位</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                     size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当调用add()方法时，实际函数调用：</p>
<p><strong>add→ensureCapacityInternal→ensureExplicitCapacity(→grow→hugeCapacity)</strong></p>
<p>例如刚开始初始化一个空数组后add一个值，会首先进行自动扩容<br>
<img src="https://img-blog.csdnimg.cn/ddc8a1b63e08439aa5b9e7703ec55287.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6a2FTGVtb24=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<h3 id="3-6-trimToSize">3.6 trimToSize()</h3>
<p>将底层数组的容量调整为当前列表保存的实际元素的大小的功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (size &lt; elementData.length) &#123;</span><br><span class="line">        elementData = (size == <span class="number">0</span>)</span><br><span class="line">          ? EMPTY_ELEMENTDATA</span><br><span class="line">          : Arrays.copyOf(elementData, size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-7-remove-方法">3.7 remove()方法</h3>
<p><code>remove()</code>方法也有两个版本，一个是<code>remove(int index)</code>删除指定位置的元素，另一个是<code>remove(Object o)</code>删除第一个满足<code>o.equals(elementData[index])</code>的元素。删除操作是<code>add()</code>操作的逆过程，需要将删除点之后的元素向前移动一个位置。需要注意的是为了让GC起作用，必须显式的为最后一个位置赋<code>null</code>值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] = <span class="keyword">null</span>; <span class="comment">//清除该位置的引用，让GC起作用</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-8-其他方法">3.8 其他方法</h3>
<p>这里简单介绍了核心方法，其他方法查看源码可以很快了解</p>
<h3 id="3-9-Fail-Fast机制">3.9 Fail-Fast机制</h3>
<p>ArrayList采用了快速失败的机制，通过记录<code>modCount</code>参数来实现。在面对并发的修改时，迭代器很快就会完全失败，并抛出<code>ConcurrentModificationException</code>异常，而不是冒着在将来某个不确定时间发生任意不确定行为的风险</p>
<h2 id="4、总结">4、总结</h2>
<ul>
<li>ArrayList可以存放null</li>
<li>ArrayList本质上就是一个elementData数组</li>
<li>ArrayList区别于数组的地方在于能够自动扩展大小，其中关键的方法就是gorw()方法</li>
<li>ArrayList中removeAll(collection c)和clear()的区别就是removeAll可以删除批量指定的元素，而clear是全是删除集合中的元素</li>
<li>ArrayList由于本质是数组，所以它在数据的查询方面会很快，而在插入删除这些方面，性能下降很多，有移动很多数据才能达到应有的效果</li>
<li>ArrayList实现了RandomAccess，所以在遍历它的时候推荐使用for循环</li>
</ul>
<h1>三、LinkedList分析</h1>
<h2 id="1、LinkedList使用">1、LinkedList使用</h2>
<table>
<thead>
<tr>
<th><strong>方法名</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>void addFirst(Object o)</td>
<td>在列表的首部添加元素</td>
</tr>
<tr>
<td>void addLast(Object o)</td>
<td>在列表的未尾添加元素</td>
</tr>
<tr>
<td>Object getFirst()</td>
<td>返回列表中的第一个元素</td>
</tr>
<tr>
<td>Object getLast()</td>
<td>返回列表中的最后一个元素</td>
</tr>
<tr>
<td>Object removeFirst()</td>
<td>删除并返回列表中的第一个元素</td>
</tr>
<tr>
<td>Object removeLast()</td>
<td>删除并返回列表中的最后一个元素</td>
</tr>
</tbody>
</table>
<h2 id="2、LinkedList介绍">2、LinkedList介绍</h2>
<p><code>LinkedList</code>同时实现了List接口和Deque接口，也就是说它既可以看作一个顺序容器，又可以看作一个队列(Queue)，同时又可以看作一个栈(Stack)。这样看来，LinkedList简直就是个全能冠军。当你需要使用栈或者队列时，可以考虑使用<code>LinkedList</code>，一方面是因为Java官方已经声明不建议使用Stack类，更遗憾的是，Java里根本没有一个叫做Queue_的类(它是个接口名字)。关于栈或队列，现在的首选是<code>ArrayDeque</code>，它有着比<code>LinkedList</code>(当作栈或队列使用时)有着更好的性能。</p>
<p>LinkedList的实现方式决定了所有跟下标相关的操作都是线性时间，而在首段或者末尾删除元素只需要常数时间。为追求效率LinkedList没有实现同步(synchronized)，如果需要多个线程并发访问，可以先采用<code>Collections.synchronizedList()</code>方法对其进行包装</p>
<h2 id="3、源码分析-v2">3、源码分析</h2>
<h3 id="3-1-继承结构与层次">3.1 继承结构与层次</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/c7737a6ae175461ab1369a5ae54f5796.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6a2FTGVtb24=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>
<img src="https://img-blog.csdnimg.cn/b200fe62d3f34c1091d7cceb848e674e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6a2FTGVtb24=,size_18,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<p>这里可以发现LinkedList多了一层<code>AbstractSequentialList</code>的抽象类，这是为了减少实现顺序存取（例如LinkedList）这种类的工作。如果自己想实现顺序存取这种特性的类(就是链表形式)，那么就继承 这个AbstractSequentialList抽象类，如果想像数组那样的随机存取的类，那么就去实现AbstracList抽象类。</p>
<ul>
<li><strong>List接口</strong><br>
列表add、set等一些对列表进行操作的方法</li>
<li><strong>Deque接口</strong><br>
有队列的各种特性</li>
<li><strong>Cloneable接口</strong><br>
能够复制，使用那个copy方法</li>
<li><strong>Serializable接口</strong><br>
能够序列化。</li>
<li><strong>没有RandomAccess</strong><br>
推荐使用iterator，在其中就有一个foreach，增强的for循环，其中原理也就是iterator，我们在使用的时候，使用foreach或者iterator</li>
</ul>
<h3 id="3-2-属性与构造方法">3.2 属性与构造方法</h3>
<p>transient关键字修饰，这也意味着在序列化时该域是不会序列化的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实际元素个数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//头结点</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"><span class="comment">//尾结点</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    <span class="comment">//将集合c中的各个元素构建成LinkedList链表</span></span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-内部类Node✨">3.3 内部类Node✨</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据前面介绍双向链表就知道这个代表什么了，linkedList的奥秘就在这里</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 数据域（当前节点的值）</span></span><br><span class="line">    E item;</span><br><span class="line">    <span class="comment">//后继</span></span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    <span class="comment">//前驱</span></span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line">    <span class="comment">// 构造函数，赋值前驱后继</span></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-4-核心方法add-和addAll-✨">3.4 核心方法add()和addAll()✨</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//临时节点l(L的小写)保存last，也就是l指向了最后一个节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="comment">//将e封装为节点，并且e.prev指向了最后一个节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//newNode成为了最后一个节点，所以last指向了它</span></span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//判断是不是一开始链表中就什么都没有，如果没有，则new Node就成为了第一个结点，first和last都指向它</span></span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//正常的在最后一个节点后追加，那么原先的最后一个节点的next就要指向现在真正的 最后一个节点，原先的最后一个节点就变成了倒数第二个节点</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    <span class="comment">//添加一个节点，size自增</span></span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>addAll()</code>有两个重载函数，<code>addAll(Collection&lt;? extends E&gt;)</code>型和<code>addAll(int,Collection&lt;? extends E&gt;)</code>型，我们平时习惯调用的<code>addAll(Collection&lt;?extends E&gt;)</code>型会转化为<code>addAll(int,Collection&lt;? extends&lt;E&gt;)</code>型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> addAll(size, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//检查index这个是否为合理</span></span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line">    <span class="comment">//将集合c转换为Object数组</span></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="comment">//数组a的长度numNew，也就是由多少个元素</span></span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    <span class="keyword">if</span> (numNew == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//如果空的就什么也不做</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    Node&lt;E&gt; pred, succ;</span><br><span class="line">    <span class="comment">//构造方法中传过来的就是index==size</span></span><br><span class="line">    <span class="comment">//情况一：构造方法创建的一个空的链表，那么size=0，last、和first都为null。linkedList中是空的。</span></span><br><span class="line">    <span class="comment">//什么节点都没有。succ=null、pred=last=null</span></span><br><span class="line">    <span class="comment">//情况二：链表中有节点，size就不是为0，first和last都分别指向第一个节点，和最后一个节点，</span></span><br><span class="line">    <span class="comment">//在最后一个节点之后追加元素，就得记录一下最后一个节点是什么，所以把last保存到pred临时节点中。</span></span><br><span class="line">    <span class="comment">//情况三index！=size，说明不是前面两种情况，而是在链表中间插入元素，那么就得知道index上的节点是谁，</span></span><br><span class="line">    <span class="comment">//保存到succ临时节点中，然后将succ的前一个节点保存到pred中，这样保存了这两个节点，就能够准确的插入节点了</span></span><br><span class="line">    <span class="keyword">if</span> (index == size) &#123;</span><br><span class="line">        succ = <span class="keyword">null</span>;</span><br><span class="line">        pred = last;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        succ = node(index);</span><br><span class="line">        pred = succ.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Object o : a) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) E e = (E) o;</span><br><span class="line">        Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pred.next = newNode;</span><br><span class="line">        pred = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (succ == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">/*如果succ==null，说明是情况一或者情况二，</span></span><br><span class="line"><span class="comment">        情况一、构造方法，也就是刚创建的一个空链表，pred已经是newNode了，</span></span><br><span class="line"><span class="comment">        last=newNode，所以linkedList的first、last都指向第一个节点。</span></span><br><span class="line"><span class="comment">        情况二、在最后节后之后追加节点，那么原先的last就应该指向现在的最后一个节点了，</span></span><br><span class="line"><span class="comment">        就是newNode。*/</span></span><br><span class="line">        last = pred;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pred.next = succ;</span><br><span class="line">        succ.prev = pred;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size += numNew;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据引下标找到该结点并返回</span></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断插入的位置在链表前半段或者是后半段</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="comment">//从头结点开始正向遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="comment">//从尾结点开始反向遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-5-remove">3.5 remove()</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*如果我们要移除的值在链表中存在多个一样的值，那么我们</span></span><br><span class="line"><span class="comment">会移除index最小的那个，也就是最先找到的那个值，如果不存在这个值，那么什么也不做</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">////不能传一个null值</span></span><br><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert x != null;</span></span><br><span class="line">    <span class="keyword">final</span> E element = x.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev.next = next;</span><br><span class="line">        x.prev = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next.prev = prev;</span><br><span class="line">        x.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//x的前后指向都为null了，也把item为null，让gc回收它</span></span><br><span class="line">    x.item = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-6-其他方法">3.6 其他方法</h3>
<p>**get(index)、indexOf(Object o)**等查看源码即可</p>
<h3 id="3-7-LinkedList的迭代器">3.7 <strong>LinkedList的迭代器</strong></h3>
<p>在LinkedList中除了有一个Node的内部类外，应该还能看到另外两个内部类，那就是<code>ListItr</code>，还有一个是<code>DescendingIterator</code>内部类</p>
<p><img src="https://img-blog.csdnimg.cn/3d4c8f02fddf41688e60258f73d4632c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6a2FTGVtb24=,size_19,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*这个类，还是调用的ListItr，作用是封装一下Itr中几个方法，让使用者以正常的思维去写代码，</span></span><br><span class="line"><span class="comment">例如，在从后往前遍历的时候，也是跟从前往后遍历一样，使用next等操作，而不用使用特殊的previous。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">DescendingIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ListItr itr = <span class="keyword">new</span> ListItr(size());</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> itr.hasPrevious();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> itr.previous();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        itr.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4、总结-v2">4、总结</h2>
<ul>
<li>linkedList本质上是一个双向链表，通过一个Node内部类实现的这种链表结构。linkedList能存储null值</li>
<li>跟ArrayList相比较，就真正的知道了，LinkedList在删除和增加等操作上性能好，而ArrayList在查询的性能上好，从源码中看，它不存在容量不足的情况</li>
<li>linkedList不光能够向前迭代，还能像后迭代，并且在迭代的过程中，可以修改值、添加值、还能移除值</li>
<li>linkedList不光能当链表，还能当队列使用，这个就是因为实现了Deque接口</li>
</ul>
<h1>四、List总结</h1>
<h2 id="1、ArrayList和LinkedList区别">1、ArrayList和LinkedList区别</h2>
<ul>
<li>ArrayList底层是用数组实现的顺序表，是随机存取类型，可自动扩增，并且在初始化时，数组的长度是0，只有在增加元素时，长度才会增加。默认是10，不能无限扩增，有上限，在查询操作的时候性能更好</li>
<li>LinkedList底层是用链表来实现的，是一个双向链表，注意这里不是双向循环链表,顺序存取类型。在源码中，似乎没有元素个数的限制。应该能无限增加下去，直到内存满了在进行删除，增加操作时性能更好。</li>
</ul>
<p>两个都是线程不安全的，在iterator时，会发生<strong>fail-fast：快速失效</strong>。</p>
<h2 id="2、ArrayList和Vector区别">2、ArrayList和Vector区别</h2>
<ul>
<li>ArrayList线程不安全，在用iterator，会发生fail-fast</li>
<li>Vector线程安全，因为在方法前加了Synchronized关键字，也会发生fail-fast</li>
</ul>
<h2 id="3、fail-fast和fail-safe区别与情况说明">3、fail-fast和fail-safe区别与情况说明</h2>
<blockquote>
<p>在java.util下的集合都是发生fail-fast，而在java.util.concurrent下的发生的都是fail-safe</p>
</blockquote>
<ul>
<li><strong>fail-fast</strong><br>
快速失败，例如在arrayList中使用迭代器遍历时，有另外的线程对arrayList的存储数组进行了改变，比 如add、delete等使之发生了结构上的改变，所以Iterator就会快速报一个<code>java.util.ConcurrentModiﬁcationException</code>异常（并发修改异常），这就是快速失败</li>
<li><strong>fail-safe</strong><br>
安全失败，在<code>java.util.concurrent</code>下的类，都是线程安全的类，他们在迭代的过程中，如果有线程进行结构的改变，不会报异常，而是正常遍历，这就是安全失败</li>
<li><strong>为什么在java.util.concurrent包下对集合有结构的改变却不会报异常？</strong><br>
在concurrent下的集合类增加元素的时候使用<code>Arrays.copyOf()</code>来拷贝副本，在副本上增加元素，如果有其他线程在此改变了集合的结构，那也是在副本上的改变，而不是影响到原集合，迭代器还是照常遍历，遍历完之后，改变原引用指向副本，所以总的一句话就是如果在此包下的类进行增加删除，就会出现一个副本。所以能防止fail-fast，这种机制并不会出错，所以我们叫这种现象为fail-safe</li>
<li><strong>vector也是线程安全的，为什么是fail-fast呢？</strong><br>
出现fail-safe是因为他们在实现增删的底层机制不一样，就像上面说的，会有一个副本，而像arrayList、linekdList、verctor等他们底层就是对着真正的引用进行操作，所以才会发生异常</li>
</ul>
<h2 id="4、为什么现在都不提倡使用Vector">4、为什么现在都不提倡使用Vector</h2>
<ul>
<li>vector实现线程安全的方法是在每个操作方法上加锁，这些锁并不是必须要的，在实际开发中，一般都是通过锁一系列的操作来实现线程安全，也就是说将需要同步的资源放一起加锁来保证线程安全</li>
<li>如果多个Thread并发执行一个已经加锁的方法，但是在该方法中，又有Vector的存在，Vector<br>
本身实现中已经加锁了，那么相当于锁上又加锁，会造成额外的开销</li>
<li>Vector还有fail-fast的问题，也就是说它也无法保证遍历安全，在 遍历时又得额外加锁，又是额外的开销，还不如直接用arrayList，然后再加锁</li>
</ul>
<p>总结：Vector在你不需要进行线程安全的时候，也会给你加锁，也就导致了额外开销，所以在jdk1.5之后就被弃用了，现在如果要用到线程安全的集合，都是从<code>java.util.concurrent</code>包下去拿相应的类。</p>
<h1>五、HashMap分析</h1>
<h2 id="1、HashMap介绍">1、HashMap介绍</h2>
<h3 id="1-1-Java8以前的HashMap">1.1 Java8以前的HashMap</h3>
<blockquote>
<p>通过key、value封装成一个entry对象，然后通过key的值来计算该entry的hash值，通过entry的hash 值和数组的长度length来计算出entry放在数组中的哪个位置上面，每次存放都是将entry放在第一个位置。</p>
</blockquote>
<p>HashMap实现了Map接口，即允许放入<code>key</code>为<code>null</code>的元素，也允许插入<code>value</code>为<code>null</code>的元素；除该类未实现同步外，其余跟<code>Hashtable</code>大致相同；跟TreeMap不同，该容器不保证元素顺序，根据需要该容器可能会对元素重新哈希，元素的顺序也会被重新打散，因此不同时间迭代同一个HashMap的顺序可能会不同。 根据对冲突的处理方式不同，哈希表有两种实现方式，一种开放地址方式(Open addressing)，另一种是冲突链表方式(Separate chaining with linked lists)。<strong>Java7 HashMap采用的是冲突链表方式</strong>。</p>
<p><img src="https://img-blog.csdnimg.cn/4e37614a989b4425afc5aa0929257903.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6a2FTGVtb24=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<h3 id="1-2-Java8后的HashMap">1.2 Java8后的HashMap</h3>
<p>Java8 对 HashMap 进行了一些修改，最大的不同就是利用了红黑树，所以其由 <strong>数组+链表+红黑树</strong> 组成。根据 <strong>Java7 HashMap</strong> 的介绍，我们知道，查找的时候，根据 hash 值我们能够快速定位到数组的具体下标，但是之后的话，需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决于链表的长度为 O(n)。为了降低这部分的开销，在 <strong>Java8</strong> 中，当链表中的元素达到了 8 个时，会将链表转换为<strong>红黑树</strong>，在这些位置进行查找的时候可以降低时间复杂度为 <strong>O(logN)</strong>。<br>
<img src="https://img-blog.csdnimg.cn/158044daf3244036b2714ff9f72fe4e9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6a2FTGVtb24=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<p>Java7 中使用 Entry 来代表每个 HashMap 中的数据节点，Java8 中使用 Node，基本没有区别，都是 key，value，hash 和 next 这四个属性，不过，Node 只能用于链表的情况，红黑树的情况需要使用 TreeNode</p>
<h2 id="2、Java8-HashMap源码分析">2、Java8 HashMap源码分析</h2>
<h3 id="2-1-继承结构与层次">2.1 继承结构与层次</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/a527533fb7d14a3cbabca86c8c64c6ce.png#pic_center" alt="在这里插入图片描述"></p>
<h3 id="2-2-属性">2.2 属性</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//序列号</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">362498820763181265L</span>;</span><br><span class="line"><span class="comment">//默认的初始容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"><span class="comment">//最大容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">//默认加载因子</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">//当桶(bucket)上的结点数大于这个值时会转成红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="comment">//当桶(bucket)上的结点数小于这个值时树转链表</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"><span class="comment">//桶中结构转化为红黑树对应的table的最小大小</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"><span class="comment">//存储元素的数组，总是2的幂次倍</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="comment">//存放具体元素的集</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"><span class="comment">//存放元素的个数，注意这个不等于数组的长度</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="comment">//每次扩容和更改map结构的计数器</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"><span class="comment">//临界值，当实际大小(容量*填充因子)超过临界值时，会进行扩容</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"><span class="comment">//填充因子,计算HashMap的实时装载因子的方法为：size/capacity</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-构造方法">2.3 构造方法</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始容量不能小于0，否则报错</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="comment">// 初始容量不能大于最大值，否则为最大值</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="comment">//填充因子不能小于或等于0，不能为非数字</span></span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">         loadFactor);</span><br><span class="line">    <span class="comment">//初始化填充因子                                       </span></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="comment">//初始化threshold大小</span></span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个方法将传进来的参数转变为2的n次方的数值</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义初始容量，加载因子为默认</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用默认的加载因子等字段</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化填充因子</span></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    <span class="comment">//将m中的所有元素添加至HashMap中</span></span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将m的所有元素存入该实例</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = m.size();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//判断table是否已经初始化</span></span><br><span class="line">        <span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">            <span class="comment">//未初始化，s为m的实际元素个数</span></span><br><span class="line">            <span class="keyword">float</span> ft = ((<span class="keyword">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">            <span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                     (<span class="keyword">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="comment">//计算得到的t大于阈值，则初始化阈值</span></span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="comment">//将m中的所有元素添加至HashMap中</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">            K key = e.getKey();</span><br><span class="line">            V value = e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-核心方法✨">2.4 核心方法✨</h3>
<p><strong>put()方法</strong></p>
<p>先计算key的hash值，然后根据hash值搜索在table数组中的索引位置，如果table数组在该位置处有元素，则查找是否存在相同的key，若存在则覆盖原来key的value，否则将该元素保存在链表尾部，注意JDK1.7中采用的是头插法，即每次都将冲突的键值对放置在链表头，这样最初的那个键值对最终就会成为链尾，而JDK1.8中使用的是尾插法。此外，若table在该处没有元素，则直接保存。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">//第一次put元素时，table数组为空，先调用resize生成一个指定容量的数组</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">//hash值和n-1的与运算结果为桶的位置，如果该位置空就直接放置一个Node</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//如果计算出的bucket不空，即发生哈希冲突，就要进一步判断</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">//判断当前Node的key与要put的key是否相等</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">//判断当前Node是否是红黑树的节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">//以上都不是，说明要new一个Node，加入到链表中</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">              <span class="comment">//在链表尾部插入新节点，注意jdk1.8是在链表尾部插入新节点</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 如果当前链表中的元素大于树化的阈值，进行链表转树的操作</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//在链表中继续判断是否已经存在完全相同的key</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//走到这里，说明本次put是更新一个已存在的键值对的value</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">//在hashMap中，afterNodeAccess方法体为空，交给子类去实现</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">//如果当前size超过临界值，就扩容。注意是先插入节点再扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">//在hashMap中，afterNodeInsertion方法体为空，交给子类去实现</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>resize() 数组扩容</strong></p>
<p>用于初始化数组或数组扩容，每次扩容后，容量为原来的 2 倍，并进行数据迁移</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123; <span class="comment">// 对应数组扩容</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将数组大小扩大一倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="comment">// 将阈值扩大一倍</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// 对应使用 new HashMap(int initialCapacity) 初始化后，第一次 put 的时候</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">// 对应使用 new HashMap() 初始化后，第一次 put 的时候</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用新的数组大小初始化新的数组</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab; <span class="comment">// 如果是初始化数组，到这里就结束了，返回 newTab 即可</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 开始遍历原数组，进行数据迁移。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 如果该数组位置上只有单个元素，那就简单了，简单迁移这个元素就可以了</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">// 如果是红黑树，具体我们就不展开了</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; </span><br><span class="line">                    <span class="comment">// 这块是处理链表的情况，</span></span><br><span class="line">                    <span class="comment">// 需要将此链表拆成两个链表，放到新的数组中，并且保留原来的先后顺序</span></span><br><span class="line">                    <span class="comment">// loHead、loTail 对应一条链表，hiHead、hiTail 对应另一条链表，代码还是比较简单的</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="comment">// 第一条链表</span></span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="comment">// 第二条链表的新的位置是 j + oldCap，这个很好理解</span></span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>get()过程</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断第一个节点是不是就是需要的</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断是否是红黑树</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 链表遍历</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-5-其他方法">2.5 其他方法</h3>
<p>HashSet是对HashMap的简单包装，其他还有迭代器等</p>
<h2 id="3、总结">3、总结</h2>
<p>关于数组扩容，从putVal源代码中我们可以知道，当插入一个元素的时候size就加1，若size大于threshold的时候，就会进行扩容。假设我们的capacity大小为32，loadFator为0.75，则threshold为24 = 32 * 0.75，此时，插入了25个元素，并且插入的这25个元素都在同一个桶中，桶中的数据结构为红黑树，则还有31个桶是空的，也会进行扩容处理，其实此时，还有31个桶是空的，好像似乎不需要进行扩容处理，但是是需要扩容处理的，因为此时我们的capacity大小可能不适当。我们前面知道，扩容处理会遍历所有的元素，时间复杂度很高；前面我们还知道，经过一次扩容处理后，元素会更加均匀的分布在各个桶中，会提升访问效率。所以说尽量避免进行扩容处理，也就意味着，遍历元素所带来的坏处大于元素在桶中均匀分布所带来的好处。</p>
<ul>
<li>HashMap在JDK1.8以前是一个链表散列这样一个数据结构，而在JDK1.8以后是一个数组加链表加红黑树的数据结构</li>
<li>通过源码的学习，HashMap是一个能快速通过key获取到value值得一个集合，原因是内部使用的是hash查找值得方法</li>
</ul>
<p>另外LinkedHashMap是HashMap的直接子类，<strong>二者唯一的区别是LinkedHashMap在HashMap的基础上，采用双向链表(doubly-linked list)的形式将所有</strong><code>**entry**</code><strong>连接起来，这样是为保证元素的迭代顺序跟插入顺序相同</strong></p>
<h1>六、Collections工具类</h1>
<h2 id="1、概述">1、概述</h2>
<p>此类完全由在 collection 上进行操作或返回 collection 的静态方法组成。它包含在 collection 上操作的多态算法，即“包装器”，包装器返回由指定 collection 支持的新 collection，以及少数其他内容。如果为此类的方法所提供的 collection 或类对象为 null，则这些方法都将抛出<code>NullPointerException</code></p>
<h2 id="2、排序常用方法">2、排序常用方法</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//反转列表中元素的顺序</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(List&lt;?&gt; list)</span></span></span><br><span class="line"><span class="function"><span class="comment">//对List集合元素进行随机排序</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(List&lt;?&gt; list)</span></span></span><br><span class="line"><span class="function"><span class="comment">//根据元素的自然顺序 对指定列表按升序进行排序</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; list)</span></span></span><br><span class="line"><span class="function"><span class="comment">//根据指定比较器产生的顺序对指定列表进行排序</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; list, Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span></span></span><br><span class="line"><span class="function"><span class="comment">//在指定List的指定位置i,j处交换元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(List&lt;?&gt; list, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"><span class="comment">//当distance为正数时，将List集合的后distance个元素“整体”移到前面；当distance为负数时，将list集合的前distance个元素“整体”移到后边。该方法不会改变集合的长度</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(List&lt;?&gt; list, <span class="keyword">int</span> distance)</span></span></span><br></pre></td></tr></table></figure>
<h2 id="3、查找、替换操作">3、查找、替换操作</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用二分搜索法搜索指定列表，以获得指定对象在List集合中的索引</span></span><br><span class="line"><span class="comment">//注意：此前必须保证List集合中的元素已经处于有序状态</span></span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(List&lt;? extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt;list, T key)</span></span></span><br><span class="line"><span class="function"><span class="comment">//根据元素的自然顺序，返回给定collection 的最大元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Object <span class="title">max</span><span class="params">(Collection coll)</span></span></span><br><span class="line"><span class="function"><span class="comment">//根据指定比较器产生的顺序，返回给定 collection 的最大元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Object <span class="title">max</span><span class="params">(Collection coll,Comparator comp)</span>:</span></span><br><span class="line"><span class="function"><span class="comment">//根据元素的自然顺序，返回给定collection 的最小元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Object <span class="title">min</span><span class="params">(Collection coll)</span>:</span></span><br><span class="line"><span class="function"><span class="comment">//根据指定比较器产生的顺序，返回给定 collection 的最小元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Object <span class="title">min</span><span class="params">(Collection coll,Comparator comp)</span>:</span></span><br><span class="line"><span class="function"><span class="comment">//使用指定元素替换指定列表中的所有元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title">fill</span><span class="params">(List&lt;? <span class="keyword">super</span> T&gt; list,T obj)</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回指定co1lection中等于指定对象的出现次数</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">frequency</span><span class="params">(collection&lt;?&gt;c,object o)</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回指定源列表中第一次出现指定目标列表的起始位置；如果没有出现这样的列表，则返回-1</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexofsubList</span><span class="params">(List&lt;?&gt;source, List&lt;?&gt;target)</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回指定源列表中最后一次出现指定目标列表的起始位置；如果没有出现这样的列表，则返回-1</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lastIndexofsubList</span><span class="params">(List&lt;?&gt;source,List&lt;?&gt;target)</span></span></span><br><span class="line"><span class="function"><span class="comment">//使用一个新值替换List对象的所有旧值o1dval</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;T&gt; <span class="keyword">boolean</span> <span class="title">replaceA1l</span><span class="params">(list&lt;T&gt; list,T oldval,T newval)</span></span></span><br></pre></td></tr></table></figure>
<h2 id="4、同步控制">4、同步控制</h2>
<p>Collectons提供了多个synchronizedXxx()方法，该方法可以将指定集合包装成线程同步的集合，从而解决多线程并发访问集合时的线程安全问题。正如前面介绍的HashSet，TreeSet，arrayList，LinkedList，HashMap，TreeMap都是线程不安全的。Collections提供了多个静态方法可以把他们包装成线程同步的集合。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回指定 Collection 支持的同步（线程安全的）collection</span></span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">Collection&lt;T&gt; <span class="title">synchronizedCollection</span><span class="params">(Collection&lt;T&gt; c)</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回指定列表支持的同步（线程安全的）列表</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title">synchronizedList</span><span class="params">(List&lt;T&gt; list)</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回由指定映射支持的同步（线程安全的）映射</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;K,V&gt; Map&lt;K,V&gt; <span class="title">synchronizedMap</span><span class="params">(Map&lt;K,V&gt; m)</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回指定 set 支持的同步（线程安全的）set</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;T&gt; Set&lt;T&gt; <span class="title">synchronizedSet</span><span class="params">(Set&lt;T&gt; s)</span></span></span><br></pre></td></tr></table></figure>
<h2 id="5、Collection设置不可变集合">5、Collection设置不可变集合</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回一个空的、不可变的集合对象，此处的集合既可以是List，也可以是Set，还可以是Map。</span></span><br><span class="line">emptyXxx()</span><br><span class="line"><span class="comment">//返回一个只包含指定对象（只有一个或一个元素）的不可变的集合对象，此处的集合可以是：List，Set，Map。</span></span><br><span class="line">singletonXxx():</span><br><span class="line"><span class="comment">//返回指定集合对象的不可变视图，此处的集合可以是：List，Set，Map</span></span><br><span class="line">unmodifiableXxx()</span><br></pre></td></tr></table></figure>
<hr>
<p>参考问题</p>
<p><a href="https://pdai.tech/md/java/collection/java-collection-all.html" target="_blank" rel="noopener">https://pdai.tech/md/java/collection/java-collection-all.html</a></p>
<p><a href="https://blog.csdn.net/fuzhongmin05/article/details/104355841" target="_blank" rel="noopener">https://blog.csdn.net/fuzhongmin05/article/details/104355841</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java IO流</title>
    <url>/posts/59ae8782.html</url>
    <content><![CDATA[<h1>一、Java IO流基础</h1>
<h2 id="1、流式输入-输出原理">1、流式输入/输出原理</h2>
<p>在java程序中，对于数据的输入/输出操作以&quot;流&quot;（stream）方式进行；J2SDK提供了各种各样的&quot;流&quot;类，用以获取不同种类的数据：程序中通过标准的方法输入或输出数据</p>
<p><img src="https://img-blog.csdnimg.cn/c192f69684c0424685408c7c267311bc.png?type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6a2FTGVtb24=,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<a id="more"></a>
<h2 id="2、输入流-输出流">2、输入流/输出流</h2>
<p><img src="https://img-blog.csdnimg.cn/c7beb57475c14405a7c6571a1a5dc416.png?type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6a2FTGVtb24=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<h2 id="3、节点流-处理流">3、节点流/处理流</h2>
<p><img src="https://img-blog.csdnimg.cn/a65bdfaded0d4e20b87eb1f02b0d3b7b.png?type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6a2FTGVtb24=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<h3 id="3-1-节点流">3.1 节点流</h3>
<p>节点流就是一根管道直接插到数据源上面，直接读数据源里面的数据，或者是直接往数据源里面写入数据。典型的节点流是文件流：文件的字节输入流（<code>FileInputStream</code>），文件的字节输出流（<code>FileOutputStream</code>），文件的字符输入流（<code>FileReader</code>），文件的字符输出流（<code>FileWriter</code>）</p>
<p><img src="https://img-blog.csdnimg.cn/f1082502ed5a4c6d8750ea71d32e0e63.png?type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6a2FTGVtb24=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<h3 id="3-2-处理流">3.2 处理流</h3>
<p>处理流是对一个已存在的流的连接和封装，通过所封装的流的功能调用实现数据读写。<br>
如<code>BufferedInputStream、BufferedOutputStream、BufferedReader、BufferedWriter</code>；处理流的构造方法总是要带一个其他的流对象做参数，一个流对象经过其他流的多次包装，称为流的链接</p>
<p><img src="https://img-blog.csdnimg.cn/30d1990717be48528078e3dd6707f78e.png?type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6a2FTGVtb24=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<h1>二、节点流讲解</h1>
<h2 id="1、InputStream-输入流">1、InputStream(输入流)</h2>
<p><img src="https://img-blog.csdnimg.cn/0eb61b98a0d44dacba2a3e54abf4b2c9.png?type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6a2FTGVtb24=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读取一个字节并以整数的形式返回（0~255）</span></span><br><span class="line"><span class="comment">//如果返回-1就说明已经到了输入流的末尾</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="comment">//读取一系列字节并存储到一个数组buffer</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回实际读取的字节数，如果读取前己到输入流的末尾，则返回-1</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] buffer)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="comment">//读取1ength个字节</span></span></span><br><span class="line"><span class="function"><span class="comment">//并存储到一个字节数组buffer，从1ength位置开始</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回实际读取的字节数，如果读取前以到输入流的末尾返回-1.</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[]buffer, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="comment">//关闭流释放内存资源</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="comment">//跳过n个字节不读，返回实际跳过的字节数</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">skip</span><span class="params">(<span class="keyword">long</span> n)</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure>
<h2 id="2、OutputStream-输出流">2、OutputStream(输出流)</h2>
<p><img src="https://img-blog.csdnimg.cn/f9ef50b335f94a0da3923c7fe6a62354.png?type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6a2FTGVtb24=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//向输出流中写入一个字节数据，该字节数据为参数b的低8位</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> b)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="comment">//将一个字节类型的数组中的数据写入输出流</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] b)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="comment">//将一个字节类型的数组中的从指定位置(off）开始的1en个字节写入到输出流</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="comment">//关闭流释放内存资源</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="comment">//将输出流中缓冲的数据全部写出到目的地</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：FilelnputStream和FileOutputStream这两个流都是字节流，都是以一个字节为单位进行输入和输出的。所以对于占用2个字节存储空间的字符来说读取出来时就会显示成乱码</p>
</blockquote>
<h2 id="3、Reader流">3、Reader流</h2>
<p><img src="https://img-blog.csdnimg.cn/d8b880f989f4402a88330070e2d84a33.png?type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6a2FTGVtb24=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读取一个字节并以整数的形式返回（0~255）</span></span><br><span class="line"><span class="comment">//如果返回-1就说明已经到了输入流的末尾</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="comment">//读取一系列字节并存储到一个数组buffer</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回实际读取的字节数，如果读取前己到输入流的末尾，则返回-1</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] buffer)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="comment">//读取1ength个字节</span></span></span><br><span class="line"><span class="function"><span class="comment">//并存储到一个字节数组buffer，从1ength位置开始</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回实际读取的字节数，如果读取前以到输入流的末尾返回-1.</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[]buffer, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="comment">//关闭流释放内存资源</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="comment">//跳过n个字节不读，返回实际跳过的字节数</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">skip</span><span class="params">(<span class="keyword">long</span> n)</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure>
<h2 id="4、Writer流">4、Writer流</h2>
<p><img src="https://img-blog.csdnimg.cn/b974369c94084ae9a7b0c5009d0cf52a.png?type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6a2FTGVtb24=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//向输出流中写入一个字节数据，该字节数据为参数b的低8位</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> b)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="comment">//将一个字节类型的数组中的数据写入输出流</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] b)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="comment">//将一个字节类型的数组中的从指定位置(off）开始的1en个字节写入到输出流</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="comment">//关闭流释放内存资源</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="comment">//将输出流中缓冲的数据全部写出到目的地</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：FileReader和FileWriter这两个流都是字符流，都是以一个字符为单位进行输入和输出的，所以读取和写入占用2个字节的字符时都可以正常地显示出来</p>
</blockquote>
<h1>三、 处理流讲解</h1>
<h2 id="1、缓冲流-Buffering">1、<strong>缓冲流(Buffering)</strong></h2>
<p>缓冲流要“套接在相应的节点流之上，对读写的数据提供了缓冲的功能，提高了读写的效率，同时增加了一些新的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BufferedReader(Reader in)</span><br><span class="line">BufferedReader(Reader in, <span class="keyword">int</span> sz)<span class="comment">//sz为自定义缓冲区的大小Bufferedwriter（writer out）</span></span><br><span class="line">Bufferedwriter(Writer out, <span class="keyword">int</span> sz)</span><br><span class="line">BufferedInputstream(Inputstream in)</span><br><span class="line">BufferedInputstream(Inputstream in, <span class="keyword">int</span> size)</span><br><span class="line">Bufferedoutputstream(Inputstream in)</span><br><span class="line">Bufferedoutputstream(Inputstream in <span class="keyword">int</span> size)</span><br></pre></td></tr></table></figure>
<ul>
<li>缓冲输入流支持其父类的mark和reset方法</li>
<li>BufferedReader提供了readLine方法用于读取一行字符串</li>
<li>BufferedWriter提供了newLine用于写入一个行分隔符</li>
<li>对于输出的缓冲流，写出的数据会现在内存中缓存，使用flush方法将会使内存中的数据立刻写出</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/2840760fb0924dad954001b3bd004ab6.png?type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6a2FTGVtb24=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<h2 id="2、转换流">2、转换流</h2>
<ul>
<li>InputstreamReader 和OutputStreamwriter 用于字节数据到字符数据之间的转换</li>
<li>InputstreamReader 需要和Inputstream“套接&quot;。</li>
<li>OutputstreamWriter 需要和Outputstream“套接&quot;。</li>
<li>转换流在构造时可以指定其编码集合</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Inputstream isr=<span class="keyword">new</span> InputstreamReader(System.in, <span class="string">"ISO8859-1"</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/ed33ddf4f3114a918c3fd4e21b73bc1c.png?type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6a2FTGVtb24=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<h2 id="3、数据流">3、数据流</h2>
<ul>
<li>DatalnputStream 和DataOutputStream 分别继承自InputStream和 OutputStream，它属于处理流，需要分别“套接&quot;在Inputstream和OutputStream类型的节点流上</li>
<li>Datalnputstream 和DataOutputStream 提供了可以存取与机器无关的Java原始类型数据（int，double等）的方法</li>
<li>DatalnputStream 和DataOutputStream的构造方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DataInputstream(InputStream in)</span><br><span class="line">DataoutputStream(OutputStream out)</span><br></pre></td></tr></table></figure>
<p>举例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">    ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">    <span class="comment">//在调用构造方法时，首先会在内存里面创建一个ByteArray字节数组</span></span><br><span class="line">    DataOutputStream dos = <span class="keyword">new</span> DataOutputStream(baos);</span><br><span class="line">    <span class="comment">//在输出流的外面套上一层数据流，用来处理int，double类型的数</span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        dos.writeDouble(Math.random());<span class="comment">//把产生的随机数直接写入到字节数组ByteArray中</span></span><br><span class="line">        dos.writeBoolean(<span class="keyword">true</span>);<span class="comment">//布尔类型的数据在内存中就只占一个字节</span></span><br><span class="line">        ByteArrayInputStream bais = <span class="keyword">new</span> ByteArrayInputStream(baos.toByteArray());</span><br><span class="line">        <span class="comment">// 9,九个字节</span></span><br><span class="line">        System.out.println(bais.available());</span><br><span class="line">        DataInputStream dis = <span class="keyword">new</span> DataInputStream(bais);</span><br><span class="line">        System.out.println(dis.readDouble());<span class="comment">//先写进去的就先读出来，调用readDouble()方法读取出写入的随机数</span></span><br><span class="line">        System.out.println(dis.readBoolean());<span class="comment">//后写进去的就后读出来，这里面的读取顺序不能更改位置，否则会打印出不正确的结果</span></span><br><span class="line">        dos.close();</span><br><span class="line">        bais.close();</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4、打印流-Print">4、打印流(Print)</h2>
<ul>
<li>PrintWriter 和PrintStream都属于输出流，分别针对与字符和字节</li>
<li>PrintWriter 和PrintStream 提供了重载的print</li>
<li>Println方法用于多种数据类型的输出</li>
<li>PrintWriter和PrintStream的输出操作不会抛出异常，用户通过检测错误状态获取错误信息</li>
<li>PrintWriter 和PrintStream有自动flush功能</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Printwriter(Writer out)</span><br><span class="line">Printwriter(Writer out,<span class="keyword">boolean</span> autoFlush)</span><br><span class="line">Printwriter(OutputStream out)</span><br><span class="line">Printwriter(OutputStream out,<span class="keyword">boolean</span> autoFlush)</span><br><span class="line">Printstream(OutputStream out)</span><br><span class="line">Printstream(OutputStream out,<span class="keyword">boolean</span> autoFlush)</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/46b73be4d6294f85892c5a50b4f26abd.png?type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6a2FTGVtb24=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<h2 id="5、对象流-Object">5、对象流(Object)</h2>
<blockquote>
<p>直接将Object写入或读出，直接实现Serializable接口的类是JDK自动把这个类的对象序列化，而如果实现public interface Externalizable extends Serializable的类则可以自己控制对象的序列化，建议能让JDK自己控制序列化的就不要让自己去控制</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Shawn</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/1/29 21:01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        T t = <span class="keyword">new</span> T();</span><br><span class="line">        t.k = <span class="number">8</span>;<span class="comment">// 把k的值修改为8</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(</span><br><span class="line">                    <span class="string">"D:/logs/TestObjectIo.txt"</span>);</span><br><span class="line">            ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(fos);</span><br><span class="line">            <span class="comment">// ObjectOutputStream流专门用来处理Object的，在fos流的外面套接ObjectOutputStream流就可以直接把一个Object写进去</span></span><br><span class="line">            oos.writeObject(t);<span class="comment">// 直接把一个t对象写入到指定的文件里面</span></span><br><span class="line">            oos.flush();</span><br><span class="line">            oos.close();</span><br><span class="line">            FileInputStream fis = <span class="keyword">new</span> FileInputStream(</span><br><span class="line">                    <span class="string">"D:/logs/TestObjectIo.txt"</span>);</span><br><span class="line">            ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(fis);</span><br><span class="line">            <span class="comment">// ObjectInputStream专门用来读一个Object的</span></span><br><span class="line">            T tRead = (T) ois.readObject();</span><br><span class="line">            <span class="comment">// 直接把文件里面的内容全部读取出来然后分解成一个Object对象，并使用强制转换成指定类型T</span></span><br><span class="line">            System.out.print(tRead.i + <span class="string">"\t"</span> + tRead.j + <span class="string">"\t"</span> + tRead.d + <span class="string">"\t"</span></span><br><span class="line">                    + tRead.k);</span><br><span class="line">            ois.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 凡是要将一个类的对象序列化成一个字节流就必须实现Serializable接口</span></span><br><span class="line"><span class="comment"> * Serializable接口中没有定义方法，Serializable接口是一个标记性接口，用来给类作标记，只是起到一个标记作用。</span></span><br><span class="line"><span class="comment"> * 这个标记是给编译器看的，编译器看到这个标记之后就可以知道这个类可以被序列化 如果想把某个类的对象序列化，就必须得实现Serializable接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Serializable的意思是可以被序列化的</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">double</span> d = <span class="number">2.3</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">15</span>;</span><br><span class="line">    <span class="comment">// transient int k = 15;</span></span><br><span class="line">    <span class="comment">// 在声明变量时如果加上transient关键字，那么这个变量就会被当作是透明的，即不存在。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>四、总结</h1>
<p><img src="https://img-blog.csdnimg.cn/1d8d645ceffd4e429ad1e0c59860fcbb.png?type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6a2FTGVtb24=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<hr>
<p>参考文章</p>
<p><a href="https://www.cnblogs.com/xdp-gacl/p/3634409.html" target="_blank" rel="noopener">https://www.cnblogs.com/xdp-gacl/p/3634409.html</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>几种Bean映射工具介绍</title>
    <url>/posts/ed9e2fb2.html</url>
    <content><![CDATA[<h1>一、介绍</h1>
<h2 id="1、功能介绍">1、功能介绍</h2>
<p>在 Java 系统工程开发过程中，都会有各个层之间的对象转换，比如  VO、DTO、PO、VO 等，而如果都是手动<code>get、set</code>又太浪费时间，还可能操作错误，所以选择一个自动化工具会更加方便</p>
<a id="more"></a>
<h2 id="2、不同方法与性能对比">2、不同方法与性能对比</h2>
<p>目前用于对象属性转换有12种，包括普通的<strong>get/set、json2Json、Apache属性拷贝、Spring属性拷贝、bean-mapping、bean-mapping-asm、BeanCopier、Orika、Dozer、ModelMapper、JMapper、MapStruct</strong></p>
<p><img src="https://img-blog.csdnimg.cn/8e3de2474301425ca45fc896ec5387d0.png?type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6a2FTGVtb24=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li>Spring 提供的<code>BeanUtils.copyProperties</code> 是大家代码里最常出现的工具类，注意不是 <code>Apache</code> 包下</li>
<li>手动<code>get、set</code>性能是最好的，另外 <code>MapStruct</code> 性能和操作也很方便，因为它本身就是在编译期生成<code>get、set</code>代码，和我们写<code>get、set</code>一样</li>
<li>其他一些组件包主要基于 <code>AOP</code>、<code>ASM</code>、<code>CGlib</code>，的技术手段实现的，所以也会有相应的性能损耗<br>
<img src="https://img-blog.csdnimg.cn/161aabde273244fbbb886a1c916f51fc.png?type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6a2FTGVtb24=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></li>
</ul>
<h1>二、转换案例</h1>
<h2 id="1、源VO和目标VO">1、源VO和目标VO</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//源类</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Accessors</span>(chain = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SourceVO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//目标类</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Accessors</span>(chain = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TargetVO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2、get-set">2、get/set</h2>
<p>这种方式也是日常使用的最多的，性能十分优秀，但是操作起来有点麻烦。多个get/set可以通过 Shift+Alt 选中所有属性，Shift+Tab 归并到一列，接下来在使用 Alt 选中这一列，批量操作粘贴 <code>targetVO.set</code> 以及快捷键大写属性首字母，最后切换到结尾补充括号和分号，最终格式化一下就可以了</p>
<h2 id="3、Json2Json">3、Json2Json</h2>
<p>把对象转JSON串，再把JSON转另外一个对象，这种方式性能不是很高</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里用了fastjson</span></span><br><span class="line"><span class="comment"> * 两个对象或集合同名属性赋值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectConversion</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从List&lt;A&gt; copy到List&lt;B&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list List&lt;B&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz B</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> List&lt;B&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">copy</span><span class="params">(List&lt;?&gt; list,Class&lt;T&gt; clazz)</span></span>&#123;</span><br><span class="line">        String oldOb = JSON.toJSONString(list);</span><br><span class="line">        <span class="keyword">return</span> JSON.parseArray(oldOb, clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从对象A copy到 对象B</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ob A</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz B.class</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> B</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">copy</span><span class="params">(Object ob, Class&lt;T&gt; clazz)</span></span>&#123;</span><br><span class="line">        String oldOb = JSON.toJSONString(ob);</span><br><span class="line">        <span class="keyword">return</span> JSON.parseObject(oldOb, clazz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        SourceVO sourceVO = <span class="keyword">new</span> SourceVO(<span class="string">"shawn"</span>,<span class="string">"123456"</span>,<span class="number">18</span>);</span><br><span class="line">        TargetVO targetVO = ObjectConversion.copy(sourceVO, TargetVO<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(targetVO);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4、Spring-copyProperties✨">4、Spring copyProperties✨</h2>
<p>这个方法是<strong>反射的属性拷贝</strong>，Spring 提供的 copyProperties 要比 Apache 好用的多，性能和操作都比较好，这个包是<code>org.springframework.beans.BeanUtils</code></p>
<p>另外这里考虑到<strong>属性不同的字段的拷贝</strong>，还额外创建了一个回调函数进行映射处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//回调函数定义，这里用了java8特性函数式接口</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanCopyUtilCallBack</span> &lt;<span class="title">S</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义默认回调方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">callBack</span><span class="params">(S t, T s)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 定义拷贝工具类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanCopyUtil</span> <span class="keyword">extends</span> <span class="title">BeanUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 集合数据的拷贝</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sources: 数据源类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target: 目标类::new(eg: UserVO::new)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;S, T&gt; <span class="function">List&lt;T&gt; <span class="title">copyListProperties</span><span class="params">(List&lt;S&gt; sources, Supplier&lt;T&gt; target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> copyListProperties(sources, target, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 带回调函数的集合数据的拷贝（可自定义字段拷贝规则）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sources: 数据源类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target: 目标类::new(eg: UserVO::new)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> callBack: 回调函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;S, T&gt; <span class="function">List&lt;T&gt; <span class="title">copyListProperties</span><span class="params">(List&lt;S&gt; sources, Supplier&lt;T&gt; target, BeanCopyUtilCallBack&lt;S, T&gt; callBack)</span> </span>&#123;</span><br><span class="line">        List&lt;T&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(sources.size());</span><br><span class="line">        <span class="keyword">for</span> (S source : sources) &#123;</span><br><span class="line">            T t = target.get();</span><br><span class="line">            copyProperties(source, t);</span><br><span class="line">            list.add(t);</span><br><span class="line">            <span class="keyword">if</span> (callBack != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 回调</span></span><br><span class="line">                callBack.callBack(source, t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的回调函数可以使用Enum枚举进行规范化，最终进行测试，成功拷贝</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ublic <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 单个拷贝</span></span><br><span class="line">        SourceVO sourceBean = <span class="keyword">new</span> SourceVO(<span class="string">"shawn"</span>, <span class="string">"123456"</span>, <span class="number">18</span>);</span><br><span class="line">        TargetVO targetBean = <span class="keyword">new</span> TargetVO();</span><br><span class="line">        BeanUtils.copyProperties(sourceBean,targetBean);</span><br><span class="line">        System.out.println(targetBean);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 列表拷贝</span></span><br><span class="line">        List&lt;SourceVO&gt; sourceVOList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        sourceVOList.add(<span class="keyword">new</span> SourceVO(<span class="string">"shawn"</span>,<span class="string">"123456"</span>,<span class="number">18</span>));</span><br><span class="line">        sourceVOList.add(<span class="keyword">new</span> SourceVO(<span class="string">"shawn1"</span>,<span class="string">"12345678"</span>,<span class="number">20</span>));</span><br><span class="line">        List&lt;TargetVO&gt; targetVOList= BeanCopyUtil.copyListProperties(sourceVOList, TargetVO::<span class="keyword">new</span>,</span><br><span class="line">                (sourceVO,targetVO)-&gt;&#123;</span><br><span class="line">            targetVO.setAge(sourceVO.getAge());</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(targetVOList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5、BeanCopier">5、BeanCopier</h2>
<p>Cglib BeanCopier 的原理与Beanutils 原理不太一样，其主要使用 字节码技术动态生成一个代理类，<strong>代理类实现get 和 set方法</strong>。生成代理类过程存在一定开销，但是一旦生成，我们可以缓存起来重复使用，所有 Cglib 性能相比Beanutils 性能比较好整体性能不错，使用也不复杂</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//工具类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WrapperBeanCopier</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单个对象属性拷贝</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> source 源对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz 目标对象Class</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; 目标对象类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;M&gt; 源对象类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 目标对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T, M&gt; <span class="function">T <span class="title">copyProperties</span><span class="params">(M source, Class&lt;T&gt; clazz)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(source) || Objects.isNull(clazz))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">return</span> copyProperties(source, clazz, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 列表对象拷贝</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sources 源列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz 源列表对象Class</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; 目标列表对象类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;M&gt; 源列表对象类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 目标列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T, M&gt; <span class="function">List&lt;T&gt; <span class="title">copyObjects</span><span class="params">(List&lt;M&gt; sources, Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(sources) || Objects.isNull(clazz) || sources.isEmpty())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        BeanCopier copier = BeanCopier.create(sources.get(<span class="number">0</span>).getClass(), clazz, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> Optional.of(sources)</span><br><span class="line">                .orElse(<span class="keyword">new</span> ArrayList&lt;&gt;())</span><br><span class="line">                .stream().map(m -&gt; copyProperties(m, clazz, copier))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单个对象属性拷贝</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> source 源对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz 目标对象Class</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> copier copier</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; 目标对象类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;M&gt; 源对象类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 目标对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T, M&gt; <span class="function">T <span class="title">copyProperties</span><span class="params">(M source, Class&lt;T&gt; clazz, BeanCopier copier)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == copier)&#123;</span><br><span class="line">            copier = BeanCopier.create(source.getClass(), clazz, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        T t = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t = clazz.newInstance();</span><br><span class="line">            copier.copy(source, t, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 单个拷贝</span></span><br><span class="line">        SourceVO sourceVO = <span class="keyword">new</span> SourceVO(<span class="string">"shawn"</span>, <span class="string">"123456"</span>, <span class="number">18</span>);</span><br><span class="line">        TargetVO targetVO = WrapperBeanCopier.copyProperties(sourceVO, TargetVO<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(targetVO);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 列表拷贝</span></span><br><span class="line">        List&lt;SourceVO&gt; sourceVOList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        sourceVOList.add(<span class="keyword">new</span> SourceVO(<span class="string">"shawn"</span>,<span class="string">"123456"</span>,<span class="number">18</span>));</span><br><span class="line">        sourceVOList.add(<span class="keyword">new</span> SourceVO(<span class="string">"shawn1"</span>,<span class="string">"12345678"</span>,<span class="number">20</span>));</span><br><span class="line">        List&lt;TargetVO&gt; targetVOS = WrapperBeanCopier.copyObjects(sourceVOList, TargetVO<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(targetVOS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要自定义转换，可以使用<code>new Converter()</code>，一旦我们自己打开使用转换器，所有属性复制都需要我们自己来了，否则会导致无法复制。另外这里需要注意的是拷贝对象要去除<code>@Accessors(chain = true)</code>注解，因为该注解会将 <code>setter</code> 方法的返回值由 <code>void</code> 修改为当前对象。这导致 <code>setter</code> 的方法签名改变，最终导致 <code>BeanCopier</code> 无法识别现有的 <code>setter</code> 方法</p>
<h2 id="6、MapStruct✨✨">6、MapStruct✨✨</h2>
<blockquote>
<p>官网文档地址：<a href="https://github.com/mapstruct/mapstruct" target="_blank" rel="noopener">https://github.com/mapstruct/mapstruct</a></p>
</blockquote>
<p>MapStruct是一款基于Java注解的对象属性映射工具，在Github上已经有4.5K+Star。使用的时候我们只要在接口中定义好对象属性映射规则，它就能自动生成映射实现类，不使用反射，性能优秀，能实现各种复杂映射。(强烈推荐)</p>
<p><strong>首先导入Maven依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mapstruct<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mapstruct<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.2.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mapstruct<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mapstruct-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.2.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>创建Bean对象</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Accessors</span>(chain = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SourceVO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------------------*/</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Accessors</span>(chain = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TargetVO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String pwd;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String birthday;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>编写Mapper文件</strong>，实现同名同类型属性、不同名称属性、不同类型属性的映射</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    UserMapper INSTANCE = Mappers.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mapping</span>(target = <span class="string">"pwd"</span>, source = <span class="string">"password"</span>)</span><br><span class="line">    <span class="meta">@Mapping</span>(source = <span class="string">"birthday"</span>,target = <span class="string">"birthday"</span>, dateFormat = <span class="string">"yyyy-MM-dd"</span>)</span><br><span class="line">    <span class="function">TargetVO <span class="title">getTargetVO</span><span class="params">(SourceVO sourceVO)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后直接通过接口中的<code>INSTANCE</code>实例调用转换方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        SourceVO sourceVO = <span class="keyword">new</span> SourceVO(<span class="string">"shawn"</span>, <span class="string">"123456"</span>, <span class="number">18</span>, <span class="keyword">new</span> Date());</span><br><span class="line">        TargetVO targetVO = UserMapper.INSTANCE.getTargetVO(sourceVO);</span><br><span class="line">        System.out.println(targetVO);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实MapStruct的实现原理很简单，就是根据我们在Mapper接口中使用的<code>@Mapper</code>和<code>@Mapping</code>等注解，在运行时生成接口的实现类，我们可以打开项目的<code>target</code>目录查看</p>
<p>初次之外，MapStruct使用有：</p>
<ul>
<li><strong>基本映射、集合映射、子对象映射、合并映射</strong></li>
<li><strong>使用依赖注入、使用常量/默认值/表达式、映射前后自定义、处理映射异常等</strong></li>
</ul>
<blockquote>
<p>详情可参考：<br>
<a href="https://blog.csdn.net/zhenghongcs/article/details/121349361" target="_blank" rel="noopener">https://blog.csdn.net/zhenghongcs/article/details/121349361</a><br>
<a href="https://mapstruct.org/documentation/stable/reference/html/" target="_blank" rel="noopener">https://mapstruct.org/documentation/stable/reference/html/</a></p>
</blockquote>
<hr>
<p>参考文章</p>
<p><a href="https://mp.weixin.qq.com/s/_QJa5RSxvPBsqXo8yS5-pg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/_QJa5RSxvPBsqXo8yS5-pg</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Spring基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java方法参数传递</title>
    <url>/posts/feb80121.html</url>
    <content><![CDATA[<h1>一、引言</h1>
<h2 id="1、描述">1、描述</h2>
<p>对于C++来说，调用方法时存在<strong>值传递</strong>(新产生的副本不影响原来的)和<strong>引用传递</strong>(会影响原来的值)，那么对于Java呢？</p>
<a id="more"></a>
<h2 id="2、Java传递介绍">2、Java传递介绍</h2>
<p>通过查阅资料，java中不存在引用传递，始终是<strong>值传递</strong>。Java里面传的任何参数都是传的“值的副本”，如果是对象那么传递的是指针的“值的副本”，所以会有以下几种情况：</p>
<ul>
<li>8种基本类型，传的是值的副本，在另外的方法里面修改值，当前函数的值都不会改变；</li>
<li>对于final修饰的包装类对象，且没有提供方法对自身进行修改的对象，比如String、Integer…对变量进行赋值操作实际上是把传进来的引用的副本改变成了一个新的对象的引用，不会影响到原来的引用里面的对象；</li>
<li>提供方法对自身进行修改的对象，如StringBuffer…对象自身对自身进行改变，引用没有被改变，所以原方法里面的引用也会跟着改变；</li>
<li>数组名(相当于把数组的头指针的“值的副本”传递进来)，而arr[i]可以理解为是根据地址计算实际的数据位置偏移来操作数组当中的某个元素，所以原方法当中也会跟着改变，如果是直接给arr赋一个新值就相当于重新创建一个新对象了。</li>
</ul>
<h1>二、实战验证</h1>
<h2 id="1、8种基本类型">1、8种基本类型</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Method</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> c = <span class="string">'a'</span>;</span><br><span class="line">        change(a, c);</span><br><span class="line">        <span class="comment">// 输出仍是 1、a</span></span><br><span class="line">        System.out.println(a);</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">char</span> c1)</span> </span>&#123;</span><br><span class="line">        a1 = <span class="number">2</span>;</span><br><span class="line">        c1 = <span class="string">'c'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2、final修饰的包装类对象">2、final修饰的包装类对象</h2>
<p>对于String、Integer等对象会生成新的对象，因此传递到方法时并不会修改原来的值，因为final修饰符表示对象不可变。</p>
<p>main方法栈中的引用地址name、c传递给方法，因为String等对象不可修改，所以java会重新创建一个对象，此时新生成的对象指向局部变量，因此对原先变量不产生影响<br>
<img src="https://img-blog.csdnimg.cn/2b242337fa664980b15aff549e3b5c22.png" alt></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Method</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer a = <span class="number">1</span>;</span><br><span class="line">        String c = <span class="string">"lemon"</span>;</span><br><span class="line">        String name = <span class="keyword">new</span> String(<span class="string">"shawn"</span>);</span><br><span class="line">        change(a, c,name);</span><br><span class="line">        <span class="comment">// 输出仍是 1、lemon、shawn</span></span><br><span class="line">        System.out.println(a);</span><br><span class="line">        System.out.println(c);</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(Integer a1, String c1,String name1)</span> </span>&#123;</span><br><span class="line">        a1 = <span class="number">222</span>;</span><br><span class="line">        c1 = <span class="string">"lemon22"</span>;</span><br><span class="line">        name1 = <span class="keyword">new</span> String(<span class="string">"shawn22"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3、提供方法对自身进行修改的对象">3、提供方法对自身进行修改的对象</h2>
<p>这里举例StringBuilder对象和自定义类对象，传值传过来的是对象地址，对象本身内容可修改，且提供了方法对自身内容进行修改<br>
<img src="https://img-blog.csdnimg.cn/4054110a4fcb4f64b127c12b01d7839b.png" alt></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Method</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        stringBuilder.append(<span class="string">"hello "</span>);</span><br><span class="line"></span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        test.setName(<span class="string">"shawn"</span>);</span><br><span class="line">        test.setPassword(<span class="string">"123456"</span>);</span><br><span class="line"></span><br><span class="line">        change(test,stringBuilder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// hello world!</span></span><br><span class="line">        <span class="comment">// Test(name=lemon, password=123456)</span></span><br><span class="line">        System.out.println(stringBuilder);</span><br><span class="line">        System.out.println(test);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(Test test1,StringBuilder stringBuilder1)</span> </span>&#123;</span><br><span class="line">        test1.setName(<span class="string">"lemon"</span>);</span><br><span class="line">        stringBuilder1.append(<span class="string">"world!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java字符编码、码点与代码单元</title>
    <url>/posts/70eb2978.html</url>
    <content><![CDATA[<h1>一、字符编码</h1>
<h2 id="1、Unicode">1、Unicode</h2>
<p><strong>Unicode</strong>（<strong>万国码</strong>、<strong>国际码</strong>、<strong>统一码</strong>、<strong>单一码</strong>）是计算机科学领域里的一项业界标准。它对世界上大部分的文字系统进行了整理、编码，使得电脑可以用更为简单的方式来呈现和处理文字。</p>
<p>Unicode <strong>为世界上所有字符都分配了一个唯一的数字编号</strong>，这个编号范围从 0x000000 到 0x10FFFF (十六进制)，有 110 多万，每个字符都有一个唯一的 Unicode 编号，这个编号一般写成 16 进制，在前面加上 U+。例如：“马”的 Unicode 是U+9A6C。Unicode 就相当于一张表，建立了字符与编号之间的联系。</p>
<p>所以Unicode**本身只规定了每个字符的数字编号是多少，并没有规定这个编号如何存储。**因此才有了多种字符编码的存储方案，比较常见就是国际通用字符编码utf-8。</p>
<a id="more"></a>
<h2 id="2、utf-8、utf-16和utf-32区别">2、utf-8、utf-16和utf-32区别</h2>
<p><strong>UTF-32</strong>是一种定长编码，使用1个32bit的码元，其值与Unicode编码值相等</p>
<p><strong>UTF-16</strong>也是一种变长编码，对于一个Unicode字符被编码成1至2个码元，每个码元为16位。在基本多语言平面内的码位UTF-16编码使用1个码元且其值与Unicode是相等的（不需要转换），但在辅助平面内的码位在UTF-16中被编码为一对16bit的码元（即32bit,4字节）</p>
<p><strong>UTF-8</strong>是一种变长编码，对于一个Unicode的字符被编码成1至4个字节。Unicode编码与UTF-8的编码的对应关系:</p>
<table>
<thead>
<tr>
<th>Unicode编码</th>
<th>UTF-8编码(二进制)</th>
</tr>
</thead>
<tbody>
<tr>
<td>U+0000 – U+007F</td>
<td>0xxxxxxx</td>
</tr>
<tr>
<td>U+0080 – U+07FF</td>
<td>110xxxxx 10xxxxxx</td>
</tr>
<tr>
<td>U+0800 – U+FFFF</td>
<td>1110xxxx 10xxxxxx 10xxxxxx</td>
</tr>
<tr>
<td>U+10000 – U+10FFFF</td>
<td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td>
</tr>
</tbody>
</table>
<p>一个字节的uft8表示的unicode 码范围为(0 ~0x7F)<br>
两个字节长度的uft8 表示的unicode码范围为(0x80 ~ 0x07FF)<br>
三个字节长度的uft8 表示的unicode码范围为(0x0800 ~ 0xFFFF)<br>
四个字节长度的uft8 表示的unicode码范围为( 0x10000 ~ 0x10FFFF)</p>
<h1>二、码点和代码单元</h1>
<h2 id="1、码点和代码单元">1、码点和代码单元</h2>
<p>Java中char数据类型是一个采用UTF-16编码表示Unicode码点的代码单元，最常用的Unicode字符使用一个代码单元就可以表示，而辅助字符则需要一对代码单元表示。</p>
<p>通俗理解是有些Unicode字符可以用一个char值表示，表示一个码点，一个代码单元；但另外的Unicode字符则需要两个char值来表示，即辅助字符需要用两个char值，但表示一个码点，两个代码单元。</p>
<h2 id="2、实战理解">2、实战理解</h2>
<p>字符串中如果有一些非常规字符的话，使用charAt会导致结果不正确</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String test=<span class="string">"🍷Hello"</span>;</span><br><span class="line">        System.out.println(test);</span><br><span class="line">        System.out.println(test.length());<span class="comment">//得到的是代码单元的数量7, 🍷占两个代码单元</span></span><br><span class="line">        System.out.println(test.codePointCount(<span class="number">0</span>,test.length()));<span class="comment">//得到的是码点的数量6</span></span><br><span class="line"></span><br><span class="line">        System.out.println((<span class="keyword">int</span>)test.charAt(<span class="number">2</span>));<span class="comment">//返回第三个的代码单元：得到H的int型</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index=test.offsetByCodePoints(<span class="number">0</span>,<span class="number">1</span>);<span class="comment">//得到第二个码点位置</span></span><br><span class="line">        <span class="keyword">int</span> cp=test.codePointAt(index);<span class="comment">//得到该位置码点int型表示</span></span><br><span class="line">        System.out.println(cp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3、遍历字符串">3、遍历字符串</h2>
<p>对于无非常规字符的字符串，我们可以使用charAt来遍历（代码单元遍历）；而对于非常规字符的字符串，我们就只能遍历码点来实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 也可以实现反向遍历</span></span><br><span class="line">    <span class="comment">// if(Character.isSurrogate(test.charAt((i)))) i--;</span></span><br><span class="line">       String test = <span class="string">"🍷Hello"</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; test.length(); ) &#123;</span><br><span class="line">            <span class="keyword">int</span> cp = test.codePointAt(i);</span><br><span class="line">            <span class="keyword">if</span> (Character.isSupplementaryCodePoint(cp)) i += <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span> i++;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>) cp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String test=<span class="string">"🍷Hello"</span>;</span><br><span class="line">        <span class="keyword">int</span> [] codePoints=test.codePoints().toArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;codePoints.length;i++)&#123;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>)codePoints[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将码点数组转换成字符串</span></span><br><span class="line">        String str=<span class="keyword">new</span> String(codePoints,<span class="number">0</span>,codePoints.length);</span><br><span class="line">        <span class="comment">//🍷Hello</span></span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>《Java核心技术卷一》</p>
<p><a href="https://blog.csdn.net/hongsong673150343/article/details/88584753" target="_blank" rel="noopener">https://blog.csdn.net/hongsong673150343/article/details/88584753</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java ProcessBuilder类</title>
    <url>/posts/ddd598d5.html</url>
    <content><![CDATA[<h1>一、ProcessBuilder基础</h1>
<h2 id="1、ProcessBuilder类">1、ProcessBuilder类</h2>
<h3 id="1-1-概述">1.1 概述</h3>
<p><code>ProcessBuilder</code>类是J2SE 1.5在java.lang中新添加的一个新类，此类用于创建操作系统进程，它提供一种启动和管理进程（也就是应用程序）的方法。在J2SE 1.5之前，都是由<code>Process</code>类处理实现进程的控制管理。</p>
<p>每个<code> ProcessBuilder</code> 实例管理一个进程属性集，它的<code>start()</code>方法利用这些属性创建一个新的 Process 实例。<code>start()</code>方法可以从同一实例重复调用，以利用相同的或相关的属性创建新的子进程。</p>
<a id="more"></a>
<h3 id="1-2-进程属性">1.2 进程属性</h3>
<ul>
<li><strong>命令 command</strong><br>
表示要调用的外部程序文件及其参数（如果有）。</li>
<li><strong>环境 environment</strong><br>
从变量到值依赖于系统的映射。初始值是当前进程环境的一个副本（请参阅System.getenv()）。</li>
<li><strong>工作目录 working directory</strong><br>
默认值是当前进程的当前工作目录，通常根据系统属性 user.dir 来命名。</li>
<li><strong>redirectErrorStream属性</strong><br>
此属性为 false意思是子进程的标准输出和错误输出被发送给两个独立的流，这些流可以通过 <code>Process.getInputStream()</code> 和 <code>Process.getErrorStream()</code>方法来访问。如果将值设置为 true，标准错误将与标准输出合并，在此情况下，合并的数据可从 Process.getInputStream() 返回的流读取，而从 Process.getErrorStream() 返回的流读取将直接到达文件尾。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ProcessBuilder pb = <span class="keyword">new</span> ProcessBuilder(<span class="string">"myCommand"</span>, <span class="string">"myArg1"</span>, <span class="string">"myArg2"</span>);</span><br><span class="line">Map&lt;String, String&gt; env = pb.environment();</span><br><span class="line">env.put(<span class="string">"VAR1"</span>, <span class="string">"myValue"</span>);</span><br><span class="line">env.remove(<span class="string">"OTHERVAR"</span>);</span><br><span class="line">env.put(<span class="string">"VAR2"</span>, env.get(<span class="string">"VAR1"</span>) + <span class="string">"suffix"</span>);</span><br><span class="line">pb.directory(<span class="string">"myDir"</span>);</span><br><span class="line">Process p = pb.start();</span><br></pre></td></tr></table></figure>
<h2 id="2、Process类">2、Process类</h2>
<h3 id="2-1-概述">2.1 概述</h3>
<p>Process类是一个抽象类（所有的方法均是抽象的），封装了一个进程（即一个执行程序）。</p>
<p>Process 类提供了执行从进程输入、执行输出到进程、等待进程完成、检查进程的退出状态以及销毁（杀掉）进程的方法。创建的子进程没有自己的终端或控制台。它的所有标准 io（即 stdin、stdout 和 stderr）操作都将通过三个流 (<code>getOutputStream()、getInputStream() 和 getErrorStream()</code>) 重定向到父进程。父进程使用这些流来提供到子进程的输入和获得从子进程的输出。</p>
<h3 id="2-2-Process抽象类">2.2 Process抽象类</h3>
<ul>
<li><strong>destroy()</strong><br>
杀掉子进程。</li>
<li><strong>exitValue()</strong><br>
返回子进程的出口值。</li>
<li><strong>InputStream getErrorStream()</strong><br>
获得子进程的错误流。</li>
<li><strong>InputStream getInputStream()</strong><br>
获得子进程的输入流。</li>
<li><strong>OutputStream getOutputStream()</strong><br>
获得子进程的输出流。</li>
<li><strong>waitFor()</strong><br>
导致当前线程等待，如果必要，一直要等到由该 Process 对象表示的进程已经终止</li>
</ul>
<p>同时Process对象可以获得进程句柄，从而可以获得进程ID、父进程、子进程等信息</p>
<h3 id="2-3-创建Process对象方式">2.3 创建Process对象方式</h3>
<ul>
<li>使用命令名和命令的参数选项构造ProcessBuilder对象，它的start方法执行命令，启动一个进程，返回一个Process对象</li>
<li><code>Runtime.exec()</code>方法创建一个本机进程，并返回 Process 子类的一个实例</li>
</ul>
<h2 id="3、-ProcessBuilder与Runtime-exec-异同">3、**ProcessBuilder与Runtime.exec()**异同</h2>
<h3 id="3-1-相同点">3.1 相同点</h3>
<p><code>ProcessBuilder.start()</code> 和 <code>Runtime.exec()</code> 方法都被用来创建一个操作系统进程（执行命令行操作），并返回 Process 子类的一个实例，该实例可用来控制进程状态并获得相关信息</p>
<h3 id="3-2-不同点">3.2 不同点</h3>
<p><code>ProcessBuilder.start()</code> 和 <code>Runtime.exec()</code>传递的参数有所不同</p>
<p>Runtime.exec()可接受一个单独的字符串，这个字符串是通过空格来分隔可执行命令程序和参数的；也可以接受字符串数组参数。而ProcessBuilder的构造函数是一个字符串列表或者数组。列表中第一个参数是可执行命令程序，其他的是命令行执行是需要的参数。</p>
<h1>二、<strong>ProcessBuilder</strong>实战</h1>
<h2 id="1、API介绍">1、API介绍</h2>
<p><strong>构造方法</strong></p>
<ul>
<li><strong>ProcessBuilder(List<String> command)</String></strong><br>
利用指定的操作系统程序和参数构造一个进程生成器。</li>
<li><strong>ProcessBuilder(String… command)</strong><br>
利用指定的操作系统程序和参数构造一个进程生成器。</li>
</ul>
<p><strong>方法</strong></p>
<ul>
<li><strong>command()</strong><br>
返回此进程生成器的操作系统程序和参数。</li>
<li><strong>command(List<String> command)</String></strong><br>
设置此进程生成器的操作系统程序和参数。</li>
<li><strong>command(String… command)</strong><br>
设置此进程生成器的操作系统程序和参数。</li>
<li><strong>directory()</strong><br>
返回此进程生成器的工作目录。</li>
<li><strong>directory(File directory)</strong><br>
设置此进程生成器的工作目录。</li>
<li><strong>environment()</strong><br>
返回此进程生成器环境的字符串映射视图。 environment方法获得运行进程的环境变量,得到一个Map,可以修改环境变量</li>
<li><strong>redirectErrorStream()</strong><br>
通知进程生成器是否合并标准错误和标准输出。</li>
<li><strong>redirectErrorStream(boolean redirectErrorStream)</strong><br>
设置此进程生成器的 redirectErrorStream 属性。</li>
<li><strong>start()</strong><br>
使用此进程生成器的属性启动一个新进程。</li>
</ul>
<h2 id="2、实战demo">2、实战demo</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Runtime.exec()进行创建</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Process process = Runtime.getRuntime().exec(<span class="string">"ipconfig /all"</span>);</span><br><span class="line">            InputStream is = process.getInputStream();</span><br><span class="line">            InputStreamReader isr =<span class="keyword">new</span> InputStreamReader(is, <span class="string">"gbk"</span>);</span><br><span class="line"></span><br><span class="line">            BufferedReader br = <span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line"></span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(line);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> exitCode = process.waitFor();</span><br><span class="line">            System.out.println(exitCode);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       ProcessBuilder processBuilder = <span class="keyword">new</span> ProcessBuilder();</span><br><span class="line">       <span class="comment">// System.out.println(processBuilder.directory());</span></span><br><span class="line">       <span class="comment">// System.out.println(processBuilder.environment());</span></span><br><span class="line">       <span class="comment">//processBuilder.command("ping","127.0.0.1");</span></span><br><span class="line">       processBuilder.command(<span class="string">"ipconfig"</span>,<span class="string">"/all"</span>);</span><br><span class="line">       <span class="comment">//将标准输入流和错误输入流合并，通过标准输入流读取信息</span></span><br><span class="line">       processBuilder.redirectErrorStream(<span class="keyword">true</span>);</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//启动进程</span></span><br><span class="line">           Process start = processBuilder.start();</span><br><span class="line">           <span class="comment">//获取输入流</span></span><br><span class="line">           InputStream inputStream = start.getInputStream();</span><br><span class="line">           <span class="comment">//转成字符输入流</span></span><br><span class="line">           InputStreamReader inputStreamReader = <span class="keyword">new</span> InputStreamReader(inputStream, <span class="string">"gbk"</span>);</span><br><span class="line">           <span class="keyword">int</span> len = -<span class="number">1</span>;</span><br><span class="line">           <span class="keyword">char</span>[] c = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">           StringBuffer outputString = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">           <span class="comment">//读取进程输入流中的内容</span></span><br><span class="line">           <span class="keyword">while</span> ((len = inputStreamReader.read(c)) != -<span class="number">1</span>) &#123;</span><br><span class="line">               String s = <span class="keyword">new</span> String(c, <span class="number">0</span>, len);</span><br><span class="line">               outputString.append(s);</span><br><span class="line">               System.out.print(s);</span><br><span class="line">           &#125;</span><br><span class="line">           inputStream.close();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ProcessBuilder processBuilder = <span class="keyword">new</span> ProcessBuilder(<span class="string">"cmd"</span>,<span class="string">"/c"</span>,<span class="string">"dir"</span>);</span><br><span class="line">        processBuilder.directory(<span class="keyword">new</span> File(<span class="string">"D:/"</span>));</span><br><span class="line">        Process process = processBuilder.start();</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(process.getInputStream(), <span class="string">"GBK"</span>));</span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java泛型</title>
    <url>/posts/a14eb637.html</url>
    <content><![CDATA[<h1>一、泛型介绍</h1>
<h2 id="1、简介">1、简介</h2>
<blockquote>
<p>Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许开发者在编译时检测到非法的类型</p>
</blockquote>
<p>参数化类型:</p>
<ul>
<li>把类型当作是参数一样传递</li>
<li><code>**&lt;数据类型&gt;**</code> 只能是引用类型</li>
</ul>
<p>相关术语：</p>
<ul>
<li><code>ArrayList&lt;E&gt;</code>中的<strong>E</strong>称为类型参数变量</li>
<li><code>ArrayList&lt;Integer&gt;</code>中的<strong>Integer</strong>称为实际类型参数</li>
<li>整个称为<code>ArrayList&lt;E&gt;</code>泛型类型</li>
<li>整个<code>ArrayList&lt;Integer&gt;</code>称为参数化的类型ParameterizedType</li>
</ul>
<a id="more"></a>
<h2 id="2、泛型优点">2、泛型优点</h2>
<ul>
<li><strong>类型安全</strong>。 泛型的主要目标是提高 Java 程序的类型安全。通过知道使用泛型定义的变量的类型限制，编译器可以在一个高得多的程度上验证类型假设。没有泛型，这些假设就只存在于程序员的头脑中（或者如果幸运的话，还存在于代码注释中）。</li>
<li><strong>消除强制类型转换</strong>。 泛型的一个附带好处是，消除源代码中的许多强制类型转换。这使得代码更加可读，并且减少了出错机会。</li>
<li><strong>潜在的性能收益</strong>。 泛型为较大的优化带来可能。在泛型的初始实现中，编译器将强制类型转换（没有泛型的话，程序员会指定这些强制类型转换）插入生成的字节码中。但是更多类型信息可用于编译器这一事实，为未来版本的 JVM 的优化带来可能。由于泛型的实现方式，支持泛型（几乎）不需要 JVM 或类文件更改。所有工作都在编译器中完成，编译器生成类似于没有泛型（和强制类型转换）时所写的代码，只是更能确保类型安全而已。</li>
</ul>
<h2 id="3、泛型的定义和使用">3、泛型的定义和使用</h2>
<ul>
<li>泛型类</li>
<li>泛型方法</li>
<li>泛型接口</li>
</ul>
<h1>二、泛型基础</h1>
<h2 id="1、泛型类与泛型方法">1、泛型类与泛型方法</h2>
<h3 id="1、泛型类">1、泛型类</h3>
<p>**泛型类就是把泛型定义在类上，用户使用该类的时候，才把类型明确下来。**这样的话，用户明确了什么类型，该类就代表着什么类型；用户在使用的时候就不用担心强转的问题，运行时转换异常的问题了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建对象并指定元素类型</span></span><br><span class="line">        User&lt;String&gt; tool = <span class="keyword">new</span> User&lt;&gt;();</span><br><span class="line">        tool.setObj(<span class="string">"shawn"</span>);</span><br><span class="line">        String s = tool.getObj();</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        <span class="comment">//创建对象并指定元素类型</span></span><br><span class="line">        User&lt;Integer&gt; objectTool = <span class="keyword">new</span> User&lt;&gt;();</span><br><span class="line">        <span class="comment">//如果我在这个对象里传入的是String类型的,它在编译时期就通过不了了.</span></span><br><span class="line">        objectTool.setObj(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">int</span> i = objectTool.getObj();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1:把泛型定义在类上</span></span><br><span class="line"><span class="comment">    2:类型变量定义在类上,方法中也可以使用</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> T obj;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">getObj</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObj</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.obj = obj;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、泛型方法">2、泛型方法</h3>
<p>泛型方法与泛型类稍有不同的地方是，类型参数也就是尖括号那一部分是写在返回值前面的。第一个 T 被称为类型参数，而方法中的 T 被称为参数化类型，它不是运行时真正的参数。最后声明的类型参数，其实也是可以当作返回值的类型的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">      <span class="comment">//定义泛型方法</span></span><br><span class="line">      <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">      <span class="comment">// TODO</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="3、泛型类和泛型方法并存">3、泛型类和泛型方法并存</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Test1&lt;String&gt; t = <span class="keyword">new</span> Test1();</span><br><span class="line">        t.testMethod(<span class="string">"shawn"</span>);</span><br><span class="line">        <span class="comment">//注意使用泛型方法并不需要我们显式地用&lt;&gt;声明类型</span></span><br><span class="line">        Integer i = t.testMethod1(<span class="keyword">new</span> Integer(<span class="number">1</span>));</span><br><span class="line">        <span class="comment">// 1</span></span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 泛型类和泛型方法并存，两者的类型参数最好不要同名</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">            <span class="comment">// java.lang.String</span></span><br><span class="line">            System.out.println(t.getClass().getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span>  &lt;E&gt; <span class="function">E <span class="title">testMethod1</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2、泛型继承关系">2、泛型继承关系</h2>
<p>泛型类是拥有泛型这个特性的类，它本质上还是一个Java类，那么它就可以被继承。泛型继承分两种情况</p>
<ul>
<li>子类明确泛型类的类型参数变量</li>
<li>子类不明确泛型类的类型参数变量</li>
</ul>
<p>要注意的是实现类的要是重写父类的方法，返回值的类型是要和父类一样的；其次类上声明的泛形只对非静态成员有效</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试第一种情况</span></span><br><span class="line">        Inter&lt;String&gt; i = <span class="keyword">new</span> InterImpl();</span><br><span class="line">        i.show(<span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二种情况测试</span></span><br><span class="line">        Inter&lt;String&gt; ii = <span class="keyword">new</span> InterImpl1&lt;&gt;();</span><br><span class="line">        ii.show(<span class="string">"100"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        把泛型定义在接口上</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Inter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(T t)</span></span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 子类明确泛型类的类型参数变量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InterImpl</span> <span class="keyword">implements</span> <span class="title">Inter</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当子类不明确泛型类的类型参数变量时，外界使用子类的时候</span></span><br><span class="line"><span class="comment">     * 也需要传递类型参数变量进来，</span></span><br><span class="line"><span class="comment">     * 在实现类上需要定义出类型参数变量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InterImpl1</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Inter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">            System.out.println(t);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3、泛型通配符">3、泛型通配符</h2>
<h3 id="1、介绍">1、介绍</h3>
<p>**常用的 T，E，K，V，？**本质上都是通配符，没啥区别，只不过是编码时的一种约定俗成的东西。比如代码中的 T ，我们可以换成 A-Z 之间的任何一个 字母都可以，并不会影响程序的正常运行，但是如果换成其他的字母代替 T ，在可读性上可能会弱一些。<strong>通常情况下，T，E，K，V，？是这样约定的：</strong></p>
<ul>
<li>？表示不确定的 java 类型</li>
<li>T (type) 表示具体的一个java类型</li>
<li>K V (key value) 分别代表java键值中的Key Value</li>
<li>E (element) 代表Element</li>
</ul>
<h3 id="2、？无界通配符">2、？无界通配符</h3>
<p>对于不确定或者不关心实际要操作的类型，可以使用无限制通配符（尖括号里一个问号，即 &lt;?&gt; ），表示可以持有任何类型。无限定通配符经常与容器类配合使用，它其中的 ? 其实代表的是未知类型，所以涉及到 ? 时的操作，一定与具体类型无关。</p>
<h3 id="3、上界通配符-extends-E">3、<strong>上界通配符 &lt; ? extends E&gt;</strong></h3>
<blockquote>
<p>上届：用 extends 关键字声明，表示参数化的类型可能是所指定的类型，或者是此类型的子类。</p>
</blockquote>
<p>在类型参数中使用 extends 表示这个泛型中的参数必须是 E 或者 E 的子类，这样有两个好处：</p>
<ul>
<li>如果传入的类型不是 E 或者 E 的子类，编译不成功</li>
<li>泛型中可以使用 E 的方法，要不然还得强转成 E 才能使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> &lt;<span class="title">T</span>,<span class="title">E</span> <span class="keyword">extends</span> <span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">        T value1;</span><br><span class="line">        E value2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> &lt;D,S extends D&gt; <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(D d,S s)</span></span>&#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4、下界通配符-super-E">4、<strong>下界通配符 &lt; ? super E&gt;</strong></h3>
<blockquote>
<p>下界: 用 super 进行声明，表示参数化的类型可能是所指定的类型，或者是此类型的父类型，直至 Object</p>
</blockquote>
<p><strong>在泛型的上限和下限中有一个原则：PECS(Producer Extends Consumer Super)</strong></p>
<ul>
<li>带有子类限定的可以从泛型读取【也就是—&gt;(? extend T)】--------&gt;Producer Extends</li>
<li>带有超类限定的可以从泛型写入【也就是—&gt;(? super T)】--------&gt;Consumer Super</li>
</ul>
<h3 id="5、通配符-和泛型方法T区别">5、通配符?和泛型方法T区别</h3>
<p>使用原则：</p>
<ul>
<li>如果<strong>参数之间的类型有依赖关系</strong>，或者返<strong>回值是与参数之间有依赖关系</strong>的。那么就使用<strong>泛型方法</strong></li>
<li>如果<strong>没有依赖关系</strong>的，就使用<strong>通配符</strong>，通配符会<strong>灵活一些.</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//大多时候，我们都可以使用泛型方法来代替通配符</span></span><br><span class="line"><span class="comment">//使用通配符</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(List&lt;?&gt; list)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用泛型方法</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span>  <span class="title">test2</span><span class="params">(List&lt;T&gt; t)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>两者区别：</strong></p>
<ul>
<li>通过 T 来 确保 泛型参数的一致性</li>
<li>类型参数可以多重限定而通配符不行</li>
<li>通配符可以使用超类限定而类型参数不行</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类型参数 T 只具有 一种 类型限定方式：</span></span><br><span class="line"><span class="comment">//但是通配符 ? 可以进行 两种限定： </span></span><br><span class="line">T extends A</span><br><span class="line">? extends A</span><br><span class="line">? <span class="keyword">super</span> A</span><br></pre></td></tr></table></figure>
<h1>三、泛型与虚拟机</h1>
<h2 id="1、类型擦除">1、类型擦除</h2>
<p>泛型是 <strong>Java 1.5 <strong>版本才引进的概念，但是泛型代码能够很好地和之前版本的代码很好地兼容。这是因为泛型是</strong>提供给javac编译器使用的</strong>，它用于限定集合的输入类型，让编译器在源代码级别上，即挡住向集合中插入非法数据。但编译器编译完带有泛形的java程序后，<strong>生成的class文件中将不再带有泛形信息</strong>，以此使程序运行效率不受到影响，这个过程称之为“擦除”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 结果为True,因为结果都为List</span></span><br><span class="line">        System.out.println(list.getClass()==list1.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类型擦除过程中，原始类型用第一个限定来替换类型变量，如果没有给定限定，就替换为<code>Object</code>。例如<code>User&lt;T&gt;</code>中的类型变量没有显示的限定，就会用<code>Object</code>进行替换；如果声明了<code>User&lt;T extends Comparable&gt;</code>，就会用<code>Comparable</code>替换。</p>
<h2 id="2、泛型转换重要结论">2、泛型转换重要结论</h2>
<ul>
<li>虚拟机中没有泛型，只有普通的类和方法</li>
<li>所有的类型参数都会替换为它们的限定类型</li>
<li>会合成桥方法来保持多态</li>
<li>为保持类型安全性，必要时会插人强制类型转换</li>
</ul>
<h2 id="3、泛型局限性">3、泛型局限性</h2>
<ol>
<li>不能使用基本类型实例化类型参数</li>
<li>不能实例化类型参数</li>
<li>不可以实例化类型变量的数组</li>
<li>不可以定义泛型类的数组</li>
<li>不可以对泛型类型进行类型检测/转化</li>
<li>不可以抛出或捕获泛型异常</li>
<li>泛型类的静态类型变量/方法无效</li>
<li>类型擦除引发的冲突</li>
</ol>
<hr>
<p>参考文章</p>
<p>《Java核心技术卷1》</p>
<p><a href="https://segmentfault.com/a/1190000014120746" target="_blank" rel="noopener">https://segmentfault.com/a/1190000014120746</a></p>
<p><a href="https://www.cnblogs.com/jiading/articles/12560549.html" target="_blank" rel="noopener">https://www.cnblogs.com/jiading/articles/12560549.html</a></p>
<p><a href="https://mp.weixin.qq.com/s/ZxOULsyFt1Iy8HqPW8VOSw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/ZxOULsyFt1Iy8HqPW8VOSw</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC并发编程</title>
    <url>/posts/eb9166f8.html</url>
    <content><![CDATA[<h1>一、简介</h1>
<h2 id="1、JUC介绍">1、JUC介绍</h2>
<p><code>java.util.concurrent</code> 包是在并发编程中使用的工具类，简称JUC，有以下三个包</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.util.concurrent</span><br><span class="line">java.util.concurrent.atomic</span><br><span class="line">java.util.concurrent.locks</span><br></pre></td></tr></table></figure>
<blockquote>
<p>JDK8官方在线文档：<a href="https://www.matools.com/api/java8" target="_blank" rel="noopener">https://www.matools.com/api/java8</a></p>
</blockquote>
<a id="more"></a>
<h2 id="2、进程与线程">2、进程与线程</h2>
<h3 id="2-1-异同介绍">2.1 异同介绍</h3>
<p><strong>进程</strong>：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动，它是操作系统动态执行的基本单元。在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。</p>
<p><strong>线程</strong>：通常在一个进程中可以包含若干个线程，一个进程中至少有一个线程，线程可以利用进程所有拥有的资源。在引入线程的操作系统中，通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位，由于线程比进程小，基本上不拥有系统资源，故对它的调度所付出的开销就会小得多，能更高效的提高系统多个程序间并发执行的程度。</p>
<h3 id="2-2-线程状态">2.2 线程状态</h3>
<p>线程有6种状态，可以进入<code>Thread.State</code>查看源码分析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State &#123; </span><br><span class="line">      <span class="comment">//线程刚创建       </span></span><br><span class="line">      NEW,</span><br><span class="line">      <span class="comment">//在JVM中运行的线程</span></span><br><span class="line">      RUNNABLE,</span><br><span class="line">      <span class="comment">//线程处于阻塞状态，等待监视锁，可以重新进行同步代码块中执行</span></span><br><span class="line">      BLOCKED,</span><br><span class="line">      <span class="comment">//等待状态</span></span><br><span class="line">      WAITING,</span><br><span class="line">      <span class="comment">//调用sleep() join() wait()方法可能导致线程处于等待状态</span></span><br><span class="line">      TIMED_WAITING,</span><br><span class="line">      <span class="comment">//线程执行完毕，已经退出</span></span><br><span class="line">      TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/fb475ee1526946c282bf96a9b1497b43.png" alt></p>
<h3 id="2-3-线程wait-sleep区别">2.3 线程wait/sleep区别</h3>
<ul>
<li><strong>两个方法来自不同的类</strong><br>
sleep来自Thread类，wait来自Object类</li>
<li><strong>释放资源不同(有没有释放锁)</strong><br>
sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。sleep(100L)占用cpu，线程休眠100毫秒后继续执行；而wait是无限期的除非用户主动notify()</li>
<li><strong>使用范围不同</strong><br>
wait()、notify()和notifyAll()只能在同步控制方法或者同步控制块里面使用，而sleep()可以在任何地方使用</li>
<li><strong>是否需要捕获异常</strong><br>
sleep()必须捕获异常，而wait()、notify()和notifyAll()不需要捕获异常。</li>
</ul>
<h2 id="3、并行与并发">3、并行与并发</h2>
<p><strong>并发(concurrency)</strong>：在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。</p>
<p><strong>并行(parallel)</strong>：在同一时刻，有多条指令在多个处理器上同时执行。所以无论从微观还是从宏观来看，二者都是一起执行的。</p>
<h1>二、Lock接口与synchronized</h1>
<h2 id="1、synchronized关键字">1、synchronized关键字</h2>
<p>synchronized 是 Java 中的关键字，是一种<strong>同步锁</strong>（对方法或者代码块中存在共享数据的操作）。同步锁可以是任意对象</p>
<p><strong>具体修饰的对象有3种方式</strong>：</p>
<ul>
<li><strong>修饰代码块</strong><br>
被修饰的代码块称为同步语句块，作用的范围是大括号{ }内的内容</li>
<li><strong>修饰方法</strong><br>
作用范围为整个方法，作用对象是调用该代码块的对象（虽然可以修饰方法，但 synchronized 并不属于方法定义的一部分，因此synchronized 关键字不能被继承）</li>
<li><strong>修饰静态方法</strong><br>
作用的范围是整个静态方法，作用的对象是这个类的所有对象（修饰一个类也同理）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">synchronizedTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="comment">//共享资源(临界资源)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * synchronized 修饰实例方法</span></span><br><span class="line"><span class="comment">     * 对静态方法加锁，锁是当前类的class对象锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">10</span>;j++)&#123;</span><br><span class="line">            add();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        synchronizedTest b1=<span class="keyword">new</span> synchronizedTest();</span><br><span class="line">        synchronizedTest b2=<span class="keyword">new</span> synchronizedTest();</span><br><span class="line">        Thread m1=<span class="keyword">new</span> Thread(b1);</span><br><span class="line">        Thread m2=<span class="keyword">new</span> Thread(b2);</span><br><span class="line">        m1.start();</span><br><span class="line">        m2.start();</span><br><span class="line">        m1.join();</span><br><span class="line">        m2.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2、Lock接口">2、Lock接口</h2>
<h3 id="2-1-介绍">2.1 介绍</h3>
<blockquote>
<p><code>Lock</code>实现提供比使用<code>synchronized</code>方法和语句可以获得的更广泛的锁定操作。 它们允许更灵活的结构化，可能具有完全不同的属性，并且可以支持多个相关<a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/concurrent/locks/Condition.html" target="_blank" rel="noopener">联的</a>对象<a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/concurrent/locks/Condition.html" target="_blank" rel="noopener"><code>Condition</code></a> 。</p>
</blockquote>
<h3 id="2-2-lock常用方法">2.2 lock常用方法</h3>
<p><code>lock()</code><strong>方法用来获取锁</strong></p>
<ul>
<li>如果锁已被其他线程获取，则进行等待</li>
<li>发生异常不会自动解锁，需用在 try{}catch{}块中进行</li>
</ul>
<p><code>Condition 类</code><strong>也可以实现等待/通知模式</strong></p>
<blockquote>
<p>关键字 synchronized 与 wait()/notify()这两个方法一起使用可以实现等待/通知模式；Lock 锁的 newContition()方法返回 Condition 对象，Condition 类也可以实现等待/通知模式</p>
</blockquote>
<ul>
<li>await()会使当前线程等待,同时会释放锁,当其他线程调用 signal()时,线程会重新获得锁并继续执行</li>
<li>signal()用于唤醒一个等待的线程</li>
<li>signalAll()用于唤醒所有等待的线程(推荐)</li>
</ul>
<p><code>unlock()</code><strong>方法用于解锁</strong>(此方法必须在finally中，否则会造成死锁)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">  <span class="comment">//上锁</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">  <span class="comment">//尝试获取锁</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">  <span class="comment">//解锁</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">//可实现等待/通知模式</span></span><br><span class="line">  <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-Lock实战">2.3 Lock实战</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">//票数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">30</span>;</span><br><span class="line">    <span class="comment">//创建可重入锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//卖票方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//lock不能使用try-with-resource方法</span></span><br><span class="line">        <span class="comment">//上锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//判断是否有票</span></span><br><span class="line">            <span class="keyword">if</span>(number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">" ：卖出"</span>+(number--)+<span class="string">" 剩余："</span>+number);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//解锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LockTest ticket = <span class="keyword">new</span> LockTest();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">                    ticket.sale();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,<span class="string">"shawn1"</span>).start();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">                    ticket.sale();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,<span class="string">"shawn2"</span>).start();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">                    ticket.sale();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,<span class="string">"shawn3"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3、线程间的通信">3、线程间的通信</h2>
<p>对于synchronized 来说，自定义同步通信</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object lock1 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object lock2 = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock1.wait();</span><br><span class="line">                <span class="comment">//TODO</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock2.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于Lock来说，可自定义同步通信</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建Lock锁</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建三个condition</span></span><br><span class="line">    <span class="keyword">private</span> Condition c1 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition c2 = lock.newCondition();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//打印5次，参数第几轮</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print5</span><span class="params">(<span class="keyword">int</span> loop)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//上锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            c1.await();</span><br><span class="line">            <span class="comment">//TODO</span></span><br><span class="line">            c2.signal(); <span class="comment">//通知第二个线程</span></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4、synchronized与lock的异同">4、<strong>synchronized与lock的异同</strong></h2>
<ul>
<li>synchronized是java关键字，内置；而lock不是内置，是一个类，可以实现同步访问且比synchronized中的方法更加丰富</li>
<li>synchronized不会手动释放锁，而lock需手动释放锁（不解锁会出现死锁，需要在 finally 块中释放锁）</li>
<li>lock等待锁的线程会相应中断，而synchronized不会相应，只会一直等待</li>
<li>通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到</li>
<li>Lock 可以提高多个线程进行读操作的效率（当多个线程竞争的时候）</li>
</ul>
<h1>三、多线程锁与并发</h1>
<h2 id="1、多线程锁结论">1、多线程锁结论</h2>
<ul>
<li><strong>对于普通同步方法，锁的是当前实例对象</strong><br>
所有的非静态的同步方法用的都是同一把锁—实例对象本身。一个对象里面如果有多个synchronized方法，某个时刻内，只要一个线程去调用其中一个synchronized 方法，其他的线程都要等待。换句话说，在某个时刻内，只能有唯一一个线程去访问这些synchronized方法，锁的是当前对象this，被锁定后，其他的线程都不能进入到当前对象的其他的synchronized方法</li>
<li><strong>对于静态同步方法，锁的是当前的Class对象</strong><br>
所有的静态同步方法用的也是同一把锁—类对象本身</li>
<li><strong>对于同步方法块，锁是synchronized括号里面的配置对象</strong></li>
</ul>
<h2 id="2、并发同步">2、并发同步</h2>
<h3 id="2-1-JMM介绍">2.1 JMM介绍</h3>
<blockquote>
<p>JMM即为JAVA 内存模型（java memorymodel）。因为在<strong>不同的硬件生产商和不同的操作系统</strong>下，内存的访问逻辑有一定的差异，结果就是当你的代码在某个系统环境下运行良好，并且线程安全，但是换了个系统就出现各种问题。Java内存模型，就是为了屏蔽系统和硬件的差异，让一套代码在不同平台下能到达相同的访问结果。JMM从java 5开始的JSR-133发布后，已经成熟和完善起来。<br>
JMM规定了内存主要划分为<strong>主内存</strong>和<strong>工作内存</strong>两种。此处的主内存和工作内存跟JVM内存划分（堆、栈、方法区）是在不同的层次上进行的，如果非要对应起来，主内存对应的是Java堆中的对象实例部分，工作内存对应的是栈中的部分区域，从更底层的来说，主内存对应的是硬件的物理内存，工作内存对应的是寄存器和高速缓存。</p>
</blockquote>
<p>单线程环境里面确保程序最终执行结果和代码顺序执行的结果一致。处理器在进行重排序时必须要考虑指令之间的数据依赖性；多线程环境中线程交替执行，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的，结果无法预测。<br>
<img src="https://img-blog.csdnimg.cn/8ccc9947c9ed4ed6943510b5f71bbe42.png" alt></p>
<h3 id="2-2-volatile">2.2 volatile</h3>
<p>volitile 是 Java 虚拟机提供的轻量级的同步机制，三大特性：</p>
<ul>
<li>保证可见性</li>
<li><strong>不保证原子性</strong></li>
<li>禁止指令重排</li>
</ul>
<p>volatile 实现了<strong>禁止指令重排优化</strong>，从而避免多线程环境下程序出现乱序执行的现象。通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化。<strong>内存屏障</strong>另外一个作用是强制刷出各种CPU的缓存数据，因此任何CPU上的线程都能读取到这些数据的最新版本。</p>
<p>而使用volatile的另一好处是相比synchronized来说，volatile更加轻量，运行速度更快</p>
<h3 id="2-3-JUC原子类工具">2.3 JUC原子类工具</h3>
<p>在<code>java.util.concurrent.atomic</code>包下有很多使用了高效的机器级指令(而没有使用锁)来保证其他操作的原子性。例如AtomicInteger类提供了incrementAndGet()方法，它以原子方式将一个整数进行自增。具体查看JDK8文档</p>
<h2 id="3、公平锁与非公平锁">3、公平锁与非公平锁</h2>
<ul>
<li><strong>公平锁</strong>：效率相对低</li>
<li><strong>非公平锁</strong>：效率高，但是线程容易饿死</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查看源码可知ReentrantLock默认是非公平锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4、可重入锁">4、可重入锁</h2>
<p>synchronized和ReentrantLock都是可重入锁</p>
<ul>
<li>sychronized是隐式锁，不用手工上锁与解锁，而ReentrantLock为显示锁，需要手工上锁与解锁</li>
<li>可重入锁也叫递归锁</li>
<li>可以有效避免死锁</li>
</ul>
<h2 id="5、自旋锁-spinlock">5、自旋锁(spinlock)</h2>
<p>自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU；</p>
<p>自旋锁的底层是CAS，CAS 的全称为 Compare-And-Swap，它是一条CPU并发原语。它的功能是判断内存某个位置的值是否为预期值，如果是则更改为新的值，整个过程是原子的。</p>
<p>CAS并发原语体现在JAVA语言中就是 sun.misc.Unsafe类中的各个方法。调用UnSafe类中的CAS方法，JVM会帮我们实现出CAS汇编指令。UnSafe是CAS的核心类，由于Java方法无法直接访问底层系统，需要通过本地（native）方法来访问，UnSafe相当于一个后门，基于该类可以直接操作特定内存的数据，Unsafe类存在于 sun.misc包中，其内部方法操作可以像C的指针一样直接操作内存，因为Java中CAS操作的执行依赖于Unsafe类的方法。</p>
<h2 id="6、读写锁">6、读写锁</h2>
<p><strong>独占锁(写锁)</strong>：指该锁一次只能被一个线程锁持有。对于ReentranrLock和 Synchronized 而言都是独占锁</p>
<p><strong>共享锁(读锁)</strong>：该锁可被多个线程所持有</p>
<p>ReentrantReadWriteLock其读锁时共享锁，写锁是独占锁，读锁的共享锁可保证并发读是非常高效的</p>
<h2 id="7、死锁">7、死锁</h2>
<p>产生死锁主要原因：</p>
<ul>
<li>系统资源不足</li>
<li>进程运行推进的顺序不合适</li>
<li>资源分配不当</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/f348b7ee0e354487be8d7049eb8e6ed2.png" alt><br>
验证是否是死锁：</p>
<ul>
<li><code>jps -l</code>类似于linux中的ps -ef查看进程号，定位进程号</li>
<li><code>jstack 进程号</code>自带的堆栈跟踪工具死锁查看</li>
</ul>
<h2 id="8、JUC三大辅助类">8、JUC三大辅助类</h2>
<p>减少计数<code>CountDownLatch</code></p>
<p>循环栅栏<code>CyclicBarrier</code></p>
<p>信号灯<code>Semaphore</code></p>
<h3 id="8-1-CountDownLatch">8.1 CountDownLatch</h3>
<blockquote>
<p>CountDownLatch 类可以设置一个计数器，然后通过 countDown 方法来进行减 1 的操作，使用 await 方法等待计数器不大于 0，然后继续执行 await 方法之后的语句</p>
</blockquote>
<p><strong>构造方法</strong></p>
<p><code>CountDownLatch(int count)</code>构造一个用给定计数初始化的CountDownLatch</p>
<p><strong>两个常用的主要方法</strong><br>
<code>await()</code> 使当前线程在锁存器倒计数至零之前一直在等待，除非线程被中断<br>
<code>countDown()递</code>减锁存器的计数，如果计数达到零，将释放所有等待的线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">//6个同学陆续离开教室之后，班长锁门</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建CountDownLatch对象，设置初始值</span></span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">6</span>);</span><br><span class="line">        <span class="comment">//6个同学陆续离开教室之后</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">" 号同学离开了教室"</span>);</span><br><span class="line">                <span class="comment">//计数  -1</span></span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//等待</span></span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">" 班长锁门走人了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-2-CyclicBarrier">8.2 CyclicBarrier</h3>
<blockquote>
<p>CyclicBarrier 的构造方法第一个参数是目标障碍数，每次执行 CyclicBarrier 一次障碍数会加一，如果达到了目标障碍数，才会执行 cyclicBarrier.await()之后的语句。可以将 CyclicBarrier 理解为加 1 操作</p>
</blockquote>
<p><strong>构造方法</strong><br>
<code>CyclicBarrier(int parties，Runnable barrierAction)</code>创建一个新的CyclicBarrier，它将在给定数量的参与者（线程）处于等待状态时启动，并在启动barrier时执行给定的屏障操作，该操作由最后一个进入barrier的线程操作</p>
<p><strong>常用的方法</strong><br>
await()在所有的参与者都已经在此barrier上调用await方法之前一直等待</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建固定值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUMBER = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建CyclicBarrier</span></span><br><span class="line">        CyclicBarrier cyclicBarrier =</span><br><span class="line">                <span class="keyword">new</span> CyclicBarrier(NUMBER,()-&gt;&#123;</span><br><span class="line">                    System.out.println(<span class="string">"集齐7颗龙珠就可以召唤神龙"</span>);</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//集齐七颗龙珠过程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">7</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">" 星龙被收集到了"</span>);</span><br><span class="line">                    <span class="comment">//等待</span></span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-3-Semaphore">8.3 Semaphore</h3>
<blockquote>
<p>一个计数信号量，从概念上将，信号量维护了一个许可集，如有必要，在许可可用前会阻塞每一个acquire()，然后在获取该许可。每个release()添加一个许可，从而可能释放一个正在阻塞的获取者。但是，不使用实际的许可对象，Semaphore只对可用许可的号码进行计数，并采取相应的行动</p>
</blockquote>
<p><strong>构造方法</strong><br>
<code>Semaphore(int permits)</code>创建具有给定的许可数和非公平的公平设置的Semapore</p>
<p><strong>具体方法</strong><br>
<code>acquire()</code>从此信号量获取一个许可，在提供一个许可前一直将线程阻塞，否则线程被中断<br>
<code>release()</code>释放一个许可，将其返回给信号量</p>
<p>设置许可数量Semaphore semaphore = new Semaphore(3)；一般acquire(）都会抛出异常，release在finally中执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建Semaphore，设置许可数量</span></span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//模拟6辆汽车</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//抢占</span></span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">" 抢到了车位"</span>);</span><br><span class="line">                    <span class="comment">//设置随机停车时间</span></span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">5</span>));</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">" ------离开了车位"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//释放</span></span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="9、线程局部变量">9、线程局部变量</h2>
<blockquote>
<p>ThreadLocal是解决线程安全问题一个很好的思路，它通过为每个线程提供一个独立的变量副本解决了变量并发访问的冲突问题。在很多情况下，ThreadLocal比直接使用synchronized同步机制解决线程安全问题更简单，更方便，且结果程序拥有更高的并发性。</p>
</blockquote>
<p>线程间共享变量有风险，而使用ThreadLocal辅助类可以为各个线程提供各自的实例，例如时间格式化类<code>SimpleDateFormat</code>是线程不安全的，并发访问会出现混乱，而使用同步锁开销又很大，这时候就可以使用<code>ThreadLocal</code>是最方便高效的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用ThreadLocal处理simplDateFormat线程不安全</span></span><br><span class="line"><span class="comment"> * SimpleDateFormat在多线程情况下会出现线程不安全的情况，故用ThreadLoacl 处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用了JUC辅助类</span></span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                ThreadLocal&lt;SimpleDateFormat&gt; dateFormat = ThreadLocal.withInitial(() -&gt; <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>));</span><br><span class="line">                String format = dateFormat.get().format(<span class="keyword">new</span> Date());</span><br><span class="line">                System.out.println(format);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">            ).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(end - start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>四、线程安全的集合</h1>
<h2 id="1、线程不安全集合">1、线程不安全集合</h2>
<p>平时使用的ArrayList、HashSet、HashMap等方法虽然运行速度快，但是都是现成不安全的集合，在多线程运行时，可能会产生<code>java.util.ConcurrentModificationException</code>并发修改异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建ArrayList集合</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">30</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="comment">//向集合添加内容</span></span><br><span class="line">                <span class="comment">//故障原因add方法没有加锁</span></span><br><span class="line">                list.add(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">8</span>));</span><br><span class="line">                <span class="comment">//从集合获取内容</span></span><br><span class="line">                System.out.println(list);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="2、集合的线程安全类">2、集合的线程安全类</h2>
<h3 id="2-1-Vector和Hashtable">2.1 Vector和Hashtable</h3>
<p>通过list和map实现的线程安全类，通过查看源码可发现是在方法中添加了<code>synchronized</code>关键字，现在用的较少(不推荐)</p>
<h3 id="2-2-Collections">2.2 Collections</h3>
<p>Collections类中的很多方法都是static静态，其中有一个方法是返回指定列表支持的同步（线程安全的）列表为<code>synchronizedList(List &lt;T&gt; list)</code>，通过包装获得线程安全</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br></pre></td></tr></table></figure>
<p>此方法也比较古老，很少使用</p>
<h3 id="2-3-CopyOnWriteArrayList">2.3 CopyOnWriteArrayList</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>涉及的底层原理为<strong>写时复制技术</strong>，支持读多写少的并发情况</p>
<ul>
<li>读的时候并发（多个线程操作）</li>
<li>写的时候独立，先复制相同的空间到某个区域，将其写到新区域，旧新合并，并且读新区域（每次加新内容都写到新区域，覆盖合并之前旧区域，读取新区域添加的内容）</li>
</ul>
<h3 id="2-4-CopyOnWriteArraySet">2.4 CopyOnWriteArraySet</h3>
<p>该类是HashSet的实现类，同样使用HashSet类，也会出现线程不安全</p>
<p><code>Set&lt;String&gt; set = new CopyOnWriteArraySet&lt;&gt;();</code></p>
<h3 id="2-5-ConcurrentHashMap">2.5 ConcurrentHashMap</h3>
<p><code>ConcurrentHashMap</code>类是HashMap的实现类，保证线程安全以及效率</p>
<h2 id="3、阻塞队列">3、阻塞队列</h2>
<h3 id="3-1-介绍">3.1 介绍</h3>
<p>与普通队列不同，阻塞队列是<strong>共享队列</strong>（多线程操作），一端输入一端输出，不能无限放队列，满了之后就会进入阻塞，取出也同理，在多线程环境下，程序员不必自己去控制这些细节。阻塞队列有以下几点特点：</p>
<ul>
<li>队列是空的，从队列中获取元素的操作将会被阻塞</li>
<li>当队列是满的，从队列中添加元素的操作将会被阻塞</li>
<li>试图从空的队列中获取元素的线程将会被阻塞，直到其他线程往空的队列插入新的元素</li>
<li>试图向已满的队列中添加新元素的线程将会被阻塞，直到其他线程从队列中移除一个或多个元素或者完全清空，使队列变得空闲起来并后续新增</li>
</ul>
<h3 id="3-2-阻塞队列种类">3.2 阻塞队列种类</h3>
<ul>
<li>
<p><strong>ArrayBlockingQueue</strong></p>
<blockquote>
<p>基于数组的阻塞队列，由数组结构组成的有界阻塞队列</p>
</blockquote>
<p>ArrayBlockingQueue在生产者放入数据和消费者获取数据，都是共用同一个锁对象，无法并行</p>
</li>
<li>
<p><strong>LinkedBlockingQueue</strong></p>
<blockquote>
<p>基于链表的阻塞队列，由链表结构组成的有界（但大小默认值为integer.MAX_VALUE）阻塞队列</p>
</blockquote>
<p>能够高效的处理并发数据的原因，是因为其对于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能</p>
</li>
<li>
<p><strong>DelayQueue</strong></p>
<blockquote>
<p>使用优先级队列实现的延迟无界阻塞队列</p>
</blockquote>
<p>DelayQueue 中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。DelayQueue 是一个没有大小限制的队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞</p>
</li>
<li>
<p><strong>PriorityBlockingQueue</strong></p>
<blockquote>
<p>基于优先级的阻塞队列，支持优先级排序的无界阻塞队列</p>
</blockquote>
<p>不会阻塞数据生产者，而只会在没有可消费的数据时，阻塞数据的消费者</p>
</li>
<li>
<p><strong>SynchronousQueue</strong></p>
<blockquote>
<p>一种无缓冲的等待队列，相对于有缓冲的 BlockingQueue 来说，少了一个缓冲区不存储元素的阻塞队列，也即单个元素的队列</p>
</blockquote>
<p>• 公平模式：SynchronousQueue 会采用公平锁，并配合一个 FIFO 队列来阻塞<br>
多余的生产者和消费者，从而体系整体的公平策略；<br>
• 非公平模式（SynchronousQueue 默认）：SynchronousQueue 采用非公平锁，同时配合一个 LIFO 队列来管理多余的生产者和消费者</p>
</li>
<li>
<p><strong>LinkedTransferQueue</strong></p>
<blockquote>
<p>由链表结构组成的无界阻塞 TransferQueue 队列，由链表组成的无界阻塞队列</p>
</blockquote>
<p>预占模式，意思就是消费者线程取元素时，如果队列不为空，则直接取走数据，若队列为空，生成一个节点（节点元素为 null）入队，消费者线程被等待在这个节点上，生产者线程入队时发现有一个元素为 null 的节点，生产者线程就不入队了，直接就将元素填充到该节点，并唤醒该节点等待的线程，被唤醒的消费者线程取走元素，从调用的方法返回</p>
</li>
<li>
<p><strong>LinkedBlockingDeque</strong></p>
<blockquote>
<p>由链表组成的双向阻塞队列</p>
</blockquote>
<ul>
<li>插入元素时: 如果当前队列已满将会进入阻塞状态，一直等到队列有空的位置时再该元素插入，该操作可以通过设置超时参数，超时后返回 false 表示操作失败，也可以不设置超时参数一直阻塞，中断后抛出 InterruptedException异常</li>
<li>读取元素时: 如果当前队列为空会阻塞住直到队列不为空然后返回元素，同样可以通过设置超时参数</li>
</ul>
</li>
</ul>
<h3 id="3-3-阻塞队列常用API">3.3 阻塞队列常用API</h3>
<table>
<thead>
<tr>
<th>方法类型</th>
<th>抛出异常</th>
<th>特殊值</th>
<th>阻塞</th>
<th>超时</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入方法</td>
<td>add(e)</td>
<td>offer(e)</td>
<td>put(e)</td>
<td>offer(e,time.unit)</td>
</tr>
<tr>
<td>移除方法</td>
<td>remove()</td>
<td>poll()</td>
<td>take()</td>
<td>poll(time.unit)</td>
</tr>
<tr>
<td>检查方法</td>
<td>element()</td>
<td>peek()</td>
<td>不可用</td>
<td>不可用</td>
</tr>
</tbody>
</table>
<p><strong>抛出异常</strong></p>
<ul>
<li>当阻塞队列满时，再往队列里add插入元素会抛llegalstateException.Queue full</li>
<li>当阻塞队列空时，再往队列里remove移除元素会抛NoSuchElementException</li>
</ul>
<p><strong>特殊值</strong></p>
<ul>
<li>插入方法，成功ture失败false</li>
<li>移除方法，成功返回出队列的元素，队列里没有就返回null</li>
</ul>
<p><strong>阻塞</strong></p>
<ul>
<li>当阻塞队列满时，生产者线程继续往队列里put元素，队列会一直阻塞生产者线程直到put数据or响应中断退出</li>
<li>当阻塞队列空时，消费者线程试图从队列里take元素，队列会一直阻塞消费者线程直到队列可用</li>
</ul>
<p><strong>超时退出</strong></p>
<ul>
<li>当阻塞队列满时，队列会阻塞生产者线程一定时间，超过限时后生产者线程会退出</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//举例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 队列大小</span></span><br><span class="line">        ArrayBlockingQueue blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        System.out.println(blockingQueue.add(<span class="string">"a"</span>));</span><br><span class="line">        System.out.println(blockingQueue.add(<span class="string">"b"</span>));</span><br><span class="line">        System.out.println(blockingQueue.add(<span class="string">"c"</span>));</span><br><span class="line">        System.out.println(blockingQueue.element()); <span class="comment">// 检测队列队首元素！</span></span><br><span class="line">        <span class="comment">// public E remove()  返回值E，就是移除的值</span></span><br><span class="line">        System.out.println(blockingQueue.remove());  <span class="comment">//a</span></span><br><span class="line">        System.out.println(blockingQueue.remove());  <span class="comment">//b</span></span><br><span class="line">        System.out.println(blockingQueue.remove());  <span class="comment">//c </span></span><br><span class="line">        <span class="comment">// java.util.NoSuchElementException</span></span><br><span class="line">        System.out.println(blockingQueue.remove());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1>五、线程池与异步计算</h1>
<h2 id="1、Java线程池">1、Java线程池</h2>
<h3 id="1-1-Java线程池概述">1.1 Java线程池概述</h3>
<p><strong>线程池（英语：thread pool）</strong>：一种线程使用模式。线程过多会带来调度开销，进而影响缓存局部性和整体性能。而线程池维护着多个线程，等待着监督管理者分配可并发执行的任务。这避免了在处理短时间任务时创建与销毁线程的代价。线程池不仅能够保证内核的充分利用，还能防止过分调度</p>
<p><strong>特点：</strong></p>
<ul>
<li>降低资源消耗: 通过重复利用已创建的线程降低线程创建和销毁造成的销耗。</li>
<li>提高响应速度: 当任务到达时，任务可以不需要等待线程创建就能立即执行。</li>
<li>提高线程的可管理性: 线程是稀缺资源，如果无限制的创建，不仅会销耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ul>
<p><strong>具体架构:</strong><br>
Java 中的线程池是通过 Executor 框架实现的，该框架中用到了 Executor，Executors，ExecutorService，ThreadPoolExecutor 这几个类。Java提供了一个工厂类来构造我们需要的线程池，这个工厂类就是 Executors 。这里主要讲4个创建线程池的方法，即</p>
<ul>
<li>newCachedThreadPool()</li>
<li>newFixedThreadPool(int nThreads)</li>
<li>newScheduledThreadPool(int corePoolSize)</li>
<li>newSingleThreadExecutor()</li>
</ul>
<h3 id="1-2-newCachedThreadPool">1.2 newCachedThreadPool()</h3>
<p>创建缓存线程池。缓存的意思就是这个线程池会<strong>根据需要创建新的线程</strong>，在有新任务的时候会优先使用先前创建出的线程。线程一旦创建了就一直在这个池子里面了，执行完任务后后续还有任务需要会<strong>重用这个线程</strong>，若是<strong>线程不够用了再去新建线程</strong>，60秒线程空闲就会被回收</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每次发布任务前根据奇偶不同等待一段时间，如1s，这样就会创建两个线程</span></span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行任务</span></span><br><span class="line">    cachedThreadPool.execute(() -&gt; System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + index));</span><br></pre></td></tr></table></figure>
<p>注意这里的线程池是<strong>无限大的</strong>，并没有规定他的大小</p>
<h3 id="1-3-newFixedThreadPool-int-nThreads">1.3 newFixedThreadPool(int nThreads)</h3>
<p>创建定长线程池，参数是线程池的大小。也就是说，在同一时间执行的线程数量只能是 nThreads 这么多，这个线程池可以有效的控制最大并发数从而防止占用过多资源。超出的线程会放在线程池的一个<strong>无界队列里等待</strong>其他线程执行完。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<h3 id="1-4-newScheduledThreadPool-int-corePoolSize">1.4 newScheduledThreadPool(int corePoolSize)</h3>
<p>第3个坏处线程池的坏处就是缺乏定时执行功能，这个Scheduled代表是支持的，这个线程池也是定长的，参数 corePoolSize 就是线程池的大小，即在空闲状态下要保留在池中的线程数量。而要实现调度需要使用这个线程池的 schedule() 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 三秒后执行</span></span><br><span class="line">scheduledExecutorService.schedule(() -&gt; System.out.println(Thread.currentThread().getName() + <span class="string">": 我会在3秒后执行。"</span>),</span><br><span class="line">                <span class="number">3</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>
<h3 id="1-5-newSingleThreadExecutor">1.5 newSingleThreadExecutor()</h3>
<p>创建<strong>单线程池</strong>，只使用<strong>一个线程</strong>来执行任务。但是它与 <code>newFixedThreadPool(1, threadFactory)</code> 不同，它会<strong>保证创建的这个线程池不会被重新配置为使用其他的线程</strong>，也就是说这个线程池里的线程始终如一。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br></pre></td></tr></table></figure>
<h3 id="1-6-线程池的拒绝策略">1.6 线程池的拒绝策略</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RejectedExecutionHandler rejected = <span class="keyword">null</span>;</span><br><span class="line">rejected = <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy();<span class="comment">//默认，队列满了丢任务，抛出异常</span></span><br><span class="line">rejected = <span class="keyword">new</span> ThreadPoolExecutor.DiscardPolicy();<span class="comment">//队列满了丢任务，不抛出异常[如果允许任务丢失这是最好的]</span></span><br><span class="line">rejected = <span class="keyword">new</span> ThreadPoolExecutor.DiscardOldestPolicy();<span class="comment">//将最早进入队列的任务删，之后再尝试加入队列</span></span><br><span class="line">rejected = <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy();<span class="comment">//如果添加到线程池失败，那么主线程会自己去执行该任务，回退</span></span><br></pre></td></tr></table></figure>
<h3 id="1-7-自定义线程池">1.7 自定义线程池</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// public ThreadPoolExecutor(int corePoolSize,</span></span><br><span class="line">        <span class="comment">// int maximumPoolSize,</span></span><br><span class="line">        <span class="comment">// long keepAliveTime,</span></span><br><span class="line">        <span class="comment">// TimeUnit unit,</span></span><br><span class="line">        <span class="comment">// BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line">        <span class="comment">// ThreadFactory threadFactory,</span></span><br><span class="line">        <span class="comment">// RejectedExecutionHandler handler);  </span></span><br><span class="line"></span><br><span class="line">ExecutorService threadPool = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                <span class="number">2</span>,</span><br><span class="line">                <span class="number">5</span>,</span><br><span class="line">                <span class="number">2L</span>,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>),</span><br><span class="line">                Executors.defaultThreadFactory(),</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy()</span><br><span class="line">        );</span><br></pre></td></tr></table></figure>
<h3 id="1-8-线程池的关闭">1.8 线程池的关闭</h3>
<p>线程池启动后需要手动关闭，否则会一直不结束</p>
<ul>
<li><code>shutdown()</code> : 将线程池状态置成 <code>SHUTDOWN</code>，此时<strong>不再接受新的任务</strong>，<strong>等待线程池中已有任务执行完成后结束</strong>；</li>
<li><code>shutdownNow()</code> : 将线程池状态置成 <code>SHUTDOWN</code>，将线程池中<strong>所有线程中断</strong>（调用线程的 <code>interrupt()</code> 操作），清空队列，并返回<strong>正在等待执行的任务列表</strong>。</li>
</ul>
<p>并且它还提供了查看线程池是否关闭和是否终止的方法，分别为 <code>isShutdown()</code> 和 <code>isTerminated()</code> 。</p>
<h2 id="2、Fork与Join分支">2、Fork与Join分支</h2>
<blockquote>
<p>从JDK1.7开始，Java提供Fork/Join框架用于并行执行任务，它的思想就是讲一个大任务分割成若干小任 务，最终汇总每个小任务的结果得到这个大任务的结果。**工作窃取（work-stealing）**算法是指某个线程从其他队列里窃取任务来执行，率先完成任务的线程会去未完成任务的线程对应的队列里窃取一个任务来执行，被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行。</p>
</blockquote>
<p><strong>核心类</strong></p>
<p><strong>ForkJoinPool</strong>：WorkQueue是一个ForkJoinPool中的内部类，它是线程池中线程的工作队列的一个封装，支持任务窃取。<strong>ForkJoinTask</strong> 需要通过 ForkJoinPool 来执行</p>
<p><strong>主要方法</strong></p>
<ul>
<li><code>fork()</code> 在当前线程运行的线程池中安排一个异步执行。简单的理解就是再创建一个子任务。</li>
<li><code>join()</code> 当任务完成的时候返回计算结果。</li>
<li><code>invoke() </code>开始执行任务，如果必要，等待计算完成。</li>
</ul>
<p><strong>子类Recursive：递归</strong></p>
<ul>
<li><strong>RecursiveAction</strong>：用于没有返回结果的任务</li>
<li><strong>RecursiveTask</strong>：用于有返回结果的任务</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拆分差值不能超过10，计算10以内运算</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer VALUE = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> begin ;<span class="comment">//拆分开始值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end;<span class="comment">//拆分结束值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> result ; <span class="comment">//返回结果</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建有参数构造</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyTask</span><span class="params">(<span class="keyword">int</span> begin,<span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.begin = begin;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拆分和合并过程</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断相加两个数值是否大于10</span></span><br><span class="line">        <span class="keyword">if</span>((end-begin)&lt;=VALUE) &#123;</span><br><span class="line">            <span class="comment">//相加操作</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt;=end; i++) &#123;</span><br><span class="line">                result = result+i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//进一步拆分</span></span><br><span class="line">            <span class="comment">//获取中间值</span></span><br><span class="line">            <span class="keyword">int</span> middle = (begin+end)/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">//拆分左边</span></span><br><span class="line">            MyTask task01 = <span class="keyword">new</span> MyTask(begin,middle);</span><br><span class="line">            <span class="comment">//拆分右边</span></span><br><span class="line">            MyTask task02 = <span class="keyword">new</span> MyTask(middle+<span class="number">1</span>,end);</span><br><span class="line">            <span class="comment">//调用方法拆分</span></span><br><span class="line">            task01.fork();</span><br><span class="line">            task02.fork();</span><br><span class="line">            <span class="comment">//合并结果</span></span><br><span class="line">            result = task01.join()+task02.join();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//创建MyTask对象</span></span><br><span class="line">        MyTask myTask = <span class="keyword">new</span> MyTask(<span class="number">0</span>,<span class="number">100</span>);</span><br><span class="line">        <span class="comment">//创建分支合并池对象</span></span><br><span class="line">        ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        ForkJoinTask&lt;Integer&gt; forkJoinTask = forkJoinPool.submit(myTask);</span><br><span class="line">        <span class="comment">//获取最终合并之后结果</span></span><br><span class="line">        Integer result = forkJoinTask.invoke();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        <span class="comment">//关闭池对象</span></span><br><span class="line">        forkJoinPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3、异步回调">3、异步回调</h2>
<h3 id="3-1-函数式接口简介">3.1 函数式接口简介</h3>
<p>函数式接口可以参考<a href="https://blog.csdn.net/lemon_TT/article/details/119415154" target="_blank" rel="noopener">java8常用新特性</a>，这里主要介绍几种函数式接口，Callable、Runnable、Future、CompletableFuture和FutureTask</p>
<h3 id="3-2-Callable和Runnable异同">3.2 Callable和Runnable异同</h3>
<p>两个接口的定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>相同点</strong></p>
<p>都是接口，都可以编写多线程程序，都可以通过线程池启动线程</p>
<p><strong>不同点</strong></p>
<p>Runnable没有返回值，Callable可以返回执行结果，是个泛型；Callable接口的call()方法允许抛出异常；而Runnable接口的run()方法的异常只能在内部消化，不能继续上抛；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Min</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Max</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="meta">@SneakyThrows</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        executorService.submit(<span class="keyword">new</span> Min());</span><br><span class="line">        executorService.submit(<span class="keyword">new</span> Max());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-Future类">3.3 Future类</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Since:1.5</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//取消任务的执行,参数指定是否立即中断任务执行，或者等等任务结束</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line">    <span class="comment">//任务是否已经取消,任务正常完成前将其取消，则返回 true</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//任务是否已经完成。需要注意的是如果任务正常终止、异常或取消，都将返回true</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//等待任务执行结束，然后获得V类型的结果。InterruptedException 线程被中断异常， ExecutionException任务执行异常,如果任务被取消，还会抛出CancellationException</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line">    <span class="comment">//同上面的get功能一样，多了设置超时时间。超时会抛出TimeoutException</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般情况下，我们会结合Callable和Future一起使用，通过ExecutorService的submit方法执行Callable，并返回Future。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException, TimeoutException </span>&#123;</span><br><span class="line">       ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line">       <span class="comment">//Lambda 是一个 callable， 提交后便立即执行，这里返回的是 FutureTask 实例</span></span><br><span class="line">       Future&lt;String&gt; future = executor.submit(() -&gt; &#123;</span><br><span class="line">           System.out.println(<span class="string">"running task"</span>);</span><br><span class="line">           Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">           <span class="keyword">return</span> <span class="string">"return task"</span>;</span><br><span class="line">       &#125;);</span><br><span class="line">       future.get(<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>当然Future模式也有它的缺点，它没有提供通知的机制，我们无法得知Future什么时候完成。如果要在<code>future.get()</code>的地方等待future返回的结果，那只能通过<code>isDone()</code>轮询查询。</p>
<h3 id="3-4-CompletableFuture类">3.4 CompletableFuture类</h3>
<blockquote>
<p><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html</a></p>
</blockquote>
<p>CompletableFuture能够将回调放到与任务不同的线程中执行，也能将回调作为继续执行的同步函数，在与任务相同的线程中执行。它避免了传统回调最大的问题，那就是能够将控制流分离到不同的事件处理器中。CompletableFuture弥补了Future模式的缺点。在异步的任务完成后，需要用其结果继续操作时，无需等待。可以直接通过thenAccept、thenApply、thenCompose等方式将前面异步处理的结果交给另外一个异步事件处理线程来处理。</p>
<p><code>CompletableFuture</code>的静态工厂方法，其中<code>runAsync</code> 和<code> supplyAsync</code> 方法的区别是<code>runAsync</code>返回的<code>CompletableFuture</code>是没有返回值的。</p>
<table>
<thead>
<tr>
<th><strong>方法名</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>runAsync(Runnable runnable)</td>
<td>使用ForkJoinPool.commonPool()作为它的线程池执行异步代码</td>
</tr>
<tr>
<td>runAsync(Runnable runnable, Executor executor)</td>
<td>使用指定的thread pool执行异步代码</td>
</tr>
<tr>
<td>supplyAsync(Supplier supplier)</td>
<td>使用ForkJoinPool.commonPool()作为它的线程池执行异步代码，异步操作有返回值</td>
</tr>
<tr>
<td>supplyAsync(Supplier supplier, Executor executor)</td>
<td>使用指定的thread pool执行异步代码，异步操作有返回值</td>
</tr>
<tr>
<td>allOf(CompletableFuture&lt;?&gt;… cfs)</td>
<td>等待所有任务完成，构造后CompletableFuture完成</td>
</tr>
<tr>
<td>anyOf(CompletableFuture&lt;?&gt;… cfs)</td>
<td>只要有一个任务完成，构造后CompletableFuture就完成</td>
</tr>
</tbody>
</table>
<p>对于变量的方法，常用有这几种方法</p>
<table>
<thead>
<tr>
<th><strong>方法名</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>complete(T t)</td>
<td>完成异步执行的话返回执行结果，若不是返回设置的值</td>
</tr>
<tr>
<td>completeExceptionally(Throwable ex)</td>
<td>完成异步执行的话返回执行结果，若不是返回一个异常</td>
</tr>
<tr>
<td>thenApply(Function&lt;? super T,? extends U&gt; fn)</td>
<td>返回一个新的CompletionStage，当这个阶段正常完成时，它将以这个阶段的结果作为所提供函数的参数执行</td>
</tr>
<tr>
<td>thenAccept(Consumer&lt;? super T&gt; action)</td>
<td>返回一个新的CompletionStage，当这个阶段正常完成时，返回为void</td>
</tr>
<tr>
<td>handle(BiFunction&lt;? super T, Throwable, ? extends U&gt; fn)</td>
<td>处理结果或错误，生成一个新结果返回</td>
</tr>
<tr>
<td>whenCompleteAsync(BiConsumer&lt;? super T, ? super Throwable&gt; action)</td>
<td>处理结果或错误，返回为void</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException, TimeoutException </span>&#123;</span><br><span class="line">        CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; <span class="string">"Hello"</span>);</span><br><span class="line">        <span class="comment">//在这里执行返回值为World</span></span><br><span class="line">        <span class="comment">// future.complete("World");</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在这里执行结果为Hello</span></span><br><span class="line">        future.complete(<span class="string">"World"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//get() 方法会抛出经检查的异常，可被捕获，自定义处理或者直接抛出。join() 会抛出未经检查的异常。</span></span><br><span class="line">            System.out.println(future.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//thenApplyhello shawn</span></span><br><span class="line"><span class="comment">// thenAccept shawn</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    <span class="comment">//thenApply</span></span><br><span class="line">    CompletableFuture&lt;String&gt; cfuture =</span><br><span class="line">            CompletableFuture.supplyAsync(() -&gt; <span class="string">"shawn"</span>).thenApply(data -&gt; <span class="string">"hello "</span>+ data);</span><br><span class="line">    System.out.println(<span class="string">"thenApply"</span> + cfuture.get());</span><br><span class="line">    <span class="comment">//thenAccept</span></span><br><span class="line">    CompletableFuture.supplyAsync(() -&gt; <span class="string">"thenAccept shawn"</span>).thenAccept(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-5-FutureTask">3.5 FutureTask</h3>
<blockquote>
<p><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/FutureTask.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/FutureTask.html</a></p>
</blockquote>
<p>Future是一个接口，是无法生成一个实例的，所以又有了FutureTask。FutureTask实现了RunnableFuture接口，RunnableFuture接口又实现了Runnable接口和Future接口。所以FutureTask既可以被当做Runnable来执行，也可以被当做Future来获取Callable的返回结果。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java注解与反射</title>
    <url>/posts/20d0a84c.html</url>
    <content><![CDATA[<h1>一、注解Annotation</h1>
<h2 id="1、注解介绍">1、注解介绍</h2>
<ul>
<li>Annotation 是从JDK5.0开始引入的新技术</li>
<li>Annotation不是程序本身，但可以对程序作出解释(和注释差不多) ，也可以被其他程序(编译器等)读取</li>
<li>Annotation注解是以<code>@注解名</code>在代码中存在的，还可以添加一些参数值 , 例如:<code>@SuppressWarnings(value=&quot;unchecked&quot;)</code></li>
<li>Annotation可以附加在package , class , method , ﬁeld 等上面 , 相当于给他们添加了额外的辅助信息，我们可以通过反射机制实现对这些元数据的访问</li>
</ul>
<a id="more"></a>
<h2 id="2、内置注解">2、内置注解</h2>
<p><strong>@Override</strong>定义在 java.lang.Override中 ，此注释只适用于修辞方法, 表示一个方法声明打算重写超类中的另一个方法声明；</p>
<p><strong>@Deprecated</strong>定义在java.lang.Deprecated中 ，此注释可以用于修辞方法 ，属性 ， 类 ，表示不鼓励程序员使用这样的元素 ，通常是因为它很危险或者存在更好的选择或者已经过时 ；</p>
<p><strong>@SuppressWarnings</strong>定义在java.lang.SuppressWarnings中，用来抑制编译时的警告信息。与前两个注释有所不同，你需要添加一个参数才能正确使用，这些参数都是已经定义好了的，我们选择性的使用就好了 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 还有很多类型</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"all"</span>)</span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="meta">@SuppressWarnings</span>(value=&#123;<span class="string">"unchecked"</span>,<span class="string">"deprecation"</span>&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="3、元注解">3、元注解</h2>
<blockquote>
<p>元注解的作用就是负责注解其他注解 ， Java定义了4个标准的meta-annotation类型，他们被用来提供对其他annotation类型作说明；这四种类型在<strong>java.lang.annotation</strong>包中可以找到 (<code>@Target</code> , <code>@Retention</code> , <code>@Documented </code>, <code>@Inherited</code> )</p>
</blockquote>
<p><strong>@Target</strong></p>
<p>描述注解的使用范围(即被描述的注解可以用在什么地方) ；ElementType类中存在常数<code>ANNOTATION_TYPE</code>，<code>CONSTRUCTOR</code>，<code>FIELD</code>，<code>LOCAL_VARIABLE</code>，<code>METHOD</code>，<code>PACKAGE</code>，<code>PARAMETER</code>，<code>TYPE</code>，和<code>TYPE_PARAMETER</code></p>
<p><strong>@Retention</strong></p>
<p>需要在什么级别保存该注释信息 , 用于描述注解的生命周期(SOURCE &lt; CLASS &lt; RUNTIME)</p>
<ul>
<li><code>RetentionPolicy.SOURCE</code>注释将被编译器丢弃 ；</li>
<li><code>RetentionPolicy.CLASS</code>注释将由编译器记录在类文件中，但不需要在运行时由VM保留。这是默认行为；</li>
<li><code>RetentionPolicy.RUNTIME</code>注释将由编译器记录在类文件中，并且由VM在运行时保留，因此可以反射地读取它们。</li>
</ul>
<p><strong>@Document</strong></p>
<p>说明该注解将被包含在javadoc中@Inherited：说明子类可以继承父类中的该注解</p>
<p><strong>@Inherited</strong></p>
<p>说明子类可以继承父类中的该注解</p>
<h2 id="4、自定义注解">4、自定义注解</h2>
<p>使用 @interface自定义注解时, 自动继承了<strong>java.lang.annotation.Annotation</strong>接口</p>
<ul>
<li><code>@interface</code>用来声明一个注解，格式：<code>public @interface 注解名 {定义内容 }</code></li>
<li>注解的每一个方法实际上是声明了一个配置参数</li>
<li>方法的名称就是参数的名称</li>
<li>返回值类型就是参数的类型 (返回值只能是基本类型Class ，String ，enum)</li>
<li>可以通过default来声明参数的默认值</li>
<li>如果只有一个参数成员 , 一般参数名为value</li>
<li>注解元素必须要有值，我们定义注解元素时，经常使用空字符串0作为默认值</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">annotationTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示定义</span></span><br><span class="line">    <span class="meta">@MyAnnotation</span>(value = <span class="string">"value"</span>,name = <span class="string">"shawn"</span>,age = <span class="number">18</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 默认名字一般是value</span></span><br><span class="line">    <span class="meta">@MyAnnotation</span>(<span class="string">"shawn"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义一个注解，其中用到了四个元注解</span></span><br><span class="line"><span class="meta">@Target</span>(value = &#123;ElementType.TYPE,ElementType.METHOD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(value = RetentionPolicy.RUNTIME) <span class="comment">//一般自定义注解，都选择RUNTIME;</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation&#123;</span><br><span class="line">    <span class="comment">// 参数类型，参数名</span></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">age</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>二、反射Refection</h1>
<h2 id="1、静态-VS-动态语言">1、静态 VS 动态语言</h2>
<p><strong>动态语言</strong>是一类在运行时可以改变其结构的语言：例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。通俗点说就是在运行时代码可以根据某些条件改变自身结构。主要动态语言：Object-C、C#、JavaScript、PHP、Python等。</p>
<p><strong>静态语言</strong>与动态语言相对应的，运行时结构不可变的语言就是静态语言。如Java、C、C++。Java不是动态语言，但Java可以称之为“准动态语言”。即Java有一定的动态性，我们可以利用反射机制获得类似动态语言的特性。Java的动态性让编程的时候更加灵活！</p>
<h2 id="2、反射概述">2、反射概述</h2>
<h3 id="1、概述">1、概述</h3>
<p>反射机制允许程序在执行期间借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在加载了类之后，在堆内存的方法区中，就产生了一个Class类型的对象（一个类只有一个Class对象）</span></span><br><span class="line"><span class="comment">// 该对象包含了完整的类的结构信息。我们可以通过该对象来看到类的完整的结构</span></span><br><span class="line"><span class="comment">// 这个对象就像是一个镜子一样，透过镜子看到类的结构，因此成为反射</span></span><br><span class="line">Class c = Class.forName(<span class="string">"java.lang.String"</span>);</span><br></pre></td></tr></table></figure>
<p><strong>正常方式</strong>：引入需要的&quot;包类&quot;名称&gt;通过new实例化&gt;取得实例化对象</p>
<p><strong>反射方式</strong>：实例化对象&gt;getClass()对象方法&gt;得到完整的&quot;包类&quot;名称</p>
<h3 id="2、功能与优缺点">2、功能与优缺点</h3>
<p><strong>反射有以下几点功能(不局限以下几点)：</strong></p>
<ul>
<li>在运行时判断任意一个对象所属的类</li>
<li>在运行时构造任意一个类的对象</li>
<li>在运行时判断任意一个类所具有的成员变量和方法</li>
<li>在运行时获取泛型信息</li>
<li>在运行时调用任意一个对象的成员变量和方法</li>
<li>在运行时处理注解</li>
<li>生成动态代理</li>
</ul>
<p><strong>反射优缺点：</strong></p>
<ul>
<li>优点：可以在运行时获得类的各种内容，进行反编译，对于Java这种先编译再运行的特点，能够让我们很方便的创建灵活的代码，这些代码可以在运行时进行装配，不用在组件之间进行代码之间的链接。</li>
<li>缺点：反射会消耗一定的系统资源，假如不需要动态的创建对象的时候，就不要使用反射；反射调用方法的时候可以忽略权限的检查，因此可能会破坏封装性而导致安全问题</li>
</ul>
<h2 id="3、反射Class类">3、反射Class类</h2>
<h3 id="1、Class详解">1、Class详解</h3>
<p><strong>Class类</strong>对于每个类而言，JRE都为其保留了一个不变的Class类型的对象。一个Class对象包含了特定某个结构的有关信息</p>
<ul>
<li>Class 本身也是一个类</li>
<li>Class 对象只能由系统建立对象</li>
<li>一个加载的类在 JVM 中只会有一个Class实例</li>
<li>一个Class对象对应的是一个加载到JVM中的一个.class文件每个类的实例都会记得自己是由哪个 Class 实例所生成</li>
<li>通过Class可以完整地得到一个类中的所有被加载的结构</li>
<li>Class类是Reﬂection的根源，针对任何你想动态加载、运行的类，唯有先获得相应的Class对象</li>
</ul>
<h3 id="2、反射常用API">2、反射常用API</h3>
<p><code>Class类</code> 代表类的实体，在运行的Java应用程序中表示类和接口</p>
<p><code>Field类</code> 代表类的成员变量（成员变量也称为类的属性）</p>
<p><code>Method类</code> 代表类的方法</p>
<p><code>Constructor类</code> 代表类的构造方法</p>
<ul>
<li><code>getField</code>、<code>getMethod</code>和<code>getCostructor</code>方法可以 获得指定名字的域、方法和构造器。</li>
<li><code>getFields</code>、<code>getMethods</code>和<code>getCostructors</code>方法可以 获得类提供的public域、方法和构造器数组，其中包括超类的共有成员。</li>
<li><code>getDeclatedFields</code>、<code>getDeclatedMethods</code>和<code>getDeclaredConstructors</code>方法可以 获得类中声明的全部域、方法和构造器，其中包括私有和受保护的成员，但不包括超类的成员。</li>
</ul>
<table>
<thead>
<tr>
<th><strong>方法名</strong></th>
<th><strong>功能说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>static ClassforName(String name)</td>
<td>返回指定类名name的Class对象</td>
</tr>
<tr>
<td>Object newInstance()</td>
<td>调用缺省构造函数，返回Class对象的一个实例</td>
</tr>
<tr>
<td>getName()</td>
<td>返回此Class对象所表示的实体（类，接口，数组类或void）的名称。</td>
</tr>
<tr>
<td>Class getSuperClass()</td>
<td>返回当前Class对象的父类的Class对象</td>
</tr>
<tr>
<td>Class[] getinterfaces()</td>
<td>获取当前Class对象的接口</td>
</tr>
<tr>
<td>ClassLoader getClassLoader()</td>
<td>返回该类的类加载器</td>
</tr>
<tr>
<td>Constructor[] getConstructors()</td>
<td>返回一个包含某些Constructor对象的数组</td>
</tr>
<tr>
<td>Method getMothed(String name,Class… T)</td>
<td>返回一个Method对象，此对象的形参类型为paramType</td>
</tr>
<tr>
<td>Field[] getDeclaredFields()</td>
<td>返回Field对象的一个数组</td>
</tr>
</tbody>
</table>
<h3 id="3、获取Class类的多种方式">3、<strong>获取Class类的多种方式</strong></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 若已知是具体的类，通过类的class属性获取，该方法最为安全可靠，程序性能最高：</span></span><br><span class="line">Class clazz1 = Person<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"><span class="comment">// 已知某个类的实例，调用该实例的getClass()方法获取Class对象：</span></span><br><span class="line">Class clazz2 = Person.getClass();</span><br><span class="line"><span class="comment">// 已知一个类的全名，且该类在类路径中，可通过Class类的静态方法forName()获取：</span></span><br><span class="line">Class clazz3 = Class.forName(…);</span><br><span class="line"><span class="comment">// 内置基本数据类型的包装类可以直接用</span></span><br><span class="line">Class clazz4 = Integer.TYPE;</span><br><span class="line"><span class="comment">// 还可以利用ClassLoader加载器</span></span><br></pre></td></tr></table></figure>
<p><strong>哪些类型可以有Class对象</strong></p>
<ul>
<li>class：外部类，成员(成员内部类，静态内部类)，局部内部类，匿名内部类</li>
<li>interface：接口</li>
<li>[]：数组</li>
<li>enum：枚举</li>
<li>annotation：注解@interface</li>
<li>primitive type：基本数据类型</li>
<li>void</li>
</ul>
<h2 id="4、Java内存模型">4、Java内存模型</h2>
<h3 id="1、Java内存划分">1、Java内存划分</h3>
<p><img src="https://gitee.com/LXT2017/Picbed/raw/master/noteimg/image.png" alt></p>
<h3 id="2、类的加载过程">2、类的加载过程</h3>
<p><strong>加载</strong></p>
<ul>
<li>将<strong>class</strong>文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构， 然后生成一个代表这个类的<strong>java.lang.Class</strong>对象.</li>
</ul>
<p>**链接：**将Java类的二进制代码合并到JVM的运行状态之中的过程。</p>
<ul>
<li>验证：确保加载的类信息符合JVM规范，没有安全方面的问题</li>
<li>准备：正式为类变量（static）分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配。</li>
<li>解析：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程。</li>
</ul>
<p><strong>初始化</strong></p>
<ul>
<li>执行类构造器()方法的过程。类构造器()方法是由编译期自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的。（类构造器是构造类信息的，不是构造该类对象的构造器）。</li>
<li>当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。</li>
<li>虚拟机会保证一个类的()方法在多线程环境中被正确加锁和同步</li>
</ul>
<p><img src="https://gitee.com/LXT2017/Picbed/raw/master/noteimg/image_1.png" alt></p>
<h3 id="3、分析类初始化">3、分析类初始化</h3>
<p><strong>类的主动引用</strong>（一定会发生类的初始化）</p>
<ul>
<li>当虚拟机启动，先初始化main方法所在的类</li>
<li>new一个类的对象</li>
<li>调用类的静态成员（除了ﬁnal常量）和静态方法</li>
<li>使用java.lang.reﬂect包的方法对类进行反射调用</li>
<li>当初始化一个类，如果其父类没有被初始化，则先会初始化它的父类</li>
</ul>
<p><strong>类的被动引用</strong>（不会发生类的初始化）</p>
<ul>
<li>当访问一个静态域时，只有真正声明这个域的类才会被初始化。如：当通过子类引用父类的静 态变量，不会导致子类初始化</li>
<li>通过数组定义类引用，不会触发此类的初始化</li>
<li>引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池中了）</li>
</ul>
<h3 id="4、类加载器的作用">4、类加载器的作用</h3>
<ul>
<li>类加载的作用：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口。</li>
<li>类缓存：标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间。不过JVM垃圾回收机制可以回收这些Class对象</li>
</ul>
<p><img src="https://gitee.com/LXT2017/Picbed/raw/master/noteimg/image_3.png" alt></p>
<ul>
<li>类加载器作用是用来把类(class)装载进内存的。JVM 规范定义了如下类型的类的加载器</li>
</ul>
<p><img src="https://gitee.com/LXT2017/Picbed/raw/master/noteimg/image_2.png" alt></p>
<h2 id="5、反射创建">5、反射创建</h2>
<h3 id="1、获取类加载器">1、获取类加载器</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zstu.sso;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestUser</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//获取系统类的加载器</span></span><br><span class="line">        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">        System.out.println(systemClassLoader);<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取系统类的加载器的父类加载器---&gt;扩展类加载器</span></span><br><span class="line">        ClassLoader parent = systemClassLoader.getParent();</span><br><span class="line">        System.out.println(parent);<span class="comment">//sun.misc.Launcher$ExtClassLoader@1540e19d</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取扩展类加载器的父类加载器---&gt;根加载器(c/c++)</span></span><br><span class="line">        ClassLoader parent1 = parent.getParent();</span><br><span class="line">        System.out.println(parent1);<span class="comment">//null</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//测试当前类是哪个加载器加载的：系统类加载器</span></span><br><span class="line">        ClassLoader classLoader = Class.forName(<span class="string">"com.zstu.sso.TestUser"</span>).getClassLoader();</span><br><span class="line">        System.out.println(classLoader);<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//测试JDK内置的类是谁加载的：根加载器</span></span><br><span class="line">        classLoader = Class.forName(<span class="string">"java.lang.Object"</span>).getClassLoader();</span><br><span class="line">        System.out.println(classLoader);<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//如何获得系统类加载器可以加载的路径</span></span><br><span class="line">        System.out.println(System.getProperty(<span class="string">"java.class.path"</span>));<span class="comment">//各种jdk/jre/jar包路径</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、获取类的运行时结构">2、获取类的运行时结构</h3>
<p>通过反射获取运行时类的完整结构：Field,Method,Constructor,Superclass,Interface,Annotation；另外反射获取内部类是需要用<code>$</code>隔开</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zstu.sso;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestUser</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, </span></span><br><span class="line"><span class="function">            NoSuchMethodException, NoSuchFieldException, </span></span><br><span class="line"><span class="function">            InvocationTargetException, IllegalAccessException, </span></span><br><span class="line"><span class="function">            InstantiationException </span>&#123;</span><br><span class="line">        Class user = Class.forName(<span class="string">"com.zstu.sso.User"</span>);</span><br><span class="line">        <span class="comment">//获得类的名字</span></span><br><span class="line">        System.out.println(user.getName());</span><br><span class="line">        System.out.println(user.getSimpleName());</span><br><span class="line">        System.out.println(<span class="string">"=============================="</span>);</span><br><span class="line">        <span class="comment">//获得类的属性</span></span><br><span class="line">        <span class="comment">//user.getFields()只能找到类的public属性</span></span><br><span class="line">        Field[] fields = user.getDeclaredFields(); <span class="comment">//找到全部属性</span></span><br><span class="line">        <span class="keyword">for</span>(Field field:fields) &#123;</span><br><span class="line">            System.out.println(field);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获得类的指定属性</span></span><br><span class="line">        Field field = user.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line">        System.out.println(field);</span><br><span class="line">        System.out.println(<span class="string">"=============================="</span>);</span><br><span class="line">        <span class="comment">//获得类的方法</span></span><br><span class="line">        Method[] methods = user.getMethods(); <span class="comment">//获得本类以及父类的所有public方法</span></span><br><span class="line">        <span class="keyword">for</span>(Method method:methods)&#123;</span><br><span class="line">            System.out.println(<span class="string">"所有的方法："</span>+method);</span><br><span class="line">        &#125;</span><br><span class="line">        methods = user.getDeclaredMethods(); <span class="comment">//获得本类的所有方法(包含私有方法)</span></span><br><span class="line">        <span class="keyword">for</span>(Method method:methods)&#123;</span><br><span class="line">            System.out.println(<span class="string">"本类的方法："</span>+method);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取指定方法</span></span><br><span class="line">        Method test = user.getDeclaredMethod(<span class="string">"test"</span>,<span class="keyword">null</span>);</span><br><span class="line">        Method test1 = user.getDeclaredMethod(<span class="string">"test1"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(test);</span><br><span class="line">        System.out.println(test1);</span><br><span class="line">        System.out.println(<span class="string">"=============================="</span>);</span><br><span class="line">        <span class="comment">//获取类的构造器</span></span><br><span class="line">        Constructor[] constructors = user.getConstructors(); <span class="comment">//获得public的构造器</span></span><br><span class="line">        <span class="keyword">for</span> (Constructor constructor : constructors) &#123;</span><br><span class="line">            System.out.println(<span class="string">"public构造器："</span>+constructor);</span><br><span class="line">        &#125;</span><br><span class="line">        constructors = user.getDeclaredConstructors(); <span class="comment">//获得所有构造器</span></span><br><span class="line">        <span class="keyword">for</span> (Constructor constructor : constructors) &#123;</span><br><span class="line">            System.out.println(<span class="string">"所有的构造器："</span>+constructor);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获得指定的构造器</span></span><br><span class="line">        Constructor constructor = user.getDeclaredConstructor(String<span class="class">.<span class="keyword">class</span>, <span class="title">String</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        System.out.println(constructor);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用某个实例化类的方法，会抛出InvocationTargetException, IllegalAccessException,InstantiationException</span></span><br><span class="line">        test.invoke(user.newInstance());</span><br><span class="line">        test1.invoke(user.newInstance(),<span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我执行了test的方法啦"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">(String test1)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我执行了test1的方法啦，内容是"</span> + test1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3、动态创建对象执行方法">3、动态创建对象执行方法</h3>
<ul>
<li>可以通过Class对象创建该类的对象，然后执行该类的方法</li>
<li>如何利用反射机制动态创建对象：
<ol>
<li>调用Class对象的**newInstance()**方法，要求类必须有一个无参数的构造器，而且类的构造器的访问权限足够；</li>
<li>当类没有无参的构造器的时候，只要在操作的过程中明确指定类中的构造器即可创建对象，步骤如下：首先，通过Class对象获取本类的指定形参类型的构造器；第二步，向构造器的形参中传递一个对象数组进去，里面包含了构造器所需的各个参数；第三步，通过Constructor实例化对象；</li>
</ol>
</li>
<li>通过**Object invoke(Object obj,Object[] args)**调用指定的方法：
<ol>
<li>Object对应原方法的返回值，若原方法无返回值，此时返回null；</li>
<li>若原方法为静态方法，则obj参数可以为null；</li>
<li>若原方法形参列表为空，则args参数可以为null；</li>
<li>（★）若原方法声明为private，则在调用invoke方法之前，需要先调用**setAccessible(true)**方法，即可访问private的方法；另外反射执行的速度比普通方式要慢很多，如果非得要用反射，而且是多次用的情况下，可以通过关闭检测来提高速度</li>
</ol>
</li>
</ul>
<h3 id="4、setAccessible">4、setAccessible</h3>
<ul>
<li>Method和Field、Constructor对象都有setAccessible()方法。</li>
<li>setAccessible作用是启动和禁用访问安全检查的开关。</li>
<li>参数值为true则指示反射的对象在使用时应该取消Java语言访问检查。</li>
<li>提高反射的效率。如果代码中必须用反射，而该句代码需要频繁的被调用，那么请设置为true。</li>
<li>使得原本无法访问的私有成员也可以访问</li>
<li>参数值为false则指示反射的对象应该实施Java语言访问检查</li>
</ul>
<h1>三、反射实战</h1>
<blockquote>
<p>java8在线参考文档：<a href="https://docs.oracle.com/javase/8/docs/api/" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/</a></p>
</blockquote>
<h2 id="1、获取泛型信息">1、获取泛型信息</h2>
<p>对于泛型，Java采用泛型擦除的机制来引入泛型，Java中的泛型仅仅是给编译器javac使用的，确保数据的安全性和免去强制类型转换的问题，但是，一旦编译成功，所有和泛型有关的类型全部擦除；但是泛型的信息，还是会在加载的过程中存储在Class中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zstu.sso;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestUser</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException </span>&#123;</span><br><span class="line">        <span class="comment">//通过反射获取方法参数泛型</span></span><br><span class="line">        <span class="comment">//第一步：获取指定的方法</span></span><br><span class="line">        Method method = User.class.getDeclaredMethod("test", Map.class, List.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二步：获取该方法的参数泛型</span></span><br><span class="line">        Type[] genericParameterTypes = method.getGenericParameterTypes();<span class="comment">//通过方法获得参数泛型</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//第三步：遍历该方法的参数泛型</span></span><br><span class="line">        <span class="keyword">for</span> (Type genericParameterType : genericParameterTypes) &#123;</span><br><span class="line">            System.out.println(<span class="string">"方法参数类型"</span>+genericParameterType);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断该参数泛型是否为参数化类型，若是，则获取其中的实际类型参数</span></span><br><span class="line">            <span class="keyword">if</span>(genericParameterType <span class="keyword">instanceof</span> ParameterizedType)&#123; <span class="comment">//判断是不是参数化类型</span></span><br><span class="line">                Type[] actualTypeArguments = ((ParameterizedType) genericParameterType).getActualTypeArguments();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (Type actualTypeArgument : actualTypeArguments) &#123;</span><br><span class="line">                    System.out.println(actualTypeArgument);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"====================="</span>);</span><br><span class="line">        <span class="comment">//通过反射获取方法返回值泛型</span></span><br><span class="line">        method = User.class.getDeclaredMethod("test1",null);</span><br><span class="line">        Type genericReturnType = method.getGenericReturnType();<span class="comment">//通过方法获得返回值泛型</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(genericReturnType <span class="keyword">instanceof</span> ParameterizedType)&#123;</span><br><span class="line">            Type[] actualTypeArguments = ((ParameterizedType) genericReturnType).getActualTypeArguments();</span><br><span class="line">            <span class="keyword">for</span> (Type actualTypeArgument : actualTypeArguments) &#123;</span><br><span class="line">                System.out.println(actualTypeArgument);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我执行了test的方法啦"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Map&lt;String, String&gt; map,List&lt;String&gt; list)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我执行了test1的方法啦，内容是"</span> + map + list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2、获取注解信息">2、获取注解信息</h2>
<p>在类上、字段和方法上的注解都可以通过反射进行读取，不过要注意抛出的异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zstu.sso;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">annotationTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException, NoSuchMethodException,</span></span><br><span class="line"><span class="function">            InstantiationException, IllegalAccessException, InvocationTargetException </span>&#123;</span><br><span class="line">        Class c1 = Class.forName(<span class="string">"com.zstu.sso.MyAnnotationClass"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过反射获取类的注解</span></span><br><span class="line">        Annotation[] classAnnotations = c1.getAnnotations();</span><br><span class="line">        <span class="keyword">for</span> (Annotation annotation : classAnnotations) &#123;</span><br><span class="line">            System.out.println(annotation); <span class="comment">//@com.zstu.sso.MyAnnotation(name=, value=这是类, age=0)</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得指定注解的value值</span></span><br><span class="line">        MyAnnotation classAnnotation = (MyAnnotation)c1.getAnnotation(MyAnnotation<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        String value = classAnnotation.value();</span><br><span class="line">        System.out.println(value); <span class="comment">//这是类</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得类内部字段的指定注解</span></span><br><span class="line">        Field field = c1.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line">        MyAnnotation fieldAnnotation = field.getAnnotation(MyAnnotation<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(fieldAnnotation.value());<span class="comment">//field</span></span><br><span class="line">        System.out.println(fieldAnnotation.age());<span class="comment">//18</span></span><br><span class="line">        System.out.println(fieldAnnotation.name());<span class="comment">//这是字段</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得类内部方法的指定注解</span></span><br><span class="line">        Method method = c1.getDeclaredMethod(<span class="string">"test"</span>);</span><br><span class="line">        MyAnnotation methodAnnotation = method.getAnnotation(MyAnnotation<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(methodAnnotation.value());<span class="comment">//method</span></span><br><span class="line">        System.out.println(methodAnnotation.age());<span class="comment">//18</span></span><br><span class="line">        System.out.println(methodAnnotation.name());<span class="comment">//这是方法</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁用访问安全检查的开关</span></span><br><span class="line">        method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        method.invoke(c1.newInstance());<span class="comment">// 运行了test方法</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认名字一般是value</span></span><br><span class="line"><span class="meta">@MyAnnotation</span>(<span class="string">"这是类"</span>)</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAnnotationClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MyAnnotation</span>(value = <span class="string">"field"</span>,name = <span class="string">"这是字段"</span>,age = <span class="number">18</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="comment">// 显示定义</span></span><br><span class="line">    <span class="meta">@MyAnnotation</span>(value = <span class="string">"method"</span>,name = <span class="string">"这是方法"</span>,age = <span class="number">18</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"运行了test方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义一个注解，其中用到了四个元注解</span></span><br><span class="line"><span class="meta">@Target</span>(value = &#123;ElementType.TYPE,ElementType.METHOD,ElementType.FIELD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(value = RetentionPolicy.RUNTIME) <span class="comment">//一般自定义注解，都选择RUNTIME;</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation&#123;</span><br><span class="line">    <span class="comment">// 参数类型，参数名</span></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">age</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>参考资料</p>
<p><a href="https://www.bilibili.com/video/BV1p4411P7V3" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1p4411P7V3</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue Axios请求封装</title>
    <url>/posts/cbf77484.html</url>
    <content><![CDATA[<h1>一、介绍</h1>
<p>对axios进行封装以及将API接口按业务模块统一管理，有助于我们简化代码，方便后期维护；也可以方便的统一对请求API进行修改</p>
<a id="more"></a>
<h1>二、Vue实战</h1>
<blockquote>
<p><a href="https://javasoho.com/axios/index.html" target="_blank" rel="noopener">https://javasoho.com/axios/index.html</a><br>
<a href="https://github.com/axios/axios" target="_blank" rel="noopener">https://github.com/axios/axios</a></p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/814b5e1a301e42a19d65ebd80dd62dc3.png" alt></p>
<h2 id="1、Axios全局配置文件">1、Axios全局配置文件</h2>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Message &#125; <span class="keyword">from</span> <span class="string">'element-ui'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建axios实例</span></span><br><span class="line"><span class="keyword">const</span> service = axios.create(&#123;</span><br><span class="line">    baseURL: <span class="string">'http://localhost:8090'</span>, <span class="comment">// api 的 base_url</span></span><br><span class="line">    timeout: <span class="number">20000</span> <span class="comment">// 请求超时时间</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// request拦截器</span></span><br><span class="line">service.interceptors.request.use(</span><br><span class="line">    config =&gt; &#123;</span><br><span class="line">        <span class="comment">//每次请求之前判断vuex中是否存在token</span></span><br><span class="line">        <span class="comment">//如果存在，则统一在http请求的header上都加上token，以便后台根据token判断当前登陆情况</span></span><br><span class="line">        <span class="comment">//即使本地存在token，也有可能过期，所以需要对返回状态进行判断</span></span><br><span class="line">        <span class="keyword">const</span> token = localStorage.getItem(<span class="string">"token"</span>);</span><br><span class="line">        <span class="keyword">if</span> (token &amp;&amp; (config.headers.Authorization = token)) &#123;</span><br><span class="line">          config.headers[<span class="string">'Authorization'</span>] = token; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> config</span><br><span class="line">    &#125;,</span><br><span class="line">    error =&gt; &#123;</span><br><span class="line">        <span class="comment">// Do something with request error</span></span><br><span class="line">        <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// response 拦截器</span></span><br><span class="line">service.interceptors.response.use(</span><br><span class="line">    response =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> res = response.data</span><br><span class="line">        <span class="keyword">if</span> (res.code &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            Message(&#123;</span><br><span class="line">                message: res.message,</span><br><span class="line">                type: <span class="string">'error'</span>,</span><br><span class="line">                duration: <span class="number">5</span> * <span class="number">1000</span></span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="string">'error'</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 注意：这里务必要返回配置对象，否则请求就停在这里出不去了</span></span><br><span class="line">            <span class="keyword">return</span> response.data</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    error =&gt; &#123;</span><br><span class="line">        Message(&#123;</span><br><span class="line">            message: error.message,</span><br><span class="line">            type: <span class="string">'error'</span>,</span><br><span class="line">            duration: <span class="number">5</span> * <span class="number">1000</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">// 如果请求出错了（还没有发出去）会进入这里</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 响应拦截器</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> service</span><br></pre></td></tr></table></figure>
<h2 id="2、设置统一API管理">2、设置统一API管理</h2>
<p>这里注意的是@代表的是src目录，同时配置接口后要记得返回</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> request <span class="keyword">from</span> <span class="string">'@/utils/request'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//查询订单列表</span></span><br><span class="line">  list() &#123;</span><br><span class="line">    <span class="keyword">return</span> request(&#123;</span><br><span class="line">      url: <span class="string">'/api/order-info/list'</span>,</span><br><span class="line">      method: <span class="string">'get'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  queryOrderStatus(orderNo) &#123;</span><br><span class="line">    <span class="keyword">return</span> request(&#123;</span><br><span class="line">      url: <span class="string">'/api/order-info/query-order-status/'</span> + orderNo,</span><br><span class="line">      method: <span class="string">'get'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3、业务逻辑">3、业务逻辑</h2>
<p>最后在业务逻辑处理页面进行调用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> orderInfoApi <span class="keyword">from</span> <span class="string">"../api/orderInfo"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">methods: &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示订单列表</span></span><br><span class="line">    showOrderList()&#123;</span><br><span class="line">      orderInfoApi.list().then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.list = response.data.list;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring开发社交模块小记</title>
    <url>/posts/26648891.html</url>
    <content><![CDATA[<h1>一、引言</h1>
<p>社交模块作为热点数据来说，可能会频繁改动字段，因此用Mysql是肯定不现实的，一般使用Redis。这里我以发表朋友圈动态为例，社交模块包括发表动态，点赞、评论、收藏、关注以及签到统计等模块，这里我简单实现了动态发表，点赞、评论这三个模块。</p>
<a id="more"></a>
<p><strong>关注功能模块</strong>，使用Redis集合Set，一个人两个集合数据，定时更新到数据库</p>
<blockquote>
<p><a href="https://blog.csdn.net/INGNIGHT/article/details/107066022" target="_blank" rel="noopener">https://blog.csdn.net/INGNIGHT/article/details/107066022</a><br>
<a href="https://www.cnblogs.com/linjiqin/p/12828315.html" target="_blank" rel="noopener">https://www.cnblogs.com/linjiqin/p/12828315.html</a></p>
</blockquote>
<p><strong>点赞、收藏模块</strong>，Set（点赞视频、点赞人评论）和Hash(like::url =1或0)结构都比较合适</p>
<blockquote>
<p><a href="https://juejin.cn/post/6904816415912493069#heading-10" target="_blank" rel="noopener">https://juejin.cn/post/6904816415912493069#heading-10</a><br>
<a href="https://juejin.cn/post/6895185457110319118#heading-20" target="_blank" rel="noopener">https://juejin.cn/post/6895185457110319118#heading-20</a><br>
<a href="https://juejin.cn/post/6844903967168675847" target="_blank" rel="noopener">https://juejin.cn/post/6844903967168675847</a></p>
</blockquote>
<p><strong>评论模块</strong>，可以选择list，用list和zset存储id，其他存储内容</p>
<blockquote>
<p><a href="https://juejin.cn/post/6844903709374169102" target="_blank" rel="noopener">https://juejin.cn/post/6844903709374169102</a><br>
<a href="https://blog.csdn.net/qq171563857/article/details/107406409" target="_blank" rel="noopener">https://blog.csdn.net/qq171563857/article/details/107406409</a><br>
<a href="https://symonlin.github.io/2019/07/29/redis-1/" target="_blank" rel="noopener">https://symonlin.github.io/2019/07/29/redis-1/</a></p>
</blockquote>
<p><strong>登录统计、签到</strong>，使用Redis的Bitmap</p>
<blockquote>
<p><a href="https://juejin.cn/post/6990152493099384869" target="_blank" rel="noopener">https://juejin.cn/post/6990152493099384869</a></p>
</blockquote>
<h1>二、数据库设计</h1>
<p>数据库自行参考，可以考虑持久化到数据库。这里说一下我的设计思路：</p>
<p>动态分为视频动态和图片形式的动态，类似于抖音和微信朋友圈，该模块单独编写，需要信息从其他模块获取；评论为二级评论，后端包装后返回，评论可以点赞等操作；点赞优先经过Redis，若没有查询数据库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span> lamp_social;</span><br><span class="line"><span class="keyword">use</span> lamp_social;</span><br><span class="line"><span class="comment">-- 评论表</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">exists</span> social_comment;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> social_comment (</span><br><span class="line">comment_id <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'评论表id'</span>,</span><br><span class="line">owner_id <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'文章或视频id'</span>,</span><br><span class="line">user_id <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户id'</span>,</span><br><span class="line"><span class="keyword">content</span> <span class="built_in">text</span> <span class="keyword">COMMENT</span> <span class="string">'评论内容'</span>,</span><br><span class="line">star_num <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">default</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'点赞数量'</span>,</span><br><span class="line">p_comment_id <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'若父评论则为0，默认一级评论；子评论对应其相应的评论父Id'</span>,</span><br><span class="line">state <span class="built_in">int</span>(<span class="number">2</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'默认0,表示未审核，1表示审核通过，2表示不通过'</span>,</span><br><span class="line"><span class="keyword">type</span> <span class="built_in">int</span>(<span class="number">2</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'评论类型，默认为0，可以是对人、对资源、对视频等，暂时不用'</span>,</span><br><span class="line">create_time <span class="built_in">timestamp</span> <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">default</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">comment</span> <span class="string">'创建时间'</span>,</span><br><span class="line">update_time <span class="built_in">timestamp</span> <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">default</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">comment</span> <span class="string">'修改时间'</span>,</span><br><span class="line">deleted <span class="built_in">tinyint</span> <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">default</span> <span class="number">0</span> <span class="keyword">comment</span> <span class="string">'数据删除位 0正常 1逻辑删除'</span>,</span><br><span class="line">primary <span class="keyword">key</span>(comment_id)</span><br><span class="line">)AUTO_INCREMENT=<span class="number">1</span> <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4 <span class="keyword">COMMENT</span>=<span class="string">'评论表'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 个人动态表</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">exists</span> social_dynamic;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> social_dynamic (</span><br><span class="line">dynamic_id <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'动态id'</span>,</span><br><span class="line">dynamic_url <span class="built_in">varchar</span>(<span class="number">5000</span>) <span class="keyword">default</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'视频地址,若是图片朋友圈，那么地址中间用|进行分隔'</span>,</span><br><span class="line">user_id <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户id'</span>,</span><br><span class="line"><span class="keyword">content</span> <span class="built_in">text</span> <span class="keyword">COMMENT</span> <span class="string">'朋友圈内容'</span>,</span><br><span class="line">star_num <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">default</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'点赞数量'</span>,</span><br><span class="line">collection_num <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">default</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'收藏数'</span>,</span><br><span class="line">state <span class="built_in">int</span>(<span class="number">2</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'默认0,表示未审核，1表示审核通过，2表示不通过'</span>,</span><br><span class="line"><span class="keyword">type</span> <span class="built_in">int</span>(<span class="number">2</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'动态类型，默认为0，表示视频，1表示图片朋友圈，每个数字可以对应不同视频类型'</span>,</span><br><span class="line">create_time <span class="built_in">timestamp</span> <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">default</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">comment</span> <span class="string">'创建时间'</span>,</span><br><span class="line">update_time <span class="built_in">timestamp</span> <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">default</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">comment</span> <span class="string">'修改时间'</span>,</span><br><span class="line">deleted <span class="built_in">tinyint</span> <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">default</span> <span class="number">0</span> <span class="keyword">comment</span> <span class="string">'数据删除位 0正常 1逻辑删除'</span>,</span><br><span class="line">primary <span class="keyword">key</span>(dynamic_id)</span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4 <span class="keyword">COMMENT</span>=<span class="string">'个人动态表'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 用户表可以添加一个点赞数字段，可选</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">exists</span> social_user;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> social_user (</span><br><span class="line">user_id <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">comment</span> <span class="string">'用户id'</span>,</span><br><span class="line">school_id <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">comment</span> <span class="string">'学校id'</span>,</span><br><span class="line">star_num <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">default</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'点赞数量'</span>,</span><br><span class="line">focus_num <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">default</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'关注数量'</span>,</span><br><span class="line">fan_num <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">default</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'粉丝数量'</span>,</span><br><span class="line">create_time <span class="built_in">timestamp</span> <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">default</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">comment</span> <span class="string">'创建时间'</span>,</span><br><span class="line">update_time <span class="built_in">timestamp</span> <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">default</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">comment</span> <span class="string">'修改时间'</span>,</span><br><span class="line">primary <span class="keyword">key</span>(user_id)</span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4 <span class="keyword">COMMENT</span>=<span class="string">'用户点赞表'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 用户点赞表</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">exists</span> social_user_like_dynamic;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> social_user_like_dynamic (</span><br><span class="line">liked_id <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'主键id'</span>,</span><br><span class="line">dynamic_id <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'动态id'</span>,</span><br><span class="line">user_id <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户id'</span>,</span><br><span class="line">state <span class="built_in">int</span>(<span class="number">2</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'默认0,表示点赞，1表示取消点赞'</span>,</span><br><span class="line">create_time <span class="built_in">timestamp</span> <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">default</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">comment</span> <span class="string">'创建时间'</span>,</span><br><span class="line">update_time <span class="built_in">timestamp</span> <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">default</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">comment</span> <span class="string">'修改时间'</span>,</span><br><span class="line">primary <span class="keyword">key</span>(liked_id)</span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4 <span class="keyword">COMMENT</span>=<span class="string">'用户点赞表'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 用户收藏表</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">exists</span> social_user_collect_dynamic;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> social_user_collect_dynamic (</span><br><span class="line">collection_id <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'主键id'</span>,</span><br><span class="line">dynamic_id <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'动态id'</span>,</span><br><span class="line">user_id <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户id'</span>,</span><br><span class="line">state <span class="built_in">int</span>(<span class="number">2</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'默认0,表示收藏，1表示取消收藏'</span>,</span><br><span class="line">create_time <span class="built_in">timestamp</span> <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">default</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">comment</span> <span class="string">'创建时间'</span>,</span><br><span class="line">update_time <span class="built_in">timestamp</span> <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">default</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">comment</span> <span class="string">'修改时间'</span>,</span><br><span class="line">primary <span class="keyword">key</span>(collection_id)</span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4 <span class="keyword">COMMENT</span>=<span class="string">'用户收藏表'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 用户关注与粉丝表</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">exists</span> social_user_focus;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> social_user_focus (</span><br><span class="line">focus_id <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'主键id'</span>,</span><br><span class="line">user_id <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户id'</span>,</span><br><span class="line">focus_user_id <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'关注用户id'</span>,</span><br><span class="line">state <span class="built_in">int</span>(<span class="number">2</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'默认0,表示关注，1表示取消关注'</span>,</span><br><span class="line">create_time <span class="built_in">timestamp</span> <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">default</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">comment</span> <span class="string">'创建时间'</span>,</span><br><span class="line">update_time <span class="built_in">timestamp</span> <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">default</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">comment</span> <span class="string">'修改时间'</span>,</span><br><span class="line">primary <span class="keyword">key</span>(focus_id)</span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4 <span class="keyword">COMMENT</span>=<span class="string">'用户关注与粉丝表'</span>;</span><br></pre></td></tr></table></figure>
<h1>三、动态发表模块设计</h1>
<h2 id="1、介绍">1、介绍</h2>
<p>Feed流产品在我们手机APP中几乎无处不在，常见的Feed流比如微信朋友圈、新浪微博、今日头条等。对Feed流的定义，可以简单理解为只要大拇指不停地往下划手机屏幕，就有一条条的信息不断涌现出来。</p>
<p>大多数Feed流产品都包含两种Feed流，一种是基于算法推荐，另一种是基于关注（好友关系）。例如下图中的微博和知乎，顶栏的页卡都包含“关注”和“推荐”这两种。两种Feed流背后用到的技术差别会比较大（读扩散、写扩散）。</p>
<blockquote>
<p>参考：<a href="https://cloud.tencent.com/developer/article/1744756" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1744756</a></p>
</blockquote>
<h2 id="2、Redis结构选择">2、Redis结构选择</h2>
<p>动态发布因为考虑到先缓存到Redis，在异步保存到MySql，因此动态主键使用Redis的自增函数，通过Redis生成MySql的动态主键；</p>
<p>对于动态数据的存储，我使用了list存储结构，新的数据从左边压入list，考虑到feed流查询，我还设置了一个伴生list列表，用来与动态同步存储主键值，首先通过lastid查询上一次浏览的值，查询list的index，在通过存储动态的列表返回一个列表；同时使用了读写锁，是为了保证原子性；</p>
<p>最后异步或定时检查列表长度，若过长可以从右边舍弃，或者设置列表过期时间，插入的时候重新刷新过期时间<br>
<img src="https://img-blog.csdnimg.cn/38cd060cb74444e481ace785d68270af.png" alt></p>
<h1>四、评论模块设计</h1>
<h2 id="1、介绍-v2">1、介绍</h2>
<p>mysql表字段，评论父表和字表存储在同一个数据表，根据<code>p_comment_id</code>字段分辨，返回的时候先查询出总的list，在使用JDK8的Stream流形成树形结构返回。ORM映射使用了Fluent MyBatis ，树形结构格式转换；</p>
<h2 id="2、对象类型转换工具">2、对象类型转换工具</h2>
<p>首先创建转换工具类，这里先将对象转化为json，在通过解析json进行复制操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 两个对象或集合同名属性赋值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectConversion</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从List&lt;A&gt; copy到List&lt;B&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list List&lt;B&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz B</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> List&lt;B&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">copy</span><span class="params">(List&lt;?&gt; list,Class&lt;T&gt; clazz)</span></span>&#123;</span><br><span class="line">        String oldOb = JSON.toJSONString(list);</span><br><span class="line">        <span class="keyword">return</span> JSON.parseArray(oldOb, clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从对象A copy到 对象B</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ob A</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz B.class</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> B</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">copy</span><span class="params">(Object ob,Class&lt;T&gt; clazz)</span></span>&#123;</span><br><span class="line">        String oldOb = JSON.toJSONString(ob);</span><br><span class="line">        <span class="keyword">return</span> JSON.parseObject(oldOb, clazz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3、多级评论树型拼接">3、多级评论树型拼接</h2>
<p>我的VO类，主要用将数据库的评论拼装返回前端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Accessors</span>(chain = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VideoCommentVO</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 评论表id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer commentId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 评论内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文章或视频id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer ownerId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 若父评论则为0，默认一级评论；子评论对应其相应的评论父Id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer pCommentId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 点赞数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer starNum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer userId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 孩子</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;VideoCommentVO&gt; child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>树形结构拼装，用了jdk8新特性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VideoCommentService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    CommentMapper commentMapper;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//就先二级评论吧</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;VideoCommentVO&gt; <span class="title">getVideoComment</span><span class="params">(Integer videoId)</span> </span>&#123;</span><br><span class="line">        CommentQuery query = <span class="keyword">new</span> CommentQuery()</span><br><span class="line">                .where().ownerId().eq(videoId).end()</span><br><span class="line">                .where().state().eq(<span class="number">0</span>).end()</span><br><span class="line">                .where().deleted().eq(<span class="number">0</span>).end();</span><br><span class="line">        List&lt;CommentEntity&gt; commentEntities = commentMapper.listEntity(query);</span><br><span class="line">        <span class="comment">//列表拷贝</span></span><br><span class="line">        List&lt;VideoCommentVO&gt; videoCommentVOList = ObjectConversion.copy(commentEntities, VideoCommentVO<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">//列表通过pcommentid进行分组</span></span><br><span class="line">        Map&lt;Integer, List&lt;VideoCommentVO&gt;&gt; collect = videoCommentVOList.stream().collect(Collectors.groupingBy(VideoCommentVO::getPCommentId));</span><br><span class="line">        <span class="comment">//分组后遍历每一个数组设置孩子</span></span><br><span class="line">        videoCommentVOList.forEach(</span><br><span class="line">                videoComment-&gt;videoComment.setChild(collect.get(videoComment.getCommentId()))</span><br><span class="line">        );</span><br><span class="line">        System.out.println(videoCommentVOList);</span><br><span class="line">        <span class="comment">//找出父结点并返回,排序默认从小到大</span></span><br><span class="line">        List&lt;VideoCommentVO&gt; result = videoCommentVOList.stream()</span><br><span class="line">                .filter(s -&gt; s.getPCommentId().equals(<span class="number">0</span>))</span><br><span class="line">                .sorted(Comparator.comparing(VideoCommentVO::getStarNum).reversed())</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果遇到下面问题，回退版本号，我当时遇到了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fastJson1.2.78版本会概率性出现该错误，回退到1.2.76即可</span></span><br><span class="line">Comparison method violates its general contract</span><br></pre></td></tr></table></figure>
<h2 id="4、评论简单过滤">4、评论简单过滤</h2>
<p><img src="https://img-blog.csdnimg.cn/16208973b157451caf70e64f7258585f.png" alt></p>
<p>简单原理如上图所示，创建结点类，里面包含是否是敏感词结束符，以及一个HashMap，哈希里key值存储的是敏感词的一个词，value指向下一个结点（即指向下一个词），一个哈希表中可以存放多个值，比如赌博、赌黄这两个都是敏感词。</p>
<p>敏感词文件存在在<code>resources</code>文件夹下，通过类加载器获取里面的敏感词。在springboot中，被<code>@PostConstruct</code>修饰的方法会在服务器加载Servlet的时候运行，并且只会被服务器执行一次。<code>PostConstruct</code>在构造函数之后执行，<code>init()</code>方法之前执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 敏感词过滤器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Shawn</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021年11月20日11:09</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SensitiveFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(SensitiveFilter<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将敏感词替换成 ***</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String REPLACEMENT = <span class="string">"***"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TreeNode rootNode = <span class="keyword">new</span> TreeNode();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 被<span class="doctag">@PostConstruct</span>修饰的方法会在服务器加载Servlet的时候运行，并且只会被服务器执行一次。PostConstruct在构造函数之后执行，init（）方法之前执行。</span></span><br><span class="line"><span class="comment">     * 初始化敏感词的结构树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 带资源的try语句，try块退出时，会自动调用res.close()方法，关闭资源。</span></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">            InputStream resourceAsStream = <span class="keyword">this</span>.getClass().getClassLoader().getResourceAsStream(<span class="string">"sensitive-words.txt"</span>);</span><br><span class="line">            BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(resourceAsStream));</span><br><span class="line">        )&#123;</span><br><span class="line">            String keyword;</span><br><span class="line">            <span class="keyword">while</span>((keyword=bufferedReader.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">this</span>.addKeyWord(keyword);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            logger.error(<span class="string">"资源文件加载失败 ==&gt; &#123;&#125;"</span>,e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将敏感词加入前缀树里</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keyword 敏感词</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addKeyWord</span><span class="params">(@NotNull String keyword)</span></span>&#123;</span><br><span class="line">        TreeNode tempNode = rootNode;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i&lt;keyword.length();i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = keyword.charAt(i);</span><br><span class="line">            <span class="comment">// 进行空值判断，当多个敏感词首字母相同时，可以指向不同结点</span></span><br><span class="line">            TreeNode subNode = tempNode.getKeywordNode(c);</span><br><span class="line">            <span class="keyword">if</span>(subNode==<span class="keyword">null</span>)&#123;</span><br><span class="line">                subNode = <span class="keyword">new</span> TreeNode();</span><br><span class="line">                tempNode.addKeywordNode(c,subNode);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 指向下一个结点</span></span><br><span class="line">            tempNode=subNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 结尾设置结束符</span></span><br><span class="line">        tempNode.setKeywordEnd(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 敏感词过滤器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> text 文本</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> String&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">filter</span><span class="params">(String text)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isBlank(text))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 规则树，用来匹配敏感词</span></span><br><span class="line">        TreeNode tempNode = rootNode;</span><br><span class="line">        <span class="comment">// begin指针，指向文本中某个敏感词的第一位</span></span><br><span class="line">        <span class="keyword">int</span> begin=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// end指针，指向文本中某个敏感词的最后一位</span></span><br><span class="line">        <span class="keyword">int</span> end = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span> (end&lt;text.length())&#123;</span><br><span class="line">            <span class="keyword">char</span> c = text.charAt(end);</span><br><span class="line">            <span class="comment">// 跳过符号（防止敏感词混合符号，比如 ☆赌☆博）</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.isSymbol(c))&#123;</span><br><span class="line">                <span class="comment">// 若tempNode结点在开头，代表还没有匹配敏感字，这个特殊符号加入返回词，且 begin 指针指向下一个</span></span><br><span class="line">                <span class="keyword">if</span>(tempNode == rootNode)&#123;</span><br><span class="line">                    sb.append(c);</span><br><span class="line">                    begin++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 无论符号在开头还是在中间，指针 end 都会向下走一步</span></span><br><span class="line">                end++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 检查子节点</span></span><br><span class="line">            tempNode = tempNode.getKeywordNode(c);</span><br><span class="line">            <span class="keyword">if</span>(tempNode==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">// 以指针 begin 开头的字符串不是敏感词</span></span><br><span class="line">                sb.append(text.charAt(begin));</span><br><span class="line">                <span class="comment">// 进入下一位的判断</span></span><br><span class="line">                end++;</span><br><span class="line">                begin=end;</span><br><span class="line">                <span class="comment">// 这里需要把规则树重新指向根节点</span></span><br><span class="line">                tempNode=rootNode;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tempNode.isKeyWordEnd())&#123;</span><br><span class="line">                <span class="comment">// 发现敏感词，将 begin~end 的字符串替换掉</span></span><br><span class="line">                sb.append(REPLACEMENT);</span><br><span class="line">                end++;</span><br><span class="line">                begin=end;</span><br><span class="line">                tempNode=rootNode;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 敏感词匹配过程中</span></span><br><span class="line">                end++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将最后一批字符计入结果（如果最后一次循环的字符串不是敏感词，上述的循环逻辑不会将其加入最终结果）</span></span><br><span class="line">        sb.append(text.substring(begin));</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否是符号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSymbol</span><span class="params">(Character c)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 0x2E80~0x9FFF 是东亚文字范围</span></span><br><span class="line">        <span class="keyword">return</span> !CharUtils.isAsciiAlphanumeric(c) &amp;&amp; (c &lt; <span class="number">0x2E80</span> || c &gt; <span class="number">0x9FFF</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 树节点</span></span><br><span class="line"><span class="comment">     * 敏感词结点类，与hash表类似，所有敏感词形成一个hash表，每个词语的每个词形成一个链表，用map指向下一个</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">        <span class="comment">// 关键词结束标识，默认是不是非结束结点</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> isKeywordEnd = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// map的key存储一个敏感词，value指向下一个敏感词结点</span></span><br><span class="line">        HashMap&lt;Character, TreeNode&gt; nodeMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回是否本次词语结束</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isKeyWordEnd</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> isKeywordEnd;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置是否是结束词</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setKeywordEnd</span><span class="params">(<span class="keyword">boolean</span> keywordEnd)</span></span>&#123;</span><br><span class="line">            isKeywordEnd = keywordEnd;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加敏感词，key表示字符</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addKeywordNode</span><span class="params">(Character c, TreeNode treeNode)</span></span>&#123;</span><br><span class="line">            nodeMap.put(c,treeNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取当前词是否是敏感词，若没有在表中，则返回null</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> TreeNode <span class="title">getKeywordNode</span><span class="params">(Character c)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nodeMap.get(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>五、点赞模块设计</h1>
<h2 id="1、问题描述">1、问题描述</h2>
<p>考虑到点赞是字段频繁变动的，用Mysql肯定不合适，使用需要使用Redis内存数据库。这里以动态点赞为例子，点赞模块需要解决的几个问题</p>
<ul>
<li>用户对某个动态点赞/取消点赞</li>
<li>该动态获得了多少赞</li>
<li>用户是否已经点赞该动态</li>
<li>用户的总点赞数是多少</li>
<li>数据的持久化</li>
</ul>
<h2 id="2、Redis数据结构选择">2、Redis数据结构选择</h2>
<p>对于点赞来说，Set和Hash结构都可以选择。set中的值不能重复，是无序不重复的，Hash相当于Map集合，相当于key-Map，通常来存储经常变动的对象。对于点赞，两种结构都可以，根据业务自由选择</p>
<h3 id="1-Set结构存储">1. Set结构存储</h3>
<p>这里我选择了一种较为简单的存储方案，不过这种方案很难进行MySql持久化，用Set结构存储某视频点赞的用户，用String结构存储用户点赞数量，查询用户是否点赞只需查询用户是否在这个Set集合里，点赞/取消点赞加入/移除Set，查询某视频点赞数只需统计Set集合中的用户数量，两个存储结构为</p>
<ul>
<li>视频点赞Set的存储结构   <code>like:dynamic:{dynamicType}:{dynamicId}={userId}</code></li>
<li>用户点赞数量的String存储结构     <code>like:user:{userId}=value</code></li>
</ul>
<h3 id="2-Hash结构存储">2. Hash结构存储</h3>
<p>这种Hash结构可以记录点赞人和被点赞产品，还有点赞状态（点赞/取消点赞设置值为1/0），还可以固定时间间隔取出 Redis 中所有点赞数据</p>
<ul>
<li>视频点赞Hash的Key结构<code>like:dynamic:{dynamicType}</code>，里面的键值对为<code>{userId}::{dynamicId}=1</code></li>
<li>视频点赞数Hash的Key结构<code>like:count:dynamic</code>，里面的键值对为<code>{dynamicId}={count}</code></li>
<li>用户点咱叔Hash的Key结构<code>like:count:user</code>，里面的键值对为<code>{userId}={count}</code></li>
</ul>
<h2 id="3、编码实现">3、编码实现</h2>
<h3 id="1-配置redis">1. 配置redis</h3>
<p>首先进行redis配置，实现序列化，否则不能正常显示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Shawn</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021年11月19日13:22</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 编写自己的RedisTemplate</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"all"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="comment">//序列化配置，默认会报错类型转换错误</span></span><br><span class="line">        <span class="comment">//FastJsonRedisSerializer fastJsonRedisSerializer = new FastJsonRedisSerializer&lt;&gt;(Object.class);</span></span><br><span class="line">        FastJson2JsonRedisSerializer fastJsonRedisSerializer = <span class="keyword">new</span> FastJson2JsonRedisSerializer&lt;&gt;(Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        <span class="comment">//String的序列化</span></span><br><span class="line">        StringRedisSerializer stringRedisSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line">        <span class="comment">// key采用String的序列化方式</span></span><br><span class="line">        template.setKeySerializer(stringRedisSerializer);</span><br><span class="line">        <span class="comment">// hash采用String序列方式</span></span><br><span class="line">        template.setHashKeySerializer(stringRedisSerializer);</span><br><span class="line">        <span class="comment">// value采用jackson</span></span><br><span class="line">        template.setValueSerializer(fastJsonRedisSerializer);</span><br><span class="line">        <span class="comment">// hash的value采用jackson</span></span><br><span class="line">        template.setHashValueSerializer(fastJsonRedisSerializer);</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建<code>FastJson2JsonRedisSerializer</code>类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FastJson2JsonRedisSerializer</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">RedisSerializer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Charset DEFAULT_CHARSET = StandardCharsets.UTF_8;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        ParserConfig.getGlobalInstance().setAutoTypeSupport(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; clazz;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FastJson2JsonRedisSerializer</span><span class="params">(Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.clazz = clazz;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] serialize(T t) <span class="keyword">throws</span> SerializationException &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == t) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 序列化时写入类型信息，默认为false,反序列化是需用到</span></span><br><span class="line">        <span class="comment">// 如果序列化是没有加入类型信息SerializerFeature.WriteClassName，就会报错java.lang.ClassCastException</span></span><br><span class="line">        <span class="keyword">return</span> JSON.toJSONString(t, SerializerFeature.WriteClassName).getBytes(DEFAULT_CHARSET);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 反序列化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> <span class="keyword">throws</span> SerializationException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == bytes || bytes.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String str = <span class="keyword">new</span> String(bytes, DEFAULT_CHARSET);</span><br><span class="line">        <span class="keyword">return</span> (T) JSON.parseObject(str, clazz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-Redis工具类编写">2. Redis工具类编写</h3>
<p>新建RedisKeyUtil，进行key的拼接</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回redis的key</span></span><br><span class="line"><span class="comment"> * 每个视频点赞用set进行保存，里面的用户数就是点赞数</span></span><br><span class="line"><span class="comment"> * 用户的点赞数用k-v保存</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Shawn</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021年11月19日13:52</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisKeyUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * redis分隔符</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SPLIT = <span class="string">":"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 动态的获赞</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PREFIX_DYNAMIC_LIKE = <span class="string">"like:dynamic"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 动态的获赞数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PREFIX_DYNAMIC_LIKE_COUNT = <span class="string">"like:count:dynamic"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户的获赞</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PREFIX_USER_LIKE = <span class="string">"like:count:user"</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回redis视频点赞set key值</span></span><br><span class="line"><span class="comment">     * 举例like:dynamic:1:11</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dynamicType 动态类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dynamicId 视频id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> String&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getDynamicLikeKey</span><span class="params">(<span class="keyword">int</span> dynamicType,<span class="keyword">int</span> dynamicId)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> PREFIX_DYNAMIC_LIKE + SPLIT + dynamicType + SPLIT + dynamicId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回redis视频点赞key值，使用hash</span></span><br><span class="line"><span class="comment">     * 举例hashkey为 like:dynamic:1</span></span><br><span class="line"><span class="comment">     * value为 dynamicId:userId(1111::2222)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dynamicType 动态类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> String&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getDynamicLikeHashKey</span><span class="params">(<span class="keyword">int</span> dynamicType)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> PREFIX_DYNAMIC_LIKE + SPLIT + dynamicType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 动态的获赞数的key值,使用hash</span></span><br><span class="line"><span class="comment">     * hashkey是动态id</span></span><br><span class="line"><span class="comment">     * 定时更新到数据库</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> String&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getDynamicLikeCountHashKey</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> PREFIX_DYNAMIC_LIKE_COUNT ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * hash的用户key (userId::dunamicId)</span></span><br><span class="line"><span class="comment">     * 4444::3333</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getDynamicUserLikeHashKey</span><span class="params">(<span class="keyword">int</span> userId, <span class="keyword">int</span> dynamicId)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userId + SPLIT + SPLIT + dynamicId ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户总的点赞数key</span></span><br><span class="line"><span class="comment">     * 举例like:user:2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userId 用户id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> String&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getUserLikeKey</span><span class="params">(<span class="keyword">int</span> userId)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> PREFIX_USER_LIKE + SPLIT + userId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户总的点赞数key hash</span></span><br><span class="line"><span class="comment">     * 举例like:count:user</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> String&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getUserLikeHashKey</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> PREFIX_USER_LIKE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-使用Set结构存储点赞">3. 使用Set结构存储点赞</h3>
<p>redis点赞模块service代码，自己写的，没有持久化，仅供参考</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 某个视频用户是否点赞</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dynamicType 动态类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> userId    用户id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dynamicId   动态id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> Boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Boolean <span class="title">getDynamicIsLikeByUser</span><span class="params">(<span class="keyword">int</span> dynamicType, <span class="keyword">int</span> userId,<span class="keyword">int</span> dynamicId)</span></span>&#123;</span><br><span class="line">    String dynamicLikeKey = RedisKeyUtil.getDynamicLikeKey(dynamicType,dynamicId);</span><br><span class="line">    Boolean member = redisTemplate.opsForSet().isMember(dynamicLikeKey, userId);</span><br><span class="line">    <span class="keyword">return</span> member;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> userId  用户id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dynamicId 动态id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> boolean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">putDynamicLikedByRedis</span><span class="params">(<span class="keyword">int</span> dynamicType, <span class="keyword">int</span> userId,<span class="keyword">int</span> dynamicId)</span></span>&#123;</span><br><span class="line">    redisTemplate.execute(<span class="keyword">new</span> SessionCallback() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> Object <span class="title">execute</span><span class="params">(RedisOperations operations)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</span><br><span class="line"></span><br><span class="line">              String dynamicLikeKey = RedisKeyUtil.getDynamicLikeKey(dynamicType,dynamicId);</span><br><span class="line">              String userLikeKey = RedisKeyUtil.getUserLikeKey(userId);</span><br><span class="line"></span><br><span class="line">              Boolean member = redisTemplate.opsForSet().isMember(dynamicLikeKey, userId);</span><br><span class="line">              <span class="comment">//开启redis事务</span></span><br><span class="line">              redisTemplate.multi();</span><br><span class="line">              <span class="comment">//如果已经点过赞了,就去除</span></span><br><span class="line">              <span class="keyword">if</span>(Boolean.TRUE.equals(member))&#123;</span><br><span class="line">                  redisTemplate.opsForSet().remove(dynamicLikeKey,userId);</span><br><span class="line">                  redisTemplate.opsForValue().decrement(userLikeKey);</span><br><span class="line">              &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                  <span class="comment">//如果没有点赞，就点赞</span></span><br><span class="line">                  redisTemplate.opsForSet().add(dynamicLikeKey,userId);</span><br><span class="line">                  redisTemplate.opsForValue().increment(userLikeKey);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">// 返回每条成功执行的记录</span></span><br><span class="line">              redisTemplate.exec();</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取视频点赞数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dynamicType 动态类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dynamicId   动态id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> Long&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">getDynamicLikeCount</span><span class="params">(<span class="keyword">int</span> dynamicType,<span class="keyword">int</span> dynamicId)</span></span>&#123;</span><br><span class="line">    String dynamicLikeKey = RedisKeyUtil.getDynamicLikeKey(dynamicType,dynamicId);</span><br><span class="line">    Long size = redisTemplate.opsForSet().size(dynamicLikeKey);</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里有个小坑，如果没有记录，返回的是null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> userId</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">getUserLikeCount</span><span class="params">(<span class="keyword">int</span> userId)</span></span>&#123;</span><br><span class="line">    String userLikeKey = RedisKeyUtil.getUserLikeKey(userId);</span><br><span class="line">    Integer result = (Integer) redisTemplate.opsForValue().get(userLikeKey);</span><br><span class="line">    <span class="keyword">return</span> result==<span class="keyword">null</span> ? <span class="number">0</span> : result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-使用Hash结构存储点赞">4. 使用Hash结构存储点赞</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 某个视频用户是否点赞</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dynamicType 动态类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> userId    用户id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dynamicId   动态id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> Boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Boolean <span class="title">getDynamicIsLikeByUser1</span><span class="params">(<span class="keyword">int</span> dynamicType, <span class="keyword">int</span> userId,<span class="keyword">int</span> dynamicId)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String dynamicLikeKey = RedisKeyUtil.getDynamicLikeHashKey(dynamicType);</span><br><span class="line">        String dynamicLikeHashkey = RedisKeyUtil.getDynamicUserLikeHashKey(userId,dynamicId);</span><br><span class="line">        <span class="comment">// redis Set的值</span></span><br><span class="line">        String dynamicLikeSetKey = RedisKeyUtil.getDynamicLikeKey(dynamicType,dynamicId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 首先查询缓存</span></span><br><span class="line">        Object redisResult = redisTemplate.opsForHash().get(dynamicLikeKey, dynamicLikeHashkey);</span><br><span class="line">        <span class="comment">// 查询二级缓存Set</span></span><br><span class="line">        Boolean member = redisTemplate.opsForSet().isMember(dynamicLikeSetKey, userId);</span><br><span class="line">        <span class="comment">// 缓存没有查询数据库</span></span><br><span class="line">        <span class="keyword">if</span>(redisResult == <span class="keyword">null</span> &amp;&amp; member == <span class="keyword">false</span>)&#123;</span><br><span class="line">            log.warn(<span class="string">"redis查询失败"</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SqlException(<span class="string">"redis查询失败"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">catch</span> (SqlException e)&#123;</span><br><span class="line">        UserLikeDynamicQuery userLikeDynamicQuery = <span class="keyword">new</span> UserLikeDynamicQuery()</span><br><span class="line">                .where().dynamicId().eq(dynamicId).end()</span><br><span class="line">                .where().userId().eq(userId).end()</span><br><span class="line">                .where().state().eq(<span class="number">0</span>).end();</span><br><span class="line">        UserLikeDynamicEntity one = userLikeDynamicMapper.findOne(userLikeDynamicQuery);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == one || one.getState()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 数据库查询不到或者状态位0，则没有点赞</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        log.error(<span class="string">"点赞模块发生未知错误"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 点赞,返回点赞数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> userId  用户id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dynamicId 动态id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> boolean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"all"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">putDynamicLikedByRedis1</span><span class="params">(<span class="keyword">int</span> dynamicType, <span class="keyword">int</span> userId, <span class="keyword">int</span> dynamicId)</span></span>&#123;</span><br><span class="line">    String dynamicLikeKey = RedisKeyUtil.getDynamicLikeHashKey(dynamicType);</span><br><span class="line">    String dynamicLikeHashkey = RedisKeyUtil.getDynamicUserLikeHashKey(userId,dynamicId);</span><br><span class="line">    <span class="comment">// 首先查询缓存</span></span><br><span class="line">    Object redisResult = redisTemplate.opsForHash().get(dynamicLikeKey, dynamicLikeHashkey);</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">null</span> != redisResult &amp;&amp; redisResult.equals(<span class="number">1</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Long result = (Long) redisTemplate.execute(<span class="keyword">new</span> SessionCallback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">execute</span><span class="params">(RedisOperations operations)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</span><br><span class="line">            String dynamicLikeKey = RedisKeyUtil.getDynamicLikeHashKey(dynamicType);</span><br><span class="line">            String dynamicLikeHashkey = RedisKeyUtil.getDynamicUserLikeHashKey(userId, dynamicId);</span><br><span class="line">            String userLikeHashKey = RedisKeyUtil.getUserLikeHashKey();</span><br><span class="line">            <span class="comment">// 点赞数记数</span></span><br><span class="line">            String dynamicLikeCountHashKey = RedisKeyUtil.getDynamicLikeCountHashKey();</span><br><span class="line"></span><br><span class="line">            redisTemplate.multi();</span><br><span class="line">            redisTemplate.opsForHash().put(dynamicLikeKey, dynamicLikeHashkey, <span class="number">1</span>);</span><br><span class="line">            redisTemplate.opsForHash().increment(userLikeHashKey,String.valueOf(userId),<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 自增</span></span><br><span class="line">            Long increment = redisTemplate.opsForHash().increment(dynamicLikeCountHashKey, String.valueOf(dynamicId), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            List exec = redisTemplate.exec();</span><br><span class="line">            <span class="keyword">return</span> exec.get(exec.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result.intValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 取消点赞,返回点赞数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> userId  用户id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dynamicId 动态id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> boolean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"all"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">putDynamicDislikedByRedis1</span><span class="params">(<span class="keyword">int</span> dynamicType, <span class="keyword">int</span> userId,<span class="keyword">int</span> dynamicId)</span></span>&#123;</span><br><span class="line">    String dynamicLikeKey = RedisKeyUtil.getDynamicLikeHashKey(dynamicType);</span><br><span class="line">    String dynamicLikeHashkey = RedisKeyUtil.getDynamicUserLikeHashKey(userId,dynamicId);</span><br><span class="line">    <span class="comment">// 首先查询缓存</span></span><br><span class="line">    Object redisResult = redisTemplate.opsForHash().get(dynamicLikeKey, dynamicLikeHashkey);</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">null</span> == redisResult || redisResult.equals(<span class="number">0</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Long result = (Long) redisTemplate.execute(<span class="keyword">new</span> SessionCallback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">execute</span><span class="params">(RedisOperations operations)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</span><br><span class="line">            String dynamicLikeKey = RedisKeyUtil.getDynamicLikeHashKey(dynamicType);</span><br><span class="line">            String dynamicLikeHashkey = RedisKeyUtil.getDynamicUserLikeHashKey(userId, dynamicId);</span><br><span class="line">            String userLikeHashKey = RedisKeyUtil.getUserLikeHashKey();</span><br><span class="line">            <span class="comment">// 点赞数记数</span></span><br><span class="line">            String dynamicLikeCountHashKey = RedisKeyUtil.getDynamicLikeCountHashKey();</span><br><span class="line"></span><br><span class="line">            redisTemplate.multi();</span><br><span class="line">            redisTemplate.opsForHash().put(dynamicLikeKey, dynamicLikeHashkey, <span class="number">0</span>);</span><br><span class="line">            redisTemplate.opsForHash().increment(userLikeHashKey,String.valueOf(userId),-<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 自增</span></span><br><span class="line">            Long increment = redisTemplate.opsForHash().increment(dynamicLikeCountHashKey, String.valueOf(dynamicId), -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            List exec = redisTemplate.exec();</span><br><span class="line">            <span class="keyword">return</span> exec.get(exec.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result.intValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取点赞数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dynamicId   动态id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> Long&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">getDynamicLikeCount1</span><span class="params">(<span class="keyword">int</span> dynamicId)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Integer result;</span><br><span class="line">    <span class="comment">// 点赞数记数</span></span><br><span class="line">    String dynamicLikeCountHashKey = RedisKeyUtil.getDynamicLikeCountHashKey();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Hash这里操作都需要String</span></span><br><span class="line">        Object o = redisTemplate.opsForHash().get(dynamicLikeCountHashKey, String.valueOf(dynamicId));</span><br><span class="line">        <span class="comment">// 如果缓存挂了,查询数据库</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == o)&#123;</span><br><span class="line">            log.info(<span class="string">"redis查询失败"</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"redis查询为空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        result = (Integer) o;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">        DynamicEntity byId = dynamicMapper.findById(dynamicId);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == byId)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"没有该id动态"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Integer starNum = byId.getStarNum();</span><br><span class="line">        result=starNum;</span><br><span class="line">        <span class="comment">//将结果缓存到redis</span></span><br><span class="line">        redisTemplate.opsForHash().put(dynamicLikeCountHashKey, String.valueOf(dynamicId), starNum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-Quartz定时任务持久化">5. Quartz定时任务持久化</h3>
<p>对于Hash结构存储的，还可以根据::分离出点赞人和被赞动态，拆分后进行持久化，配置好Quartz定时任务后，下面举例其中一个</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回需要插入数据库的列表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;UserLikeDynamicEntity&gt; <span class="title">getDBList</span><span class="params">(<span class="keyword">int</span> dynamicType)</span> </span>&#123;</span><br><span class="line">    List&lt;UserLikeDynamicEntity&gt; userLikeDynamicEntityList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Cursor&lt;Map.Entry&lt;Object,Object&gt;&gt; cursor = redisTemplate.opsForHash()</span><br><span class="line">                .scan(RedisKeyUtil.getDynamicLikeHashKey(dynamicType), ScanOptions.NONE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cursor.hasNext())&#123;</span><br><span class="line">            Map.Entry&lt;Object, Object&gt; entry = cursor.next();</span><br><span class="line">            String key = (String) entry.getKey();</span><br><span class="line">            <span class="comment">//分离出 UserId，dynamicId</span></span><br><span class="line">            String[] split = key.split(<span class="string">"::"</span>);</span><br><span class="line">            Integer userId = Integer.valueOf(split[<span class="number">0</span>]);</span><br><span class="line">            Integer dynamicId = Integer.valueOf(split[<span class="number">1</span>]);</span><br><span class="line">            Integer value = (Integer) entry.getValue();</span><br><span class="line"></span><br><span class="line">            String dynamicLikeSetKey = RedisKeyUtil.getDynamicLikeKey(dynamicType, dynamicId);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置过期，如果热点数据将会一直存在，如果不是会自动删除</span></span><br><span class="line">            redisTemplate.expire(dynamicLikeSetKey,<span class="number">2</span>, TimeUnit.DAYS);</span><br><span class="line">            redisTemplate.opsForSet().add(dynamicLikeSetKey,userId);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//组装成 UserLike 对象</span></span><br><span class="line">            UserLikeDynamicEntity userLikeDynamicEntity = <span class="keyword">new</span> UserLikeDynamicEntity();</span><br><span class="line">            userLikeDynamicEntity.setUserId(userId).setDynamicId(dynamicId).setState(value);</span><br><span class="line">            userLikeDynamicEntityList.add(userLikeDynamicEntity);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//存到 list 后从 Redis 中删除</span></span><br><span class="line">            redisTemplate.opsForHash().delete(RedisKeyUtil.getDynamicLikeHashKey(dynamicType),key);</span><br><span class="line">        &#125;</span><br><span class="line">    cursor.close();</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        log.error(<span class="string">"cursor关闭异常"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回需要插入的列表</span></span><br><span class="line">    <span class="keyword">return</span> userLikeDynamicEntityList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>以上是我暂时做的，可能有很多问题，如果有问题，希望能够指出，后期不一定可放源码</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring容器加入bean的几种方式</title>
    <url>/posts/47ffe934.html</url>
    <content><![CDATA[<h1>一、五种方式简介</h1>
<ul>
<li>@Configuration + @Bean</li>
<li>@ComponentScan + @Component</li>
<li>@Import 配合接口进行导入</li>
<li>使用FactoryBean。</li>
<li>实现BeanDefinitionRegistryPostProcessor进行后置处理。</li>
</ul>
<a id="more"></a>
<h1>二、五种方式具体介绍</h1>
<h2 id="1、-Configuration-Bean">1、@Configuration + @Bean</h2>
<p><code>@Configuration</code>用来声明一个配置类，然后使用 <code>@Bean</code> 注解，用于声明一个bean，将其加入到Spring容器中。这种方式是我们最常用的一种</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        person.setName(<span class="string">"spring"</span>);</span><br><span class="line">        <span class="keyword">return</span> person;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2、-Componet-ComponentScan">2、@Componet + @ComponentScan</h2>
<p><code>@Componet</code>中文译为组件，放在类名上面，然后<code>@ComponentScan</code>放置在我们的配置类上，然后可以指定一个路径，进行扫描带有<code>@Componet</code>注解的bean，然后加至容器中。这种方式也较为常用，spring扫描包路径就是使用这种方式，这样可以一下子扫描很多个bean到容器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该类在com.shawn.*包下面</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//*代表该包下匹配的所有包和类</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages = <span class="string">"com.shawn.*"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(Demo<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        Person bean = applicationContext.getBean(Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">//结果输出Person&#123;name='null'&#125;</span></span><br><span class="line">        System.out.println(bean);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3、-Import注解导入">3、@Import注解导入</h2>
<p><code>@Import</code>注解用到的并不是很多，但是非常重要，在进行Spring扩展时经常会用到。它通过搭配自定义注解进行使用，然后往容器中导入一个配置文件。它有四种使用方式。</p>
<p><code>@Import</code>注解的源码，表示只能放置在类上</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Import &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 用于导入一个class文件</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> Configuration <span class="doctag">@Configuration</span>&#125;, &#123;<span class="doctag">@link</span> ImportSelector&#125;,</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> ImportBeanDefinitionRegistrar&#125;, or regular component classes to import.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;?&gt;[] value();</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1、Import直接导入类">1、Import直接导入类</h3>
<p>直接使用<code>@Import</code>导入了一个类，然后自动的就被放置在IOC容器中了。<strong>注意</strong>我们的Person类上 就不需要任何的注解了，直接导入即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 直接使用<span class="doctag">@Import</span>导入person类，然后尝试从applicationContext中取，成功拿到</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="meta">@Import</span>(Person<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(Demo<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        Person bean = applicationContext.getBean(Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(bean);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、-Import-ImportSelector">2、@Import + ImportSelector</h3>
<p>自定义了一个<code>MyImportSelector</code> 实现了 <code>ImportSelector</code> 接口，重写<code>selectImports</code>方法，然后将我们要导入的类的全限定名写在里面即可导入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Import</span>(MyImportSelector<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(Demo<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        Person bean = applicationContext.getBean(Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(bean);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyImportSelector</span> <span class="keyword">implements</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">        <span class="comment">//这里需要具体到类名</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;<span class="string">"com.shawn.Person"</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3、-Import-ImportBeanDefinitionRegistrar">3、@Import + ImportBeanDefinitionRegistrar</h3>
<p>这种方式需要实现 <code>ImportBeanDefinitionRegistrar</code> 接口中的方法。BeanDefinition可以简单理解为bean的定义(bean的元数据)，也是需要放在IOC容器中进行管理的，先有bean的元数据，applicationContext再根据bean的元数据去创建Bean。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Import</span>(MyImportBeanDefinitionRegistrar<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(Demo<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        Person bean = applicationContext.getBean(Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(bean);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyImportBeanDefinitionRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 构建一个beanDefinition</span></span><br><span class="line">        AbstractBeanDefinition beanDefinition = BeanDefinitionBuilder.rootBeanDefinition(Person<span class="class">.<span class="keyword">class</span>).<span class="title">getBeanDefinition</span>()</span>;</span><br><span class="line">        <span class="comment">// 将beanDefinition注册到Ioc容器中</span></span><br><span class="line">        registry.registerBeanDefinition(<span class="string">"person"</span>, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4、-Import-DeferredImportSelector">4、@Import + DeferredImportSelector</h3>
<p>这种方式也需要我们进行实现接口，其实它和<code>@Import</code>的第二种方式差不多，<code>DeferredImportSelector</code> 它是 <code>ImportSelector</code> 的子接口，所以实现的方法和第二种无异。只是Spring的处理方式不同，它和Spring Boot中的自动导入配置文件延迟导入有关，非常重要</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Import</span>(MyDeferredImportSelector<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(Demo<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        Person bean = applicationContext.getBean(Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(bean);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDeferredImportSelector</span> <span class="keyword">implements</span> <span class="title">DeferredImportSelector</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">        <span class="comment">// 也是直接将Person的全限定名放进去</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;Person<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()&#125;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述三类还可以搭配@Configuration注解使用，用于导入一个配置类</p>
<h2 id="4、使用FactoryBean接口">4、使用FactoryBean接口</h2>
<p>FactoryBean接口和BeanFactory不一样，<code>BeanFactory</code>顾名思义 bean工厂，它是IOC容器的顶级接口。</p>
<p>下述代码通过<code>@Configuration + @Bean</code>的方式将 <code>PersonFactoryBean</code> 加入到容器中，注意，我没有向容器中注入 <code>Person</code>, 而是直接注入的 <code>PersonFactoryBean</code> 然后从容器中拿<code>Person</code>这个类型的<code>bean</code>，成功运行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PersonFactoryBean <span class="title">personFactoryBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PersonFactoryBean();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(Demo<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        Person bean = applicationContext.getBean(Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(bean);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  直接new出来Person进行返回.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  指定返回bean的类型.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> Person<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5、使用-BeanDefinitionRegistryPostProcessor">5、使用 BeanDefinitionRegistryPostProcessor</h2>
<p>这种方式也是利用到了 <code>BeanDefinitionRegistry</code>，在Spring容器启动的时候会执行 <code>BeanDefinitionRegistryPostProcessor</code> 的 <code>postProcessBeanDefinitionRegistry</code> 方法，大概意思就是等<code>beanDefinition</code>加载完毕之后，对<code>beanDefinition</code>进行后置处理，可以在此进行调整IOC容器中的<code>beanDefinition</code>，从而干扰到后面进行初始化bean。</p>
<p>下述代码中我们手动向beanDefinitionRegistry中注册了person的BeanDefinition，最终成功将person加入到applicationContext中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        MyBeanDefinitionRegistryPostProcessor beanDefinitionRegistryPostProcessor = <span class="keyword">new</span> MyBeanDefinitionRegistryPostProcessor();</span><br><span class="line">        applicationContext.addBeanFactoryPostProcessor(beanDefinitionRegistryPostProcessor);</span><br><span class="line">        applicationContext.refresh();</span><br><span class="line">        Person bean = applicationContext.getBean(Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(bean);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyBeanDefinitionRegistryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistryPostProcessor</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        AbstractBeanDefinition beanDefinition = BeanDefinitionBuilder.rootBeanDefinition(Person<span class="class">.<span class="keyword">class</span>).<span class="title">getBeanDefinition</span>()</span>;</span><br><span class="line">        registry.registerBeanDefinition(<span class="string">"person"</span>, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>参考文章</p>
<p><a href="https://blog.csdn.net/weixin_43741092/article/details/120176466" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43741092/article/details/120176466</a></p>
<p><a href="https://mp.weixin.qq.com/s/NpTNVGqU4dQwwgec3X4ibg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/NpTNVGqU4dQwwgec3X4ibg</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Spring基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Fluent MyBatis新建记录</title>
    <url>/posts/3faba84c.html</url>
    <content><![CDATA[<h2 id="1、代码生成">1、代码生成</h2>
<blockquote>
<p>官网文档：<a href="https://gitee.com/fluent-mybatis/fluent-mybatis/wikis/" target="_blank" rel="noopener">https://gitee.com/fluent-mybatis/fluent-mybatis/wikis/</a></p>
</blockquote>
<p>数据库结构表举例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 用户表可以添加一个点赞数字段，可选</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">exists</span> social_user;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> social_user (</span><br><span class="line">user_id <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">comment</span> <span class="string">'用户id'</span>,</span><br><span class="line">star_num <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">default</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'点赞数量'</span>,</span><br><span class="line">focus_num <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">default</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'关注数量'</span>,</span><br><span class="line">fan_num <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">default</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'粉丝数量'</span>,</span><br><span class="line">create_time <span class="built_in">timestamp</span> <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">default</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">comment</span> <span class="string">'创建时间'</span>,</span><br><span class="line">update_time <span class="built_in">timestamp</span> <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">default</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">comment</span> <span class="string">'修改时间'</span>,</span><br><span class="line">primary <span class="keyword">key</span>(user_id)</span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4 <span class="keyword">COMMENT</span>=<span class="string">'用户点赞表'</span>;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>在<code>pom.xml</code>中引入相关依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">fluent-mybatis.version</span>&gt;</span>1.8.7<span class="tag">&lt;/<span class="name">fluent-mybatis.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.projectreactor<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>reactor-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 引入fluent-mybatis 运行依赖包, scope为compile --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.atool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fluent-mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;fluent-mybatis.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 引入fluent-mybatis-processor, scope设置为provider 编译需要，运行时不需要 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.atool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fluent-mybatis-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;fluent-mybatis.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>设置代码生成文件，配置还是比较简单的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zstu.social.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.org.atool.generator.FileGenerator;</span><br><span class="line"><span class="keyword">import</span> cn.org.atool.generator.annotation.Table;</span><br><span class="line"><span class="keyword">import</span> cn.org.atool.generator.annotation.Tables;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EntityGenerator</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 数据源 url</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String url = <span class="string">"jdbc:mysql://localhost:3306/lamp_social?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=GMT%2B8"</span>;</span><br><span class="line">    <span class="comment">// 数据库用户名</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String username = <span class="string">"root"</span>;</span><br><span class="line">    <span class="comment">// 数据库密码</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String password = <span class="string">"root"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generate</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 引用配置类，build方法允许有多个配置类</span></span><br><span class="line">        FileGenerator.build(Empty<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Tables</span>(</span><br><span class="line">            <span class="comment">// 设置数据库连接信息</span></span><br><span class="line">            url = url, username = username, password = password,</span><br><span class="line">            <span class="comment">// 设置entity类生成src目录, 相对于 user.dir</span></span><br><span class="line">            srcDir = <span class="string">"src/main/java"</span>,</span><br><span class="line">            <span class="comment">// 设置entity类的package值</span></span><br><span class="line">            basePack = <span class="string">"com.zstu.social.entity"</span>,</span><br><span class="line">            <span class="comment">// 设置dao接口和实现的src目录, 相对于 user.dir</span></span><br><span class="line">            daoDir = <span class="string">"src/main/java"</span>,</span><br><span class="line">            <span class="comment">// 设置哪些表要生成Entity文件</span></span><br><span class="line">            <span class="comment">// tables = &#123;@Table(value = &#123;"social_comment","social_user","social_user_collect_video",</span></span><br><span class="line">            <span class="comment">// "social_user_focus","social_user_like_video","social_video"&#125;)&#125;,</span></span><br><span class="line">            tables = &#123;<span class="meta">@Table</span>(value = &#123;<span class="string">"social_user"</span>&#125;)&#125;,</span><br><span class="line">            tablePrefix = <span class="string">"social_"</span>,</span><br><span class="line">            logicDeleted = <span class="string">"deleted"</span>,</span><br><span class="line">            gmtCreated = <span class="string">"create_time"</span>,</span><br><span class="line">            gmtModified = <span class="string">"update_time"</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Empty</span> </span>&#123; <span class="comment">//类名随便取, 只是配置定义的一个载体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>点击运行后，此时会生成相应的entity和dao包，此时dao包可能会出现找不到类的错误信息<br>
<img src="https://img-blog.csdnimg.cn/6e8d83975f724e58b0262f5c27fb0bfe.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6a2FTGVtb24=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="请添加图片描述"><br>
需要对项目进行编译，完成后在target目录下会自动生成相应包<br>
<img src="https://img-blog.csdnimg.cn/2a6d83ba3ab8414b85f9bab0b32c3555.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6a2FTGVtb24=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="请添加图片描述"><br>
<img src="https://img-blog.csdnimg.cn/1c61d29cf3f0480e988ed7e23e9fb516.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6a2FTGVtb24=,size_19,color_FFFFFF,t_70,g_se,x_16" alt="请添加图片描述"><br>
<img src="https://img-blog.csdnimg.cn/c9add9bd74c34b2782e375fd0d124993.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6a2FTGVtb24=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="请添加图片描述"></p>
<p>之后在application.yml配置相关数据</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment"># 应用名称</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">social</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/lamp_social?useSSL=false&amp;allowPublicKeyRetrieval=true&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=GMT%2B8&amp;rewriteBatchedStatements=true</span></span><br></pre></td></tr></table></figure>
<p>😄较为关键一点，需要设置数据源。我之前忘记配置就出错了，这里先配置默认数据源</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zstu.social.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.org.atool.fluent.mybatis.spring.MapperFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  @Bean("dataSource")</span></span><br><span class="line">    <span class="comment">//  public DruidDataSource newDataSource() &#123;</span></span><br><span class="line">    <span class="comment">//    return DataSourceCreator.create("datasource");</span></span><br><span class="line">    <span class="comment">//  &#125;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//  @Bean</span></span><br><span class="line">    <span class="comment">//  public SqlSessionFactoryBean sqlSessionFactoryBean() throws Exception &#123;</span></span><br><span class="line">    <span class="comment">//    SqlSessionFactoryBean bean = new SqlSessionFactoryBean();</span></span><br><span class="line">    <span class="comment">//    bean.setDataSource(newDataSource());</span></span><br><span class="line">    <span class="comment">//    ResourcePatternResolver resolver = new PathMatchingResourcePatternResolver();</span></span><br><span class="line">    <span class="comment">//    // 以下部分根据自己的实际情况配置</span></span><br><span class="line">    <span class="comment">//    // 如果有mybatis原生文件, 请在这里加载</span></span><br><span class="line">    <span class="comment">//    bean.setMapperLocations(resolver.getResources("classpath*:mapper/*.xml"));</span></span><br><span class="line">    <span class="comment">//    /* bean.setMapperLocations(</span></span><br><span class="line">    <span class="comment">//    /*      new ClassPathResource("mapper/xml1.xml"),</span></span><br><span class="line">    <span class="comment">//    /*      new ClassPathResource("mapper/xml2.xml")</span></span><br><span class="line">    <span class="comment">//    /* );</span></span><br><span class="line">    <span class="comment">//    */</span></span><br><span class="line">    <span class="comment">//    org.apache.ibatis.session.Configuration configuration =</span></span><br><span class="line">    <span class="comment">//        new org.apache.ibatis.session.Configuration();</span></span><br><span class="line">    <span class="comment">//    configuration.setLazyLoadingEnabled(true);</span></span><br><span class="line">    <span class="comment">//    configuration.setMapUnderscoreToCamelCase(true);</span></span><br><span class="line">    <span class="comment">//    bean.setConfiguration(configuration);</span></span><br><span class="line">    <span class="comment">//    return bean;</span></span><br><span class="line">    <span class="comment">//  &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义fluent mybatis的MapperFactory</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MapperFactory <span class="title">mapperFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MapperFactory();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后在主函数上添加<code>@MapperScan</code>注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan</span>(&#123;<span class="string">"com.zstu.social.entity.mapper"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocialApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SocialApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码，成功</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zstu.social;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.zstu.social.entity.entity.UserEntity;</span><br><span class="line"><span class="keyword">import</span> com.zstu.social.entity.mapper.UserMapper;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SocialApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsert</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UserEntity userEntity = <span class="keyword">new</span> UserEntity()</span><br><span class="line">                .setUserId(<span class="number">1</span>)</span><br><span class="line">                .setFanNum(<span class="number">2</span>)</span><br><span class="line">                .setFocusNum(<span class="number">3</span>)</span><br><span class="line">                .setStarNum(<span class="number">4</span>);</span><br><span class="line">        userMapper.insertWithPk(userEntity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2、错误分析">2、错误分析</h2>
<p>1、出现以下错误，需要引入mybatis的maven依赖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Invalid <span class="keyword">default</span>: <span class="keyword">public</span> <span class="keyword">abstract</span> java.lang.Class org.mybatis.spring.annotation.MapperScan.factoryBean()</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>2、出现以下错误，代表没配置好数据源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Error invoking SqlProvider method <span class="string">'public static java.lang.String cn.org.atool.fluent.mybatis.base.provider.SqlProvider.insertWithPk(java.util.Map,org.apache.ibatis.builder.annotation.ProviderContext)'</span> with specify parameter <span class="string">'class org.apache.ibatis.binding.MapperMethod$ParamMap'</span>.  Cause: cn.org.atool.fluent.mybatis.exception.FluentMybatisException: Please add MapperFactory to spring container management:</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo在github添加域名</title>
    <url>/posts/2a9a9350.html</url>
    <content><![CDATA[<h2 id="1、创建CNAME文件">1、创建CNAME文件</h2>
<p>😀首先在hexo目录下的source文件夹生成CNAME文件，里面写上你的域名。因为我购买了shawn22.xyz的域名，所以这里我写了blog.shawn22.xyz</p>
<a id="more"></a>
<p><img src="https://img-blog.csdnimg.cn/cec589494c3e4a02828131ff8c5eccf0.png" alt></p>
<p>之后在主目录<code>hexo g</code>和<code>hexo d</code>即可</p>
<p>😄或者直接在仓库这里填写，仓库会自动生成CNAME文件<br>
<img src="https://img-blog.csdnimg.cn/97359905b76943ae82634b4bbe1818f2.png" alt></p>
<h2 id="2、域名解析">2、域名解析</h2>
<p>在域名添加记录，这里使用CNAME记录类型，记录值填写之前的地址<br>
<img src="https://img-blog.csdnimg.cn/9432aff41df5401eba56167944461ac9.png" alt></p>
]]></content>
      <categories>
        <category>Github</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot文件上传与校验</title>
    <url>/posts/2bc534dd.html</url>
    <content><![CDATA[<h1>一、简介</h1>
<h2 id="1、概述">1、概述</h2>
<p>文件上传是Web项目的一个基本功能，一般是通过上传文件的后缀名进行格式校验，但是由于文件的后缀是可以手动更改的，黑客可以通过修改后缀名入侵文件服务器，因此后缀名校验不是一种严格有效的文件校验方式。如果想要对上传文件进行严格的格式校验，则需要通过文件头进行校验，即<strong>魔数</strong>，<strong>文件头</strong>是位于文件开头的一段承担一定任务的数据，一般都在开头的部分，其作用就是为了描述一个文件的一些重要的属性,其可以作为是一类特定文件的标识。</p>
<a id="more"></a>
<h2 id="2、环境与技术介绍">2、环境与技术介绍</h2>
<p>SpringBoot2.5.6，AOP思想</p>
<p>使用切面编程，在文件上传之前，通过自定义注解首先进行自定义文件类型判断，若判断不通过，则通过全全局自定义异常返回，通过所有检查后才进行文件的上传，同时通过<code>ConditionalOnProperty</code>注解可以在<code>application.yml</code>中进行注解文件的打开或关闭，即校验文件功能的开启与关闭。</p>
<h2 id="3、简单的文件上传">3、简单的文件上传</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;file.staticPath&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> String staticPath;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;file.uploadFolder&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> String uploadFolder;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 上传文件，比较通用的方法，这里我写在这里可以进行参考修改</span></span><br><span class="line"><span class="comment"> * 其他方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">uploadFile</span><span class="params">(MultipartFile multipartFile, String dir)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//上传的文件：aaa.jpg</span></span><br><span class="line">        String realFileName = multipartFile.getOriginalFilename();</span><br><span class="line">        <span class="comment">//2：藏图文件名的后级</span></span><br><span class="line">        String imgSuffix = realFileName.substring(realFileName.lastIndexOf(<span class="string">"."</span>));</span><br><span class="line">        <span class="comment">//3：生成的唯一的文件名：能不能用中文名：不能因为统一用英文命名。</span></span><br><span class="line">        String newFileName = UUID.randomUUID().toString() + imgSuffix;</span><br><span class="line">        <span class="comment">//4：日期目录</span></span><br><span class="line">        SimpleDateFormat dateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy/MM/dd"</span>);</span><br><span class="line">        String datePath = dateFormat.format(<span class="keyword">new</span> Date());</span><br><span class="line">        <span class="comment">//5：服务路径</span></span><br><span class="line">        String serverName = uploadFolder;</span><br><span class="line">        <span class="comment">//6：指定文件上传以后的目录</span></span><br><span class="line">        File targetPath = <span class="keyword">new</span> File(serverName + dir, datePath);</span><br><span class="line">        <span class="keyword">if</span> (!targetPath.exists()) &#123;</span><br><span class="line">            targetPath.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//6：指定文件上传以后的服务器的完整的文件名</span></span><br><span class="line">        File targetFileName = <span class="keyword">new</span> File(targetPath, newFileName);</span><br><span class="line">        <span class="comment">//7：文件上传到指定的目录</span></span><br><span class="line">        multipartFile.transferTo(targetFileName);</span><br><span class="line">        <span class="comment">// 返回的自由选择，可以选择Map进行返回</span></span><br><span class="line">        String fileName = dir + File.separator + datePath + File.separator + newFileName;</span><br><span class="line">        <span class="keyword">return</span> staticPath + File.separator + fileName;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"fail"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>yml中进行配置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">file:</span></span><br><span class="line">  <span class="attr">staticPatternPath:</span> <span class="string">/upload/**</span></span><br><span class="line">  <span class="attr">uploadFolder:</span> <span class="string">/www/upload/</span></span><br><span class="line">  <span class="attr">staticPath:</span> <span class="string">http://www.shawn22.xyz:8080</span></span><br></pre></td></tr></table></figure>
<h1>二、文件校验与上传实战</h1>
<h2 id="1、-前提准备">1、 前提准备</h2>
<p><a href="https://blog.csdn.net/lemon_TT/article/details/114846566" target="_blank" rel="noopener">SpringBoot Log4j2日志</a></p>
<p><a href="https://blog.csdn.net/lemon_TT/article/details/108309900" target="_blank" rel="noopener">SpringBoot自定义全局异常</a></p>
<h2 id="2、-文件枚举类">2、 文件枚举类</h2>
<p>包含了每种文件的后缀名与头部魔数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文件类型</span></span><br><span class="line"><span class="comment"> * 文件魔数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Shawn</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/11/23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> FileType &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * JPEG  (jpg)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    JPEG(<span class="string">"JPEG"</span>, <span class="string">"FFD8FF"</span>),</span><br><span class="line"></span><br><span class="line">    JPG(<span class="string">"JPG"</span>, <span class="string">"FFD8FF"</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * PNG</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    PNG(<span class="string">"PNG"</span>, <span class="string">"89504E47"</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * GIF</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    GIF(<span class="string">"GIF"</span>, <span class="string">"47494638"</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * TIFF (tif)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TIFF(<span class="string">"TIF"</span>, <span class="string">"49492A00"</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Windows bitmap (bmp)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    BMP(<span class="string">"BMP"</span>, <span class="string">"424D"</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 16色位图(bmp)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    BMP_16(<span class="string">"BMP"</span>, <span class="string">"424D228C010000000000"</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 24位位图(bmp)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    BMP_24(<span class="string">"BMP"</span>, <span class="string">"424D8240090000000000"</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 256色位图(bmp)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    BMP_256(<span class="string">"BMP"</span>, <span class="string">"424D8E1B030000000000"</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * CAD  (dwg)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    DWG(<span class="string">"DWG"</span>, <span class="string">"41433130"</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Adobe photoshop  (psd)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    PSD(<span class="string">"PSD"</span>, <span class="string">"38425053"</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Rich Text Format  (rtf)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RTF(<span class="string">"RTF"</span>, <span class="string">"7B5C727466"</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * XML</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    XML(<span class="string">"XML"</span>, <span class="string">"3C3F786D6C"</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HTML (html)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    HTML(<span class="string">"HTML"</span>, <span class="string">"68746D6C3E"</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Email [thorough only] (eml)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    EML(<span class="string">"EML"</span>, <span class="string">"44656C69766572792D646174653A"</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Outlook Express (dbx)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    DBX(<span class="string">"DBX"</span>, <span class="string">"CFAD12FEC5FD746F "</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Outlook (pst)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    PST(<span class="string">""</span>, <span class="string">"2142444E"</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * doc;xls;dot;ppt;xla;ppa;pps;pot;msi;sdw;db</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    OLE2(<span class="string">"OLE2"</span>, <span class="string">"0xD0CF11E0A1B11AE1"</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Microsoft Word/Excel 注意：word 和 excel的文件头一样</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    XLS(<span class="string">"XLS"</span>, <span class="string">"D0CF11E0"</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Microsoft Word/Excel 注意：word 和 excel的文件头一样</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    DOC(<span class="string">"DOC"</span>, <span class="string">"D0CF11E0"</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Microsoft Word/Excel 2007以上版本文件 注意：word 和 excel的文件头一样</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    DOCX(<span class="string">"DOCX"</span>, <span class="string">"504B0304"</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Microsoft Word/Excel 2007以上版本文件 注意：word 和 excel的文件头一样 504B030414000600080000002100</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    XLSX(<span class="string">"XLSX"</span>, <span class="string">"504B0304"</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Microsoft Access (mdb)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    MDB(<span class="string">"MDB"</span>, <span class="string">"5374616E64617264204A"</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Adobe Acrobat (pdf) 255044462D312E</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    PDF(<span class="string">"PDF"</span>, <span class="string">"25504446"</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Windows Password  (pwl)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    PWL(<span class="string">"PWL"</span>, <span class="string">"E3828596"</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * WAVE (wav)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    WAV(<span class="string">"WAV"</span>, <span class="string">"57415645"</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * AVI</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AVI(<span class="string">"AVI"</span>, <span class="string">"41564920"</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Real Audio (ram)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RAM(<span class="string">"RAM"</span>, <span class="string">"2E7261FD"</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Real Media (rm) rmvb/rm相同</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RM(<span class="string">"RM"</span>, <span class="string">"2E524D46"</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Real Media (rm) rmvb/rm相同</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RMVB(<span class="string">"RMVB"</span>, <span class="string">"2E524D46000000120001"</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * MPEG (mpg)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    MPG(<span class="string">"MPG"</span>, <span class="string">"000001BA"</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Quicktime  (mov)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    MOV(<span class="string">"MOV"</span>, <span class="string">"6D6F6F76"</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * MIDI (mid)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    MID(<span class="string">"MID"</span>, <span class="string">"4D546864"</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * MP4</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    MP4(<span class="string">"MP4"</span>, <span class="string">"00000020667479706D70"</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * MP3</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    MP3(<span class="string">"MP3"</span>, <span class="string">"49443303000000002176"</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * FLV</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    FLV(<span class="string">"FLV"</span>, <span class="string">"464C5601050000000900"</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * torrent</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TORRENT(<span class="string">"TORRENT"</span>, <span class="string">"6431303A637265617465"</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * JSP Archive</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    JSP(<span class="string">"JSP"</span>, <span class="string">"3C2540207061676520"</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * JAVA Archive</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    JAVA(<span class="string">"JAVA"</span>, <span class="string">"7061636B61676520"</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * CLASS Archive</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    CLASS(<span class="string">"CLASS"</span>, <span class="string">"CAFEBABE0000002E00"</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * JAR Archive</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    JAR(<span class="string">"JAR"</span>, <span class="string">"504B03040A000000"</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * MF Archive</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    MF(<span class="string">"MF"</span>, <span class="string">"4D616E69666573742D56"</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * EXE Archive</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    EXE(<span class="string">"EXE"</span>, <span class="string">"4D5A9000030000000400"</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ELF Executable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ELF(<span class="string">"ELF"</span>, <span class="string">"7F454C4601010100"</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Lotus 123 v1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    WK1(<span class="string">"WK1"</span>, <span class="string">"2000604060"</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Lotus 123 v3</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    WK3(<span class="string">"WK3"</span>, <span class="string">"00001A0000100400"</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Lotus 123 v5</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    WK4(<span class="string">"WK4"</span>, <span class="string">"00001A0002100400"</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Lotus WordPro v9</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    LWP(<span class="string">"LWP"</span>, <span class="string">"576F726450726F"</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sage(sly.or.srt.or.slt;sly;srt;slt)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SLY(<span class="string">"SLY"</span>, <span class="string">"53520100"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后缀 大写字母</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String suffix;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 魔数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String magicNumber;</span><br><span class="line"></span><br><span class="line">    FileType(String suffix, String magicNumber) &#123;</span><br><span class="line">        <span class="keyword">this</span>.suffix = suffix;</span><br><span class="line">        <span class="keyword">this</span>.magicNumber = magicNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> FileType <span class="title">getBySuffix</span><span class="params">(String suffix)</span> <span class="keyword">throws</span> FileUploadException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (FileType fileType : FileType.values()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fileType.getSuffix().equals(suffix.toUpperCase())) &#123;</span><br><span class="line">                <span class="keyword">return</span> fileType;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> FileUploadException(<span class="string">"不支持的文件后缀 : "</span> + suffix);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3、-自定义文件校验注解">3、 自定义文件校验注解</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文件检查</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Shawn</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/11/23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FileCheck &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 校验不通过提示信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">message</span><span class="params">()</span> <span class="keyword">default</span> "不支持的文件格式"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 校验方式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">CheckType <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> CheckType.SUFFIX</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 支持的文件后缀</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] supportedSuffixes() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 支持的文件类型</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    FileType[] supportedFileTypes() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> CheckType &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 仅校验后缀</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        SUFFIX,</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 校验文件头(魔数)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        MAGIC_NUMBER,</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 同时校验后缀和文件头</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        SUFFIX_MAGIC_NUMBER</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4、-文件校验切面">4、 文件校验切面</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Shawn</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021年11月23日9:32</span></span><br><span class="line"><span class="comment"> * prefix为配置文件中的前缀,</span></span><br><span class="line"><span class="comment"> * name为配置的名字</span></span><br><span class="line"><span class="comment"> * havingValue是与配置的值对比值,当两个值相同返回true,配置类生效</span></span><br><span class="line"><span class="comment"> * 需要在yml中进行配置：前缀+名字，值为true，表示该配置文件生效</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"file-check"</span>, name = <span class="string">"enabled"</span>, havingValue = <span class="string">"true"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileCheckAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 目标方法：被<span class="doctag">@FileCheck</span>注解的方法即为目标方法</span></span><br><span class="line"><span class="comment">     * 其中<span class="doctag">@annotation</span>中的值，需要和target方法中参数名称相同（必须相同，但是名称任意）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint  连接点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> annotation 文件检查</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"@annotation(annotation)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(JoinPoint joinPoint, FileCheck annotation)</span> <span class="keyword">throws</span> FileUploadException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String[] suffixes = annotation.supportedSuffixes();</span><br><span class="line">        <span class="keyword">final</span> FileCheck.CheckType type = annotation.type();</span><br><span class="line">        <span class="keyword">final</span> FileType[] fileTypes = annotation.supportedFileTypes();</span><br><span class="line">        <span class="keyword">final</span> String message = annotation.message();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 支持的文件后缀和文件类型有一个为空则返回</span></span><br><span class="line">        <span class="keyword">if</span> (ArrayUtils.isEmpty(suffixes) &amp;&amp; ArrayUtils.isEmpty(fileTypes)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line">        <span class="comment">//文件后缀转成set集合</span></span><br><span class="line">        Set&lt;String&gt; suffixSet = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(suffixes));</span><br><span class="line">        <span class="keyword">for</span> (FileType fileType : fileTypes) &#123;</span><br><span class="line">            suffixSet.add(fileType.getSuffix());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//文件类型转成set集合</span></span><br><span class="line">        Set&lt;FileType&gt; fileTypeSet = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(fileTypes));</span><br><span class="line">        <span class="keyword">for</span> (String suffix : suffixes) &#123;</span><br><span class="line">            fileTypeSet.add(FileType.getBySuffix(suffix));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对参数是文件的进行校验</span></span><br><span class="line">        <span class="keyword">for</span> (Object arg : args) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arg <span class="keyword">instanceof</span> MultipartFile) &#123;</span><br><span class="line">                doCheck((MultipartFile) arg, type, suffixSet, fileTypeSet, message);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arg <span class="keyword">instanceof</span> MultipartFile[]) &#123;</span><br><span class="line">                <span class="keyword">for</span> (MultipartFile file : (MultipartFile[]) arg) &#123;</span><br><span class="line">                    doCheck(file, type, suffixSet, fileTypeSet, message);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据指定的检查类型对文件进行校验</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doCheck</span><span class="params">(MultipartFile file, FileCheck.CheckType type, Set&lt;String&gt; suffixSet, Set&lt;FileType&gt; fileTypeSet, String message)</span> <span class="keyword">throws</span> FileUploadException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (type == FileCheck.CheckType.SUFFIX) &#123;</span><br><span class="line">            doCheckSuffix(file, suffixSet, message);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == FileCheck.CheckType.MAGIC_NUMBER) &#123;</span><br><span class="line">            doCheckMagicNumber(file, fileTypeSet, message);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            doCheckSuffix(file, suffixSet, message);</span><br><span class="line">            doCheckMagicNumber(file, fileTypeSet, message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 验证文件魔数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doCheckMagicNumber</span><span class="params">(MultipartFile file, Set&lt;FileType&gt; fileTypeSet, String message)</span> <span class="keyword">throws</span> FileUploadException </span>&#123;</span><br><span class="line">        String magicNumber = readMagicNumber(file);</span><br><span class="line">        String fileName = file.getOriginalFilename();</span><br><span class="line">        String fileSuffix = fileName.substring(fileName.lastIndexOf(<span class="string">"."</span>) + <span class="number">1</span>).toUpperCase();</span><br><span class="line">        <span class="keyword">for</span> (FileType fileType : fileTypeSet) &#123;</span><br><span class="line">            <span class="keyword">if</span> (magicNumber.startsWith(fileType.getMagicNumber()) &amp;&amp; fileType.getSuffix().toUpperCase().equalsIgnoreCase(fileSuffix)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        log.error(<span class="string">"文件头格式错误：&#123;&#125;"</span>, magicNumber);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> FileUploadException(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 验证文件后缀</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doCheckSuffix</span><span class="params">(MultipartFile file, Set&lt;String&gt; suffixSet, String message)</span> <span class="keyword">throws</span> FileUploadException </span>&#123;</span><br><span class="line">        String fileName = file.getOriginalFilename();</span><br><span class="line">        String fileSuffix = fileName.substring(fileName.lastIndexOf(<span class="string">"."</span>) + <span class="number">1</span>).toUpperCase();</span><br><span class="line">        <span class="keyword">for</span> (String suffix : suffixSet) &#123;</span><br><span class="line">            <span class="keyword">if</span> (suffix.toUpperCase().equalsIgnoreCase(fileSuffix)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        log.error(<span class="string">"文件后缀格式错误：&#123;&#125;"</span>, message);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> FileUploadException(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取文件，获取文件头</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">readMagicNumber</span><span class="params">(MultipartFile file)</span> <span class="keyword">throws</span> FileUploadException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (InputStream is = file.getInputStream()) &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] fileHeader = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>];</span><br><span class="line">            is.read(fileHeader, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">            <span class="keyword">return</span> byteArray2Hex(fileHeader);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            log.error(<span class="string">"文件读取错误：&#123;0&#125;"</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> FileUploadException(<span class="string">"读取文件失败!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字节数组转十六进制</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">byteArray2Hex</span><span class="params">(<span class="keyword">byte</span>[] data)</span> </span>&#123;</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">if</span> (ArrayUtils.isEmpty(data)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span> datum : data) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = datum &amp; <span class="number">0xFF</span>;</span><br><span class="line">            String hv = Integer.toHexString(v).toUpperCase();</span><br><span class="line">            <span class="keyword">if</span> (hv.length() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">                stringBuilder.append(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            stringBuilder.append(hv);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5、-文件上传工具类">5、 文件上传工具类</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文件上传工具类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Shawn</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021年11月22日19:45</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(FileUtils<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件上传</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file 文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> String&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception 异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">fileUpload</span><span class="params">(Integer type, Integer userId,MultipartFile file)</span> <span class="keyword">throws</span> FileUploadException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取文件名，带后缀</span></span><br><span class="line">        String originalFilename = file.getOriginalFilename();</span><br><span class="line">        <span class="comment">// 获取文件的后缀格式</span></span><br><span class="line">        String fileSuffix = originalFilename.substring(originalFilename.lastIndexOf(<span class="string">"."</span>) + <span class="number">1</span>).toLowerCase();</span><br><span class="line"></span><br><span class="line">        String filePrefix = String.valueOf(System.currentTimeMillis())</span><br><span class="line">                .concat(String.valueOf(type))</span><br><span class="line">                .concat(String.valueOf(userId));</span><br><span class="line">        String newFileName = filePrefix.concat(<span class="string">"."</span>).concat(fileSuffix);</span><br><span class="line"></span><br><span class="line">        String dirPath;</span><br><span class="line">        <span class="comment">// 判断上传类型</span></span><br><span class="line">        <span class="keyword">if</span>(type == <span class="number">0</span> )&#123;</span><br><span class="line">            dirPath = FileLocationEnum.LocalVideoLocation.getLocation();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            dirPath = FileLocationEnum.LocalPicLocation.getLocation();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String path = dirPath + newFileName;</span><br><span class="line"></span><br><span class="line">        File destFile = <span class="keyword">new</span> File(dirPath + newFileName);</span><br><span class="line">        <span class="keyword">if</span> (!destFile.getParentFile().exists()) &#123;</span><br><span class="line">            destFile.getParentFile().mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            file.transferTo(destFile);</span><br><span class="line">            logger.info(<span class="string">"单次上传文件成功"</span>);</span><br><span class="line">            <span class="comment">// 将相对路径返回给前端</span></span><br><span class="line">            <span class="keyword">return</span> path;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            logger.error(<span class="string">"upload pic error"</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> FileUploadException(<span class="string">"上传文件错误"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件上传的图片</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type   类型,图片为1，视频为0</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userId 用户id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> files   文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> List&lt;String&gt;&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">fileUploadWithPics</span><span class="params">(<span class="keyword">int</span> type, Integer userId, MultipartFile[] files)</span> <span class="keyword">throws</span> FileUploadException </span>&#123;</span><br><span class="line">        List&lt;String&gt; picList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (MultipartFile file:files) &#123;</span><br><span class="line">            picList.add(fileUpload(type,userId,file));</span><br><span class="line">        &#125;</span><br><span class="line">        logger.info(<span class="string">"多图片文件上传成功"</span>);</span><br><span class="line">        <span class="keyword">return</span> picList;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6、-控制类">6、 控制类</h2>
<p>这里提供了一个视频上传接口和多图片上传接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Shawn</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021年11月22日21:09</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/file"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUploadController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件上传的图片</span></span><br><span class="line"><span class="comment">     * 同时校验后缀和文件头</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userId 用户id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file   文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> ResultVO&lt;?&gt;&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception 异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/fileuploadwithpics"</span>)</span><br><span class="line">    <span class="meta">@FileCheck</span>(message = <span class="string">"不支持的图片格式"</span>,</span><br><span class="line">            supportedSuffixes = &#123;<span class="string">"png"</span>, <span class="string">"jpg"</span>,  <span class="string">"jpeg"</span>&#125;,</span><br><span class="line">            type = FileCheck.CheckType.SUFFIX_MAGIC_NUMBER,</span><br><span class="line">            supportedFileTypes = &#123;FileType.PNG, FileType.JPG, FileType.JPEG&#125;)</span><br><span class="line">    <span class="keyword">public</span> ResultVO&lt;?&gt; fileUploadWithPics(Integer userId, <span class="meta">@RequestParam</span>(<span class="string">"pics"</span>) MultipartFile[] MultipartFile) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span>(userId==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ResultVO&lt;&gt;(<span class="number">400</span>,<span class="string">"缺少userId参数"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1表示图片，0 表示视频</span></span><br><span class="line">        List&lt;String&gt; result = FileUtils.fileUploadWithPics(<span class="number">1</span>, userId, MultipartFile);</span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">        map.put(<span class="string">"picUrl"</span>,result);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResultVO&lt;&gt;(map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件上传视频</span></span><br><span class="line"><span class="comment">     * 仅校验后缀</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userId 用户id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file   文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> ResultVO&lt;?&gt;&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception 异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/fileuploadwithvideo"</span>)</span><br><span class="line">    <span class="meta">@FileCheck</span>(message = <span class="string">"不支持的视频格式"</span>,</span><br><span class="line">            type = FileCheck.CheckType.SUFFIX,</span><br><span class="line">            supportedSuffixes = &#123;<span class="string">"mp4"</span>,<span class="string">"gif"</span>&#125;)</span><br><span class="line">    <span class="keyword">public</span> ResultVO&lt;?&gt; fileUploadWithVideo(Integer userId, <span class="meta">@RequestParam</span>(<span class="string">"video"</span>) MultipartFile file) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span>(userId==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ResultVO&lt;&gt;(<span class="number">400</span>,<span class="string">"缺少userId参数"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        String s = FileUtils.fileUpload(<span class="number">0</span>, userId, file);</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">        map.put(<span class="string">"videoUrl"</span>,s);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResultVO&lt;&gt;(map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7、-配置文件">7、 配置文件</h2>
<p>在<code>application.yml</code>进行配置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">multipart:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">      <span class="comment"># 单个文件大小，m默认1M</span></span><br><span class="line">      <span class="attr">max-file-size:</span> <span class="string">10MB</span></span><br><span class="line">      <span class="comment"># 总上传文件大小，默认10M</span></span><br><span class="line">      <span class="attr">max-request-size:</span> <span class="string">30MB</span></span><br><span class="line">      <span class="comment"># 文件多少时写入磁盘，默认为0，有文件就写入</span></span><br><span class="line">      <span class="comment"># file-size-threshold: 10MB</span></span><br></pre></td></tr></table></figure>
<h2 id="8、-文件的前端显示">8、 文件的前端显示</h2>
<p>一种是Nginx进行映射，这种方式比较常见；另一种是SpringBoot自带的映射穿透，需要在application配置好映射关系，或者在java里配置好映射关系。</p>
<p>若视频放在<code>D:\social\</code>文件夹下，最终资源访问路径<code>http://ip:port/social/xxxx</code></p>
<p><strong>Yml配置文件方式</strong></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">    <span class="attr">static-path-pattern:</span> <span class="string">/social/**</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">static-locations:</span> <span class="string">file:D:\social\</span></span><br></pre></td></tr></table></figure>
<p><strong>javaBean配置方式</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    #application.yml中的配置</span></span><br><span class="line"><span class="comment">    file:</span></span><br><span class="line"><span class="comment">      staticPatternPath: /social/**</span></span><br><span class="line"><span class="comment">      uploadFolder: file:D:\social\</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这个注解必须加，将该bean交给Spring管理，否则无法解析@Value</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;file.staticPatternPath&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String staticPatternPath;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;file.uploadFolder&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String uploadFolder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个方法是springboot中springMvc让程序开发者去配置文件上传的额外的静态资源服务的配置</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// staticPatternPath 是访问路径，后面的是上传的资源路径</span></span><br><span class="line">        <span class="comment">// uploadFolder 是文件存储位置，而文件保存在uploadFolder 目录下</span></span><br><span class="line">        registry.addResourceHandler(staticPatternPath).addResourceLocations(uploadFolder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1>三、阿里云OSS文件上传</h1>
<h2 id="1、-阿里云oss配置">1、 阿里云oss配置</h2>
<p>首先开通阿里云oss，选择公共读，这样别人才可以读到我们的文件，但这样可能会导致上行流量剧增<br>
<img src="https://img-blog.csdnimg.cn/18ca4743d8d3451587f87c90abad7b96.png" alt="请添加图片描述"></p>
<p>创建玩Bucket后，需要配置一下ssl证书和已备案自定义域名，否则浏览器只能下载，不能读<br>
<img src="https://img-blog.csdnimg.cn/a3ecc0f366ab42edb107aa8064df404e.png" alt="请添加图片描述"></p>
<p>最后获取AccessKey和SecretKey。进入 AccessKey管理 ，进入之后选择开始使用子用户AccessKey（推荐，这样安全），创建子用户，选择openAPI访问，创建完成后，添加AliyunOSSFullAccess权限</p>
<h2 id="2、-Java整合oss">2、 Java整合oss</h2>
<blockquote>
<p>官方教程：<a href="https://help.aliyun.com/document_detail/84778.html" target="_blank" rel="noopener">https://help.aliyun.com/document_detail/84778.html</a></p>
</blockquote>
<p>下面简单说一下配置，首先配置maven</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">&lt;dependency&gt;</span></span><br><span class="line">    <span class="string">&lt;groupId&gt;com.aliyun.oss&lt;/groupId&gt;</span></span><br><span class="line">    <span class="string">&lt;artifactId&gt;aliyun-sdk-oss&lt;/artifactId&gt;</span></span><br><span class="line">    <span class="string">&lt;version&gt;3.10.2&lt;/version&gt;</span></span><br><span class="line"><span class="string">&lt;/dependency&gt;</span></span><br></pre></td></tr></table></figure>
<p>创建上传方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">uploadFile</span><span class="params">(MultipartFile multipartFile)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// yourEndpoint填写Bucket所在地域对应的Endpoint。以华东1（杭州）为例，Endpoint填写为https://oss-cn-hangzhou.aliyuncs.com。</span></span><br><span class="line">        String endpoint = <span class="string">"oss-cn-hangzhou.aliyuncs.com"</span>;</span><br><span class="line">        <span class="comment">// 阿里云账号AccessKey拥有所有API的访问权限，风险很高。强烈建议您创建并使用RAM用户进行API访问或日常运维，请登录RAM控制台创建RAM用户。</span></span><br><span class="line">        String accessKeyId = <span class="string">""</span>;</span><br><span class="line">        String accessKeySecret = <span class="string">""</span>;</span><br><span class="line">        <span class="comment">// 你的桶名字</span></span><br><span class="line">        String bucketName = <span class="string">""</span>;</span><br><span class="line">        <span class="comment">// 你的自定义域名，需要备案和配好ssl证书</span></span><br><span class="line">        String domainName = <span class="string">""</span>;</span><br><span class="line">        <span class="comment">// 桶里面你的根目录</span></span><br><span class="line">        String rootPath = <span class="string">"lamp"</span>;</span><br><span class="line"></span><br><span class="line">        OSS ossClient = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建OSSClient实例。</span></span><br><span class="line">            ossClient = <span class="keyword">new</span> OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);</span><br><span class="line">            <span class="comment">// 获取文件上传的流</span></span><br><span class="line">            InputStream inputStream = multipartFile.getInputStream();</span><br><span class="line">            <span class="comment">// 构建指定目录，按日期分类</span></span><br><span class="line">            SimpleDateFormat dateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy/MM/dd"</span>);</span><br><span class="line">            String datePath = dateFormat.format(<span class="keyword">new</span> Date());</span><br><span class="line">            <span class="comment">// 获取文件名</span></span><br><span class="line">            String originName = multipartFile.getOriginalFilename();</span><br><span class="line">            String filename = UUID.randomUUID().toString();</span><br><span class="line">            String suffix = originName.substring(originName.lastIndexOf(<span class="string">"."</span>));</span><br><span class="line">            String newName = filename + suffix;</span><br><span class="line">            String fileUrl = rootPath + <span class="string">"/"</span> + datePath + <span class="string">"/"</span> + newName;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 上传文件</span></span><br><span class="line">            ossClient.putObject(bucketName, fileUrl, inputStream);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"https://"</span> + domainName + <span class="string">"/"</span> + fileUrl;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"fail"</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 关闭OSSClient。</span></span><br><span class="line">            ossClient.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="3、-注意事项">3、 注意事项</h2>
<p>使用 OSS 默认域名访问 html、图片资源，会有以附件形式下载的情况。若需要浏览器直接访问，需使用自定义域名进行访问，同时保证已经配置好ssl证书；同时oss桶还可以用来做图床</p>
<p>其他请参考官方文档</p>
<hr>
<p>参考文献：</p>
<p><a href="https://www.jianshu.com/p/be3f4c26c39a" target="_blank" rel="noopener">https://www.jianshu.com/p/be3f4c26c39a</a></p>
<p><a href="https://www.cnblogs.com/zys2019/p/15394599.html" target="_blank" rel="noopener">https://www.cnblogs.com/zys2019/p/15394599.html</a></p>
<p><a href="https://www.bilibili.com/video/BV1C3411b7wt?p=15&amp;spm_id_from=pageDriver" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1C3411b7wt?p=15&amp;spm_id_from=pageDriver</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Java8异步编程</title>
    <url>/posts/a546640b.html</url>
    <content><![CDATA[<h1>一、引言</h1>
<p>参考<a href="https://blog.csdn.net/lemon_TT/article/details/115002211" target="_blank" rel="noopener">Java多线程几种实现方式</a>，我们可以很快速的通过<code>new Thread(...).start()</code>开启一个新的线程，但是这样创建线程会有很多坏处：</p>
<ul>
<li>
<p>每次都要新建一个对象，性能差；</p>
</li>
<li>
<p>建出来的很多个对象是独立的，缺乏统一的管理。如果在代码中无限新建线程会导致这些线程相互竞争，占用过多的系统资源从而导致死机或者 <strong>oom</strong> ；</p>
</li>
<li>
<p>缺乏许多功能如定时执行、中断等。</p>
</li>
</ul>
<p>因此Java给我们提供好一个十分好用的工具，那就是<strong>线程池</strong></p>
<a id="more"></a>
<h1>二、Java线程池</h1>
<h2 id="1、Java线程池概述">1、Java线程池概述</h2>
<p>Java提供了一个工厂类来构造我们需要的线程池，这个工厂类就是 Executors 。这里主要讲4个创建线程池的方法，即</p>
<ul>
<li>
<p>newCachedThreadPool()</p>
</li>
<li>
<p>newFixedThreadPool(int nThreads)</p>
</li>
<li>
<p>newScheduledThreadPool(int corePoolSize)</p>
</li>
<li>
<p>newSingleThreadExecutor()</p>
</li>
</ul>
<h2 id="2、newCachedThreadPool">2、newCachedThreadPool()</h2>
<p>创建缓存线程池。缓存的意思就是这个线程池会<strong>根据需要创建新的线程</strong> ，在有新任务的时候会优先使用先前创建出的线程。线程一旦创建了就一直在这个池子里面了，执行完任务后后续还有任务需要会<strong>重用这个线程</strong> ，若是<strong>线程不够用了再去新建线程</strong> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每次发布任务前根据奇偶不同等待一段时间，如1s，这样就会创建两个线程</span></span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行任务</span></span><br><span class="line">    cachedThreadPool.execute(() -&gt; System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + index));</span><br></pre></td></tr></table></figure>
<p>注意这里的线程池是<strong>无限大的</strong> ，并没有规定他的大小</p>
<h2 id="3、newFixedThreadPool-int-nThreads">3、newFixedThreadPool(int nThreads)</h2>
<p>创建定长线程池，参数是线程池的大小。也就是说，在同一时间执行的线程数量只能是 nThreads 这么多，这个线程池可以有效的控制最大并发数从而防止占用过多资源。超出的线程会放在线程池的一个<strong>无界队列里等待</strong> 其他线程执行完。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<h2 id="4、newScheduledThreadPool-int-corePoolSize">4、newScheduledThreadPool(int corePoolSize)</h2>
<p>第3个坏处线程池的坏处就是缺乏定时执行功能，这个Scheduled代表是支持的，这个线程池也是定长的，参数 corePoolSize 就是线程池的大小，即在空闲状态下要保留在池中的线程数量。而要实现调度需要使用这个线程池的 schedule() 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 三秒后执行</span></span><br><span class="line">scheduledExecutorService.schedule(() -&gt; System.out.println(Thread.currentThread().getName() + <span class="string">": 我会在3秒后执行。"</span>),</span><br><span class="line">                <span class="number">3</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>
<h2 id="5、newSingleThreadExecutor">5、newSingleThreadExecutor()</h2>
<p>创建<strong>单线程池</strong> ，只使用<strong>一个线程</strong> 来执行任务。但是它与 <code>newFixedThreadPool(1, threadFactory)</code> 不同，它会<strong>保证创建的这个线程池不会被重新配置为使用其他的线程</strong> ，也就是说这个线程池里的线程始终如一。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br></pre></td></tr></table></figure>
<h2 id="6、线程池的关闭">6、线程池的关闭</h2>
<p>线程池启动后需要手动关闭，否则会一直不结束</p>
<ul>
<li>
<p><code>shutdown()</code> : 将线程池状态置成 <code>SHUTDOWN</code>，此时<strong>不再接受新的任务</strong> ，<strong>等待线程池中已有任务执行完成后结束</strong> ；</p>
</li>
<li>
<p><code>shutdownNow()</code> : 将线程池状态置成 <code>SHUTDOWN</code>，将线程池中<strong>所有线程中断</strong> （调用线程的 <code>interrupt()</code> 操作），清空队列，并返回<strong>正在等待执行的任务列表</strong> 。</p>
</li>
</ul>
<p>并且它还提供了查看线程池是否关闭和是否终止的方法，分别为 <code>isShutdown()</code> 和 <code>isTerminated()</code> 。</p>
<h1>三、几种函数式接口</h1>
<h2 id="1、简介">1、简介</h2>
<p>函数式接口可以参考<a href="https://blog.csdn.net/lemon_TT/article/details/119415154" target="_blank" rel="noopener">java8常用新特性</a>，这里主要介绍几种函数式接口，Callable、Runnable、Future、CompletableFuture和FutureTask</p>
<h2 id="2、Callable和Runnable异同">2、Callable和Runnable异同</h2>
<p>两个接口的定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>相同点</strong></p>
<p>都是接口，都可以编写多线程程序，都可以通过线程池启动线程</p>
<p><strong>不同点</strong></p>
<p>Runnable没有返回值，Callable可以返回执行结果，是个泛型；Callable接口的call()方法允许抛出异常；而Runnable接口的run()方法的异常只能在内部消化，不能继续上抛；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Min</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Max</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="meta">@SneakyThrows</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        executorService.submit(<span class="keyword">new</span> Min());</span><br><span class="line">        executorService.submit(<span class="keyword">new</span> Max());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="3、Future类">3、Future类</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Since:1.5</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//取消任务的执行,参数指定是否立即中断任务执行，或者等等任务结束</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line">    <span class="comment">//任务是否已经取消,任务正常完成前将其取消，则返回 true</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//任务是否已经完成。需要注意的是如果任务正常终止、异常或取消，都将返回true</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//等待任务执行结束，然后获得V类型的结果。InterruptedException 线程被中断异常， ExecutionException任务执行异常,如果任务被取消，还会抛出CancellationException</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line">    <span class="comment">//同上面的get功能一样，多了设置超时时间。超时会抛出TimeoutException</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般情况下，我们会结合Callable和Future一起使用，通过ExecutorService的submit方法执行Callable，并返回Future。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException, TimeoutException </span>&#123;</span><br><span class="line">       ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line">       <span class="comment">//Lambda 是一个 callable， 提交后便立即执行，这里返回的是 FutureTask 实例</span></span><br><span class="line">       Future&lt;String&gt; future = executor.submit(() -&gt; &#123;</span><br><span class="line">           System.out.println(<span class="string">"running task"</span>);</span><br><span class="line">           Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">           <span class="keyword">return</span> <span class="string">"return task"</span>;</span><br><span class="line">       &#125;);</span><br><span class="line">       future.get(<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>当然Future模式也有它的缺点，它没有提供通知的机制，我们无法得知Future什么时候完成。如果要在<code>future.get()</code>的地方等待future返回的结果，那只能通过<code>isDone()</code>轮询查询。</p>
<h2 id="4、CompletableFuture类">4、CompletableFuture类</h2>
<blockquote>
<p><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html</a></p>
</blockquote>
<p>CompletableFuture能够将回调放到与任务不同的线程中执行，也能将回调作为继续执行的同步函数，在与任务相同的线程中执行。它避免了传统回调最大的问题，那就是能够将控制流分离到不同的事件处理器中。CompletableFuture弥补了Future模式的缺点。在异步的任务完成后，需要用其结果继续操作时，无需等待。可以直接通过thenAccept、thenApply、thenCompose等方式将前面异步处理的结果交给另外一个异步事件处理线程来处理。</p>
<p>CompletableFuture的静态工厂方法，其中runAsync 和 supplyAsync 方法的区别是runAsync返回的CompletableFuture是没有返回值的。</p>
<table>
<thead>
<tr>
<th><strong>方法名</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>runAsync(Runnable runnable)</td>
<td>使用ForkJoinPool.commonPool()作为它的线程池执行异步代码</td>
</tr>
<tr>
<td>runAsync(Runnable runnable, Executor executor)</td>
<td>使用指定的thread pool执行异步代码</td>
</tr>
<tr>
<td>supplyAsync(Supplier<U> supplier)</U></td>
<td>使用ForkJoinPool.commonPool()作为它的线程池执行异步代码，异步操作有返回值</td>
</tr>
<tr>
<td>supplyAsync(Supplier<U> supplier, Executor executor)</U></td>
<td>使用指定的thread pool执行异步代码，异步操作有返回值</td>
</tr>
<tr>
<td>allOf(CompletableFuture&lt;?&gt;… cfs)</td>
<td>等待所有任务完成，构造后CompletableFuture完成</td>
</tr>
<tr>
<td>anyOf(CompletableFuture&lt;?&gt;… cfs)</td>
<td>只要有一个任务完成，构造后CompletableFuture就完成</td>
</tr>
</tbody>
</table>
<p>对于变量的方法，常用有这几种方法</p>
<table>
<thead>
<tr>
<th><strong>方法名</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>complete(T t)</td>
<td>完成异步执行的话返回执行结果，若不是返回设置的值</td>
</tr>
<tr>
<td>completeExceptionally(Throwable ex)</td>
<td>完成异步执行的话返回执行结果，若不是返回一个异常</td>
</tr>
<tr>
<td>thenApply(Function&lt;? super T,? extends U&gt; fn)</td>
<td>返回一个新的CompletionStage，当这个阶段正常完成时，它将以这个阶段的结果作为所提供函数的参数执行</td>
</tr>
<tr>
<td>thenAccept(Consumer&lt;? super T&gt; action)</td>
<td>返回一个新的CompletionStage，当这个阶段正常完成时，它将以这个阶段的结果作为提供的操作的参数执行。</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException, TimeoutException </span>&#123;</span><br><span class="line">        CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; <span class="string">"Hello"</span>);</span><br><span class="line">        <span class="comment">//在这里执行返回值为World</span></span><br><span class="line">        <span class="comment">// future.complete("World");</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在这里执行结果为Hello</span></span><br><span class="line">        future.complete(<span class="string">"World"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//get() 方法会抛出经检查的异常，可被捕获，自定义处理或者直接抛出。join() 会抛出未经检查的异常。</span></span><br><span class="line">            System.out.println(future.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//thenApplyhello shawn</span></span><br><span class="line"><span class="comment">// thenAccept shawn</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    <span class="comment">//thenApply</span></span><br><span class="line">    CompletableFuture&lt;String&gt; cfuture =</span><br><span class="line">            CompletableFuture.supplyAsync(() -&gt; <span class="string">"shawn"</span>).thenApply(data -&gt; <span class="string">"hello "</span>+ data);</span><br><span class="line">    System.out.println(<span class="string">"thenApply"</span> + cfuture.get());</span><br><span class="line">    <span class="comment">//thenAccept</span></span><br><span class="line">    CompletableFuture.supplyAsync(() -&gt; <span class="string">"thenAccept shawn"</span>).thenAccept(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5、FutureTask">5、FutureTask</h2>
<blockquote>
<p><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/FutureTask.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/FutureTask.html</a></p>
</blockquote>
<p>Future是一个接口，是无法生成一个实例的，所以又有了FutureTask。FutureTask实现了RunnableFuture接口，RunnableFuture接口又实现了Runnable接口和Future接口。所以FutureTask既可以被当做Runnable来执行，也可以被当做Future来获取Callable的返回结果。</p>
<hr>
<p>参考文章</p>
<p><a href="https://juejin.cn/post/6970607007669682212" target="_blank" rel="noopener">https://juejin.cn/post/6970607007669682212</a></p>
<p><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Callable.html#call--" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Callable.html#call</a></p>
<p><a href="https://www.jianshu.com/p/dff9063e1ab6" target="_blank" rel="noopener">https://www.jianshu.com/p/dff9063e1ab6</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux防火墙</title>
    <url>/posts/e26546c7.html</url>
    <content><![CDATA[<h2 id="1、引言">1、引言</h2>
<h3 id="1-1-简介">1.1 简介</h3>
<p>对于云服务器来说，防火墙开启和设置安全组是对云服务器的双重保护，如果选择关闭防火墙，建议安全组谨慎开放端口。</p>
<p>Linux基于其内核拥有多种形式的发行版，其中Ubuntu 基于 Debian，CentOS 基于 RHEL；而这两者之间的防火墙操作也有差异，这里我简单记录一下两者的基本使用命令</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2014/06/1511849829609658.jpg" alt></p>
<p>最后也简单记录一下windows下的端口操作</p>
<a id="more"></a>
<h3 id="1-2-Linux通用命令">1.2 Linux通用命令</h3>
<blockquote>
<p>lsof（list open files）是一个查看当前系统文件的工具，参考：<a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/lsof.html" target="_blank" rel="noopener">https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/lsof.html</a></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下面的命令需要root权限，否则可能不会正常显示</span></span><br><span class="line"><span class="comment"># 查看某端口是否开放，如果没有信息出现则说明该端口还未开放</span></span><br><span class="line">lsof -i:80</span><br><span class="line"><span class="comment"># 列出所有网络连接</span></span><br><span class="line">lsof -i</span><br><span class="line"><span class="comment"># 累出所有tcp连接</span></span><br><span class="line">lsof -i tcp</span><br><span class="line"><span class="comment"># 查看所有开放的端口</span></span><br><span class="line">netstat -aptn</span><br><span class="line">iptables -nL</span><br></pre></td></tr></table></figure>
<h3 id="1-3-docker注意项">1.3 docker注意项</h3>
<p>默认情况下，Docker deamon会在启动container的时候向iptables中添加转发的规则。它会创建一个<code>filter chain - DOCKER</code>。docke利用这个规则向外暴露container的端口，即无需配置防火墙即可外网即可访问，这个操作对于生产环境还是很危险的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Chain FORWARD (policy DROP)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination</span><br><span class="line">DOCKER     all  --  0.0.0.0/0            0.0.0.0/0</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Chain DOCKER (1 references)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination</span><br></pre></td></tr></table></figure>
<p><strong>解决方案</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#第一种方案</span></span><br><span class="line"><span class="comment">#在宿主机docker容器启动过程中使用 --iptables=false</span></span><br><span class="line">docker run -p 80:8080 ubuntu bash --iptables=<span class="literal">false</span></span><br><span class="line"><span class="comment">#第二种方案</span></span><br><span class="line"><span class="comment">#将docker容器的8080端口绑定到local主机的80端口上</span></span><br><span class="line">docker run -p 127.0.0.1:80:8080 ubuntu bash</span><br></pre></td></tr></table></figure>
<h2 id="2、Ubuntu-操作系统">2、<strong>Ubuntu</strong> 操作系统</h2>
<h3 id="2-1-简介">2.1 简介</h3>
<blockquote>
<p>官方手册：<a href="http://manpages.ubuntu.com/manpages/focal/man8/ufw.8.html" target="_blank" rel="noopener">http://manpages.ubuntu.com/manpages/focal/man8/ufw.8.html</a></p>
</blockquote>
<p>与Debian相同，Ubuntu 里也自带了 iptables，不一样的地方是还内置了 Ubuntu 专属的 UFW 管理工具，UFW 是 Uncomplicated Firewall 的简称，UFW 默认是不开启的。</p>
<h3 id="2-2-ufw防火墙操作">2.2 ufw防火墙操作</h3>
<p>ufw的配置文件在<code>/etc/default/ufw</code>，每次进行配置文件修改后需要重载reload一下；ufw 在 active的状态下，默认是deny all incoming connection, allow all outgoing connection.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看防火墙状态，包括已开放端口</span></span><br><span class="line">sudo ufw status</span><br><span class="line"><span class="comment"># 开启防火墙，如果已开启防火墙，忽略此步</span></span><br><span class="line">sudo ufw <span class="built_in">enable</span></span><br><span class="line"><span class="comment"># 重载防火墙</span></span><br><span class="line">sudo ufw reload</span><br><span class="line"><span class="comment"># 关闭防火墙</span></span><br><span class="line">sudo ufw <span class="built_in">disable</span></span><br><span class="line"><span class="comment"># 设置防火墙默认权限</span></span><br><span class="line">sudo ufw default deny</span><br><span class="line"><span class="comment"># 重置</span></span><br><span class="line">sudo ufw reset</span><br><span class="line"><span class="comment">####################################</span></span><br><span class="line"><span class="comment"># 开放指定端口或者协议</span></span><br><span class="line">sudo ufw allow 80</span><br><span class="line">sudo ufw allow 80/tcp</span><br><span class="line">sudo ufw allow https</span><br><span class="line">sudo ufw allow 6000:7000/tcp</span><br><span class="line"><span class="comment"># 关闭普通端口，或者协议数字,需要先用status查看</span></span><br><span class="line">sudo ufw delete allow 80</span><br><span class="line">sudo ufw delete [num]</span><br><span class="line">sudo ufw delete allow 80/tcp</span><br><span class="line"><span class="comment"># 开放指定IP地址</span></span><br><span class="line">sudo ufw allow from 192.168.0.10</span><br><span class="line"><span class="comment"># 关闭指定IP地址</span></span><br><span class="line">sudo ufw delete allow from 192.168.0.10</span><br><span class="line"><span class="comment"># 开放指定IP地址指定端口</span></span><br><span class="line">sudo ufw allow from 192.168.0.10 to any port 3306</span><br><span class="line"><span class="comment"># 关闭指定IP地址指定端口</span></span><br><span class="line">sudo ufw delete allow from 192.168.0.10 to any port 3306</span><br></pre></td></tr></table></figure>
<h3 id="2-3-ufw开启注意事项">2.3 ufw开启注意事项</h3>
<p>⚠️ 我在没有配置过ufw allow端口前，直接开启了ufw防火墙，一段时间后发现ssh竟然无法连接，还好后面使用了云服务器的救援链接关闭ufw才可以重新进入。</p>
<p>在使用ufw前，请务必开启ssh协议或者22端口！</p>
<h2 id="3、Centos操作系统">3、Centos操作系统</h2>
<h3 id="3-1-简介">3.1 简介</h3>
<p>CentOS 在 6 及之前的版本里只使用 iptables，从 7 开始其实和 Ubuntu 类似，提供了 firewalld 作为便捷配置防火墙的工具。与其他系统不同的是 firewalld 默认就是跟随系统启动的，并且规则默认是禁止所有端口进入（22 这种 SSH 必要端口除外）</p>
<p>对于firewalld 底层实际还是调用 iptables 来处理的，本身也是作为一个简化配置 iptables 的工具存在firewalld 的优点是规则即时生效，不用去手动刷新。但从 CentOS8 开始，nftables 作为新的防火墙后端开始替代 iptables，firewalld 也就变成了 nftables 的前端。</p>
<h3 id="3-2-firewalld-防火墙">3.2 firewalld 防火墙</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看防火墙状态</span></span><br><span class="line">sudo systemctl status firewalld.service</span><br><span class="line"><span class="comment"># 开启防火墙</span></span><br><span class="line">sudo systemctl start firewalld.service</span><br><span class="line"><span class="comment"># 查看已开放端口</span></span><br><span class="line">sudo firewall-cmd --list-ports</span><br><span class="line"><span class="comment"># 开放指定端口,或者协议</span></span><br><span class="line">sudo firewall-cmd --zone=public --add-port=8080/tcp --permanent</span><br><span class="line">sudo firewall-cmd --permanent --zone=public --add-port=100-500/udp</span><br><span class="line"><span class="comment"># 删除指定端口</span></span><br><span class="line">sudo firewall-cmd --zone=public--remove-port=8080/tcp --permanent</span><br><span class="line"><span class="comment"># 重启防火墙</span></span><br><span class="line">sudo systemctl reload firewalld.service</span><br><span class="line">sudo systemctl restart firewalld.service</span><br></pre></td></tr></table></figure>
<h2 id="4、windows下端口检测">4、windows下端口检测</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查找所有运行的端口</span></span><br><span class="line">netstat -ano</span><br><span class="line"><span class="comment"># 查找指定端口</span></span><br><span class="line">netstat -ano | finstr <span class="string">"4000"</span></span><br><span class="line"><span class="comment"># 查看占用端口的服务列表</span></span><br><span class="line">tasklist|findstr <span class="string">"10972"</span></span><br><span class="line"><span class="comment"># 强制（/F参数）杀死 pid 为 9088 的所有进程包括子进程（/T参数）</span></span><br><span class="line">askkill /T /F /PID 9088</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux账户管理实践</title>
    <url>/posts/6cdb47ee.html</url>
    <content><![CDATA[<h2 id="1、环境准备">1、环境准备</h2>
<ul>
<li>
<p>ubuntu20.04 LTS</p>
</li>
<li>
<p>所有操作都在root账户下操作</p>
</li>
</ul>
<h2 id="2、新建用户组和用户">2、新建用户组和用户</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#首先新建一个组</span></span><br><span class="line">sudo groupadd develop</span><br><span class="line"><span class="comment">#下面是两种创建用户方式，第一种会自动配置好，推荐</span></span><br><span class="line">adduser shawn</span><br><span class="line"><span class="comment">#第二种创建用户方式，必须设置密码，否则登录不上;其中-g是否在新建时加入组，若是，则不会单独生成新的组</span></span><br><span class="line">useradd -m guest [-g develop]</span><br><span class="line">passwd guest</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p><img src="https://img-blog.csdnimg.cn/da172b4a5eea47febffef52170eea9a0.png" alt="请添加图片描述"></p>
<p>查看一下用户组状态，输入<code>cat /etc/group</code>查看组的信息，默认新建的用户自己的用户名为一组</p>
<p><img src="https://img-blog.csdnimg.cn/1baeab07f8e7444aa31ab755ba74f848.png" alt="在这里插入图片描述"></p>
<h2 id="3、group组操作">3、group组操作</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#用户操作在/etc/passwd都有记录</span></span><br><span class="line"><span class="comment">#usermod -aG group_name user_name</span></span><br><span class="line"><span class="comment">#gpasswd -a user_name group_name</span></span><br><span class="line"><span class="comment">#-g是更改用户的主组</span></span><br><span class="line"><span class="comment">#-G是更改用户的附加组</span></span><br><span class="line">usermod -aG develop shawn</span><br><span class="line"><span class="comment">#将用户加到新的组里</span></span><br><span class="line">gpasswd -a guest develop</span><br><span class="line"><span class="comment">#将用户移出某个组</span></span><br><span class="line"><span class="comment">#gpasswd -d [user_name] [group_name]</span></span><br><span class="line">gpasswd -d guest develop</span><br><span class="line"><span class="comment">#删除组，这里我已经移动到develop了所以成功删除</span></span><br><span class="line">groupdel shawn</span><br></pre></td></tr></table></figure>
<h2 id="4、登录">4、登录</h2>
<p>然后进行分别登陆，发现两个终端有点不一样！可以发现第二种方式创建的用户有点问题，只有一个$符号，这是怎么回事？</p>
<p><img src="https://img-blog.csdnimg.cn/c087e10257a54c3184db472a9ac1cfc1.png" alt="请添加图片描述"></p>
<p>原因：查看<code>/etc/passwd</code>文件后发现，新建的用户未指定shell。我们只需将其指定为<code>/bin/bash</code>即可;也可以进入该文件进行修改；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#切换用户,这里切换是使用当前用户环境</span></span><br><span class="line">su shawn</span><br><span class="line">su guest</span><br><span class="line"><span class="comment"># 切换用户，并使用用户自己的环境</span></span><br><span class="line">su - shawn</span><br><span class="line">su -l shawn</span><br><span class="line"><span class="comment">#退出当前用户</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"><span class="built_in">logout</span></span><br><span class="line"><span class="comment">#重新设置shell，这里发现用useradd命令会这样，建议用adduser</span></span><br><span class="line">usermod -s /bin/bash guest</span><br></pre></td></tr></table></figure>
<h2 id="5、给新建用户添加sudo权限">5、给新建用户添加sudo权限</h2>
<h3 id="5-1-添加到sudo组">5.1 添加到sudo组</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#添加shawn到sudo组，需要时输入shawn的密码即可</span></span><br><span class="line">usermod -G sudo shawn</span><br></pre></td></tr></table></figure>
<h3 id="5-2-修改sudoers表">5.2 修改sudoers表</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#首先要切换到root权限</span></span><br><span class="line"><span class="comment">#赋予当前用户写的权限</span></span><br><span class="line">chmod u+w /etc/sudoers</span><br><span class="line"><span class="comment">#编辑sudoers文件</span></span><br><span class="line">vim /etc/sudoers</span><br><span class="line"><span class="comment">#在User privilege specification或者#includedir /etc/sudoers.d下添加，这个代表当前组的用户都可以进行sudo,需要时输入当前账户密码即可</span></span><br><span class="line">%develop ALL=(ALL:ALL) ALL</span><br><span class="line"><span class="comment">#撤销sudoers文件写权限</span></span><br><span class="line">chmod u-w /etc/sudoers</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/3546f38f1b2641a1b5cd3c91eb09ca11.png" alt="在这里插入图片描述"></p>
<h3 id="5-3-etc-sudoers的格式">5.3 <code>/etc/sudoers</code>的格式</h3>
<p><code>user host=(run_as) command</code></p>
<ul>
<li>user:一位或几位用户，在/etc/group中可以用一个%代替它，组对象的名称一定要用百分号%开头。</li>
<li>host:一个或几个主机名，ALL表示可以在所有的主机上</li>
<li>run_as:作为哪个用户运行，常见选项是root和ALL</li>
<li>command:想让用户或组运行的一个或几个根级别命令</li>
</ul>
<p><strong>举几个例子</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#%表示用户组，！表示禁止执行。</span></span><br><span class="line"><span class="comment">#表示默认5分钟后刚才输入的sodo密码过期，下次sudo需要重新输入密码</span></span><br><span class="line">shawn  ALL=(ALL:ALL) ALL </span><br><span class="line"><span class="comment">#表示允许无时间限制的免输入密码，该组都免输入</span></span><br><span class="line">%develop  ALL=(ALL:ALL) NOPASSWD:ALL  </span><br><span class="line"><span class="comment">#develop组可以从任何主机登陆，并且可以不用输入密码执行任何命令，但是不能执行/usr/sbin下的命令</span></span><br><span class="line">%develop ALL=(ALL) NOPASSWD:ALL,!/usr/sbin/</span><br></pre></td></tr></table></figure>
<h2 id="6、-etc-passwd详解">6、<code>/etc/passwd</code>详解</h2>
<p>对于<code>/etc/passwd</code>文件，它是用于存放用户名字和用户标识符号的一些信息的。</p>
<p>以root账户为例，各部分之间用:分隔开，可以分成7部分内容</p>
<p><strong>root:x :0 :0 : root : /root : /bin/bash</strong></p>
<ul>
<li><code>root</code>：账户名称</li>
<li><code>x</code>：密码，由于/etc/passwd这个文件是可以让所有用户读取，故为了安全，这个地方只能看到x，而隐藏了真实的密码</li>
<li><code>0</code>：用户识别码（UID）</li>
<li><code>0</code>：组识别码（GID），和<code>/etc/group</code>文件有关系</li>
<li><code>root</code>：该用户的信息说明，没有很重要的用途，仅仅是一个说明而已</li>
<li><code>/root</code>：该用户的家目录，登录时候进入的目录，如果想修改登录时候的家目录所在，就可以在这里进行修改了</li>
<li><code>/bin/bash</code>：shell，当用户执行命令的时候，是用的/bin/bash(在这个例子中)这个shell来执行命令。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/ce99d0a04fb1418ea00d53709ad7c1e1.png" alt="在这里插入图片描述"></p>
<h2 id="7、删除用户和组">7、删除用户和组</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">userdel 用户名 <span class="comment"># 从配置文件中删除用户，并不删除用户下的文件夹</span></span><br><span class="line">userdel -r 用户名 <span class="comment"># 删除用户及其相关文件</span></span><br><span class="line">userdel -f 用户名 <span class="comment"># 强制删除用户</span></span><br><span class="line">groupdel 组名 <span class="comment">#删除组</span></span><br></pre></td></tr></table></figure>
<h2 id="8、其他">8、其他</h2>
<p>新建普通用户，可以将服务器资源分发给不同的用户，还可以赋予用户不同的权限；而组就是用来管理用户的，当用户多了的时候，比如需要赋予一批用户超级管理员权限，则只需要将用户添加到超级管理员的组就可以了</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux日志系统初探</title>
    <url>/posts/955628de.html</url>
    <content><![CDATA[<h2 id="1、Linux日志介绍">1、Linux日志介绍</h2>
<p>Linux日志文件包括以下三种类型</p>
<ul>
<li>
<p><strong>内核及系统日志</strong></p>
<p>这种日志数据由系统服务<code>syslog</code>统一管理，根据其主配置文件<code>/etc/syslog.conf</code>中的设置决定将内核消息及各种系统程序消息记录到什么位置。系统中有相当一部分程序会把自己的日志文件交由<code>syslog</code>管理，因而这些程序使用的日志记录也具有相似的格式。</p>
</li>
<li>
<p><strong>用户日志</strong></p>
<p>这种日志数据用于记录Linux系统用户登录及退出系统的相关信息，包括用户名、登录的终端、登录时间、来源主机、正在使用的进程操作等。</p>
</li>
<li>
<p><strong>程序日志</strong></p>
<p>有些应用程序运会选择自己来独立管理一份日志文件（而不是交给syslog服务管理），用于记录本程序运行过程中的各种事件信息。由于这些程序只负责管理自己的日志文件，因此不同的程序所使用的日志记录格式可能会存在极大差异。</p>
</li>
</ul>
<a id="more"></a>
<h2 id="2、Linux常见日志文件">2、Linux常见日志文件</h2>
<p>熟悉常用日志文件，当遇到问题时可以快速定位分析</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/var/<span class="built_in">log</span>/messages <span class="comment">#记录Linux内核消息及各种应用程序的公共日志信息，包括启动、IO错误、网络错误、程序故障等。对于未使用独立日志文件的应用程序或服务，一般都可以从该文件获得相关的事件记录信息。</span></span><br><span class="line">/var/<span class="built_in">log</span>/cron <span class="comment">#记录crond计划任务产生的事件消息。</span></span><br><span class="line">/varlog/dmesg <span class="comment">#记录Linux系统在引导过程中的各种事件信息。</span></span><br><span class="line">/var/<span class="built_in">log</span>/maillog <span class="comment">#记录进入或发出系统的电子邮件活动。</span></span><br><span class="line">/var/<span class="built_in">log</span>/lastlog <span class="comment">#最近几次成功登录事件和最后一次不成功登录事件。</span></span><br><span class="line">/var/<span class="built_in">log</span>/rpmpkgs <span class="comment">#记录系统中安装各rpm包列表信息。</span></span><br><span class="line">/var/<span class="built_in">log</span>/secure <span class="comment">#记录用户登录认证过程中的事件信息。</span></span><br><span class="line">/var/<span class="built_in">log</span>/wtmp <span class="comment">#记录每个用户登录、注销及系统启动和停机事件。</span></span><br></pre></td></tr></table></figure>
<h2 id="3、常用命令与日志分析">3、常用命令与日志分析</h2>
<p><code>last</code>是一个命令行工具，它用来展示关于系统用户最后登录会话的信息。这个命令非常有用，尤其是当你需要追踪用户活动，或者调查一个可能的安全入侵问题。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-&lt;数字&gt;              <span class="comment">#显示最近的几行记录</span></span><br><span class="line">-a, --hostlast       <span class="comment">#最后一列显示主机名</span></span><br><span class="line">-d, --dns            <span class="comment">#将 IP 号转换回主机名</span></span><br><span class="line">-F, --file &lt;文件&gt;    <span class="comment">#用指定文件代替 /var/log/wtmp</span></span><br><span class="line">-F, --fulltimes      <span class="comment">#打印完整的登录和注销时间和日期</span></span><br><span class="line">-i, --ip             <span class="comment">#以数字和点的形式显示 IP 号</span></span><br><span class="line">-n, --<span class="built_in">limit</span> &lt;数字&gt;   <span class="comment">#要显示的行数</span></span><br><span class="line">-R, --nohostname     <span class="comment">#不显示主机名字段</span></span><br><span class="line">-s, --since &lt;时间&gt;   <span class="comment">#显示从指定时间起的行；格式举例2021-11-11</span></span><br><span class="line">-t, --until &lt;时间&gt;   <span class="comment">#显示到指定时间为止的行</span></span><br><span class="line">-p, --present &lt;时间&gt; <span class="comment">#显示在指定时间谁在场(present)</span></span><br><span class="line">-w, --fullnames      <span class="comment">#显示完整的用户名和域名</span></span><br><span class="line">-x, --system         <span class="comment">#显示系统关机项和运行级别更改</span></span><br><span class="line">    --time-format &lt;格式&gt;    <span class="comment">#以指定&lt;格式&gt;显示时间戳：notime|short|full|iso</span></span><br><span class="line"></span><br><span class="line">-h, --<span class="built_in">help</span>           <span class="comment">#display this help</span></span><br><span class="line">-V, --version        <span class="comment">#display version</span></span><br></pre></td></tr></table></figure>
<p><code>lastlog</code>此命令可以查看登陆过当前系统用户的最近一次登陆时间；默认是去读取<code> /var/log/lastlog</code> 日志文件的，这个文件同样是二进制文件，不能直接用 vi 编辑，需要使用 lastlog 命令调用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-b, --before DAYS             <span class="comment">#仅打印早于 DAYS 的最近登录记录</span></span><br><span class="line">-C, --clear                   <span class="comment">#clear lastlog record of an user (usable only with -u)</span></span><br><span class="line">-h, --<span class="built_in">help</span>                    <span class="comment">#显示此帮助信息并推出</span></span><br><span class="line">-R, --root CHROOT_DIR         <span class="comment">#chroot 到的目录</span></span><br><span class="line">-S, --<span class="built_in">set</span>                     <span class="comment">#set lastlog record to current time (usable only with -u)</span></span><br><span class="line">-t, --time DAYS               <span class="comment">#仅打印晚于 DAYS 的最近登录记录</span></span><br><span class="line">-u, --user LOGIN              <span class="comment">#打印 LOGIN 用户的近登录记录</span></span><br></pre></td></tr></table></figure>
<p><code>head</code>和<code>tail</code>相关命令可参考https://blog.csdn.net/lemon_TT/article/details/114846900</p>
<h2 id="4、Linux中的tty、pts、pty等概念辨析">4、Linux中的tty、pts、pty等概念辨析</h2>
<ul>
<li>
<p>tty（teletypes，终端设备的统称）</p>
<p>tty设备包括虚拟控制台，串口以及伪终端设备。tty0~tty63是虚拟终端的设备特殊文件。/dev/tty0代表当前虚拟控制台，而/dev/tty1等代表第一个虚拟控制台。</p>
</li>
<li>
<p>pty（pseudo-tty，虚拟终端)：pty全称pseudo-tty，即伪终端设备，用于远程连接。它由master和slave两端构成，在任何一端的输入都会传达到另一端。与tty不同，系统中并不存在pty这种文件，它是由pts（pseudo-terminal slave）和ptmx（pseudo-teiminal master）两种设备文件来实现的。</p>
</li>
<li>
<p>pts(pseudo-terminal slave)</p>
<p>伪终端的slave端</p>
</li>
<li>
<p>ptmx(pseudo-terminal master)</p>
<p>伪终端的master端</p>
</li>
</ul>
<h2 id="5、查看相关文件实例">5、查看相关文件实例</h2>
<p>​	一般来说，是查看Linux查看<code>/var/log/wtmp</code>或者<code>/var/log/lastlog</code>文件查看可疑IP登陆，然后查看<code>/var/log/secure</code>文件寻找可疑IP登陆次数；对于系统问题，查看<code>/var/log/messages</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#取2020-11-11开始最近的十条登录事件</span></span><br><span class="line">last -s 2020-11-11 -n 10</span><br><span class="line"><span class="comment">#查看各个用户的登录情况</span></span><br><span class="line">lastlog</span><br><span class="line"><span class="comment">#查看secure文件的倒数100行</span></span><br><span class="line">cat secure | tail -n 100</span><br><span class="line"><span class="comment">#查看当前设备数</span></span><br><span class="line">ls /dev/pt*</span><br><span class="line"><span class="comment">#同一个用户开启多个终端，可以在不同终端打印</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"hello"</span> &gt; /dev/pts/2</span><br><span class="line"><span class="comment">#可以查看进程是当前哪个终端连接</span></span><br><span class="line">ps -aux | grep [进程名]</span><br></pre></td></tr></table></figure>
<h2 id="6、linux中log文件夹各个log文件内容">6、linux中log文件夹各个log文件内容</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/var/<span class="built_in">log</span>/messages <span class="comment">#包括整体系统信息，其中也包含系统启动期间的日志。此外，mail，cron，daemon，kern和auth等内容也记录在var/log/messages日志中。</span></span><br><span class="line">/var/<span class="built_in">log</span>/dmesg <span class="comment"># 包含内核缓冲信息（kernel ring buffer）。在系统启动时，会在屏幕上显示许多与硬件有关的信息。可以用dmesg查看它们。</span></span><br><span class="line">/var/<span class="built_in">log</span>/auth.log <span class="comment"># 包含系统授权信息，包括用户登录和使用的权限机制等。</span></span><br><span class="line">/var/<span class="built_in">log</span>/boot.log <span class="comment"># 包含系统启动时的日志。</span></span><br><span class="line">/var/<span class="built_in">log</span>/daemon.log <span class="comment"># 包含各种系统后台守护进程日志信息。</span></span><br><span class="line">/var/<span class="built_in">log</span>/dpkg.log <span class="comment">#包括安装或dpkg命令清除软件包的日志。</span></span><br><span class="line">/var/<span class="built_in">log</span>/kern.log <span class="comment">#包含内核产生的日志，有助于在定制内核时解决问题。</span></span><br><span class="line">/var/<span class="built_in">log</span>/lastlog <span class="comment">#记录所有用户的最近信息。这不是一个ASCII文件，因此需要用lastlog命令查看内容。</span></span><br><span class="line">/var/<span class="built_in">log</span>/maillog /var/<span class="built_in">log</span>/mail.log <span class="comment">#包含来着系统运行电子邮件服务器的日志信息。例如，sendmail日志信息就全部送到这个文件中。</span></span><br><span class="line">/var/<span class="built_in">log</span>/user.log <span class="comment">#记录所有等级用户信息的日志。</span></span><br><span class="line">/var/<span class="built_in">log</span>/Xorg.x.log <span class="comment">#来自X的日志信息。</span></span><br><span class="line">/var/<span class="built_in">log</span>/alternatives.log <span class="comment">#更新替代信息都记录在这个文件中。</span></span><br><span class="line">/var/<span class="built_in">log</span>/btmp <span class="comment">#记录所有失败登录信息。使用last命令可以查看btmp文件。例如，”last -f /var/log/btmp | more“。</span></span><br><span class="line">/var/<span class="built_in">log</span>/cups <span class="comment">#涉及所有打印信息的日志。</span></span><br><span class="line">/var/<span class="built_in">log</span>/anaconda.log <span class="comment">#在安装Linux时，所有安装信息都储存在这个文件中。</span></span><br><span class="line">/var/<span class="built_in">log</span>/yum.log <span class="comment">#包含使用yum安装的软件包信息。</span></span><br><span class="line">/var/<span class="built_in">log</span>/cron <span class="comment">#每当cron进程开始一个工作时，就会将相关信息记录在这个文件中。</span></span><br><span class="line">/var/<span class="built_in">log</span>/secure <span class="comment">#包含验证和授权方面信息。例如，sshd会将所有信息记录（其中包括失败登录）在这里。</span></span><br><span class="line">/var/<span class="built_in">log</span>/wtmp或/var/<span class="built_in">log</span>/utmp <span class="comment">#包含登录信息。使用wtmp可以找出谁正在登陆进入系统，谁使用命令显示这个文件或信息等。</span></span><br><span class="line">/var/<span class="built_in">log</span>/faillog <span class="comment">#包含用户登录失败信息。此外，错误登录命令也会记录在本文件中。除了上述Log文件以外，</span></span><br><span class="line">---------------------------------------</span><br><span class="line"><span class="comment">#/var/log还基于系统的具体应用包含以下一些子目录：</span></span><br><span class="line">----------------------------------------</span><br><span class="line">/var/<span class="built_in">log</span>/httpd/或/var/<span class="built_in">log</span>/apache2 <span class="comment">#包含服务器access_log和error_log信息。</span></span><br><span class="line">/var/<span class="built_in">log</span>/lighttpd/ <span class="comment">#包含light HTTPD的access_log和error_log。</span></span><br><span class="line">/var/<span class="built_in">log</span>/mail/ <span class="comment">#这个子目录包含邮件服务器的额外日志。</span></span><br><span class="line">/var/<span class="built_in">log</span>/prelink/ <span class="comment">#包含.so文件被prelink修改的信息。</span></span><br><span class="line">/var/<span class="built_in">log</span>/audit/ <span class="comment">#包含被 Linux audit daemon储存的信息。</span></span><br><span class="line">/var/<span class="built_in">log</span>/samba/ <span class="comment">#包含由samba存储的信息。</span></span><br><span class="line">/var/<span class="built_in">log</span>/sa/ <span class="comment">#包含每日由sysstat软件包收集的sar文件。</span></span><br><span class="line">/var/<span class="built_in">log</span>/sssd/ <span class="comment">#用于守护进程安全服务。</span></span><br></pre></td></tr></table></figure>
<hr>
<p>参考</p>
<p><a href="https://blog.csdn.net/weixin_44966641/article/details/120585519" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44966641/article/details/120585519</a></p>
<p><a href="https://blog.51cto.com/jschu/1882685" target="_blank" rel="noopener">https://blog.51cto.com/jschu/1882685</a></p>
<p><a href="https://www.cnblogs.com/yihr/p/7212641.html" target="_blank" rel="noopener">https://www.cnblogs.com/yihr/p/7212641.html</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux基础</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ学习笔记</title>
    <url>/posts/d439760d.html</url>
    <content><![CDATA[<h1>一、概述</h1>
<h2 id="1、中间件概述">1、中间件概述</h2>
<blockquote>
<p>中间件是介于应用系统和<a href="https://baike.baidu.com/item/%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6/215962" target="_blank" rel="noopener">系统软件</a>之间的一类软件，它使用系统软件所提供的基础服务（功能），衔接网络上应用系统的各个部分或不同的应用，能够达到资源共享、功能共享的目的。</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/46fec18887ec4fd7b76b32e6b8eb8eef.png#pic_center" alt="请添加图片描述"></p>
<a id="more"></a>
<h2 id="2、消息中间件概述">2、消息中间件概述</h2>
<h3 id="1、概述">1、概述</h3>
<p>​	消息中间件是利用可靠的消息传递机制进行系统和系统直接的通讯；以及通过提供消息传递和消息的排队机制，它可以在分布式系统环境下扩展进程间的通讯。常见的消息中间件有ActiveMQ、RabbitMQ、Kafka、RocketMQ等。</p>
<h3 id="2、应用场景">2、应用场景</h3>
<ul>
<li>跨系统数据传递</li>
<li>高并发的流量削峰</li>
<li>数据的分发和异步处理</li>
<li>大数据分析与传递</li>
<li>分布式事务</li>
</ul>
<h3 id="3、核心组成部分">3、核心组成部分</h3>
<ul>
<li>消息的协议</li>
<li>消息的持久化机制</li>
<li>消息的分发策略</li>
<li>消息的高可用，高可靠</li>
<li>消息的容错机制</li>
</ul>
<h3 id="4、其他">4、其他</h3>
<p>​	常见的持久化方式</p>
<table>
<thead>
<tr>
<th style="text-align:center">ActiveMQ</th>
<th style="text-align:center">RabbitMQ</th>
<th style="text-align:center">Kafka</th>
<th style="text-align:center">RocketMQ</th>
<th style="text-align:center">是否支持</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">文件存储</td>
<td style="text-align:center">支持</td>
<td style="text-align:center">支持</td>
<td style="text-align:center">支持</td>
<td style="text-align:center">支持</td>
</tr>
<tr>
<td style="text-align:center">数据库</td>
<td style="text-align:center">支持</td>
<td style="text-align:center">/</td>
<td style="text-align:center">/</td>
<td style="text-align:center">/</td>
</tr>
</tbody>
</table>
<p>​	消息分发策略的机制和对比</p>
<table>
<thead>
<tr>
<th style="text-align:center">ActiveMQ</th>
<th style="text-align:center">RabbitMQ</th>
<th style="text-align:center">Kafka</th>
<th style="text-align:center">RocketMQ</th>
<th style="text-align:center">是否支持</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">发布订阅</td>
<td style="text-align:center">支持</td>
<td style="text-align:center">支持</td>
<td style="text-align:center">支持</td>
<td style="text-align:center">支持</td>
</tr>
<tr>
<td style="text-align:center">轮询分发</td>
<td style="text-align:center">支持</td>
<td style="text-align:center">支持</td>
<td style="text-align:center">支持</td>
<td style="text-align:center">/</td>
</tr>
<tr>
<td style="text-align:center">公平分发</td>
<td style="text-align:center">/</td>
<td style="text-align:center">支持</td>
<td style="text-align:center">支持</td>
<td style="text-align:center">/</td>
</tr>
<tr>
<td style="text-align:center">重发</td>
<td style="text-align:center">支持</td>
<td style="text-align:center">支持</td>
<td style="text-align:center">/</td>
<td style="text-align:center">支持</td>
</tr>
<tr>
<td style="text-align:center">消息拉取</td>
<td style="text-align:center">/</td>
<td style="text-align:center">支持</td>
<td style="text-align:center">支持</td>
<td style="text-align:center">支持</td>
</tr>
</tbody>
</table>
<h1>二、RabbitMQ安装与入门</h1>
<h2 id="1、概述-v2">1、概述</h2>
<blockquote>
<p>RabbitMQ是一个开源的遵循AMQP协议实现的基于Erlang语言编写，支持多种客户端（语言）。用于在分布式系统中存储消息，转发消息，具有高可用，高可扩性，易用性等特征。</p>
<p>官网：<a href="https://www.rabbitmq.com/" target="_blank" rel="noopener">https://www.rabbitmq.com/</a></p>
</blockquote>
<h2 id="2、RabbitMQ安装">2、RabbitMQ安装</h2>
<h3 id="1、环境准备">1、环境准备</h3>
<blockquote>
<p>RabbitMQ是采用Erlang语言开发的，所以系统环境必须提供Erlang环境，第一步就是安装Erlang。<br>
RabbitMQ下载地址：<a href="https://www.rabbitmq.com/download.html" target="_blank" rel="noopener">https://www.rabbitmq.com/download.html</a><br>
Erlang下载地址：<a href="https://www.erlang-solutions.com/downloads/" target="_blank" rel="noopener">https://www.erlang-solutions.com/downloads/</a><br>
erlang和RabbitMQ版本的按照比较: <a href="https://www.rabbitmq.com/which-erlang.html" target="_blank" rel="noopener">https://www.rabbitmq.com/which-erlang.html</a></p>
</blockquote>
<p>Linux环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#命令</span></span><br><span class="line">lsb_release -a</span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line">LSB Version:    :core-4.1-amd64:core-4.1-noarch</span><br><span class="line">Distributor ID: CentOS</span><br><span class="line">Description:    CentOS Linux release 8.1.1911 (Core) </span><br><span class="line">Release:        8.1.1911</span><br><span class="line">Codename:       Core</span><br></pre></td></tr></table></figure>
<h3 id="2、Erlang安装">2、Erlang安装</h3>
<p>rpm包下载地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#下载rpm包</span></span><br><span class="line">wget https://packages.erlang-solutions.com/erlang-solutions-2.0-1.noarch.rpm</span><br><span class="line"><span class="comment">#更新本地yum仓库</span></span><br><span class="line">rpm -Uvh erlang-solutions-2.0-1.noarch.rpm</span><br><span class="line">yum install -y erlang</span><br><span class="line"><span class="comment">#查看版本测试是否安装成功</span></span><br><span class="line">erl -v</span><br><span class="line"><span class="comment">#一个小插件，需要</span></span><br><span class="line">yum install -y socat</span><br></pre></td></tr></table></figure>
<h3 id="3、RabbitMQ安装">3、RabbitMQ安装</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#下载rpm包</span></span><br><span class="line">wget https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.9.5/rabbitmq-server-3.9.5-1.el8.noarch.rpm</span><br><span class="line">rpm -Uvh rabbitmq-server-3.9.5-1.el8.noarch.rpm</span><br><span class="line">yum install rabbitmq-server -y</span><br></pre></td></tr></table></figure>
<h3 id="4、RabbitMQ运行">4、RabbitMQ运行</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动服务</span></span><br><span class="line">systemctl start rabbitmq-server</span><br><span class="line"><span class="comment"># 查看服务状态</span></span><br><span class="line">systemctl status rabbitmq-server</span><br><span class="line"><span class="comment"># 停止服务</span></span><br><span class="line">systemctl stop rabbitmq-server</span><br><span class="line"><span class="comment"># 开机启动服务</span></span><br><span class="line">systemctl <span class="built_in">enable</span> rabbitmq-server</span><br></pre></td></tr></table></figure>
<h3 id="5、MQ的相关端口">5、MQ的相关端口</h3>
<p>​	<em>注意端口的开放与安全组端口开放</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">5672 <span class="comment">#RabbitMQ的通讯端口</span></span><br><span class="line">25672 <span class="comment">#RabbitMQ的节点间的CLI通讯端口是</span></span><br><span class="line">15672 <span class="comment">#RabbitMQ HTTP_API的端口，管理员用户才能访问，用于管理RabbitMQ,需要启动Management插件。</span></span><br><span class="line">1883、8883 <span class="comment">#MQTT插件启动时的端口。</span></span><br><span class="line">61613、61614 <span class="comment">#STOMP客户端插件启用的时候的端口。</span></span><br><span class="line">15674、15675 <span class="comment">#基于webscoket的STOMP端口和MOTT端口</span></span><br></pre></td></tr></table></figure>
<h2 id="3、RabbitMQWeb管理界面及授权操作">3、RabbitMQWeb管理界面及授权操作</h2>
<h3 id="1、RabbitMQ管理界面安装">1、RabbitMQ管理界面安装</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#默认情况下，rabbitmq是没有安装web端的客户端插件，需要安装才可以生效</span></span><br><span class="line">rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_management</span><br><span class="line"><span class="comment">#安装完毕以后，重启服务即可</span></span><br><span class="line">systemctl restart rabbitmq-server</span><br><span class="line"><span class="comment">#注意端口开放</span></span><br><span class="line">firewall-cmd --zone=public --add-port=15672/tcp --permanent </span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>
<p>最后访问<code>http://ip:15672/</code>即可</p>
<h3 id="2、授权账号和密码">2、授权账号和密码</h3>
<p>​	rabbitmq有一个默认账号和密码是：<code>guest</code> 默认情况只能在localhost本机下访问，所以需要添加一个远程登录的用户。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#新增用户</span></span><br><span class="line">rabbitmqctl add_user admin admin</span><br><span class="line"><span class="comment">#设置用户分配操作权限</span></span><br><span class="line">rabbitmqctl set_user_tags admin administrator</span><br><span class="line"><span class="comment">#为用户添加资源权限</span></span><br><span class="line">rabbitmqctl set_permissions -p / admin <span class="string">".*"</span> <span class="string">".*"</span> <span class="string">".*"</span></span><br></pre></td></tr></table></figure>
<p>相关操作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rabbitmqctl add_user 账号 密码</span><br><span class="line">rabbitmqctl set_user_tags 账号 administrator</span><br><span class="line">rabbitmqctl change_password Username Newpassword 修改密码</span><br><span class="line">rabbitmqctl delete_user Username 删除用户</span><br><span class="line">rabbitmqctl list_users 查看用户清单</span><br><span class="line">rabbitmqctl set_permissions -p / 用户名 <span class="string">".*"</span> <span class="string">".*"</span> <span class="string">".*"</span> 为用户设置administrator角色</span><br><span class="line">rabbitmqctl set_permissions -p / root <span class="string">".*"</span> <span class="string">".*"</span> <span class="string">".*"</span></span><br></pre></td></tr></table></figure>
<h2 id="4、Docker安装RabbitMQ">4、Docker安装RabbitMQ</h2>
<h3 id="1、Docker安装">1、Docker安装</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#yum 包更新到最新</span></span><br><span class="line">yum update</span><br><span class="line"><span class="comment">#安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的</span></span><br><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line"><span class="comment">#设置yum源为阿里云</span></span><br><span class="line">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"><span class="comment">#安装docker</span></span><br><span class="line">yum install docker-ce -y</span><br><span class="line"><span class="comment">#安装后查看docker版本</span></span><br><span class="line">docker -v</span><br><span class="line"><span class="comment">#安装加速镜像</span></span><br><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-<span class="string">'EOF'</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"registry-mirrors"</span>: [<span class="string">"https://0wrdwnn6.mirror.aliyuncs.com"</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>
<p><em>详情查看https://blog.csdn.net/lemon_TT/article/details/117983127</em></p>
<h3 id="2、docker相关命令">2、docker相关命令</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动docker：</span></span><br><span class="line">systemctl start docker</span><br><span class="line"><span class="comment"># 停止docker：</span></span><br><span class="line">systemctl stop docker</span><br><span class="line"><span class="comment"># 重启docker：</span></span><br><span class="line">systemctl restart docker</span><br><span class="line"><span class="comment"># 查看docker状态：</span></span><br><span class="line">systemctl status docker</span><br><span class="line"><span class="comment"># 开机启动：  </span></span><br><span class="line">systemctl <span class="built_in">enable</span> docker</span><br><span class="line">systemctl unenable docker</span><br><span class="line"><span class="comment"># 查看docker概要信息</span></span><br><span class="line">docker info</span><br><span class="line"><span class="comment"># 查看docker帮助文档</span></span><br><span class="line">docker --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>
<h3 id="3、RabbitMQ安装运行">3、RabbitMQ安装运行</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#这个镜像带管理界面</span></span><br><span class="line">docker pull rabbitmq:management</span><br><span class="line"><span class="comment">#运行docker容器</span></span><br><span class="line">docker run -di --name myrabbit -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=admin -p 15672:15672 -p 5672:5672 -p 25672:25672 -p 61613:61613 -p 1883:1883 rabbitmq:management</span><br><span class="line"><span class="comment">#开放端口</span></span><br><span class="line">firewall-cmd --zone=public --add-port=15672/tcp --add-port=5672/tcp  --permanent</span><br><span class="line">firewall-cmd --reload </span><br><span class="line"><span class="comment">#查看日志</span></span><br><span class="line">docker logs -f myrabbit</span><br><span class="line"><span class="comment">#查看端口是否被占用</span></span><br><span class="line">netstat -naop | grep 5672</span><br></pre></td></tr></table></figure>
<p>最后访问<code>http://ip:15672/</code>即可</p>
<h2 id="5、RabbitMQ角色介绍">5、RabbitMQ角色介绍</h2>
<h3 id="1、none">1、none</h3>
<ul>
<li>不能访问management plugin</li>
</ul>
<h3 id="2、management：查看自己相关节点信息">2、management：查看自己相关节点信息</h3>
<ul>
<li>列出自己可以通过AMQP登入的虚拟机</li>
<li>查看自己的虚拟机节点 virtual hosts的queues,exchanges和bindings信息</li>
<li>查看和关闭自己的channels和connections</li>
<li>查看有关自己的虚拟机节点virtual hosts的统计信息。包括其他用户在这个节点virtual hosts中的活动信息。</li>
</ul>
<h3 id="3、Policymaker">3、Policymaker</h3>
<ul>
<li>包含management所有权限</li>
<li>查看和创建和删除自己的virtual hosts所属的policies和parameters信息。</li>
</ul>
<h3 id="4、Monitoring">4、Monitoring</h3>
<ul>
<li>包含management所有权限</li>
<li>罗列出所有的virtual hosts，包括不能登录的virtual hosts。</li>
<li>查看其他用户的connections和channels信息</li>
<li>查看节点级别的数据如clustering和memory使用情况</li>
<li>查看所有的virtual hosts的全局统计信息。</li>
</ul>
<h3 id="5、Administrator">5、Administrator</h3>
<ul>
<li>最高权限</li>
<li>可以创建和删除virtual hosts</li>
<li>可以查看，创建和删除users</li>
<li>查看创建permisssions</li>
<li>关闭所有用户的connections</li>
</ul>
<h1>三、RabbitMQ入门实战</h1>
<h2 id="1、概述-v3">1、概述</h2>
<blockquote>
<p>AMQP全称：Advanced Message Queuing Protocol(高级消息队列协议)。是应用层协议的一个开发标准，为面向消息的中间件设计。</p>
</blockquote>
<p><strong>AMQP生产者流转过程</strong></p>
<p><img src="https://img-blog.csdnimg.cn/6cfa8c6ebddd4efaaba0bf5d44497100.png#pic_center" alt="请添加图片描述"></p>
<p><strong>AMQP消费者流转过程</strong></p>
<p><img src="https://img-blog.csdnimg.cn/260d3c9d730748feb3f38d8e922fdc7a.png#pic_center" alt="请添加图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/c43f8febf9db4094a3145c60bcdaf758.png#pic_center" alt="请添加图片描述"></p>
<p><strong>Server</strong>：又称Broker ,接受客户端的连接，实现AMQP实体服务。 安装rabbitmq-server<br>
<strong>Connection</strong>：连接，应用程序与Broker的网络连接 TCP/IP/ 三次握手和四次挥手<br>
<strong>Channel</strong>：网络信道，几乎所有的操作都在Channel中进行，Channel是进行消息读写的通道，客户端可以建立对各Channel，每个Channel代表一个会话任务。<br>
<strong>Message</strong> :消息：服务与应用程序之间传送的数据，由Properties和body组成，Properties可是对消息进行修饰，比如消息的优先级，延迟等高级特性，Body则就是消息体的内容。<br>
<strong>Virtual Host</strong> 虚拟地址，用于进行逻辑隔离，最上层的消息路由，一个虚拟主机理由可以有若干个Exhange和Queueu，同一个虚拟主机里面不能有相同名字的Exchange<br>
<strong>Exchange</strong>：交换机，接受消息，根据路由键发送消息到绑定的队列。(==不具备消息存储的能力==)<br>
<strong>Bindings</strong>：Exchange和Queue之间的虚拟连接，binding中可以保护多个routing key.<br>
<strong>Routing key</strong>：是一个路由规则，虚拟机可以用它来确定如何路由一个特定消息。<br>
<strong>Queue</strong>：队列：也成为Message Queue,消息队列，保存消息并将它们转发给消费者。</p>
<h2 id="2、Simple简单模式">2、Simple简单模式</h2>
<ul>
<li>特点：普通消费者生产者模型</li>
</ul>
<img src="https://img-blog.csdnimg.cn/63036094c2f34977973d046a812f6255.png#pic_center" width="60%">
<h3 id="1、代码实现">1、代码实现</h3>
<p><strong>实现步骤</strong></p>
<p>1、jdk1.8<br>
2、构建一个maven工程<br>
3、导入rabbitmq的maven依赖<br>
4、启动rabbitmq-server服务<br>
5、定义生产者<br>
6、定义消费者<br>
7、观察消息的在rabbitmq-server服务中的过程</p>
<p><strong>导入maven依赖</strong></p>
<p>java原生依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.13.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>spring依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.amqp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.amqp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-rabbit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>springboot依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面依赖根据自己的项目环境进行选择即可。</p>
<p><strong>定义生产者</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里我使用了原生java依赖，导的包都是rabbitmq.client下</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1: 创建连接工厂</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">// 2: 设置连接属性</span></span><br><span class="line">        connectionFactory.setHost(<span class="string">"120.24.70.136"</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">"/"</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">"admin"</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">"admin"</span>);</span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 3: 从连接工厂中获取连接</span></span><br><span class="line">            connection = connectionFactory.newConnection(<span class="string">"生产者"</span>);</span><br><span class="line">            <span class="comment">// 4: 从连接中获取通道channel</span></span><br><span class="line">            channel = connection.createChannel();</span><br><span class="line">            <span class="comment">// 5: 申明队列queue存储消息</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             *  如果队列不存在，则会创建</span></span><br><span class="line"><span class="comment">             *  Rabbitmq不允许创建两个相同的队列名称，否则会报错。</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             *  @params1： queue 队列的名称</span></span><br><span class="line"><span class="comment">             *  @params2： durable 队列是否持久化</span></span><br><span class="line"><span class="comment">             *  @params3： exclusive 是否排他，即是否私有的，如果为true,会对当前队列加锁，其他的通道不能访问，并且连接自动关闭</span></span><br><span class="line"><span class="comment">             *  @params4： autoDelete 是否自动删除，当最后一个消费者断开连接之后是否自动删除消息。</span></span><br><span class="line"><span class="comment">             *  @params5： arguments 可以设置队列附加参数，设置队列的有效期，消息的最大长度，队列的消息生命周期等等。</span></span><br><span class="line"><span class="comment">             * */</span></span><br><span class="line">            channel.queueDeclare(<span class="string">"queue1"</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">// 6： 准备发送消息的内容</span></span><br><span class="line">            String message = <span class="string">"你好，shawn！！！"</span>;</span><br><span class="line">            <span class="comment">// 7: 发送消息给中间件rabbitmq-server</span></span><br><span class="line">            <span class="comment">// @params1: 交换机exchange</span></span><br><span class="line">            <span class="comment">// @params2: 队列名称/routing</span></span><br><span class="line">            <span class="comment">// @params3: 属性配置</span></span><br><span class="line">            <span class="comment">// @params4: 发送消息的内容</span></span><br><span class="line">            channel.basicPublish(<span class="string">""</span>, <span class="string">"queue1"</span>, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">            System.out.println(<span class="string">"消息发送成功!"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">"发送消息出现异常..."</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 7: 释放连接关闭通道</span></span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="keyword">null</span> &amp;&amp; channel.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    channel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>定义生产者</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Comsumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1: 创建连接工厂</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">// 2: 设置连接属性</span></span><br><span class="line">        connectionFactory.setHost(<span class="string">"120.24.70.136"</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">"/"</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">"admin"</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">"admin"</span>);</span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = connectionFactory.newConnection(<span class="string">"消费者"</span>);</span><br><span class="line">            channel = connection.createChannel();</span><br><span class="line">            channel.basicConsume(<span class="string">"queue1"</span>, <span class="keyword">true</span>, <span class="keyword">new</span> DeliverCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String comsumerTag, Delivery message)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">"收到消息为"</span> + <span class="keyword">new</span> String(message.getBody(), StandardCharsets.UTF_8));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="keyword">new</span> CancelCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String s)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">"接受失败了"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            System.out.println(<span class="string">"接受消息完毕"</span>);</span><br><span class="line">            <span class="comment">//System.in.read();</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">"接受消息出现异常"</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="keyword">null</span> &amp;&amp; channel.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    channel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、Web界面操作">2、Web界面操作</h3>
<p><img src="https://img-blog.csdnimg.cn/65b49943b2734dd78def0ea297029d91.png#pic_center" alt="请添加图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/6a85a51cfd0a409aab88fd6f7e65e77a.png#pic_center" alt="请添加图片描述"></p>
<h2 id="3、work工作模式">3、work工作模式</h2>
<h3 id="1、概述-v4">1、概述</h3>
<ul>
<li>特点：分发机制。包括轮询模式和公平分发模式</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/c2b717c617bb42e3801089805f634094.png?#pic_center" alt="请添加图片描述"></p>
<h3 id="2、代码实现">2、代码实现</h3>
<p><strong>1、轮询模式</strong></p>
<p>生产者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1: 创建连接工厂</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">// 2: 设置连接属性</span></span><br><span class="line">        connectionFactory.setHost(<span class="string">"120.24.70.136"</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">"/"</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">"admin"</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">"admin"</span>);</span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 3: 从连接工厂中获取连接</span></span><br><span class="line">            connection = connectionFactory.newConnection(<span class="string">"生产者"</span>);</span><br><span class="line">            <span class="comment">// 4: 从连接中获取通道channel</span></span><br><span class="line">            channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5： 准备发送消息的内容</span></span><br><span class="line">            <span class="comment">//===============================end topic模式==================================</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">                <span class="comment">//消息的内容</span></span><br><span class="line">                String msg = <span class="string">"shawn:"</span> + i;</span><br><span class="line">                <span class="comment">// 7: 发送消息给中间件rabbitmq-server</span></span><br><span class="line">                <span class="comment">// @params1: 交换机exchange</span></span><br><span class="line">                <span class="comment">// @params2: 队列名称/routingkey</span></span><br><span class="line">                <span class="comment">// @params3: 属性配置</span></span><br><span class="line">                <span class="comment">// @params4: 发送消息的内容</span></span><br><span class="line">                channel.basicPublish(<span class="string">""</span>, <span class="string">"queue1"</span>, <span class="keyword">null</span>, msg.getBytes());</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"消息发送成功!"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">"发送消息出现异常..."</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 7: 释放连接关闭通道</span></span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="keyword">null</span> &amp;&amp; channel.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    channel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>消费者，这里需要创建两个类，work1和work2，内容一样，只贴出一份</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Work1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1: 创建连接工厂</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">// 2: 设置连接属性</span></span><br><span class="line">        connectionFactory.setHost(<span class="string">"120.24.70.136"</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">"/"</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">"admin"</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">"admin"</span>);</span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = connectionFactory.newConnection(<span class="string">"消费者"</span>);</span><br><span class="line">            channel = connection.createChannel();</span><br><span class="line">            channel.basicConsume(<span class="string">"queue1"</span>, <span class="keyword">true</span>, <span class="keyword">new</span> DeliverCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String comsumerTag, Delivery message)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">"收到消息为"</span> + <span class="keyword">new</span> String(message.getBody(), StandardCharsets.UTF_8));</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="keyword">new</span> CancelCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String s)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">"接受失败了"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            System.in.read();</span><br><span class="line">            System.out.println(<span class="string">"接受消息完毕"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">"接受消息出现异常"</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="keyword">null</span> &amp;&amp; channel.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    channel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为两个消费分别消费一个，轮着消费，即使每个线程运行时间不同</p>
<p><strong>2、公平分发模式</strong></p>
<p>生产者不变，消费者改成手动消费，仍然创建两个各，其中每个类运行睡眠时间不一样，结果可以发现对于睡眠时间短的消费消息更多，即性能好的消费更多</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shawn.rabbitmq.work.fair;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Work1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1: 创建连接工厂</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">// 2: 设置连接属性</span></span><br><span class="line">        connectionFactory.setHost(<span class="string">"120.24.70.136"</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">"/"</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">"admin"</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">"admin"</span>);</span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = connectionFactory.newConnection(<span class="string">"消费者"</span>);</span><br><span class="line">            channel = connection.createChannel();</span><br><span class="line">            Channel finalChannel = channel;</span><br><span class="line">            <span class="comment">//表示每次从队列获取一个消息，根据内存状况调整</span></span><br><span class="line">            finalChannel.basicQos(<span class="number">1</span>);</span><br><span class="line">			<span class="comment">//设置手动确认消费消息</span></span><br><span class="line">            channel.basicConsume(<span class="string">"queue1"</span>, <span class="keyword">false</span>, <span class="keyword">new</span> DeliverCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String comsumerTag, Delivery message)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">"收到消息为"</span> + <span class="keyword">new</span> String(message.getBody(), StandardCharsets.UTF_8));</span><br><span class="line">                        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                       <span class="comment">//确认消费</span></span><br><span class="line">                     finalChannel.basicAck(message.getEnvelope().getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="keyword">new</span> CancelCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String s)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">"接受失败了"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            System.in.read();</span><br><span class="line">            System.out.println(<span class="string">"接受消息完毕"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">"接受消息出现异常"</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="keyword">null</span> &amp;&amp; channel.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    channel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4、fanout发布订阅模式">4、fanout发布订阅模式</h2>
<h3 id="1、概述-v5">1、概述</h3>
<ul>
<li>特点：Fanout—发布与订阅模式，是一种广播机制，它是没有路由key的模式。只要订阅了该交换机，那么就可以获取数据</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/be72b06d5297433eaf11d0c5f120e752.png#pic_center" alt="请添加图片描述"></p>
<h3 id="2、代码实现-v2">2、代码实现</h3>
<p>生产者（注意已经绑定好关系可以不用在代码中编写绑定关系了）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1: 创建连接工厂</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">// 2: 设置连接属性</span></span><br><span class="line">        connectionFactory.setHost(<span class="string">"120.24.70.136"</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">"/"</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">"admin"</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">"admin"</span>);</span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 3: 从连接工厂中获取连接</span></span><br><span class="line">            connection = connectionFactory.newConnection(<span class="string">"生产者"</span>);</span><br><span class="line">            <span class="comment">// 4: 从连接中获取通道channel</span></span><br><span class="line">            channel = connection.createChannel();</span><br><span class="line">            <span class="comment">// 5: 准备交换机,这里我在web界面以及创建完毕</span></span><br><span class="line">            String exchangeName = <span class="string">"fanout_exchange"</span>;</span><br><span class="line">            <span class="comment">// 6： 准备发送消息的内容</span></span><br><span class="line">            String message = <span class="string">"你好，shawn！！！"</span>;</span><br><span class="line">            <span class="comment">// 7:定义路由key</span></span><br><span class="line">            String routingKey=<span class="string">""</span>;</span><br><span class="line">            <span class="comment">// 8: 指定交换机类型</span></span><br><span class="line">            String type = <span class="string">"fanout"</span>;</span><br><span class="line">            <span class="comment">//这里队列声明以及绑定关系都已经在web端完成,可以不下以下声明</span></span><br><span class="line">            <span class="comment">//最后true表示重启后交换机不会删除</span></span><br><span class="line">            channel.exchangeDeclare(exchangeName, type, <span class="keyword">true</span>);</span><br><span class="line">            String queueName1 = channel.queueDeclare(<span class="string">"queue1"</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>).getQueue();</span><br><span class="line">            channel.queueBind(queueName1, exchangeName, routingKey);</span><br><span class="line">            String queueName2 = channel.queueDeclare(<span class="string">"queue2"</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>).getQueue();</span><br><span class="line">            channel.queueBind(queueName2, exchangeName, routingKey);</span><br><span class="line">            <span class="comment">// 9: 发送消息给中间件rabbitmq-server</span></span><br><span class="line">            <span class="comment">// @params1: 交换机exchange</span></span><br><span class="line">            <span class="comment">// @params2: 队列名称/routing</span></span><br><span class="line">            <span class="comment">// @params3: 属性配置</span></span><br><span class="line">            <span class="comment">// @params4: 发送消息的内容</span></span><br><span class="line">            channel.basicPublish(exchangeName, routingKey, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">            System.out.println(<span class="string">"消息发送成功!"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">"发送消息出现异常..."</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 7: 释放连接关闭通道</span></span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="keyword">null</span> &amp;&amp; channel.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    channel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>消费者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里注意消费者会将消息都消费</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Comsumer</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Runnable runnable = () -&gt; &#123;</span><br><span class="line">        <span class="comment">// 1: 创建连接工厂</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">// 2: 设置连接属性</span></span><br><span class="line">        connectionFactory.setHost(<span class="string">"120.24.70.136"</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">"/"</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">"admin"</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">"admin"</span>);</span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line">         <span class="comment">//获取队列的名称</span></span><br><span class="line">         <span class="keyword">final</span> String queueName = Thread.currentThread().getName();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = connectionFactory.newConnection(<span class="string">"消费者"</span>);</span><br><span class="line">            channel = connection.createChannel();</span><br><span class="line">            channel.basicConsume(queueName, <span class="keyword">true</span>, <span class="keyword">new</span> DeliverCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String comsumerTag, Delivery message)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">"收到消息为"</span> + <span class="keyword">new</span> String(message.getBody(), StandardCharsets.UTF_8));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="keyword">new</span> CancelCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String s)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">"接受失败了"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            System.in.read();</span><br><span class="line">            System.out.println(<span class="string">"接受消息完毕"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">"接受消息出现异常"</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="keyword">null</span> &amp;&amp; channel.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    channel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(runnable,<span class="string">"queue1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(runnable,<span class="string">"queue2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5、direct路由模式">5、direct路由模式</h2>
<ul>
<li>特点：有routing-key的匹配模式，根据给定的路由key确定对应的队列</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/d27ebed0a90e4809b0bea4a4a409f0ec.png#pic_center" alt="请添加图片描述"></p>
<p>​	代码实现如fanout模式，将生产者交换机以及路由修改即可，这里路由是精确匹配</p>
<h2 id="6、topic主题模式">6、topic主题模式</h2>
<ul>
<li>
<p>特点：模糊的routing-key的匹配模式</p>
<p>#表示0级或多级</p>
<p>*表示必须有1级</p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/ab7b0135e497418eac29cad20ee11469.png#pic_center" alt="请添加图片描述"></p>
<p>​	代码实现如fanout模式，将生产者交换机以及路由修改即可，这里路由是正则匹配方式</p>
<h2 id="7、headers参数模式">7、headers参数模式</h2>
<ul>
<li>特点：通过参数进行相应队列的分发</li>
</ul>
<h1>四、SPringBoot整合RabbitMQ入门实战</h1>
<h2 id="1、环境准备-v2">1、环境准备</h2>
<p>​	创建SPringBoot父子项目，兵在<code>pom.xml</code>引入RabbitMQ依赖，后面就创建子模块，pom依赖关系配置详见<a href="https://blog.csdn.net/lemon_TT/article/details/119654251" target="_blank" rel="noopener">父子项目搭建参考</a></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​	目标架构</p>
<p><img src="https://img-blog.csdnimg.cn/6a44267c04bd46dca86d2214712e695b.png#pic_center" alt="请添加图片描述"></p>
<h2 id="2、fanout模式">2、fanout模式</h2>
<h3 id="1、创建生产者模块">1、创建生产者模块</h3>
<p>创建springboot-rabbitmq-fanout-producer模块，并在在application.yml进行配置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 服务端口</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"><span class="comment"># 配置rabbitmq服务</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">120.24</span><span class="number">.70</span><span class="number">.136</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br></pre></td></tr></table></figure>
<p>定义订单生产者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shawn.springbootrabbitmqfanoutproducer.service;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1: 定义交换机</span></span><br><span class="line">    <span class="keyword">private</span> String exchangeName = <span class="string">"fanout_order_exchange"</span>;</span><br><span class="line">    <span class="comment">// 2: 路由key</span></span><br><span class="line">    <span class="keyword">private</span> String routeKey = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeOrder</span><span class="params">(Long userId, Long productId, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1： 模拟用户下单</span></span><br><span class="line">        String orderNumer = UUID.randomUUID().toString();</span><br><span class="line">        <span class="comment">// 2: 根据商品id productId 去查询商品的库存</span></span><br><span class="line">        <span class="comment">// int numstore = productSerivce.getProductNum(productId);</span></span><br><span class="line">        <span class="comment">// 3:判断库存是否充足</span></span><br><span class="line">        <span class="comment">// if(num &gt;  numstore )&#123; return  "商品库存不足..."; &#125;</span></span><br><span class="line">        <span class="comment">// 4: 下单逻辑</span></span><br><span class="line">        <span class="comment">// orderService.saveOrder(order);</span></span><br><span class="line">        <span class="comment">// 5: 下单成功要扣减库存</span></span><br><span class="line">        <span class="comment">// 6: 下单完成以后</span></span><br><span class="line">        System.out.println(<span class="string">"用户 "</span> + userId + <span class="string">",订单编号是："</span> + orderNumer);</span><br><span class="line">        <span class="comment">// 发送订单信息给RabbitMQ fanout</span></span><br><span class="line">        rabbitTemplate.convertAndSend(exchangeName, routeKey, orderNumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义绑定关系,，相当于之前的创建交换机、绑定队列等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shawn.springbootrabbitmqfanoutproducer.config;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Shawn</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/09/02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanoutConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">emailQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// durable:是否持久化,默认是false,持久化队列：会被存储在磁盘上，当消息代理重启时仍然存在，暂存队列：当前连接有效</span></span><br><span class="line">        <span class="comment">// exclusive:默认也是false，只能被当前创建的连接使用，而且当连接关闭后队列即被删除。此参考优先级高于durable</span></span><br><span class="line">        <span class="comment">// autoDelete:是否自动删除，当没有生产者或者消费者使用此队列，该队列会自动删除。</span></span><br><span class="line">        <span class="comment">//   return new Queue("TestDirectQueue",true,true,false);</span></span><br><span class="line">        <span class="comment">//一般设置一下队列的持久化就好,其余两个就是默认false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"email.fanout.queue"</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">smsQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// durable:是否持久化,默认是false,持久化队列：会被存储在磁盘上，当消息代理重启时仍然存在，暂存队列：当前连接有效</span></span><br><span class="line">        <span class="comment">// exclusive:默认也是false，只能被当前创建的连接使用，而且当连接关闭后队列即被删除。此参考优先级高于durable</span></span><br><span class="line">        <span class="comment">// autoDelete:是否自动删除，当没有生产者或者消费者使用此队列，该队列会自动删除。</span></span><br><span class="line">        <span class="comment">//   return new Queue("TestDirectQueue",true,true,false);</span></span><br><span class="line">        <span class="comment">//一般设置一下队列的持久化就好,其余两个就是默认false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"sms.fanout.queue"</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">weixinQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// durable:是否持久化,默认是false,持久化队列：会被存储在磁盘上，当消息代理重启时仍然存在，暂存队列：当前连接有效</span></span><br><span class="line">        <span class="comment">// exclusive:默认也是false，只能被当前创建的连接使用，而且当连接关闭后队列即被删除。此参考优先级高于durable</span></span><br><span class="line">        <span class="comment">// autoDelete:是否自动删除，当没有生产者或者消费者使用此队列，该队列会自动删除。</span></span><br><span class="line">        <span class="comment">//   return new Queue("TestDirectQueue",true,true,false);</span></span><br><span class="line">        <span class="comment">//一般设置一下队列的持久化就好,其余两个就是默认false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"weixin.fanout.queue"</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//交换机名字和类型</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FanoutExchange <span class="title">fanoutOrderExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FanoutExchange(<span class="string">"fanout_order_exchange"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//绑定  将队列和交换机绑定, 并设置用于匹配键</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bindingDirect1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(weixinQueue()).to(fanoutOrderExchange());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bindingDirect2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(smsQueue()).to(fanoutOrderExchange());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bindingDirect3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(emailQueue()).to(fanoutOrderExchange());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后进行测试类，成功后即可发现队列有了消息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpringbootRabbitmqFanoutProducerApplicationTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    OrderService orderService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            Long userId = <span class="number">100L</span> + i;</span><br><span class="line">            Long productId = <span class="number">10001L</span> + i;</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">            orderService.makeOrder(userId, productId, num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、创建消费者模块">2、创建消费者模块</h3>
<p>创建springboot-rabbitmq-fanout-consumer模块，并在在application.yml进行配置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 服务端口</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line"><span class="comment"># 配置rabbitmq服务</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">120.24</span><span class="number">.70</span><span class="number">.136</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br></pre></td></tr></table></figure>
<p>分别创建三个消费者类，这里举例其中一个SMS消费类，最后启动即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bindings其实就是用来确定队列和交换机绑定关系</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(bindings =<span class="meta">@QueueBinding</span>(</span><br><span class="line">        <span class="comment">// email.fanout.queue 是队列名字，这个名字你可以自定随便定义。</span></span><br><span class="line">        value = <span class="meta">@Queue</span>(value = <span class="string">"sms.fanout.queue"</span>,autoDelete = <span class="string">"false"</span>),</span><br><span class="line">        <span class="comment">// order.fanout 交换机的名字 必须和生产者保持一致</span></span><br><span class="line">        exchange = <span class="meta">@Exchange</span>(value = <span class="string">"fanout_order_exchange"</span>,</span><br><span class="line">                <span class="comment">// 这里是确定的rabbitmq模式是：fanout 是以广播模式 、 发布订阅模式</span></span><br><span class="line">                type = ExchangeTypes.FANOUT)</span><br><span class="line">))</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanoutSMSConsumer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// @RabbitHandler 代表此方法是一个消息接收的方法。该不要有返回值</span></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">messagerevice</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 此处省略发邮件的逻辑</span></span><br><span class="line">        System.out.println(<span class="string">"sms--------------&gt;"</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3、direct模式">3、direct模式</h2>
<p>​	新建项目，配置DirectConfiguration中的交换机和队列，并在订单业务中设置路由key，其他操作与fanout模式类似</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">emailQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// durable:是否持久化,默认是false,持久化队列：会被存储在磁盘上，当消息代理重启时仍然存在，暂存队列：当前连接有效</span></span><br><span class="line">        <span class="comment">// exclusive:默认也是false，只能被当前创建的连接使用，而且当连接关闭后队列即被删除。此参考优先级高于durable</span></span><br><span class="line">        <span class="comment">// autoDelete:是否自动删除，当没有生产者或者消费者使用此队列，该队列会自动删除。</span></span><br><span class="line">        <span class="comment">//   return new Queue("TestDirectQueue",true,true,false);</span></span><br><span class="line">        <span class="comment">//一般设置一下队列的持久化就好,其余两个就是默认false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"email.direct.queue"</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">smsQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// durable:是否持久化,默认是false,持久化队列：会被存储在磁盘上，当消息代理重启时仍然存在，暂存队列：当前连接有效</span></span><br><span class="line">        <span class="comment">// exclusive:默认也是false，只能被当前创建的连接使用，而且当连接关闭后队列即被删除。此参考优先级高于durable</span></span><br><span class="line">        <span class="comment">// autoDelete:是否自动删除，当没有生产者或者消费者使用此队列，该队列会自动删除。</span></span><br><span class="line">        <span class="comment">//   return new Queue("TestDirectQueue",true,true,false);</span></span><br><span class="line">        <span class="comment">//一般设置一下队列的持久化就好,其余两个就是默认false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"sms.direct.queue"</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">weixinQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// durable:是否持久化,默认是false,持久化队列：会被存储在磁盘上，当消息代理重启时仍然存在，暂存队列：当前连接有效</span></span><br><span class="line">        <span class="comment">// exclusive:默认也是false，只能被当前创建的连接使用，而且当连接关闭后队列即被删除。此参考优先级高于durable</span></span><br><span class="line">        <span class="comment">// autoDelete:是否自动删除，当没有生产者或者消费者使用此队列，该队列会自动删除。</span></span><br><span class="line">        <span class="comment">//   return new Queue("TestDirectQueue",true,true,false);</span></span><br><span class="line">        <span class="comment">//一般设置一下队列的持久化就好,其余两个就是默认false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"weixin.direct.queue"</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DirectExchange <span class="title">directOrderExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(<span class="string">"direct_order_exchange"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bindingDirect1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(weixinQueue()).to(directOrderExchange()).with(<span class="string">"weixin"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bindingDirect2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(smsQueue()).to(directOrderExchange()).with(<span class="string">"sms"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bindingDirect3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(emailQueue()).to(directOrderExchange()).with(<span class="string">"email"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4、topic模式">4、topic模式</h2>
<p>​	在这里可以不定义figuration，直接通过队列绑定交换机的路由关系，其他操作与fanout模式类似（通过注解方式绑定，之前都是通过配置文件方式绑定）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bindings其实就是用来确定队列和交换机绑定关系</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(bindings =<span class="meta">@QueueBinding</span>(</span><br><span class="line">        <span class="comment">// sms.topic.queue 是队列名字，这个名字你可以自定随便定义。</span></span><br><span class="line">        value = <span class="meta">@Queue</span>(value = <span class="string">"sms.topic.queue"</span>,autoDelete = <span class="string">"false"</span>),</span><br><span class="line">        exchange = <span class="meta">@Exchange</span>(value = <span class="string">"topic_order_exchange"</span>,</span><br><span class="line">                type = ExchangeTypes.TOPIC),</span><br><span class="line">        key = <span class="string">"#.sms.#"</span></span><br><span class="line">))</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicSMSConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">messagerevice</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 此处省略发邮件的逻辑</span></span><br><span class="line">        System.out.println(<span class="string">"SMS--------------&gt;"</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5、过期时间ttl和死信队列-★">5、过期时间ttl和死信队列(★)</h2>
<blockquote>
<p>过期时间TTL表示可以对消息设置预期的时间，在这个时间内都可以被消费者接收获取；过了之后消息将自动被删除。RabbitMQ可以对<strong>消息和队列</strong>设置TTL。目前有两种方法可以设置，若两个同时设置，则以时间最短的为准。</p>
<ul>
<li>通过队列属性设置，队列中所有消息都有相同的过期时间。</li>
<li>对消息进行单独设置，每条消息TTL可以不同。</li>
</ul>
<p>DLX，全称为Dead-Letter-Exchange , 可以称之为死信交换机，也有人称之为死信邮箱。当消息在一个队列中变成死信(dead message)之后，它能被重新发送到另一个交换机中，这个交换机就是DLX ，绑定DLX的队列就称之为死信队列。<br>
消息变成死信，可能是由于以下的原因：</p>
<ul>
<li>消息被拒绝</li>
<li>消息过期</li>
<li>队列达到最大长度</li>
</ul>
<p>DLX也是一个正常的交换机，和一般的交换机没有区别，它能在任何的队列上被指定，实际上就是设置某一个队列的属性。当这个队列中存在死信时，Rabbitmq就会自动地将这个消息重新发布到设置的DLX上去，进而被路由到另一个队列，即死信队列。要想使用死信队列，只需要在定义队列的时候设置队列参数 <code>x-dead-letter-exchange</code> 指定交换机即可。</p>
</blockquote>
<p>​	首先定义交换机、队列以及绑定关系，在定义队列时设置ttl参数以及dead参数，即创建后该队列会显示ttl以及DLX，代表是会自动删除消息的队列，并且删除的消息会发送到死信队列。这里定义了两种过期类型：队列过期和消息过期，其中队列过期可以将过期消息送到死信队列，而消息过期是完全删除了消息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TTLDirectConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//队列的过期时间</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">ttlQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Map&lt;String,Object&gt; args = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 这个key可以在图形化界面查看，类型一定是int类型</span></span><br><span class="line">        args.put(<span class="string">"x-message-ttl"</span>,<span class="number">5000</span>);</span><br><span class="line">        args.put(<span class="string">"x-dead-letter-exchange"</span>,<span class="string">"dead_direct_exchange"</span>);</span><br><span class="line">        <span class="comment">// fanout模式不用配置</span></span><br><span class="line">        args.put(<span class="string">"x-dead-letter-routing-key"</span>,<span class="string">"dead"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"ttl.direct.queue"</span>,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">ttlMessageQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"ttl.message.direct.queue"</span>,<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换机名字和类型</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DirectExchange <span class="title">TTLDirectExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(<span class="string">"ttl_direct_exchange"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">directTTLBinding</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(ttlQueue()).to(TTLDirectExchange()).with(<span class="string">"ttl"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">directTTLBinding1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(ttlMessageQueue()).to(TTLDirectExchange()).with(<span class="string">"ttl.message"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//死信队列交换机和队列配置</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadDirectConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">deadQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"dead.direct.queue"</span>,<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//交换机名字和类型</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DirectExchange <span class="title">deadDirectExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(<span class="string">"dead_direct_exchange"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">directTTLDeadBinding</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(deadQueue()).to(deadDirectExchange()).with(<span class="string">"dead"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	创建服务类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TTLService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1: 定义交换机</span></span><br><span class="line">    <span class="keyword">private</span> String exchangeName = <span class="string">"ttl_direct_exchange"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列设置过期</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeOrder</span><span class="params">(Long userId, Long productId, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        String routeKey = <span class="string">"ttl"</span>;</span><br><span class="line">        <span class="comment">// 1： 模拟用户下单</span></span><br><span class="line">        String orderNumer = UUID.randomUUID().toString();</span><br><span class="line">        System.out.println(<span class="string">"用户 "</span> + userId + <span class="string">",订单编号是："</span> + orderNumer);</span><br><span class="line">        <span class="comment">// 发送订单信息给RabbitMQ</span></span><br><span class="line">        rabbitTemplate.convertAndSend(exchangeName, routeKey, orderNumer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消息设置过期</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeOrderMessage</span><span class="params">(Long userId, Long productId, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        String routeKey = <span class="string">"ttl.message"</span>;</span><br><span class="line">        <span class="comment">// 1： 模拟用户下单</span></span><br><span class="line">        String orderNumer = UUID.randomUUID().toString();</span><br><span class="line">        System.out.println(<span class="string">"用户 "</span> + userId + <span class="string">",订单编号是："</span> + orderNumer);</span><br><span class="line">        MessagePostProcessor messagePostProcessor = <span class="keyword">new</span> MessagePostProcessor() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Message <span class="title">postProcessMessage</span><span class="params">(Message message)</span> <span class="keyword">throws</span> AmqpException </span>&#123;</span><br><span class="line">                <span class="comment">//设置5s过期</span></span><br><span class="line">                message.getMessageProperties().setExpiration(<span class="string">"5000"</span>);</span><br><span class="line">                message.getMessageProperties().setContentEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line">                <span class="keyword">return</span> message;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 发送订单信息给RabbitMQ</span></span><br><span class="line">        rabbitTemplate.convertAndSend(exchangeName, routeKey, orderNumer,messagePostProcessor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	最后创建测试类，启动后过期队列的消息过期会送到死信队列，而过期消息则直接删除</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpringbootRabbitmqFanoutProducerApplicationTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    TTLService ttlService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            Long userId = <span class="number">100L</span> + i;</span><br><span class="line">            Long productId = <span class="number">10001L</span> + i;</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">            <span class="comment">// 队列过期</span></span><br><span class="line">            ttlService.makeOrder(userId, productId, num);</span><br><span class="line">            <span class="comment">// 消息过期</span></span><br><span class="line">            ttlService.makeOrderMessage(userId, productId, num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6、消息确认机制的配置">6、消息确认机制的配置</h2>
<blockquote>
<p>NONE值是禁用发布确认模式，是默认值;<br>
CORRELATED值是发布消息成功到交换器后会触发回调方法;<br>
SIMPLE值经测试有两种效果，其一效果和CORRELATED值一样会触发回调方法，其二在发布消息成功后使用rabbitTemplate调用waitForConfirms或waitForConfirmsOrDie方法等待broker节点返回发送结果，根据返回结果来判定下一步的逻辑，要注意的点是waitForConfirmsOrDie方法如果返回false则会关闭channel，则接下来无法发送消息到broker;</p>
</blockquote>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 服务端口</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"><span class="comment"># 配置rabbitmq服务</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">120.24</span><span class="number">.70</span><span class="number">.136</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line"><span class="comment">#    集群配置方式</span></span><br><span class="line"><span class="comment">#    addresses: 120.24.70.136:5672</span></span><br><span class="line">    <span class="attr">publisher-confirm-type:</span> <span class="string">correlated</span></span><br></pre></td></tr></table></figure>
<p>​	在代码中配置确认机制，生产者无论成功发送与否，都会收到消息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Java中该注解的说明：@PostConstruct该注解被用来修饰一个非静态的void（）方法。被PostConstruct修饰的方法会在服务器加我Servlet的时候运行，</span></span><br><span class="line">    <span class="comment">//并且只会被服务器执行一次。Postconstruct在构造函数之后执行，init（）方法之前执行。</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">regCallback</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//消息发送成功以后，给予生产者的消息回执，来确保生产者的可靠性</span></span><br><span class="line">        rabbitTemplate.setConfirmCallback(<span class="keyword">new</span> RabbitTemplate.ConfirmCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> ack, String cause)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(ack)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"消息确认成功!!!!"</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">"消息确认失败!!!!"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>​	对于消费者来说，需要在配置文件重新配置过，解决消息重试的几种方案：</p>
<ul>
<li>控制重发的次数</li>
<li>try+catch+手动ack</li>
<li>try+catch+手动ack+死信队列处理</li>
</ul>
<h2 id="7、序列化和反序列化">7、序列化和反序列化</h2>
<p>传输bean对象时可能会出现list无法传输，有两种方案</p>
<ul>
<li>始终转换推断类型converter.setAlwaysConvertToInferredType(true);</li>
<li>将 spring-amqp 升级到 2.2.13.RELEASE 或以上</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Shawn</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021年11月25日15:35</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMQConfig</span> <span class="keyword">implements</span> <span class="title">RabbitListenerConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以将json串反序列化为对象</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureRabbitListeners</span><span class="params">(RabbitListenerEndpointRegistrar rabbitListenerEndpointRegistrar)</span> </span>&#123;</span><br><span class="line">        rabbitListenerEndpointRegistrar.setMessageHandlerMethodFactory(messageHandlerMethodFactory());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">MessageHandlerMethodFactory <span class="title">messageHandlerMethodFactory</span><span class="params">()</span></span>&#123;</span><br><span class="line">        DefaultMessageHandlerMethodFactory messageHandlerMethodFactory = <span class="keyword">new</span> DefaultMessageHandlerMethodFactory();</span><br><span class="line">        messageHandlerMethodFactory.setMessageConverter(mappingJackson2MessageConverter());</span><br><span class="line">        <span class="keyword">return</span> messageHandlerMethodFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MappingJackson2MessageConverter <span class="title">mappingJackson2MessageConverter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="keyword">new</span> MappingJackson2MessageConverter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供自定义RabbitTemplate,将对象序列化为json串</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RabbitTemplate <span class="title">jacksonRabbitTemplate</span><span class="params">(ConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        RabbitTemplate rabbitTemplate = <span class="keyword">new</span> RabbitTemplate(connectionFactory);</span><br><span class="line">        Jackson2JsonMessageConverter jackson2JsonMessageConverter = <span class="keyword">new</span> Jackson2JsonMessageConverter();</span><br><span class="line">        jackson2JsonMessageConverter.setAlwaysConvertToInferredType(<span class="keyword">true</span>);</span><br><span class="line">        rabbitTemplate.setMessageConverter(jackson2JsonMessageConverter);</span><br><span class="line">        <span class="keyword">return</span> rabbitTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>五、RabbitMQ内存磁盘的监控</h1>
<h2 id="1、概述-v6">1、概述</h2>
<p>​	把消息默认放在内存中是为了加快传输和消费的速度，存入磁盘是保证消息数据的持久化。</p>
<p><img src="https://img-blog.csdnimg.cn/5f1893c4bc8a4c9ebd83299740e48d95.png#pic_center" alt="请添加图片描述"></p>
<blockquote>
<p>参考帮助文档：<a href="https://www.rabbitmq.com/configure.html" target="_blank" rel="noopener">https://www.rabbitmq.com/configure.html</a></p>
</blockquote>
<p>​	当RabbitMQ警告时，即内存或者磁盘爆红，所有队列会进入阻塞状态，RabbitMQ无法正常运行。当出现警告的时候，可以通过配置去修改和调整</p>
<p><img src="https://img-blog.csdnimg.cn/5598d4d9fbab42da8ba755c97fbbde6a.png#pic_center" alt="请添加图片描述"></p>
<h2 id="2、RabbitMQ的内存控制">2、RabbitMQ的内存控制</h2>
<p><strong>1、命令的方式</strong></p>
<p>​	fraction/value 为内存阈值。默认情况是：0.4/2GB，代表的含义是：当RabbitMQ的内存超过40%时，就会产生警告并且阻塞所有生产者的连接。通过此命令修改阈值在Broker重启以后将会失效，通过修改配置文件方式设置的阈值则不会随着重启而消失，但修改了配置文件一样要重启broker才会生效。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rabbitmqctl set_vm_memory_high_watermark &lt;fraction&gt;</span><br><span class="line"><span class="comment">#绝对内存大小</span></span><br><span class="line">rabbitmqctl set_vm_memory_high_watermark absolute 50MB</span><br><span class="line"><span class="comment">#相对内存大小</span></span><br><span class="line">rabbitmqctl set_vm_memory_high_watermark 0.4</span><br></pre></td></tr></table></figure>
<p><strong>2、配置文件方式 rabbitmq.conf</strong></p>
<p>​	当前配置文件：<code>/etc/rabbitmq/rabbitmq.conf</code>（若不存在可自行创建）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#默认,但是配置完需要重启</span></span><br><span class="line"><span class="comment">#vm_memory_high_watermark.relative = 0.4</span></span><br><span class="line"><span class="comment"># 使用relative相对值进行设置fraction,建议取值在04~0.7之间，不建议超过0.7</span></span><br><span class="line">vm_memory_high_watermark.relative = 0.6</span><br><span class="line"><span class="comment"># 使用absolute的绝对值的方式，但是是KB,MB,GB对应的命令如下</span></span><br><span class="line"><span class="comment">#vm_memory_high_watermark.absolute = 2GB</span></span><br></pre></td></tr></table></figure>
<h2 id="3、RabbitMQ的内存换页">3、RabbitMQ的内存换页</h2>
<p>​	在某个Broker节点及内存阻塞生产者之前，它会尝试将队列中的消息换页到磁盘以释放内存空间，持久化和非持久化的消息都会写入磁盘中，其中持久化的消息本身就在磁盘中有一个副本，所以在转移的过程中持久化的消息会先从内存中清除掉。</p>
<blockquote>
<p>默认情况下，内存到达的阈值是50%时就会换页处理。<br>
也就是说，在默认情况下该内存的阈值是0.4的情况下，当内存超过0.40.5=0.2时，会进行换页动作</p>
</blockquote>
<p>​	可以通过设置 <code>vm_memory_high_watermark_paging_ratio</code> 来进行调整</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vm_memory_high_watermark.relative = 0.4</span><br><span class="line"><span class="comment">#设置小于1的值，大于1就没必要</span></span><br><span class="line">vm_memory_high_watermark_paging_ratio = 0.7</span><br></pre></td></tr></table></figure>
<h2 id="4、RabbitMQ的磁盘预警">4、RabbitMQ的磁盘预警</h2>
<p>​	当磁盘的剩余空间低于确定的阈值时，RabbitMQ同样会阻塞生产者，这样可以避免因非持久化的消息持续换页而耗尽磁盘空间导致服务器崩溃。</p>
<blockquote>
<p>默认情况下：磁盘预警为50MB的时候会进行预警。表示当前磁盘空间第50MB的时候会阻塞生产者并且停止内存消息换页到磁盘的过程。<br>
这个阈值可以减小，但是不能完全的消除因磁盘耗尽而导致崩溃的可能性。比如在两次磁盘空间的检查空隙内，第一次检查是：60MB ，第二检查可能就是1MB,就会出现警告。</p>
</blockquote>
<p>​	通过命令方式修改如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rabbitmqctl set_disk_free_limit  &lt;disk_limit&gt;</span><br><span class="line">rabbitmqctl set_disk_free_limit memory_limit  &lt;fraction&gt;</span><br><span class="line"><span class="comment">#------------------------------</span></span><br><span class="line"><span class="comment">#disk_limit：固定单位 KB MB GB</span></span><br><span class="line"><span class="comment">#fraction ：是相对阈值，建议范围在:1.0~2.0之间。（相对于内存）</span></span><br></pre></td></tr></table></figure>
<p>​	通过配置文件配置如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">disk_free_limit.relative = 3.0</span><br><span class="line">disk_free_limit.absolute = 50mb</span><br></pre></td></tr></table></figure>
<h1>六、RabbitMQ高级</h1>
<h2 id="1、消息队列高可用和高可靠">1、消息队列高可用和高可靠</h2>
<blockquote>
<p>所谓高可用：是指产品在规定的条件和规定的时刻或时间内处于可执行规定功能状态的能力。<br>
当业务量增加时，请求也过大，一台消息中间件服务器的会触及硬件（CPU,内存，磁盘）的极限，一台消息服务器你已经无法满足业务的需求，所以消息中间件必须支持集群部署。来达到高可用的目的。</p>
<p>所谓高可用是指：是指系统可以无故障低持续运行，比如一个系统突然崩溃，报错，异常等等并不影响线上业务的正常运行，出错的几率极低，就称之为：高可靠。</p>
</blockquote>
<h3 id="1、-Master-slave主从共享数据模式">1、 Master-slave主从共享数据模式</h3>
<p>​	生产者讲消费发送到Master节点，所有的都连接这个消息队列共享这块数据区域，Master节点负责写入，一旦Master挂掉，slave节点继续服务。从而形成高可用，</p>
<p><img src="https://img-blog.csdnimg.cn/2990a85ee6f54f6bbfcb139f4710a7ae.png#pic_center" alt="请添加图片描述"></p>
<h3 id="2、Master-slave主从同步模式">2、Master- slave主从同步模式</h3>
<p>​	写入消息在Master主节点上，但是主节点会同步数据到slave节点形成副本，和zookeeper或者redis主从机制很类同。这样可以达到负载均衡的效果，如果消费者有多个这样就可以去不同的节点就行消费，以为消息的拷贝和同步会暂用很大的带宽和网络资源。在后续的rabbtmq中会有使用。</p>
<p><img src="https://img-blog.csdnimg.cn/46b0d2d3a8af41a3a01cc30e9692a32a.png#pic_center" alt="请添加图片描述"></p>
<h3 id="3、多主集群同步部署模式">3、多主集群同步部署模式</h3>
<p>​	其写入可以往任意节点去写入。</p>
<p><img src="https://img-blog.csdnimg.cn/312430076fa94e74967831ee746b7870.png#pic_center" alt="请添加图片描述"></p>
<h3 id="4、多主集群转发部署模式">4、多主集群转发部署模式</h3>
<p>​	如果插入的数据是broker-1中，元数据信息会存储数据的相关描述和记录存放的位置（队列）。它会对描述信息也就是元数据信息就行同步，如果消费者在broker-2中进行消费，发现自己几点没有对应的消息，可以从对应的元数据信息中去查询，然后返回对应的消息信息，场景：比如买火车票或者黄牛买演唱会门票，比如第一个黄牛有顾客说要买的演唱会门票，但是没有但是他会去联系其他的黄牛询问，如果有就返回。</p>
<p><img src="https://img-blog.csdnimg.cn/dbcb3f8c9cf0464a8eadb3f3f34bd447.png#pic_center" alt="请添加图片描述"></p>
<h3 id="5、Master-slave与Breoker-cluster组合的方案">5、Master-slave与Breoker-cluster组合的方案</h3>
<p>​	实现多主多从的热备机制来完成消息的高可用以及数据的热备机制，在生产规模达到一定的阶段的时候，这种使用的频率比较高。</p>
<p><img src="https://img-blog.csdnimg.cn/1a2f62cc3d6f47f38bf09c7a1acac367.png#pic_center" alt="请添加图片描述"></p>
<h2 id="2、集群搭建">2、集群搭建</h2>
<h3 id="1、概述-v7">1、概述</h3>
<blockquote>
<p>RabbitMQ这款消息队列中间件产品本身是基于Erlang编写，Erlang语言天生具备分布式特性（通过同步Erlang集群各节点的magic cookie来实现）。因此，RabbitMQ天然支持Clustering。这使得RabbitMQ本身不需要像ActiveMQ、Kafka那样通过ZooKeeper分别来实现HA方案和保存集群的元数据。集群是保证可靠性的一种方式，同时可以通过水平扩展以达到增加消息吞吐量能力的目的。<br>
官网参考：<a href="https://www.rabbitmq.com/clustering.html" target="_blank" rel="noopener">https://www.rabbitmq.com/clustering.html</a></p>
</blockquote>
<h3 id="2、环境准备">2、环境准备</h3>
<p>​	保证RabbitMQ是可执行的，并把单机版的RabbitMQ服务停止，后台看不到RabbitMQ的进程为止。这里我在一台主机发布多个RabbitMQ，用的是 Master-slave主从共享数据模式。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看进程</span></span><br><span class="line">ps aux|grep rabbitmq</span><br><span class="line">systemctl status rabbitmq-server</span><br></pre></td></tr></table></figure>
<h3 id="3、单机多实例搭建">3、单机多实例搭建</h3>
<p>​	<strong>分别启动两个节点</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo RABBITMQ_NODE_PORT=5672 RABBITMQ_NODENAME=rabbit-1 rabbitmq-server start &amp;</span><br><span class="line">RABBITMQ_NODE_PORT=5672 RABBITMQ_NODENAME=rabbit-1 rabbitmq-server -detached</span><br><span class="line"><span class="comment">#web管理插件端口占用,所以还要指定其web插件占用的端口号</span></span><br><span class="line">sudo RABBITMQ_NODE_PORT=5673 RABBITMQ_SERVER_START_ARGS=<span class="string">"-rabbitmq_management listener [&#123;port,15673&#125;]"</span> RABBITMQ_NODENAME=rabbit-2 rabbitmq-server start &amp;</span><br><span class="line">RABBITMQ_NODE_PORT=5673 RABBITMQ_SERVER_START_ARGS=<span class="string">"-rabbitmq_management listener [&#123;port,15673&#125;]"</span> RABBITMQ_NODENAME=rabbit-2 rabbitmq-server -detached</span><br><span class="line"><span class="comment">#验证是否启动</span></span><br><span class="line">ps aux|grep rabbitmq</span><br></pre></td></tr></table></figure>
<p>​	<strong>rabbit-1操作作为主节点</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#停止应用</span></span><br><span class="line">sudo rabbitmqctl -n rabbit-1 stop_app</span><br><span class="line"><span class="comment">#目的是清除节点上的历史数据（如果不清除，无法将节点加入到集群）</span></span><br><span class="line">sudo rabbitmqctl -n rabbit-1 reset</span><br><span class="line"><span class="comment">#启动应用</span></span><br><span class="line">sudo rabbitmqctl -n rabbit-1 start_app</span><br></pre></td></tr></table></figure>
<p>​	<strong>rabbit2操作为从节点</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 停止应用</span></span><br><span class="line">sudo rabbitmqctl -n rabbit-2 stop_app</span><br><span class="line"><span class="comment"># 目的是清除节点上的历史数据（如果不清除，无法将节点加入到集群）</span></span><br><span class="line">sudo rabbitmqctl -n rabbit-2 reset</span><br><span class="line"><span class="comment"># 将rabbit2节点加入到rabbit1（主节点）集群当中(Server-node服务器的主机名,需要根据自己情况替换)</span></span><br><span class="line">sudo rabbitmqctl -n rabbit-2 join_cluster rabbit-1@Server-node</span><br><span class="line">rabbitmqctl -n rabbit-2 forget_cluster_node rabbit-1@Server-node</span><br><span class="line"><span class="comment"># 启动应用</span></span><br><span class="line">sudo rabbitmqctl -n rabbit-2 start_app</span><br></pre></td></tr></table></figure>
<p>​	<strong>验证集群状态</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo rabbitmqctl cluster_status -n rabbit-1</span><br><span class="line"><span class="comment">#设置web界面</span></span><br><span class="line">rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_management</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/1e7c5e38450645d4a49b37515e1e05cd.png#pic_center" alt="请添加图片描述"></p>
<h3 id="4、其他-v2">4、其他</h3>
<p>​	如果采用多机部署方式，需读取其中一个节点的cookie, 并复制到其他节点（节点之间通过cookie确定相互是否可通信）。cookie存放在<code>/var/lib/rabbitmq/.erlang.cookie</code>。<br>
​	例如：主机名分别为rabbit-1、rabbit-2<br>
​	1、逐个启动各节点<br>
​	2、配置各节点的hosts文件( vim /etc/hosts)或者加入主节点的时候采用ip<br>
​	 ip1：rabbit-1<br>
​	 ip2：rabbit-2<br>
​	其它步骤雷同单机部署方式，另外对于集群来说，springboot的yml配置需要更改为集群模式连接</p>
<h2 id="3、下单配送分布式高可用实战">3、下单配送分布式高可用实战</h2>
<p><img src="https://img-blog.csdnimg.cn/d6e6e8bd751e42209d24d4ecb955527d.png#pic_center" alt="请添加图片描述"></p>
<h2 id="4、其他配置详解">4、其他配置详解</h2>
<h3 id="1、application-yml详解">1、application.yml详解</h3>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">rabbitmq:</span></span><br><span class="line">  <span class="attr">addresses:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6605,127.0.0.1:6606,127.0.0.1:6705</span> <span class="comment">#指定client连接到的server的地址，多个以逗号分隔(优先取addresses，然后再取host)</span></span><br><span class="line">  <span class="comment">#    port:</span></span><br><span class="line">  <span class="comment">##集群配置 addresses之间用逗号隔开</span></span><br><span class="line">  <span class="comment"># addresses: ip:port,ip:port</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">admin</span></span><br><span class="line">  <span class="attr">username:</span> <span class="number">123456</span></span><br><span class="line">  <span class="attr">virtual-host:</span> <span class="string">/</span> <span class="comment"># 连接到rabbitMQ的vhost</span></span><br><span class="line">  <span class="attr">requested-heartbeat:</span> <span class="comment">#指定心跳超时，单位秒，0为不指定；默认60s</span></span><br><span class="line">  <span class="attr">publisher-confirms:</span> <span class="comment">#是否启用 发布确认</span></span><br><span class="line">  <span class="attr">publisher-reurns:</span> <span class="comment"># 是否启用发布返回</span></span><br><span class="line">  <span class="attr">connection-timeout:</span> <span class="comment">#连接超时，单位毫秒，0表示无穷大，不超时</span></span><br><span class="line">  <span class="attr">cache:</span></span><br><span class="line">    <span class="attr">channel.size:</span> <span class="comment"># 缓存中保持的channel数量</span></span><br><span class="line">    <span class="attr">channel.checkout-timeout:</span> <span class="comment"># 当缓存数量被设置时，从缓存中获取一个channel的超时时间，单位毫秒；如果为0，则总是创建一个新channel</span></span><br><span class="line">    <span class="attr">connection.size:</span> <span class="comment"># 缓存的连接数，只有是CONNECTION模式时生效</span></span><br><span class="line">    <span class="attr">connection.mode:</span> <span class="comment"># 连接工厂缓存模式：CHANNEL 和 CONNECTION</span></span><br><span class="line">  <span class="attr">listener:</span></span><br><span class="line">    <span class="attr">simple.auto-startup:</span> <span class="comment"># 是否启动时自动启动容器</span></span><br><span class="line">    <span class="attr">simple.acknowledge-mode:</span> <span class="comment"># 表示消息确认方式，其有三种配置方式，分别是none、manual和auto；默认auto</span></span><br><span class="line">    <span class="attr">simple.concurrency:</span> <span class="comment"># 最小的消费者数量</span></span><br><span class="line">    <span class="attr">simple.max-concurrency:</span> <span class="comment"># 最大的消费者数量</span></span><br><span class="line">    <span class="attr">simple.prefetch:</span> <span class="comment"># 指定一个请求能处理多少个消息，如果有事务的话，必须大于等于transaction数量.</span></span><br><span class="line">    <span class="attr">simple.transaction-size:</span> <span class="comment"># 指定一个事务处理的消息数量，最好是小于等于prefetch的数量.</span></span><br><span class="line">    <span class="attr">simple.default-requeue-rejected:</span> <span class="comment"># 决定被拒绝的消息是否重新入队；默认是true（与参数acknowledge-mode有关系）</span></span><br><span class="line">    <span class="attr">simple.idle-event-interval:</span> <span class="comment"># 多少长时间发布空闲容器时间，单位毫秒</span></span><br><span class="line">    <span class="attr">simple.retry.enabled:</span> <span class="comment"># 监听重试是否可用</span></span><br><span class="line">    <span class="attr">simple.retry.max-attempts:</span> <span class="comment"># 最大重试次数</span></span><br><span class="line">    <span class="attr">simple.retry.initial-interval:</span> <span class="comment"># 第一次和第二次尝试发布或传递消息之间的间隔</span></span><br><span class="line">    <span class="attr">simple.retry.multiplier:</span> <span class="comment"># 应用于上一重试间隔的乘数</span></span><br><span class="line">    <span class="attr">simple.retry.max-interval:</span> <span class="comment"># 最大重试时间间隔</span></span><br><span class="line">    <span class="attr">simple.retry.stateless:</span> <span class="comment"># 重试是有状态or无状态</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">mandatory:</span> <span class="comment"># 启用强制信息；默认false</span></span><br><span class="line">    <span class="attr">receive-timeout:</span> <span class="comment"># receive() 操作的超时时间</span></span><br><span class="line">    <span class="attr">reply-timeout:</span> <span class="comment"># sendAndReceive() 操作的超时时间</span></span><br><span class="line">    <span class="attr">retry.enabled:</span> <span class="comment"># 发送重试是否可用</span></span><br><span class="line">    <span class="attr">retry.max-attempts:</span> <span class="comment"># 最大重试次数</span></span><br><span class="line">    <span class="attr">retry.initial-interval:</span> <span class="comment"># 第一次和第二次尝试发布或传递消息之间的间隔</span></span><br><span class="line">    <span class="attr">retry.multiplier:</span> <span class="comment"># 应用于上一重试间隔的乘数</span></span><br><span class="line">    <span class="attr">retry.max-interval:</span> <span class="comment">#最大重试时间间隔</span></span><br></pre></td></tr></table></figure>
<p>对于发送方而言，需要做以下配置：</p>
<ul>
<li>
<p>配置CachingConnectionFactory</p>
</li>
<li>
<p>配置Exchange/Queue/Binding</p>
</li>
<li>
<p>配置RabbitAdmin创建上一步的Exchange/Queue/Binding</p>
</li>
<li>
<p>配置RabbitTemplate用于发送消息，RabbitTemplate通过CachingConnectionFactory获取到Connection，然后想指定Exchange发送</p>
</li>
</ul>
<p>对于消费方而言，需要做以下配置：</p>
<ul>
<li>配置CachingConnectionFactory</li>
<li>配置Exchange/Queue/Binding</li>
<li>配置RabbitAdmin创建上一步的Exchange/Queue/Binding</li>
<li>配置RabbitListenerContainerFactory</li>
<li>配置<a href="https://github.com/RabbitListener" target="_blank" rel="noopener">@RabbitListener</a>/<a href="https://github.com/RabbitHandler" target="_blank" rel="noopener">@RabbitHandler</a>用于接收消息</li>
</ul>
<p><strong>默认情况下主要的配置</strong></p>
<p><img src="https://img-blog.csdnimg.cn/2cf8c010ac6a4292aa7d83068b5e0fa8.png#pic_center" alt="请添加图片描述"></p>
<p><strong>Spring AMQP的主要对象</strong></p>
<p><img src="https://img-blog.csdnimg.cn/e49acb62ac5e4d68867b20c962dde14b.png#pic_center" alt="请添加图片描述"></p>
<h3 id="2、通过java-bean方式配置">2、通过java bean方式配置</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.AcknowledgeMode;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Binding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.BindingBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.DirectExchange;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.TopicExchange;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.config.SimpleRabbitListenerContainerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.connection.CachingConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.connection.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitAdmin;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.listener.RabbitListenerContainerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.support.converter.Jackson2JsonMessageConverter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(RabbitConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String RECEIVEDLXEXCHANGE=<span class="string">"spring-ex"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String RECEIVEDLXQUEUE=<span class="string">"spring-qu1"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String RECEIVEDLXROUTINGKEY=<span class="string">"aa"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DIRECTEXCHANGE=<span class="string">"spring-ex"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String MDMQUEUE=<span class="string">"mdmQueue"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TOPICEXCHANGE=<span class="string">"spring-top"</span>;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;spring.rabbitmq.addresses&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String hosts;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;spring.rabbitmq.username&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;spring.rabbitmq.password&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;spring.rabbitmq.virtual-host&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String virtualHost;</span><br><span class="line"> <span class="comment">/*   @Value("$&#123;rabbit.channelCacheSize&#125;")</span></span><br><span class="line"><span class="comment">    private int channelCacheSize;*/</span></span><br><span class="line"><span class="comment">//    @Value("$&#123;rabbit.port&#125;")</span></span><br><span class="line"><span class="comment">//    private int port;</span></span><br><span class="line"><span class="comment">/*    @Autowired</span></span><br><span class="line"><span class="comment">    private ConfirmCallBackListener confirmCallBackListener;</span></span><br><span class="line"><span class="comment">    @Autowired</span></span><br><span class="line"><span class="comment">    private ReturnCallBackListener returnCallBackListener;*/</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConnectionFactory <span class="title">connectionFactory</span><span class="params">()</span></span>&#123;</span><br><span class="line">        CachingConnectionFactory cachingConnectionFactory = <span class="keyword">new</span> CachingConnectionFactory();</span><br><span class="line">        cachingConnectionFactory.setAddresses(hosts);</span><br><span class="line">        cachingConnectionFactory.setUsername(userName);</span><br><span class="line">        cachingConnectionFactory.setPassword(password);</span><br><span class="line"><span class="comment">//        cachingConnectionFactory.setChannelCacheSize(channelCacheSize);</span></span><br><span class="line">        <span class="comment">//cachingConnectionFactory.setPort(port);</span></span><br><span class="line">        cachingConnectionFactory.setVirtualHost(virtualHost);</span><br><span class="line">        <span class="comment">//设置连接工厂缓存模式：</span></span><br><span class="line">        cachingConnectionFactory.setCacheMode(CachingConnectionFactory.CacheMode.CONNECTION);</span><br><span class="line">        <span class="comment">//缓存连接数</span></span><br><span class="line">        cachingConnectionFactory.setConnectionCacheSize(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//设置连接限制</span></span><br><span class="line">        cachingConnectionFactory.setConnectionLimit(<span class="number">6</span>);</span><br><span class="line">        logger.info(<span class="string">"连接工厂设置完成，连接地址&#123;&#125;"</span>+hosts);</span><br><span class="line">        logger.info(<span class="string">"连接工厂设置完成，连接用户&#123;&#125;"</span>+userName);</span><br><span class="line">        <span class="keyword">return</span> cachingConnectionFactory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RabbitAdmin <span class="title">rabbitAdmin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        RabbitAdmin rabbitAdmin = <span class="keyword">new</span> RabbitAdmin(connectionFactory());</span><br><span class="line">        rabbitAdmin.setAutoStartup(<span class="keyword">true</span>);</span><br><span class="line">        rabbitAdmin.setIgnoreDeclarationExceptions(<span class="keyword">true</span>);</span><br><span class="line">        rabbitAdmin.declareBinding(bindingMdmQueue());</span><br><span class="line">        <span class="comment">//声明topic交换器</span></span><br><span class="line">        rabbitAdmin.declareExchange(directExchange());</span><br><span class="line">        logger.info(<span class="string">"管理员设置完成"</span>);</span><br><span class="line">        <span class="keyword">return</span> rabbitAdmin;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RabbitListenerContainerFactory <span class="title">listenerContainerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SimpleRabbitListenerContainerFactory factory = <span class="keyword">new</span> SimpleRabbitListenerContainerFactory();</span><br><span class="line">        factory.setConnectionFactory(connectionFactory());</span><br><span class="line">        factory.setMessageConverter(<span class="keyword">new</span> Jackson2JsonMessageConverter());</span><br><span class="line">        <span class="comment">//最小消费者数量</span></span><br><span class="line">        factory.setConcurrentConsumers(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//最大消费者数量</span></span><br><span class="line">        factory.setMaxConcurrentConsumers(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//一个请求最大处理的消息数量</span></span><br><span class="line">        factory.setPrefetchCount(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        factory.setChannelTransacted(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//默认不排队</span></span><br><span class="line">        factory.setDefaultRequeueRejected(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//手动确认接收到了消息</span></span><br><span class="line">        factory.setAcknowledgeMode(AcknowledgeMode.MANUAL);</span><br><span class="line">        logger.info(<span class="string">"监听者设置完成"</span>);</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DirectExchange <span class="title">directExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(DIRECTEXCHANGE,<span class="keyword">true</span>,<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">mdmQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Map arguments = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 绑定该队列到私信交换机</span></span><br><span class="line">        arguments.put(<span class="string">"x-dead-letter-exchange"</span>,RECEIVEDLXEXCHANGE);</span><br><span class="line">        arguments.put(<span class="string">"x-dead-letter-routing-key"</span>,RECEIVEDLXROUTINGKEY);</span><br><span class="line">        logger.info(<span class="string">"队列交换机绑定完成"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(RECEIVEDLXQUEUE,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,arguments);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Binding <span class="title">bindingMdmQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(mdmQueue()).to(directExchange()).with(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RabbitTemplate <span class="title">rabbitTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        RabbitTemplate rabbitTemplate = <span class="keyword">new</span> RabbitTemplate(connectionFactory());</span><br><span class="line">        rabbitTemplate.setMandatory(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//发布确认</span></span><br><span class="line"><span class="comment">//        rabbitTemplate.setConfirmCallback(confirmCallBackListener);</span></span><br><span class="line">        <span class="comment">// 启用发布返回</span></span><br><span class="line"><span class="comment">//        rabbitTemplate.setReturnCallback(returnCallBackListener);</span></span><br><span class="line">        logger.info(<span class="string">"连接模板设置完成"</span>);</span><br><span class="line">        <span class="keyword">return</span> rabbitTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/*  @Bean</span></span><br><span class="line"><span class="comment">    public TopicExchange topicExchange()&#123;</span></span><br><span class="line"><span class="comment">        return new TopicExchange(TOPICEXCHANGE,true,false);</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> DirectExchange</span></span><br><span class="line"><span class="comment">     */</span><span class="comment">/*</span></span><br><span class="line"><span class="comment">    @Bean</span></span><br><span class="line"><span class="comment">    public DirectExchange dlxExchange() &#123;</span></span><br><span class="line"><span class="comment">        return new DirectExchange(RECEIVEDLXEXCHANGE,true,false);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">/*</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">     * @return Queue</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">/*</span></span><br><span class="line"><span class="comment">    @Bean</span></span><br><span class="line"><span class="comment">    public Queue dlxQueue() &#123;</span></span><br><span class="line"><span class="comment">        return new Queue(RECEIVEDLXQUEUE,true);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">/*</span></span><br><span class="line"><span class="comment">     * @return Binding</span></span><br><span class="line"><span class="comment">     */</span><span class="comment">/*</span></span><br><span class="line"><span class="comment">    @Bean</span></span><br><span class="line"><span class="comment">    public Binding binding() &#123;</span></span><br><span class="line"><span class="comment">        return BindingBuilder.bind(dlxQueue()).to(dlxExchange()).with(RECEIVEDLXROUTINGKEY);</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言回调函数与日志系统</title>
    <url>/posts/89470054.html</url>
    <content><![CDATA[<h1>一、C语言回调函数</h1>
<h2 id="1、回调函数概念">1、回调函数概念</h2>
<p>​	回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/e66d68f96431c515096148dd98a06363.png#pic_center" alt="回调函数"></p>
<a id="more"></a>	
<p>简单点来说，就是主函数 <code>Main program</code> 调用函数 <code>Library function</code> 的时候，函数<code>Main program</code> 通过参数给函数 <code>Library function</code>传递了另外一个函数<code>Callback function</code> 的指针。在函数 <code>Library function</code> 执行的过程中，函数<code>Library function</code> 调用了函数<code>Callback function</code>，这个动作就叫做回调（Callback），而先被当做指针传入、后面又被回调的函数<code>Callback function</code>就是回调函数。</p>
<h2 id="2、回调函数的作用">2、回调函数的作用</h2>
<p>​	回调似乎只是函数间的调用，和普通函数调用没啥区别，但仔细一看，可以发现两者之间的一个关键的不同：在回调中，主程序把回调函数像参数一样传入库函数。这样一来，只要我们改变传进库函数的参数，就可以实现不同的功能，并且丝毫不需要修改库函数的实现，实现解耦。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;softwareLib.h&gt; // 包含Library Function所在读得Software library库的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Callback Function</span></span><br><span class="line"><span class="comment">// 只需要编写需要的回调函数即可</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Callback</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> <span class="comment">// Main program</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">    Library(Callback);</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3、回调函数的简单使用">3、回调函数的简单使用</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Callback_1</span><span class="params">()</span> <span class="comment">// Callback Function 1</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello, this is Callback_1 "</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Callback_2</span><span class="params">()</span> <span class="comment">// Callback Function 2</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello, this is Callback_2 "</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//形参是回调函数的指针，返回值是回调函数的返回值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Handle</span><span class="params">(<span class="keyword">int</span> (*Callback)())</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Entering Handle Function. \n"</span>);</span><br><span class="line">    <span class="comment">//运行回调函数</span></span><br><span class="line">    Callback();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Leaving Handle Function. \n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Entering Main Function. \n"</span>);</span><br><span class="line">    Handle(Callback_1);</span><br><span class="line">    Handle(Callback_2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Leaving Main Function. \n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4、回调函数进阶版">4、回调函数进阶版</h2>
<p>​	四则运算的简单回调函数.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************</span></span><br><span class="line"><span class="comment"> * 函数指针结构体，定义四个函数指针分别指向这四个函数</span></span><br><span class="line"><span class="comment"> ***************************************/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OP</span> &#123;</span></span><br><span class="line">    <span class="keyword">float</span> (*p_add)(<span class="keyword">float</span>, <span class="keyword">float</span>); </span><br><span class="line">    <span class="keyword">float</span> (*p_sub)(<span class="keyword">float</span>, <span class="keyword">float</span>); </span><br><span class="line">    <span class="keyword">float</span> (*p_mul)(<span class="keyword">float</span>, <span class="keyword">float</span>); </span><br><span class="line">    <span class="keyword">float</span> (*p_div)(<span class="keyword">float</span>, <span class="keyword">float</span>); </span><br><span class="line">&#125; OP; </span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************</span></span><br><span class="line"><span class="comment"> * 加减乘除函数</span></span><br><span class="line"><span class="comment"> ***************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">ADD</span><span class="params">(<span class="keyword">float</span> a, <span class="keyword">float</span> b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">SUB</span><span class="params">(<span class="keyword">float</span> a, <span class="keyword">float</span> b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">MUL</span><span class="params">(<span class="keyword">float</span> a, <span class="keyword">float</span> b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">DIV</span><span class="params">(<span class="keyword">float</span> a, <span class="keyword">float</span> b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************</span></span><br><span class="line"><span class="comment"> * 初始化函数指针</span></span><br><span class="line"><span class="comment"> ***************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_op</span><span class="params">(OP *op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    op-&gt;p_add = ADD;</span><br><span class="line">    op-&gt;p_sub = SUB;</span><br><span class="line">    op-&gt;p_mul = &amp;MUL;</span><br><span class="line">    op-&gt;p_div = &amp;DIV;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************</span></span><br><span class="line"><span class="comment"> * 当做库函数，以函数指针为参数，通过它来调用不同的函数</span></span><br><span class="line"><span class="comment"> ***************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">add_sub_mul_div</span><span class="params">(<span class="keyword">float</span> a, <span class="keyword">float</span> b, <span class="keyword">float</span> (*op_func)(<span class="keyword">float</span>, <span class="keyword">float</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (*op_func)(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    OP *op = (OP *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(OP)); </span><br><span class="line">    init_op(op);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 直接使用函数指针调用函数 */</span> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ADD = %f, SUB = %f, MUL = %f, DIV = %f\n"</span>, (op-&gt;p_add)(<span class="number">1.3</span>, <span class="number">2.2</span>), (*op-&gt;p_sub)(<span class="number">1.3</span>, <span class="number">2.2</span>), </span><br><span class="line">            (op-&gt;p_mul)(<span class="number">1.3</span>, <span class="number">2.2</span>), (*op-&gt;p_div)(<span class="number">1.3</span>, <span class="number">2.2</span>));</span><br><span class="line">     </span><br><span class="line">    <span class="comment">/* 调用回调函数 */</span> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ADD = %f, SUB = %f, MUL = %f, DIV = %f\n"</span>, </span><br><span class="line">            add_sub_mul_div(<span class="number">1.3</span>, <span class="number">2.2</span>, ADD), </span><br><span class="line">            add_sub_mul_div(<span class="number">1.3</span>, <span class="number">2.2</span>, SUB), </span><br><span class="line">            add_sub_mul_div(<span class="number">1.3</span>, <span class="number">2.2</span>, MUL), </span><br><span class="line">            add_sub_mul_div(<span class="number">1.3</span>, <span class="number">2.2</span>, DIV));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>二、C语言简单日志系统</h1>
<blockquote>
<p>简答的不同等级日志打印底层，可以控制日志输出，打印出具体的行号，函数名等，可以用来当做参考，和spring的日志系统有点像</p>
</blockquote>
<p>​	新建<code>log.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _EM_LOG_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _EM_LOG_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OPEN_LOG 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_LEVEL LOG_DEBUG </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_SAVE 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span></span><br><span class="line">&#123; </span><br><span class="line">	LOG_DEBUG=<span class="number">0</span>, </span><br><span class="line">	LOG_INFO, </span><br><span class="line">	LOG_WARN, </span><br><span class="line">	LOG_ERROR,</span><br><span class="line">&#125;E_LOGLEVEL; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EM_LOG</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> level, <span class="keyword">const</span> <span class="keyword">char</span> *fun, <span class="keyword">const</span> <span class="keyword">int</span> <span class="built_in">line</span>, <span class="keyword">const</span> <span class="keyword">char</span> *fmt,...)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EMLOG(level,fmt...) EM_LOG(level,__FUNCTION__,__LINE__,fmt)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>​	新建<code>log.c</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"log.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义不同等级的日志级别</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">EM_LOGLevelGet</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(level==LOG_DEBUG)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"DEBUG"</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span>(level==LOG_INFO)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"INFO"</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span>(level ==LOG_WARN)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"LOG_WARN"</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span>(level ==LOG_ERROR)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"LOG_ERROR"</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">"UNKNOW"</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 日志输出，可以定位行号、方法名</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EM_LOG</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> level, <span class="keyword">const</span> <span class="keyword">char</span> *fun, <span class="keyword">const</span> <span class="keyword">int</span> <span class="built_in">line</span>, <span class="keyword">const</span> <span class="keyword">char</span> *fmt,...)</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">ifdef</span> OPEN_LOG </span></span><br><span class="line">	va_list arg; </span><br><span class="line">	va_start(arg, fmt); </span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">1</span>+vsnprintf(<span class="literal">NULL</span>,<span class="number">0</span>, fmt, arg)]; </span><br><span class="line">	vsnprintf(buf,<span class="keyword">sizeof</span>(buf), fmt, arg); </span><br><span class="line">	va_end(arg); </span><br><span class="line">	<span class="keyword">if</span>(level&gt;=LOG_LEVEL)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"[%s] [%s %d] %s\n"</span>,EM_LOGLevelGet(level),fun,<span class="built_in">line</span>,buf);</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a=<span class="number">10</span>,b=<span class="number">11</span>; </span><br><span class="line">	EMLOG(LOG_DEBUG,<span class="string">"app start"</span>); </span><br><span class="line">	EMLOG(LOG_INFO,<span class="string">"A=%d %d"</span>,a,b); </span><br><span class="line">	EMLOG(LOG_WARN,<span class="string">"app LOG_WARN"</span>); </span><br><span class="line">	EMLOG(LOG_ERROR,<span class="string">"app LOG_ERROR"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>参考文章:</p>
<p><a href="https://www.runoob.com/w3cnote/c-callback-function.html" target="_blank" rel="noopener">https://www.runoob.com/w3cnote/c-callback-function.html</a></p>
<p><a href="https://segmentfault.com/a/1190000008293902" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008293902</a></p>
<p><a href="https://www.bilibili.com/video/BV1EB4y1N7iD" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1EB4y1N7iD</a></p>
]]></content>
      <categories>
        <category>C&amp;C++</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>mysqlbinlog简单入门实践</title>
    <url>/posts/78413d01.html</url>
    <content><![CDATA[<h1>一、概述</h1>
<p>​	删库跑路这个词大家看到不会陌生，那万一发生在自己身上怎么办？直接跑？那肯定是不现实的，其实这里有种方法可以恢复误删除的数据，使用binlog可以很轻松的查看你之前的操作，当然前提是打开了这个功能，而且使用了<code>mysqlbinlog </code>，因为 binlog 文件是二进制的。</p>
<p>​	这里也简单记录一下防止自己以后手贱误删操作。</p>
<p>​	环境准备：MySql8.0，navicate15</p>
<a id="more"></a>
<h1>二、binlog日志</h1>
<h2 id="1、binlog介绍与配置">1、binlog介绍与配置</h2>
<p>​	<code>binlog</code> 即 <code>Binary Log</code>，它是二进制文件，用来记录数据库写操作的日志。数据库的 insert、delete、update、create、alter、drop 等写入操作都会被 binlog 记录。因此，数据库的主从数据同步通常也是基于 binlog 完成的。</p>
<p>​	一般情况下，<code>binlog</code>是默认开启的，可以通过脚本查看 binlog 是否开启，也可以查看文件存放地址。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#39;LOG_BIN%&#39;;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/image-20210929204012919.png" alt="image-20210929204012919"></p>
<p>​	如果<code>log_bin</code>参数显示的是<code>OFF</code>说明 binlog 是关闭状态，需要手动开启。开启 binlog 需要修改数据库的<code>my.cnf</code>配置文件，my.cnf文件通常在服务器的<code>/etc</code>目录下。binlog 的日志有三种格式，分别是 STATEMENT、ROW、MIXED。在 mysql5.7.7 版本之前默认使用的是 STATEMENT，之后的版本默认使用的是 ROW。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启用binlog并设置binlog日志的存储目录</span></span><br><span class="line"><span class="string">log_bin</span> <span class="string">=</span> <span class="string">/www/server/data/mysql-bin</span></span><br><span class="line"><span class="comment"># 设置binlog索引存储目录</span></span><br><span class="line"><span class="string">log_bin_index</span> <span class="string">=</span> <span class="string">/www/server/data/mysql-bin.index</span></span><br><span class="line"><span class="comment"># 30天之前的日志自动删除</span></span><br><span class="line"><span class="string">expire_logs_days</span> <span class="string">=</span> <span class="number">30</span></span><br><span class="line"><span class="comment"># 设置binlog日志模式，共有3种模式：STATMENT、ROW、MIXED </span></span><br><span class="line"><span class="string">binlog_format</span> <span class="string">=</span> <span class="string">row</span></span><br></pre></td></tr></table></figure>
<h2 id="2、binlog三种日志格式">2、binlog三种日志格式</h2>
<ul>
<li>
<p><strong>ROW</strong></p>
<p>binlog 记录的是每一条数据被修改的详细细节。它记录了每条数据修改细节，所以在一些极端情况下也不会出现数据错乱的问题，其中记录的是伪SQL，需要去除注释才能运行。在做数据恢复或主从同步时能很好的保证数据的真实性和一致性，但是磁盘占用会大。</p>
</li>
<li>
<p><strong>STATMENT</strong></p>
<p>日志中记录的是真正的 sql 语句，可以直接拿到数据库运行。因为记录的是 sql 语句和执行语句时的上下文环境，而不是每一条数据。所以它的日志文件会比 ROW 格式的日志文件小一些。但由于记录的只是 sql 语句和上下文的环境，STATEMENT 格式的日志在进行主从数据同步时会有一些不可预估的情况出现，导致数据错乱。比如 sleep()、last_insert_id() 等函数会出现问题。</p>
</li>
<li>
<p><strong>MIXED</strong></p>
<p>MIXED 格式是 STATEMENT 和 ROW 的结合，mysql 会根据具体执行的 sql 语句，来选择合适的日志格式进行记录。MIXED 格式下，在执行普通的 sql 语句时会选 STATEMENT 来记录日志，在遇到复杂的语句或函数操作时会选择 ROW 来记录日志。</p>
</li>
</ul>
<h2 id="3、MySql常用查询">3、MySql常用查询</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#查看数据库时间</span><br><span class="line">SELECT @@log_timestamps;</span><br><span class="line">#查看当前使用的二进制日志</span><br><span class="line">show master status</span><br><span class="line">#查看二进制日志格式</span><br><span class="line">show VARIABLES like &#39;binlog_format&#39;</span><br><span class="line">#查看某个日志中的事件</span><br><span class="line">show binlog events in &#39;mysql-bin.000001&#39;;</span><br><span class="line">#查看某个日志中的事件，从5446开始</span><br><span class="line">show binlog events in &#39;mysql-bin.000001&#39; from 5446 limit 10;</span><br><span class="line">#手动滚动一下二进制日志</span><br><span class="line">flush logs;</span><br><span class="line">#清空日志</span><br><span class="line">reset master;</span><br></pre></td></tr></table></figure>
<h2 id="4、mysqlbinlog命令介绍">4、mysqlbinlog命令介绍</h2>
<p>​	mysql 数据库的 binlog 文件是二进制的，基本看不懂，使用数据库自带的<code>mysqlbinlog</code>命令可以把二进制文件转换成能看懂的十进制文件。由于数据库的 binlog 文件可能会很大，查看起来会很麻烦，所以<code>mysqlbinlog</code>命令也提供了一些参数可以用来筛选日志。</p>
<p><strong>「mysqlbinlog 语法」</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#options：可选参数 </span></span><br><span class="line"><span class="comment">#log-files：文件名称</span></span><br><span class="line">mysqlbinlog [options] <span class="built_in">log</span>-files</span><br></pre></td></tr></table></figure>
<p><strong>「options 的常用值」</strong></p>
<p><code>-d</code>: 根据数据库的名称筛选日志</p>
<p><code>-o</code>：跳过前N行日志</p>
<p><code>-r, --result-fil</code>: 把日志输出到指定文件</p>
<p><code>--start-datetime</code>: 读取指定时间之后的日志，时间格式：yyyy-MM-dd HH:mm:ss</p>
<p><code>--stop-datetime</code>: 读取指定时间之前的日志，时间格式：yyyy-MM-dd HH:mm:ss</p>
<p><code>--start-position</code>: 从指定位置开始读取日志</p>
<p><code>--stop-position</code>: 读取到指定位置停止</p>
<p><code>--base64-output</code>：在 row 格式下，显示伪 sql 语句</p>
<p><code>-v, --verbose</code>：显示伪 sql 语句，-v 可以为 sql 语句添加备注</p>
<p><strong>「常用写法」</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看 test 数据库的日志</span></span><br><span class="line">mysqlbinlog -d=<span class="built_in">test</span> mysql-bin.000001</span><br><span class="line"><span class="comment">#查看某个时间段内的日志，并解析输出</span></span><br><span class="line">mysqlbinlog -v --start-datetime <span class="string">"2021-10-09 19:30:00"</span> --stop-datetime <span class="string">"2021-10-09 20:50:00"</span> mysql-bin.000001 &gt; temp.log</span><br><span class="line"><span class="comment">#恢复数据，事件的开始位置是 4300，结束位置是 10345</span></span><br><span class="line">mysqlbinlog --start-position 4300 --stop-position 10345 mysql-bin.000001 | mysql -uroot -p123456 <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<h1>三、实践操作</h1>
<h2 id="1、数据生成与环境准备">1、数据生成与环境准备</h2>
<p>​	首先<code>flush logs;</code>手动生成一个新的二进制文件，之后新建数据库与存储过程用于生产数据，这里我开启了bin-log已经我的格式是row格式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#新建数据库</span><br><span class="line">DROP TABLE IF EXISTS &#96;test_user&#96;;</span><br><span class="line">CREATE TABLE &#96;test_user&#96;  (</span><br><span class="line">  &#96;id&#96; bigint(0) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;username&#96; varchar(11) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,</span><br><span class="line">  &#96;gender&#96; int(0) NULL DEFAULT 0,</span><br><span class="line">  &#96;age&#96; int(0) NULL DEFAULT 0,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;) USING BTREE</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">#新建存储过程用于产生数据</span><br><span class="line">CREATE DEFINER&#x3D;&#96;root&#96;@&#96;%&#96; PROCEDURE &#96;generation&#96;(IN &#96;startNum&#96; int, IN &#96;endNum&#96; int)</span><br><span class="line">BEGIN</span><br><span class="line">	#Routine body goes here...</span><br><span class="line">	while startNum &lt;&#x3D; endNum do   </span><br><span class="line">    insert into test_user(username,gender,age) values(startNum,rand()*2 ,RAND()*100);   </span><br><span class="line">    set startNum&#x3D;startNum+1;  </span><br><span class="line">end while;  </span><br><span class="line">END</span><br></pre></td></tr></table></figure>
<p>​	随机产生1w条数据，并进行删除操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#调用存储过程</span><br><span class="line">CALL generation(1,10000);</span><br><span class="line">#当做误删操作</span><br><span class="line">DELETE FROM test_user WHERE age &gt; 60;</span><br></pre></td></tr></table></figure>
<h2 id="2、数据恢复">2、数据恢复</h2>
<p>找到二进制文件路径，使用<code>mysqlbinlog</code>工具解析，并把它输出到<code>temp.log</code>文件，若文件过大，可以进行简单的过滤。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqlbinlog -v mysql-bin.000001 &gt; temp.log</span><br><span class="line">#查看test数据库的数据</span><br><span class="line">mysqlbinlog -v --start-datetime &quot;2021-10-10 09:00:00&quot; --stop-datetime &quot;2021-10-10 09:50:00&quot; mysql-bin.000001 | grep test</span><br></pre></td></tr></table></figure>
<p>​	最后的文件如图所示，可以查看到每一条语句的具体的操作记录，使用工具替换即可复原数据，sql 执行完以后，被误删除的数据就恢复回来了。</p>
<p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/image-20211010102129943.png" alt="image-20211010102129943"></p>
<h1>四、数据库操作的几点建议</h1>
<ul>
<li>研发人员不能直连生产库</li>
<li>登录生产库使用只读账号</li>
<li>关闭 autocomit、多人复核</li>
<li>修改数据之前先备份</li>
<li>设置数据库定期备份</li>
</ul>
<hr>
<p>参考文章：<br>
<a href="https://mp.weixin.qq.com/s/SOI4Fh3g1DcYi59BcHpIFg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/SOI4Fh3g1DcYi59BcHpIFg</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>ShardingSphere数据库中间件</title>
    <url>/posts/a31fee08.html</url>
    <content><![CDATA[<h1>一、SharingJdbc简介</h1>
<h2 id="1、概述">1、概述</h2>
<blockquote>
<p>官网：<a href="http://shardingsphere.apache.org/index_zh.html" target="_blank" rel="noopener">http://shardingsphere.apache.org/index_zh.html</a></p>
<p>官网概述：<a href="https://shardingsphere.apache.org/document/current/cn/overview/" target="_blank" rel="noopener">https://shardingsphere.apache.org/document/current/cn/overview/</a></p>
</blockquote>
<p>​	Apache ShardingSphere 是一套开源的分布式数据库解决方案组成的生态圈，它由 JDBC、Proxy 和 Sidecar（规划中）这 3 款既能够独立部署，又支持混合部署配合使用的产品组成。 它们均提供标准化的数据水平扩展、分布式事务和分布式治理等功能，可适用于如 Java 同构、异构语言、云原生等各种多样化的应用场景。</p>
<a id="more"></a>
<h2 id="2、Sharding-Jdbc介绍">2、Sharding-Jdbc介绍</h2>
<p>​	shardingjdbc定位为轻量级 Java 框架，在 Java 的 JDBC 层提供的额外服务。 它使用客户端直连数据库，以 jar 包形式提供服务，无需额外部署和依赖，可理解为增强版的 JDBC 驱动，完全兼容 JDBC 和各种 ORM 框架。</p>
<ul>
<li>适用于任何基于 JDBC 的 ORM 框架，如：JPA, Hibernate, Mybatis, Spring JDBC Template 或直接使用 JDBC。</li>
<li>支持任何第三方的数据库连接池，如：DBCP, C3P0, BoneCP, Druid, HikariCP 等。</li>
<li>支持任意实现 JDBC 规范的数据库，目前支持 MySQL，Oracle，SQLServer，PostgreSQL 以及任何遵循 SQL92 标准的数据库。<br>
<img src="https://img-blog.csdnimg.cn/8c9ff02b32a4454ebb4c46ab8552805b.png" alt="请添加图片描述"></li>
</ul>
<h2 id="3、Sharding-Proxy介绍">3、Sharding-Proxy介绍</h2>
<p><img src="https://img-blog.csdnimg.cn/244d8c6dbf934bbcbd136f1e4724ac03.png" alt="请添加图片描述"><br>
定位为透明化的数据库代理端，提供封装了数据库二进制协议的服务端版本，用于完成对异构语言的支持。</p>
<h2 id="4、ShardingSphere-Sidecar（TODO）">4、ShardingSphere-Sidecar（TODO）</h2>
<h2 id="5、三种组件对比">5、三种组件对比</h2>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left"><em>ShardingSphere-JDBC</em></th>
<th style="text-align:left"><em>ShardingSphere-Proxy</em></th>
<th><em>ShardingSphere-Sidecar</em></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">数据库</td>
<td style="text-align:left">任意</td>
<td style="text-align:left">MySQL/PostgreSQL</td>
<td>MySQL/PostgreSQL</td>
</tr>
<tr>
<td style="text-align:left">连接消耗数</td>
<td style="text-align:left">高</td>
<td style="text-align:left">低</td>
<td>高</td>
</tr>
<tr>
<td style="text-align:left">异构语言</td>
<td style="text-align:left">仅 Java</td>
<td style="text-align:left">任意</td>
<td>任意</td>
</tr>
<tr>
<td style="text-align:left">性能</td>
<td style="text-align:left">损耗低</td>
<td style="text-align:left">损耗略高</td>
<td>损耗低</td>
</tr>
<tr>
<td style="text-align:left">无中心化</td>
<td style="text-align:left">是</td>
<td style="text-align:left">否</td>
<td>是</td>
</tr>
<tr>
<td style="text-align:left">静态入口</td>
<td style="text-align:left">无</td>
<td style="text-align:left">有</td>
<td>无</td>
</tr>
</tbody>
</table>
<h2 id="6、ShardingJdbc混合架构">6、ShardingJdbc混合架构</h2>
<p><img src="https://img-blog.csdnimg.cn/9262a25fb8034c209322915522e5d8f2.png" alt="请添加图片描述"><br>
ShardingSphere-JDBC 采用无中心化架构，适用于 Java 开发的高性能的轻量级 OLTP（连接事务处理） 应用；ShardingSphere-Proxy 提供静态入口以及异构语言的支持，适用于 OLAP（连接数据分析） 应用以及对分片数据库进行管理和运维的场景。<br>
Apache ShardingSphere 是多接入端共同组成的生态圈。 通过混合使用 ShardingSphere-JDBC 和 ShardingSphere-Proxy，并采用同一注册中心统一配置分片策略，能够灵活的搭建适用于各种场景的应用系统，使得架构师更加自由地调整适合与当前业务的最佳系统架构。</p>
<h2 id="7、功能列表">7、功能列表</h2>
<p><strong>数据分片</strong></p>
<ul>
<li>分库 &amp; 分表</li>
<li>读写分离</li>
<li>分片策略定制化</li>
<li>无中心化分布式主键</li>
</ul>
<p><strong>分布式事务</strong></p>
<ul>
<li>标准化事务接口</li>
<li>XA 强一致事务</li>
<li>柔性事务</li>
</ul>
<p><strong>数据库治理</strong></p>
<ul>
<li>分布式治理</li>
<li>弹性伸缩</li>
<li>可视化链路追踪</li>
<li>数据加密</li>
</ul>
<h2 id="8、ShardingSphere数据分片内核剖析">8、ShardingSphere数据分片内核剖析</h2>
<p>​	ShardingSphere 的 3 个产品的数据分片主要流程是完全一致的。 核心由 SQL 解析 =&gt; 执行器优化 =&gt; SQL 路由 =&gt; SQL 改写 =&gt; SQL 执行 =&gt; 结果归并的流程组成。</p>
<p><strong>SQL 解析</strong></p>
<p>​	分为词法解析和语法解析。 先通过词法解析器将 SQL 拆分为一个个不可再分的单词。再使用语法解析器对 SQL 进行理解，并最终提炼出解析上下文。 解析上下文包括表、选择项、排序项、分组项、聚合函数、分页信息、查询条件以及可能需要修改的占位符的标记。</p>
<p><strong>执行器优化</strong></p>
<p>​	合并和优化分片条件，如 OR 等。</p>
<p><strong>SQL 路由</strong></p>
<p>​	根据解析上下文匹配用户配置的分片策略，并生成路由路径。目前支持分片路由和广播路由。</p>
<p><strong>SQL 改写</strong></p>
<p>​	将 SQL 改写为在真实数据库中可以正确执行的语句。SQL 改写分为正确性改写和优化改写。</p>
<p><strong>SQL 执行</strong></p>
<p>​	通过多线程执行器异步执行。</p>
<p><strong>结果归并</strong></p>
<p>​	将多个执行结果集归并以便于通过统一的 JDBC 接口输出。结果归并包括流式归并、内存归并和使用装饰者模式的追加归并这几种方式。</p>
<h1>二、MySql主从复制</h1>
<h2 id="1、概述-v2">1、概述</h2>
<blockquote>
<p>主从复制（也称 AB 复制）允许将来自一个MySQL数据库服务器（主服务器）的数据复制到一个或多个MySQL数据库服务器（从服务器）。其中复制是异步的 从站不需要永久连接以接收来自主站的更新。</p>
</blockquote>
<p><strong>优点</strong></p>
<ul>
<li>横向扩展解决方案 - 在多个从站之间分配负载以提高性能。在此环境中，所有写入和更新都必须在主服务器上进行。但是，读取可以在一个或多个从设备上进行。该模型可以提高写入性能（因为主设备专用于更新），同时显着提高了越来越多的从设备的读取速度。</li>
<li>数据安全性 - 因为数据被复制到从站，并且从站可以暂停复制过程，所以可以在从站上运行备份服务而不会破坏相应的主数据。</li>
<li>分析 - 可以在主服务器上创建实时数据，而信息分析可以在从服务器上进行，而不会影响主服务器的性能。</li>
<li>远程数据分发 - 您可以使用复制为远程站点创建数据的本地副本，而无需永久访问主服务器。</li>
</ul>
<p>对于Mysql环境，本次系统使用了Centos8，Mysql版本为8.0</p>
<h2 id="2、主从复制原理">2、主从复制原理</h2>
<p><img src="https://img-blog.csdnimg.cn/b6d32084e41f4e8e9166166ed0007f5e.png" alt="请添加图片描述"><br>
主服务器上面的任何修改都会通过自己的 I/O tread(I/O 线程)保存在二进制日志 Binary log 里面。</p>
<ul>
<li>从服务器上面也启动一个 I/O thread，通过配置好的用户名和密码, 连接到主服务器上面请求读取二进制日志，然后把读取到的二进制日志写到本地的一个Realy log（中继日志）里面。</li>
<li>从服务器上面同时开启一个 SQL thread 定时检查 Realy log(这个文件也是二进制的)，如果发现有更新立即把更新的内容在本机的数据库上面执行一遍。<br>
每个从服务器都会收到主服务器二进制日志的全部内容的副本。</li>
<li>从服务器设备负责决定应该执行二进制日志中的哪些语句。<br>
除非另行指定，否则主从二进制日志中的所有事件都在从站上执行。<br>
如果需要，您可以将从服务器配置为仅处理一些特定数据库或表的事件。</li>
</ul>
<p><em>注：作为主服务器角色的数据库服务器必须开启二进制日志</em></p>
<h2 id="3、Mysql配置">3、Mysql配置</h2>
<h3 id="1、Master节点配置-etc-my-cnf-master节点执行">1、Master节点配置<code>/etc/my.cnf</code> (master节点执行)</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; vim /etc/my.cnf</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line"><span class="comment">## 同一局域网内注意要唯一</span></span><br><span class="line">server-id=100  </span><br><span class="line"><span class="comment">## 开启二进制日志功能，可以随便取（关键）</span></span><br><span class="line"><span class="built_in">log</span>-bin=mysql-bin</span><br><span class="line"><span class="comment">## 复制过滤：不需要备份的数据库，不输出（mysql库一般不同步）</span></span><br><span class="line">binlog-ignore-db=mysql</span><br><span class="line"><span class="comment">## 为每个session 分配的内存，在事务过程中用来存储二进制日志的缓存</span></span><br><span class="line">binlog_cache_size=1M</span><br><span class="line"><span class="comment">## 主从复制的格式（mixed,statement,row，默认格式是statement）</span></span><br><span class="line">binlog_format=mixed</span><br></pre></td></tr></table></figure>
<h3 id="2、Slave节点配置-etc-my-cnf-slave节点执行">2、Slave节点配置<code>/etc/my.cnf</code> (slave节点执行)</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; vim /etc/my.cnf</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line"><span class="comment">## 设置server_id,注意要唯一</span></span><br><span class="line">server-id=102</span><br><span class="line"><span class="comment">## 开启二进制日志功能，以备Slave作为其它Slave的Master时使用</span></span><br><span class="line"><span class="built_in">log</span>-bin=mysql-slave-bin</span><br><span class="line"><span class="comment">##复制过滤：不需要备份的数据库，不输出（mysql库一般不同步）</span></span><br><span class="line">binlog-ignore-db=mysql</span><br><span class="line"><span class="comment">## 如果需要同步函数或者存储过程</span></span><br><span class="line">log_bin_trust_function_creators=<span class="literal">true</span></span><br><span class="line"><span class="comment">## 为每个session 分配的内存，在事务过程中用来存储二进制日志的缓存</span></span><br><span class="line">binlog_cache_size=1M</span><br><span class="line"><span class="comment">## 主从复制的格式（mixed,statement,row，默认格式是statement）</span></span><br><span class="line">binlog_format=mixed</span><br><span class="line"><span class="comment">## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。</span></span><br><span class="line"><span class="comment">## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致</span></span><br><span class="line">slave_skip_errors=1062</span><br></pre></td></tr></table></figure>
<h3 id="3、在master服务器授权slave服务器可以同步权限-master节点执行">3、在master服务器授权slave服务器可以同步权限(master节点执行)</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在Master上执行</span></span><br><span class="line">mysql -uroot -p(master的密码)</span><br><span class="line"><span class="comment"># 授予slave服务器可以同步master服务</span></span><br><span class="line">CREATE user <span class="string">'root'</span>@<span class="string">'从机ip'</span>  IDENTIFIED WITH mysql_native_password by <span class="string">'从机数据库密码'</span>;</span><br><span class="line">grant replication slave on *.* to  <span class="string">'root'</span>@<span class="string">'从机ip'</span>;</span><br><span class="line"><span class="comment"># 刷新权限</span></span><br><span class="line">flush privileges;</span><br><span class="line"><span class="comment"># 查看MySQL现在有哪些用户及对应的IP权限(可以不执行，只是一个查看)</span></span><br><span class="line">select user,host from mysql.user;</span><br></pre></td></tr></table></figure>
<h3 id="4、查询master服务的binlog文件名和位置-master节点执行">4、查询master服务的binlog文件名和位置(master节点执行)</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">show master status;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/a35d933c41c445af81b2460ce4b58d83.png" alt="请添加图片描述"></p>
<h3 id="5、slave进行关联master节点-slave节点执行">5、slave进行关联master节点(slave节点执行)</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p(slave的密码)</span><br><span class="line"><span class="comment">#这里要保证master_log_file和master_log_pos和主机一致</span></span><br><span class="line">change master to master_host=<span class="string">'主机ip'</span>, master_user=<span class="string">'root'</span>, master_password=<span class="string">'主机数据库密码'</span>, master_port=3306, master_log_file=<span class="string">'mysql-bin.000006'</span>,master_log_pos=1490;</span><br><span class="line"><span class="comment">#开始复制</span></span><br><span class="line">start slave;</span><br><span class="line"><span class="comment">#查看slave状态</span></span><br><span class="line">show slave status\G;</span><br><span class="line"><span class="comment">#停止复制</span></span><br><span class="line">stop slave;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/ebf9e23c59014bd8b2237ddcc47eac66.png" alt="请添加图片描述"><br>
<em>在主从复制操作的时候，不要基于去创建数据库或者相关操作，然后又去删除。若这样可能需要重新绑定主机位置</em></p>
<h2 id="4、常见错误排查">4、常见错误排查</h2>
<h3 id="1、Host-‘xxxx’-is-not-allowed-to-connect-to-this-MySQL-server">1、Host ‘xxxx’ is not allowed to connect to this MySQL server</h3>
<p>​	发生该问题一般是想远程连接root权限的数据库，这需要修改修改mysql权限表 。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">##进入root权限的数据库后查看当前权限</span></span><br><span class="line">use mysql;</span><br><span class="line">select host,user from user;</span><br><span class="line"><span class="comment">##这里%代表全ip开放，正式环境可以选择ip</span></span><br><span class="line">update user <span class="built_in">set</span> host=<span class="string">'%'</span> <span class="built_in">where</span> user=<span class="string">'root'</span>;</span><br><span class="line"><span class="comment">##最后刷新一下权限即可</span></span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>
<h3 id="2、主从复制Connecting问题">2、主从复制Connecting问题</h3>
<p>​	使用<code>start slave</code>开启主从复制过程后，如果SlaveIORunning一直是Connecting，则说明主从复制一直处于连接状态，这种情况一般是下面几种原因造成的，我们可以根据 Last_IO_Error提示予以排除。</p>
<ul>
<li>网络不通</li>
<li>检查ip,端口</li>
<li>密码不对</li>
<li>检查是否创建用于同步的用户和用户密码是否正确</li>
<li>pos不对</li>
<li>检查Master的 Position</li>
</ul>
<h3 id="3、MYSQL镜像服务器因错误停止的恢复-Slave-SQL-Running-No">3、MYSQL镜像服务器因错误停止的恢复  Slave_SQL_Running: No</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">stop slave;</span><br><span class="line"><span class="built_in">set</span> global sql_slave_skip_counter=1;</span><br><span class="line">start slave; </span><br><span class="line">show slave status\G ;</span><br></pre></td></tr></table></figure>
<h3 id="4、从MYSQL服务器Slave-IO-Running-No">4、从MYSQL服务器Slave_IO_Running: No</h3>
<blockquote>
<p>造成这类问题的原因一般是在主从复制的时候，基于创建表，然后又去删除和操作了数据表或者表。</p>
</blockquote>
<ul>
<li>master节点执行，获取日志文件和post</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">show master status;</span><br></pre></td></tr></table></figure>
<ul>
<li>slave节点进行重新绑定</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">stop slave;</span><br><span class="line">CHANGE MASTER TO MASTER_LOG_FILE=<span class="string">'mysql-bin.000006'</span>, MASTER_LOG_POS=1254;</span><br><span class="line">start slave;</span><br></pre></td></tr></table></figure>
<h1>三、SharingJdbc配置和读写分离</h1>
<h2 id="1、数据库数据准备">1、数据库数据准备</h2>
<p><img src="https://img-blog.csdnimg.cn/c8e847b6ce7c4af79717fb59c86dada0.png" alt="请添加图片描述"></p>
<h2 id="2、实现步骤">2、实现步骤</h2>
<h3 id="1、新建一个springboot工程">1、新建一个springboot工程</h3>
<h3 id="2、引入相关sharding依赖、ssm依赖、数据库驱动">2、引入相关sharding依赖、ssm依赖、数据库驱动</h3>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sharding-sphere.version</span>&gt;</span>4.0.0-RC1<span class="tag">&lt;/<span class="name">sharding-sphere.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 依赖web --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 依赖mybatis和mysql驱动 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--依赖lombok--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--依赖sharding--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shardingsphere<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sharding-jdbc-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;sharding-sphere.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shardingsphere<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sharding-core-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;sharding-sphere.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--依赖数据源druid--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.22<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="3、定义配置application-yml">3、定义配置application.yml</h3>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8085</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">main:</span></span><br><span class="line">    <span class="attr">allow-bean-definition-overriding:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">shardingsphere:</span></span><br><span class="line">    <span class="comment"># 参数配置，显示sql</span></span><br><span class="line">    <span class="attr">props:</span></span><br><span class="line">      <span class="attr">sql:</span></span><br><span class="line">        <span class="attr">show:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 配置数据源</span></span><br><span class="line">    <span class="attr">datasource:</span></span><br><span class="line">      <span class="comment"># 给每个数据源取别名，下面的ds0,ds1,ds2任意取名字</span></span><br><span class="line">      <span class="attr">names:</span> <span class="string">ds0,ds1,ds2</span></span><br><span class="line">      <span class="comment"># 给master-ds0每个数据源配置数据库连接信息</span></span><br><span class="line">      <span class="attr">ds0:</span></span><br><span class="line">        <span class="comment"># 配置druid数据源</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">        <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">jdbc:mysql://云服务器ip1:3306/test?useUnicode=true&amp;characterEncoding=utf8&amp;tinyInt1isBit=false&amp;useSSL=false&amp;serverTimezone=GMT%2b8</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">maxPoolSize:</span> <span class="number">100</span></span><br><span class="line">        <span class="attr">minPoolSize:</span> <span class="number">5</span></span><br><span class="line">      <span class="comment"># 配置ds1-slave</span></span><br><span class="line">      <span class="attr">ds1:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">        <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">jdbc:mysql://云服务器ip2:3306/test?useUnicode=true&amp;characterEncoding=utf8&amp;tinyInt1isBit=false&amp;useSSL=false&amp;serverTimezone=GMT%2b8</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">maxPoolSize:</span> <span class="number">100</span></span><br><span class="line">        <span class="attr">minPoolSize:</span> <span class="number">5</span></span><br><span class="line">      <span class="comment"># 配置ds2-slave</span></span><br><span class="line">      <span class="attr">ds2:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">        <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">jdbc:mysql://云服务器ip3:3306/test?useUnicode=true&amp;characterEncoding=utf8&amp;tinyInt1isBit=false&amp;useSSL=false&amp;serverTimezone=GMT%2b8</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">maxPoolSize:</span> <span class="number">100</span></span><br><span class="line">        <span class="attr">minPoolSize:</span> <span class="number">5</span></span><br><span class="line">    <span class="comment"># 配置默认数据源ds0</span></span><br><span class="line">    <span class="attr">sharding:</span></span><br><span class="line">      <span class="comment"># 默认数据源，主要用于写，注意一定要配置读写分离 ,注意：如果不配置，那么就会把三个节点都当做从slave节点，新增，修改和删除会出错。</span></span><br><span class="line">      <span class="attr">default-data-source-name:</span> <span class="string">ds0</span></span><br><span class="line">    <span class="comment"># 配置数据源的读写分离，但是数据库一定要做主从复制</span></span><br><span class="line">    <span class="attr">masterslave:</span></span><br><span class="line">      <span class="comment"># 配置主从名称，可以任意取名字</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">ms</span></span><br><span class="line">      <span class="comment"># 配置主库master，负责数据的写入</span></span><br><span class="line">      <span class="attr">master-data-source-name:</span> <span class="string">ds0</span></span><br><span class="line">      <span class="comment"># 配置从库slave节点</span></span><br><span class="line">      <span class="attr">slave-data-source-names:</span> <span class="string">ds1,ds2</span></span><br><span class="line">      <span class="comment"># 配置slave节点的负载均衡均衡策略，采用轮询机制</span></span><br><span class="line">      <span class="attr">load-balance-algorithm-type:</span> <span class="string">round_robin</span></span><br><span class="line"><span class="comment"># 整合mybatis的配置XXXXX</span></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mapper/*.xml</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.shawn.sharingjdbc.entity</span></span><br></pre></td></tr></table></figure>
<h3 id="4、-定义mapper、controller、entity">4、 定义mapper、controller、entity</h3>
<p>entity</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 主键</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id;</span><br><span class="line">    <span class="comment">// 昵称</span></span><br><span class="line">    <span class="keyword">private</span> String nickname;</span><br><span class="line">    <span class="comment">// 密码</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="comment">// 性别</span></span><br><span class="line">    <span class="keyword">private</span> Integer sex;</span><br><span class="line">    <span class="comment">//年龄</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="comment">// 生日</span></span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mapper</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@description</span> 保存用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@params</span> [user]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Insert</span>(<span class="string">"insert into shawn_order_db(nickname,password,age,sex,birthday) values(#&#123;nickname&#125;,#&#123;password&#125;,#&#123;age&#125;,#&#123;sex&#125;,#&#123;birthday&#125;)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addUser</span><span class="params">(User user)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@description</span> 保存用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@params</span> [user]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"select * from shawn_order_db"</span>)</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findUsers</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>controller</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/save"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">insert</span><span class="params">()</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setNickname(<span class="string">"shawn1"</span>+ <span class="keyword">new</span> Random().nextInt());</span><br><span class="line">        user.setPassword(<span class="string">"1234567"</span>);</span><br><span class="line">        user.setSex(<span class="number">1</span>);</span><br><span class="line">        user.setAge(<span class="number">22</span>);</span><br><span class="line">        SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">        user.setBirthday(simpleDateFormat.parse(<span class="string">"1999-02-22"</span>));</span><br><span class="line">        userMapper.addUser(user);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/listuser"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">listuser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userMapper.findUsers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5、Props其他参数配置">5、Props其他参数配置</h3>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">acceptor.size:</span> <span class="comment"># accept连接的线程数量,默认为cpu核数2倍</span></span><br><span class="line"><span class="attr">executor.size:</span> <span class="comment">#工作线程数量最大，默认值: 无限制</span></span><br><span class="line"><span class="attr">max.connections.size.per.query:</span> <span class="comment"># 每个查询可以打开的最大连接数量,默认为1</span></span><br><span class="line"><span class="attr">check.table.metadata.enabled:</span> <span class="comment">#是否在启动时检查分表元数据一致性，默认值: false</span></span><br><span class="line"><span class="attr">proxy.frontend.flush.threshold:</span> <span class="comment"># proxy的服务时候,对于单个大查询,每多少个网络包返回一次</span></span><br><span class="line"><span class="attr">proxy.transaction.type:</span> <span class="comment"># 默认LOCAL,proxy的事务模型 允许LOCAL,XA,BASE三个值,LOCAL无分布式事务,XA则是采用atomikos实现的分布式事务 BASE目前尚未实现</span></span><br><span class="line"><span class="attr">proxy.opentracing.enabled:</span> <span class="comment"># 是否启用opentracing</span></span><br><span class="line"><span class="attr">proxy.backend.use.nio:</span> <span class="comment"># 是否采用netty的NIO机制连接后端数据库,默认False ,使用epoll机制</span></span><br><span class="line"><span class="attr">proxy.backend.max.connections:</span> <span class="comment"># 使用NIO而非epoll的话,proxy后台连接每个netty客户端允许的最大连接数量(注意不是数据库连接限制) 默认为8</span></span><br><span class="line"><span class="attr">proxy.backend.connection.timeout.seconds:</span> <span class="comment">#使用nio而非epoll的话,proxy后台连接的超时时间,默认60s</span></span><br></pre></td></tr></table></figure>
<h1>四、SharingJdbc分库和分表</h1>
<h2 id="1、Mysql分库分表原理">1、Mysql分库分表原理</h2>
<blockquote>
<p>官网参考：<a href="https://shardingsphere.apache.org/document/current/cn/user-manual/shardingsphere-jdbc/usage/sharding/" target="_blank" rel="noopener">https://shardingsphere.apache.org/document/current/cn/user-manual/shardingsphere-jdbc/usage/sharding/</a></p>
</blockquote>
<h3 id="1、概述-v3">1、概述</h3>
<blockquote>
<p>分库分表目的：解决高并发，和数据量大的问题。</p>
</blockquote>
<p>​	1、高并发情况下，会造成IO读写频繁，自然就会造成读写缓慢，甚至是宕机。一般单库不要超过2k并发，一个表数据建议不要超过500W。<br>
​	2、数据量大的问题。主要由于底层索引实现导致，MySQL的索引实现为B+TREE，数据量其他，会导致索引树十分庞大，造成查询缓慢。第二，innodb的最大存储限制64TB。</p>
<h3 id="2、分库分表">2、分库分表</h3>
<p>​	分库分表又分为水平拆分和垂直拆分</p>
<p>**水平拆分：**统一个表的数据拆到不同的库不同的表中。可以根据时间、地区、或某个业务键维度，也可以通过hash进行拆分，最后通过路由访问到具体的数据。拆分后的每个表结构保持一致。</p>
<p>**垂直拆分：**就是把一个有很多字段的表给拆分成多个表，或者是多个库上去。每个库表的结构都不一样，每个库表都包含部分字段。一般来说，可以根据业务维度进行拆分，如订单表可以拆分为订单、订单支持、订单地址、订单商品、订单扩展等表；也可以，根据数据冷热程度拆分，20%的热点字段拆到一个表，80%的冷字段拆到另外一个表(拆分两个表建立1:1关系)。</p>
<p><img src="https://img-blog.csdnimg.cn/77d336ba4db0480f8b6003e3d9b196ef.png" alt="请添加图片描述"><br>
对于数据同步，有全量数据同步(主从复制)和增量数据同步(Canal)两种</p>
<h2 id="2、实现步骤-v2">2、实现步骤</h2>
<p>​	数据库复制了<code>shawn_order_db</code>表变成<code>shawn_order_db0</code>和<code>shawn_order_db1</code>，对于<code>yml配置文件</code>。配置成功后分库分表、单库分表等操作可以自定义实现。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8085</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">main:</span></span><br><span class="line">    <span class="attr">allow-bean-definition-overriding:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">shardingsphere:</span></span><br><span class="line">    <span class="comment"># 参数配置，显示sql</span></span><br><span class="line">    <span class="attr">props:</span></span><br><span class="line">      <span class="attr">sql:</span></span><br><span class="line">        <span class="attr">show:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 配置数据源</span></span><br><span class="line">    <span class="attr">datasource:</span></span><br><span class="line">      <span class="comment"># 给每个数据源取别名，下面的ds1,ds2,ds3任意取名字</span></span><br><span class="line">      <span class="attr">names:</span> <span class="string">ds0,ds1,ds2</span></span><br><span class="line">      <span class="comment"># 给master-ds0每个数据源配置数据库连接信息</span></span><br><span class="line">      <span class="attr">ds0:</span></span><br><span class="line">        <span class="comment"># 配置druid数据源</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">        <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">jdbc:mysql://服务器ip1:3306/test?useUnicode=true&amp;characterEncoding=utf8&amp;tinyInt1isBit=false&amp;useSSL=false&amp;serverTimezone=GMT%2b8</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">maxPoolSize:</span> <span class="number">100</span></span><br><span class="line">        <span class="attr">minPoolSize:</span> <span class="number">5</span></span><br><span class="line">      <span class="comment"># 配置ds1-slave</span></span><br><span class="line">      <span class="attr">ds1:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">        <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">jdbc:mysql://服务器ip2:3306/test?useUnicode=true&amp;characterEncoding=utf8&amp;tinyInt1isBit=false&amp;useSSL=false&amp;serverTimezone=GMT%2b8</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">maxPoolSize:</span> <span class="number">100</span></span><br><span class="line">        <span class="attr">minPoolSize:</span> <span class="number">5</span></span><br><span class="line">      <span class="comment"># 配置ds2-slave</span></span><br><span class="line">      <span class="attr">ds2:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">        <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">jdbc:mysql://服务器ip3:3306/test?useUnicode=true&amp;characterEncoding=utf8&amp;tinyInt1isBit=false&amp;useSSL=false&amp;serverTimezone=GMT%2b8</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">maxPoolSize:</span> <span class="number">100</span></span><br><span class="line">        <span class="attr">minPoolSize:</span> <span class="number">5</span></span><br><span class="line">    <span class="attr">sharding:</span></span><br><span class="line">      <span class="comment"># 默认数据源，主要用于写，注意一定要配置读写分离 ,注意：如果不配置，那么就会把三个节点都当做从slave节点，新增，修改和删除会出错。</span></span><br><span class="line">      <span class="attr">default-data-source-name:</span> <span class="string">ds0</span></span><br><span class="line">      <span class="comment"># 配置分表的规则</span></span><br><span class="line">      <span class="attr">tables:</span></span><br><span class="line">        <span class="comment"># shawn_order_db 逻辑表名</span></span><br><span class="line">        <span class="attr">shawn_order_db:</span></span><br><span class="line">          <span class="comment"># 数据节点：数据源$-&gt;&#123;0..N&#125;.逻辑表名$-&gt;&#123;0..N&#125;</span></span><br><span class="line">          <span class="attr">actual-data-nodes:</span> <span class="string">ds$-&gt;&#123;0..1&#125;.shawn_order_db$-&gt;&#123;0..1&#125;</span></span><br><span class="line">          <span class="comment"># 根据需求自己修改</span></span><br><span class="line">          <span class="comment"># actual-data-nodes: ds0.shawn_order_db$-&gt;&#123;0..1&#125;</span></span><br><span class="line">          <span class="comment"># 拆分库策略，也就是什么样子的数据放入放到哪个数据库中。</span></span><br><span class="line">          <span class="attr">database-strategy:</span></span><br><span class="line">          <span class="comment"># 一般用id类数字</span></span><br><span class="line">            <span class="attr">inline:</span></span><br><span class="line">              <span class="attr">sharding-column:</span> <span class="string">sex</span>    <span class="comment"># 分片字段（分片键）</span></span><br><span class="line">              <span class="attr">algorithm-expression:</span> <span class="string">ds$-&gt;&#123;sex</span> <span class="string">%</span> <span class="number">2</span><span class="string">&#125;</span> <span class="comment"># 分片算法表达式</span></span><br><span class="line">          <span class="comment"># 拆分表策略，也就是什么样子的数据放入放到哪个数据表中。</span></span><br><span class="line">          <span class="attr">table-strategy:</span></span><br><span class="line">            <span class="attr">inline:</span></span><br><span class="line">              <span class="attr">sharding-column:</span> <span class="string">age</span>    <span class="comment"># 分片字段（分片键）</span></span><br><span class="line">              <span class="attr">algorithm-expression:</span> <span class="string">shawn_order_db$-&gt;&#123;age</span> <span class="string">%</span> <span class="number">2</span><span class="string">&#125;</span> <span class="comment"># 分片算法表达式</span></span><br></pre></td></tr></table></figure>
<h2 id="3、其他分片算法策略-了解">3、其他分片算法策略(了解)</h2>
<ul>
<li>标准分片 - Standard</li>
<li>符合分片策略</li>
<li>hint分片策略</li>
</ul>
<h1>五、分布式主键管理</h1>
<h2 id="1、分布式ID">1、分布式ID</h2>
<p>​	ShardingSphere提供灵活的配置分布式主键生成策略方式。在分片规则配置模块克配置每个表的主键生成策略。默认使用雪花算法。（snowflake）生成64bit的长整型数据。支持两种方式配置</p>
<ul>
<li>SNOWFLAKE</li>
<li>UUID</li>
</ul>
<blockquote>
<p>切记：如果用雪花算法，数据库主键列不能自增长。数据类型是：bigint(20)，在java类中使用long类型，不要用String类型；</p>
<p>如果用UUID，数据库用varchar，Java类用String，推荐用雪花，性能好</p>
</blockquote>
<p>mapper修改</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这样能返回id值，直接控制台输出可以看见，这是Mybatis注解</span></span><br><span class="line"><span class="meta">@Insert</span>(<span class="string">"insert into shawn_order_db(nickname,password,age,sex,birthday) values(#&#123;nickname&#125;,#&#123;password&#125;,#&#123;age&#125;,#&#123;sex&#125;,#&#123;birthday&#125;)"</span>)</span><br><span class="line"><span class="meta">@Options</span>(useGeneratedKeys = <span class="keyword">true</span>,keyColumn = <span class="string">"id"</span>,keyProperty = <span class="string">"id"</span>)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addUser</span><span class="params">(User user)</span></span>;</span><br></pre></td></tr></table></figure>
<p>yaml配置文件修改</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在配置文件相应位置添加</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">shardingsphere:</span></span><br><span class="line">    <span class="attr">sharding:</span></span><br><span class="line">      <span class="attr">tables:</span></span><br><span class="line">        <span class="comment"># shawn_order_db 逻辑表名</span></span><br><span class="line">        <span class="attr">shawn_order_db:</span></span><br><span class="line">          <span class="attr">key-generator:</span></span><br><span class="line">            <span class="comment"># 主键的列明，</span></span><br><span class="line">            <span class="attr">column:</span> <span class="string">id</span></span><br><span class="line">            <span class="attr">type:</span> <span class="string">SNOWFLAKE</span></span><br></pre></td></tr></table></figure>
<h2 id="2、Mysql日期实战">2、Mysql日期实战</h2>
<blockquote>
<p>按照年月分库分表，比如shawn_user_order_202101、shawn_user_order_202102，这样可以方便按照月份划分表，在运行前需要在数据库先创建好表。</p>
<p><em>下面配置仅供参考</em></p>
</blockquote>
<p>策略类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YearMonthShardingAlgorithm</span> <span class="keyword">implements</span> <span class="title">PreciseShardingAlgorithm</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SPLITTER = <span class="string">"_"</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doSharding</span><span class="params">(Collection availableTargetNames, PreciseShardingValue shardingValue)</span> </span>&#123;</span><br><span class="line">        String tbName = shardingValue.getLogicTableName() + <span class="string">"_"</span> + shardingValue.getValue();</span><br><span class="line">        System.out.println(<span class="string">"Sharding input:"</span> + shardingValue.getValue() + <span class="string">", output:&#123;&#125;"</span> + tbName);</span><br><span class="line">        <span class="keyword">return</span> tbName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置类，数据源和之前一样</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">shardingsphere:</span></span><br><span class="line">    <span class="comment"># 配置默认数据源ds0</span></span><br><span class="line">    <span class="attr">sharding:</span></span><br><span class="line">      <span class="comment"># 默认数据源，主要用于写，注意一定要配置读写分离 ,注意：如果不配置，那么就会把三个节点都当做从slave节点，新增，修改和删除会出错。</span></span><br><span class="line">      <span class="attr">default-data-source-name:</span> <span class="string">ds0</span></span><br><span class="line">      <span class="comment"># 配置分表的规则</span></span><br><span class="line">      <span class="attr">tables:</span></span><br><span class="line">        <span class="attr">shawn_order_db:</span></span><br><span class="line">          <span class="attr">key-generator:</span></span><br><span class="line">            <span class="attr">column:</span> <span class="string">id</span></span><br><span class="line">            <span class="attr">type:</span> <span class="string">SNOWFLAKE</span></span><br><span class="line">          <span class="comment"># 数据节点：数据源$-&gt;&#123;0..N&#125;.逻辑表名$-&gt;&#123;0..N&#125;</span></span><br><span class="line">          <span class="attr">actual-data-nodes:</span> <span class="string">ds$-&gt;&#123;0..1&#125;.shawn_order_db$-&gt;&#123;0..1&#125;</span></span><br><span class="line">          <span class="comment"># 拆分库策略，也就是什么样子的数据放入放到哪个数据库中。</span></span><br><span class="line">          <span class="attr">database-strategy:</span></span><br><span class="line">            <span class="attr">standard:</span></span><br><span class="line">              <span class="attr">shardingColumn:</span> <span class="string">birthday</span></span><br><span class="line">              <span class="attr">preciseAlgorithmClassName:</span> <span class="string">com.shawnn.shardingjdbc.algorithm.BirthdayAlgorithm</span></span><br><span class="line">          <span class="attr">table-strategy:</span></span><br><span class="line">            <span class="attr">inline:</span></span><br><span class="line">              <span class="attr">sharding-column:</span> <span class="string">age</span>    <span class="comment"># 分片字段（分片键）</span></span><br><span class="line">              <span class="attr">algorithm-expression:</span> <span class="string">shawn_order_db$-&gt;&#123;age</span> <span class="string">%</span> <span class="number">2</span><span class="string">&#125;</span> <span class="comment"># 分片算法表达式</span></span><br><span class="line">        <span class="comment">#第二个表</span></span><br><span class="line">        <span class="attr">order_user_db:</span></span><br><span class="line">          <span class="comment"># 数据节点：数据源$-&gt;&#123;0..N&#125;.逻辑表名$-&gt;&#123;0..N&#125;</span></span><br><span class="line">          <span class="attr">actual-data-nodes:</span> <span class="string">ds0.order_user_db$-&gt;&#123;0..1&#125;</span></span><br><span class="line">          <span class="attr">key-generator:</span></span><br><span class="line">            <span class="attr">column:</span> <span class="string">orderid</span></span><br><span class="line">            <span class="attr">type:</span> <span class="string">SNOWFLAKE</span></span><br><span class="line">          <span class="comment"># 拆分库策略，也就是什么样子的数据放入放到哪个数据库中。</span></span><br><span class="line">          <span class="attr">table-strategy:</span></span><br><span class="line">            <span class="attr">inline:</span></span><br><span class="line">              <span class="attr">sharding-column:</span> <span class="string">orderid</span>    <span class="comment"># 分片字段（分片键）</span></span><br><span class="line">              <span class="attr">algorithm-expression:</span> <span class="string">order_user_db$-&gt;&#123;orderid</span> <span class="string">%</span> <span class="number">2</span><span class="string">&#125;</span> <span class="comment"># 分片算法表达式</span></span><br><span class="line">        <span class="comment">#第三个表</span></span><br><span class="line">        <span class="attr">shawn_user_order:</span></span><br><span class="line">          <span class="comment"># 数据节点：数据源$-&gt;&#123;0..N&#125;.逻辑表名$-&gt;&#123;0..N&#125;</span></span><br><span class="line">          <span class="attr">actual-data-nodes:</span> <span class="string">ds0.shawn_user_order_$-&gt;&#123;2021..2022&#125;$&#123;(1..3).collect&#123;t</span> <span class="string">-&gt;t.toString().padLeft(2,'0')&#125;</span> <span class="string">&#125;</span></span><br><span class="line">          <span class="attr">key-generator:</span></span><br><span class="line">            <span class="attr">column:</span> <span class="string">orderid</span></span><br><span class="line">            <span class="attr">type:</span> <span class="string">SNOWFLAKE</span></span><br><span class="line">          <span class="comment"># 拆分库策略，也就是什么样子的数据放入放到哪个数据库中。</span></span><br><span class="line">          <span class="attr">table-strategy:</span></span><br><span class="line"><span class="comment">#            inline:</span></span><br><span class="line"><span class="comment">#              shardingColumn: yearmonth</span></span><br><span class="line"><span class="comment">#              algorithmExpression: shawn_user_order_$-&gt;&#123;yearmonth&#125;</span></span><br><span class="line">            <span class="attr">standard:</span></span><br><span class="line">              <span class="attr">shardingColumn:</span> <span class="string">yearmonth</span></span><br><span class="line">              <span class="attr">preciseAlgorithmClassName:</span> <span class="string">com.shawn.shardingjdbc.algorithm.YearMonthShardingAlgorithm</span></span><br><span class="line"><span class="comment"># 整合mybatis的配置XXXXX</span></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mapper/*.xml</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.shawn.shardingjdbc.entity</span></span><br></pre></td></tr></table></figure>
<h1>六、SharingJdbc事务管理</h1>
<h2 id="1、事务概述">1、事务概述</h2>
<p>​	数据库事务需要满足ACID（原子性、一致性、隔离性、持久性）四个特性。</p>
<ul>
<li>原子性（Atomicity）指事务作为整体来执行，要么全部执行，要么全不执行。</li>
<li>一致性（Consistency）指事务应确保数据从一个一致的状态转变为另一个一致的状态。</li>
<li>隔离性（Isolation）指多个事务并发执行时，一个事务的执行不应影响其他事务的执行。</li>
<li>持久性（Durability）指已提交的事务修改数据会被持久保存</li>
</ul>
<p><strong>两阶段提交</strong><br>
XA协议最早的分布式事务模型是由X/Open国际联盟提出的X/Open Distributed Transaction Processing（DTP）模型，简称XA协议。<br>
基于XA协议实现的分布式事务对业务侵入很小。 它最大的优势就是对使用方透明，用户可以像使用本地事务一样使用基于XA协议的分布式事务。 XA协议能够严格保障事务ACID特性。严格保障事务ACID特性是一把双刃剑。 事务执行在过程中需要将所需资源全部锁定，它更加适用于执行时间确定的短事务。 对于长事务来说，整个事务进行期间对数据的独占，将导致对热点数据依赖的业务系统并发性能衰退明显。 因此，在高并发的性能至上场景中，基于XA协议的分布式事务并不是最佳选择。</p>
<p><strong>柔性事务</strong><br>
如果将实现了ACID的事务要素的事务称为刚性事务的话，那么基于BASE事务要素的事务则称为柔性事务。 BASE是基本可用、柔性状态和最终一致性这三个要素的缩写。<br>
基本可用（Basically Available）保证分布式事务参与方不一定同时在线。柔性状态（Soft state）则允许系统状态更新有一定的延时，这个延时对客户来说不一定能够察觉。而最终一致性（Eventually consistent）通常是通过消息传递的方式保证系统的最终一致性。<br>
在ACID事务中对隔离性的要求很高，在事务执行过程中，必须将所有的资源锁定。 柔性事务的理念则是通过业务逻辑将互斥锁操作从资源层面上移至业务层面。通过放宽对强一致性要求，来换取系统吞吐量的提升。<br>
<img src="https://img-blog.csdnimg.cn/eb7c2af4449d4dc4bb29b1f79647ed4e.png" alt="请添加图片描述"></p>
<h2 id="2、简单实现步骤">2、简单实现步骤</h2>
<p>添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--依赖sharding--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.shardingsphere<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sharding-transaction-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在service层添加注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserOrderService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderMapper orderMapper;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//加上依赖即可</span></span><br><span class="line">    <span class="meta">@ShardingTransactionType</span>(TransactionType.XA)</span><br><span class="line">    <span class="meta">@Transactional</span>(rollbackFor = Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">int</span> <span class="title">saveUserOrder</span>(<span class="title">User</span> <span class="title">user</span>, <span class="title">Order</span> <span class="title">order</span>) </span>&#123;</span><br><span class="line">        userMapper.addUser(user);</span><br><span class="line">        order.setUserid(user.getId());</span><br><span class="line">        orderMapper.addOrder(order);</span><br><span class="line">        <span class="comment">//int a = 1/0; //测试回滚，统一提交的话，将这行注释掉就行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>七、MySql常用规范</h1>
<p><strong>基础规范</strong></p>
<ul>
<li>表必须有主键，建议使用整型作为主键</li>
<li>禁止使用外键，表之间的关联性和完整性通过应用层来控制</li>
<li>表在设计之初，应该考虑到大致的数据级，若表记录小于1000W，尽量使用单表，不建议分表。</li>
<li>建议将大字段，访问频率低，或者不需要作为筛选条件的字段拆分到拓展表中，（做好表垂直拆分）</li>
<li>控制单实例表的总数，单个表分表数控制在1024以内。</li>
</ul>
<p><strong>列设计规范</strong></p>
<ul>
<li>正确区分tinyint、int、bigint的范围</li>
<li>使用varchar(20)存储手机号，不要使用整数</li>
<li>使用int存储ipv4 不要使用char(15)</li>
<li>涉及金额使用decimal/varchar，并制定精度</li>
<li>不要设计为null的字段，而是用空字符，因为null需要更多的空间，并且使得索引和统计变得更复杂。</li>
</ul>
<p><strong>索引规范</strong></p>
<ul>
<li>唯一索引使用uniq_[字段名]来命名</li>
<li>非唯一索引使用idx_[字段名]来命名</li>
<li>不建议在频繁更新的字段上建立索引</li>
<li>非必要不要进行JOIN,如果要进行join查询，被join的字段必须类型相同，并建立索引。</li>
<li>单张表的索引数量建议控制在5个以内，索引过多，不仅会导致插入更新性能下降，还可能导致MYSQL的索引出错和性能下降</li>
<li>组合索引字段数量不建议超过5个，理解组合索引的最左匹配原则，避免重复建设索引。比如你建立了<br>
(x,y,z) 相当于你建立了(x),(x,y),(x,y,z)</li>
</ul>
<p><strong>SQL规范</strong></p>
<ul>
<li>禁止使用selet <em>，只获取必要字段，select</em> 会增加cpu/i0/内存、带宽的消耗。</li>
<li>insert 必须指定字段，禁止使用insert into Table values().指定字段插入，在表结果变更时，能保证对应应用程序无影响。</li>
<li>隐私类型转换会使索引失效，导致全表扫描。（比如：手机号码搜索时未转换成字符串）</li>
<li>禁止在where后面查询列使用内置函数或者表达式，导致不能命中索引，导致全表扫描</li>
<li>禁止负向查询（!=,not like ,no in等）以及%开头的模糊查询，造成不能命中索引，导致全表扫描</li>
<li>避免直接返回大结果集造成内存溢出，可采用分段和游标方式。</li>
<li>返回结果集时尽量使用limit分页显示。</li>
<li>尽量在order by/group by的列上创建索引。</li>
<li>大表扫描尽量放在镜像库上去做</li>
<li>禁止大表join查询和子查询</li>
<li>尽量避免数据库内置函数作为查询条件</li>
<li>应用程序尽量捕获SQL异常</li>
</ul>
<p><strong>表的垂直拆分</strong></p>
<p>垂直拆分：业务模块拆分、商品库，用户库，订单库<br>
水平拆分：对表进行水平拆分（也就是我们说的：分表）<br>
表进行垂直拆分：表的字段过多，字段使用的频率不一。（可以拆分两个表建立1:1关系）</p>
<ul>
<li>将一个属性过多的表，一行数据较大的表，将不同的属性分割到不同的数据库表中。以降低单库表的大小。<br>
特点：</li>
<li>每个表的结构不一致</li>
<li>每个表的数量都是全量</li>
<li>表和表之间一定会有一列会进行关联，一般都是主键</li>
</ul>
<p>原则：</p>
<ul>
<li>将长度较短，访问频率较高的字段放在一个表中，主表</li>
<li>将长度较长、访问频率比较低的字段放一个表中</li>
<li>将经常访问字段放一个表中。</li>
<li>所有表的并集是全量数据。</li>
</ul>
<p><strong>如何平滑添加字段</strong></p>
<p>场景：在开发时，有时需要给表加字段，在大数据量且分表的情况下，怎么样平滑添加。建议125<br>
1：直接alter table add column,数据量大时不建议，（会产生写锁）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> ksd_user <span class="keyword">add</span> <span class="keyword">column</span> api_pay_no <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">not</span> <span class="literal">null</span>  <span class="keyword">comment</span> <span class="string">'用户扩展订单号'</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> ksd_user <span class="keyword">add</span> <span class="keyword">column</span> api_pay_no <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">unique</span> <span class="keyword">comment</span> <span class="string">'用户扩展订单号'</span></span><br></pre></td></tr></table></figure>
<p>2：提前预留字段（不优雅：造成空间浪费，预留多少很难控制，拓展性差）<br>
3：新增一张表，（增加字段），迁移原表数据，在重新命名新表作为原表。<br>
4：放入extinfo（无法使用索引）<br>
5:  提前设计，使用key/value方法存储，新增字段时 ，直接加一个key就好了（优雅）</p>
<hr>
<p>学习参考</p>
<p><a href="https://www.bilibili.com/video/BV1ei4y1K7dn?p=1" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1ei4y1K7dn?p=1</a></p>
<p><a href="https://shardingsphere.apache.org/" target="_blank" rel="noopener">https://shardingsphere.apache.org/</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>java反编译JVM指令入门</title>
    <url>/posts/12cb1ce6.html</url>
    <content><![CDATA[<h1>一、概述</h1>
<blockquote>
<p>javac 是java语言编程编译器。 全称java compiler。 javac工具读由java语言编写的类和接口的定义，并将它们编译成字节代码的class文件。 javac 可以隐式编译一些没有在命令行中提及的源文件。</p>
<p>javap是jdk自带的反解析工具。它的作用就是根据class字节码文件，反解析出当前类对应的code区（汇编指令）、本地变量表、异常表和代码行偏移量映射表、常量池等等信息。</p>
</blockquote>
<p>​	针对javac和javap相关命令，在已配置好JDK环境变量的终端，使用<code>javac -help</code>和<code>javap -help</code>即可查找</p>
<a id="more"></a>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">用法: javac &lt;options&gt; &lt;<span class="built_in">source</span> files&gt;</span><br><span class="line">其中, 可能的选项包括:</span><br><span class="line">  -g                         生成所有调试信息</span><br><span class="line">  -g:none                    不生成任何调试信息</span><br><span class="line">  -g:&#123;lines,vars,<span class="built_in">source</span>&#125;     只生成某些调试信息</span><br><span class="line">  -nowarn                    不生成任何警告</span><br><span class="line">  -verbose                   输出有关编译器正在执行的操作的消息</span><br><span class="line">  -deprecation               输出使用已过时的 API 的源位置</span><br><span class="line">  -classpath &lt;路径&gt;            指定查找用户类文件和注释处理程序的位置</span><br><span class="line">  -cp &lt;路径&gt;                   指定查找用户类文件和注释处理程序的位置</span><br><span class="line">  -sourcepath &lt;路径&gt;           指定查找输入源文件的位置</span><br><span class="line">  -bootclasspath &lt;路径&gt;        覆盖引导类文件的位置</span><br><span class="line">  -extdirs &lt;目录&gt;              覆盖所安装扩展的位置</span><br><span class="line">  -endorseddirs &lt;目录&gt;         覆盖签名的标准路径的位置</span><br><span class="line">  -proc:&#123;none,only&#125;          控制是否执行注释处理和/或编译。</span><br><span class="line">  -processor &lt;class1&gt;[,&lt;class2&gt;,&lt;class3&gt;...] 要运行的注释处理程序的名称; 绕过默认的搜索进程</span><br><span class="line">  -processorpath &lt;路径&gt;        指定查找注释处理程序的位置</span><br><span class="line">  -parameters                生成元数据以用于方法参数的反射</span><br><span class="line">  -d &lt;目录&gt;                    指定放置生成的类文件的位置</span><br><span class="line">  -s &lt;目录&gt;                    指定放置生成的源文件的位置</span><br><span class="line">  -h &lt;目录&gt;                    指定放置生成的本机标头文件的位置</span><br><span class="line">  -implicit:&#123;none,class&#125;     指定是否为隐式引用文件生成类文件</span><br><span class="line">  -encoding &lt;编码&gt;             指定源文件使用的字符编码</span><br><span class="line">  -<span class="built_in">source</span> &lt;发行版&gt;              提供与指定发行版的源兼容性</span><br><span class="line">  -target &lt;发行版&gt;              生成特定 VM 版本的类文件</span><br><span class="line">  -profile &lt;配置文件&gt;            请确保使用的 API 在指定的配置文件中可用</span><br><span class="line">  -version                   版本信息</span><br><span class="line">  -<span class="built_in">help</span>                      输出标准选项的提要</span><br><span class="line">  -A关键字[=值]                  传递给注释处理程序的选项</span><br><span class="line">  -X                         输出非标准选项的提要</span><br><span class="line">  -J&lt;标记&gt;                     直接将 &lt;标记&gt; 传递给运行时系统</span><br><span class="line">  -Werror                    出现警告时终止编译</span><br><span class="line">  @&lt;文件名&gt;                     从文件读取选项和文件名</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">用法: javap &lt;options&gt; &lt;classes&gt;</span><br><span class="line">其中, 可能的选项包括:</span><br><span class="line">  -<span class="built_in">help</span>  --<span class="built_in">help</span>  -?        输出此用法消息</span><br><span class="line">  -version                 版本信息</span><br><span class="line">  -v  -verbose             输出附加信息</span><br><span class="line">  -l                       输出行号和本地变量表</span><br><span class="line">  -public                  仅显示公共类和成员</span><br><span class="line">  -protected               显示受保护的/公共类和成员</span><br><span class="line">  -package                 显示程序包/受保护的/公共类</span><br><span class="line">                           和成员 (默认)</span><br><span class="line">  -p  -private             显示所有类和成员</span><br><span class="line">  -c                       对代码进行反汇编</span><br><span class="line">  -s                       输出内部类型签名</span><br><span class="line">  -sysinfo                 显示正在处理的类的</span><br><span class="line">                           系统信息 (路径, 大小, 日期, MD5 散列)</span><br><span class="line">  -constants               显示最终常量</span><br><span class="line">  -classpath &lt;path&gt;        指定查找用户类文件的位置</span><br><span class="line">  -cp &lt;path&gt;               指定查找用户类文件的位置</span><br><span class="line">  -bootclasspath &lt;path&gt;    覆盖引导类文件的位置</span><br></pre></td></tr></table></figure>
<h1>二、入门实战</h1>
<h2 id="1、创建java源程序">1、创建java源程序</h2>
<p>​	新建<code>Hello.java</code>文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Hello hello = <span class="keyword">new</span> Hello();</span><br><span class="line">        hello.test1();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    	test2();</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;i++;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	String name = <span class="string">"shawn"</span>;</span><br><span class="line">        count++;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2、反编译JVM指令分析">2、反编译JVM指令分析</h2>
<p>​	在当前目录下打开Cmd，输入<code>javac Hello.java</code>后，成功将源文件编译成Hello.class文件，之后进行反编译，输入命令<code>javap -c Hello.class &gt; Hello.txt</code>将指令结果输出到txt文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Compiled from <span class="string">"Hello.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Hello</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0							<span class="comment">//从本地变量表中加载索引为0的变量的值，也即this的引用，压入栈</span></span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">       <span class="number">4</span>: aload_0</span><br><span class="line">       <span class="number">5</span>: iconst_0							<span class="comment">//将常量int型0推送至栈顶</span></span><br><span class="line">       6: putfield      #2                  // Field count:I，为指定的类的实例域赋值</span><br><span class="line">       <span class="number">9</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       0: new           #3                  // class Hello,创建一个对象，并将其引用值压入栈顶</span><br><span class="line">       <span class="number">3</span>: dup								<span class="comment">//将操作数栈定的数据复制一份，并压入栈，此时栈中有两个引用值</span></span><br><span class="line">       4: invokespecial #4                  // Method "&lt;init&gt;":()V,pop出栈引用值,调用其构造函数，完成对象的初始化</span><br><span class="line">       <span class="number">7</span>: astore_1							<span class="comment">//pop出栈引用值，将其（引用）赋值给局部变量表中的变量hello</span></span><br><span class="line">       <span class="number">8</span>: aload_1							<span class="comment">//将hello的引用值压入栈，因为hello.test1();调用了hello，这里使用aload_1从局部变量表中获得对应的变量hello的值并压入操作数栈</span></span><br><span class="line">       9: invokevirtual #5                  // Method test1:()V,引用出栈</span><br><span class="line">      <span class="number">12</span>: <span class="keyword">return</span>							<span class="comment">//整个main方法结束返回</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: iconst_0							<span class="comment">//将常量int型0推送至栈顶</span></span><br><span class="line">       <span class="number">1</span>: istore_1							<span class="comment">//将栈顶int型数值存入第二个本地变量</span></span><br><span class="line">       <span class="number">2</span>: aload_0							<span class="comment">//取this对应的对应引用值，压入操作数栈</span></span><br><span class="line">       3: invokevirtual #6                  // Method test2:()V</span><br><span class="line">       <span class="number">6</span>: iinc          <span class="number">1</span>, <span class="number">1</span>				<span class="comment">//将指定int型变量增加指定值（i++, i--, i+=2）</span></span><br><span class="line">       <span class="number">9</span>: goto          <span class="number">6</span>					<span class="comment">//程序跳转</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       0: ldc           #7                  // String shawn，从常量池中取出值压入栈</span><br><span class="line">       <span class="number">2</span>: astore_1							<span class="comment">//引用值出栈，赋值给局部变量表中变量name</span></span><br><span class="line">       <span class="number">3</span>: aload_0							<span class="comment">//取出this，压入栈</span></span><br><span class="line">       <span class="number">4</span>: dup								<span class="comment">//复制操作数栈栈顶的值，并压入栈，此时有两个this对象引用值在操作数组栈</span></span><br><span class="line">       5: getfield      #2                  // Field count:I,获取其count字段，然后压入栈，此时栈中有一个this和一个count的值</span><br><span class="line">       <span class="number">8</span>: iconst_1							<span class="comment">//取出一个int常量1,压入操作数栈</span></span><br><span class="line">       <span class="number">9</span>: iadd								<span class="comment">//从栈中取出count和1，将count值和1相加，结果入栈</span></span><br><span class="line">      10: putfield      #2                  // Field count:I,</span><br><span class="line">      13: getstatic     #8                  // Field  java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      <span class="number">16</span>: aload_1							<span class="comment">//将第二个引用输出类压入栈</span></span><br><span class="line">      17: invokevirtual #9                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">      <span class="number">20</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>三、总结与提高</h1>
<h2 id="1、总结">1、总结</h2>
<p>1、通过javap命令可以查看一个java类反汇编、常量池、变量表、指令代码行号表等等信息。</p>
<p>2、平常，我们比较关注的是java类中每个方法的反汇编中的指令操作过程，这些指令都是顺序执行的，</p>
<p>3、一个方法的执行通常会涉及下面几块内存的操作：</p>
<ul>
<li>
<p>java栈中：局部变量表、操作数栈。这些操作基本上都值操作。</p>
</li>
<li>
<p>java堆。通过对象的地址引用去操作。</p>
</li>
<li>
<p>常量池。</p>
</li>
<li>
<p>其他如帧数据区、方法区等部分</p>
</li>
</ul>
<p>在做值相关操作时：<br>
一个指令，可以从局部变量表、常量池、堆中对象、方法调用、系统调用中等取得数据，这些数据（可能是指，可能是对象的引用）被压入操作数栈。<br>
一个指令，也可以从操作数数栈中取出一到多个值（pop多次），完成赋值、加减乘除、方法传参、系统调用等等操作。</p>
<h2 id="2、提高">2、提高</h2>
<blockquote>
<p>官网JVM指令集：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5</a></p>
</blockquote>
<p>​	下面是较为常见的指令集，具体还可以参考《深入理解Java虚拟机第二版》、《Java虚拟机规范 JavaSE8版》两本书</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">指令码 助记符    说明</span><br><span class="line"><span class="number">0x00</span> nop        无操作</span><br><span class="line"><span class="number">0x01</span> aconst_null 将<span class="keyword">null</span>推送至栈顶</span><br><span class="line"><span class="number">0x02</span> iconst_m1    将<span class="keyword">int</span>型-<span class="number">1</span>推送至栈顶</span><br><span class="line"><span class="number">0x03</span> iconst_0    将<span class="keyword">int</span>型<span class="number">0</span>推送至栈顶</span><br><span class="line"><span class="number">0x04</span> iconst_1    将<span class="keyword">int</span>型<span class="number">1</span>推送至栈顶</span><br><span class="line"><span class="number">0x05</span> iconst_2    将<span class="keyword">int</span>型<span class="number">2</span>推送至栈顶</span><br><span class="line"><span class="number">0x06</span> iconst_3    将<span class="keyword">int</span>型<span class="number">3</span>推送至栈顶</span><br><span class="line"><span class="number">0x07</span> iconst_4    将<span class="keyword">int</span>型<span class="number">4</span>推送至栈顶</span><br><span class="line"><span class="number">0x08</span> iconst_5    将<span class="keyword">int</span>型<span class="number">5</span>推送至栈顶</span><br><span class="line"><span class="number">0x09</span> lconst_0    将<span class="keyword">long</span>型<span class="number">0</span>推送至栈顶</span><br><span class="line"><span class="number">0x0a</span> lconst_1    将<span class="keyword">long</span>型<span class="number">1</span>推送至栈顶</span><br><span class="line"><span class="number">0x0b</span> fconst_0    将<span class="keyword">float</span>型<span class="number">0</span>推送至栈顶</span><br><span class="line"><span class="number">0x0c</span> fconst_1    将<span class="keyword">float</span>型<span class="number">1</span>推送至栈顶</span><br><span class="line"><span class="number">0x0d</span> fconst_2    将<span class="keyword">float</span>型<span class="number">2</span>推送至栈顶</span><br><span class="line"><span class="number">0x0e</span> dconst_0    将<span class="keyword">double</span>型<span class="number">0</span>推送至栈顶</span><br><span class="line"><span class="number">0x0f</span> dconst_1    将<span class="keyword">double</span>型<span class="number">1</span>推送至栈顶</span><br><span class="line"><span class="number">0x10</span> bipush    将单字节的常量值(-<span class="number">128</span>~<span class="number">127</span>)推送至栈顶</span><br><span class="line"><span class="number">0x11</span> sipush    将一个短整型常量值(-<span class="number">32768</span>~<span class="number">32767</span>)推送至栈顶</span><br><span class="line"><span class="number">0x12</span> ldc    将<span class="keyword">int</span>, <span class="keyword">float</span>或String型常量值从常量池中推送至栈顶</span><br><span class="line"><span class="number">0x13</span> ldc_w    将<span class="keyword">int</span>, <span class="keyword">float</span>或String型常量值从常量池中推送至栈顶（宽索引）</span><br><span class="line"><span class="number">0x14</span> ldc2_w    将<span class="keyword">long</span>或<span class="keyword">double</span>型常量值从常量池中推送至栈顶（宽索引）</span><br><span class="line"><span class="number">0x15</span> iload    将指定的<span class="keyword">int</span>型本地变量推送至栈顶</span><br><span class="line"><span class="number">0x16</span> lload    将指定的<span class="keyword">long</span>型本地变量推送至栈顶</span><br><span class="line"><span class="number">0x17</span> fload    将指定的<span class="keyword">float</span>型本地变量推送至栈顶</span><br><span class="line"><span class="number">0x18</span> dload    将指定的<span class="keyword">double</span>型本地变量推送至栈顶</span><br><span class="line"><span class="number">0x19</span> aload    将指定的引用类型本地变量推送至栈顶</span><br><span class="line"><span class="number">0x1a</span> iload_0    将第一个<span class="keyword">int</span>型本地变量推送至栈顶</span><br><span class="line"><span class="number">0x1b</span> iload_1    将第二个<span class="keyword">int</span>型本地变量推送至栈顶</span><br><span class="line"><span class="number">0x1c</span> iload_2    将第三个<span class="keyword">int</span>型本地变量推送至栈顶</span><br><span class="line"><span class="number">0x1d</span> iload_3    将第四个<span class="keyword">int</span>型本地变量推送至栈顶</span><br><span class="line"><span class="number">0x1e</span> lload_0    将第一个<span class="keyword">long</span>型本地变量推送至栈顶</span><br><span class="line"><span class="number">0x1f</span> lload_1    将第二个<span class="keyword">long</span>型本地变量推送至栈顶</span><br><span class="line"><span class="number">0x20</span> lload_2    将第三个<span class="keyword">long</span>型本地变量推送至栈顶</span><br><span class="line"><span class="number">0x21</span> lload_3    将第四个<span class="keyword">long</span>型本地变量推送至栈顶</span><br><span class="line"><span class="number">0x22</span> fload_0    将第一个<span class="keyword">float</span>型本地变量推送至栈顶</span><br><span class="line"><span class="number">0x23</span> fload_1    将第二个<span class="keyword">float</span>型本地变量推送至栈顶</span><br><span class="line"><span class="number">0x24</span> fload_2    将第三个<span class="keyword">float</span>型本地变量推送至栈顶</span><br><span class="line"><span class="number">0x25</span> fload_3    将第四个<span class="keyword">float</span>型本地变量推送至栈顶</span><br><span class="line"><span class="number">0x26</span> dload_0    将第一个<span class="keyword">double</span>型本地变量推送至栈顶</span><br><span class="line"><span class="number">0x27</span> dload_1    将第二个<span class="keyword">double</span>型本地变量推送至栈顶</span><br><span class="line"><span class="number">0x28</span> dload_2    将第三个<span class="keyword">double</span>型本地变量推送至栈顶</span><br><span class="line"><span class="number">0x29</span> dload_3    将第四个<span class="keyword">double</span>型本地变量推送至栈顶</span><br><span class="line"><span class="number">0x2a</span> aload_0    将第一个引用类型本地变量推送至栈顶</span><br><span class="line"><span class="number">0x2b</span> aload_1    将第二个引用类型本地变量推送至栈顶</span><br><span class="line"><span class="number">0x2c</span> aload_2    将第三个引用类型本地变量推送至栈顶</span><br><span class="line"><span class="number">0x2d</span> aload_3    将第四个引用类型本地变量推送至栈顶</span><br><span class="line"><span class="number">0x2e</span> iaload    将<span class="keyword">int</span>型数组指定索引的值推送至栈顶</span><br><span class="line"><span class="number">0x2f</span> laload    将<span class="keyword">long</span>型数组指定索引的值推送至栈顶</span><br><span class="line"><span class="number">0x30</span> faload    将<span class="keyword">float</span>型数组指定索引的值推送至栈顶</span><br><span class="line"><span class="number">0x31</span> daload    将<span class="keyword">double</span>型数组指定索引的值推送至栈顶</span><br><span class="line"><span class="number">0x32</span> aaload    将引用型数组指定索引的值推送至栈顶</span><br><span class="line"><span class="number">0x33</span> baload    将<span class="keyword">boolean</span>或<span class="keyword">byte</span>型数组指定索引的值推送至栈顶</span><br><span class="line"><span class="number">0x34</span> caload    将<span class="keyword">char</span>型数组指定索引的值推送至栈顶</span><br><span class="line"><span class="number">0x35</span> saload    将<span class="keyword">short</span>型数组指定索引的值推送至栈顶</span><br><span class="line"><span class="number">0x36</span> istore    将栈顶<span class="keyword">int</span>型数值存入指定本地变量</span><br><span class="line"><span class="number">0x37</span> lstore    将栈顶<span class="keyword">long</span>型数值存入指定本地变量</span><br><span class="line"><span class="number">0x38</span> fstore    将栈顶<span class="keyword">float</span>型数值存入指定本地变量</span><br><span class="line"><span class="number">0x39</span> dstore    将栈顶<span class="keyword">double</span>型数值存入指定本地变量</span><br><span class="line"><span class="number">0x3a</span> astore    将栈顶引用型数值存入指定本地变量</span><br><span class="line"><span class="number">0x3b</span> istore_0    将栈顶<span class="keyword">int</span>型数值存入第一个本地变量</span><br><span class="line"><span class="number">0x3c</span> istore_1    将栈顶<span class="keyword">int</span>型数值存入第二个本地变量</span><br><span class="line"><span class="number">0x3d</span> istore_2    将栈顶<span class="keyword">int</span>型数值存入第三个本地变量</span><br><span class="line"><span class="number">0x3e</span> istore_3    将栈顶<span class="keyword">int</span>型数值存入第四个本地变量</span><br><span class="line"><span class="number">0x3f</span> lstore_0    将栈顶<span class="keyword">long</span>型数值存入第一个本地变量</span><br><span class="line"><span class="number">0x40</span> lstore_1    将栈顶<span class="keyword">long</span>型数值存入第二个本地变量</span><br><span class="line"><span class="number">0x41</span> lstore_2    将栈顶<span class="keyword">long</span>型数值存入第三个本地变量</span><br><span class="line"><span class="number">0x42</span> lstore_3    将栈顶<span class="keyword">long</span>型数值存入第四个本地变量</span><br><span class="line"><span class="number">0x43</span> fstore_0    将栈顶<span class="keyword">float</span>型数值存入第一个本地变量</span><br><span class="line"><span class="number">0x44</span> fstore_1    将栈顶<span class="keyword">float</span>型数值存入第二个本地变量</span><br><span class="line"><span class="number">0x45</span> fstore_2    将栈顶<span class="keyword">float</span>型数值存入第三个本地变量</span><br><span class="line"><span class="number">0x46</span> fstore_3    将栈顶<span class="keyword">float</span>型数值存入第四个本地变量</span><br><span class="line"><span class="number">0x47</span> dstore_0    将栈顶<span class="keyword">double</span>型数值存入第一个本地变量</span><br><span class="line"><span class="number">0x48</span> dstore_1    将栈顶<span class="keyword">double</span>型数值存入第二个本地变量</span><br><span class="line"><span class="number">0x49</span> dstore_2    将栈顶<span class="keyword">double</span>型数值存入第三个本地变量</span><br><span class="line"><span class="number">0x4a</span> dstore_3    将栈顶<span class="keyword">double</span>型数值存入第四个本地变量</span><br><span class="line"><span class="number">0x4b</span> astore_0    将栈顶引用型数值存入第一个本地变量</span><br><span class="line"><span class="number">0x4c</span> astore_1    将栈顶引用型数值存入第二个本地变量</span><br><span class="line"><span class="number">0x4d</span> astore_2    将栈顶引用型数值存入第三个本地变量</span><br><span class="line"><span class="number">0x4e</span> astore_3    将栈顶引用型数值存入第四个本地变量</span><br><span class="line"><span class="number">0x4f</span> iastore    将栈顶<span class="keyword">int</span>型数值存入指定数组的指定索引位置</span><br><span class="line"><span class="number">0x50</span> lastore    将栈顶<span class="keyword">long</span>型数值存入指定数组的指定索引位置</span><br><span class="line"><span class="number">0x51</span> fastore    将栈顶<span class="keyword">float</span>型数值存入指定数组的指定索引位置</span><br><span class="line"><span class="number">0x52</span> dastore    将栈顶<span class="keyword">double</span>型数值存入指定数组的指定索引位置</span><br><span class="line"><span class="number">0x53</span> aastore    将栈顶引用型数值存入指定数组的指定索引位置</span><br><span class="line"><span class="number">0x54</span> bastore    将栈顶<span class="keyword">boolean</span>或<span class="keyword">byte</span>型数值存入指定数组的指定索引位置</span><br><span class="line"><span class="number">0x55</span> castore    将栈顶<span class="keyword">char</span>型数值存入指定数组的指定索引位置</span><br><span class="line"><span class="number">0x56</span> sastore    将栈顶<span class="keyword">short</span>型数值存入指定数组的指定索引位置</span><br><span class="line"><span class="number">0x57</span> pop     将栈顶数值弹出 (数值不能是<span class="keyword">long</span>或<span class="keyword">double</span>类型的)</span><br><span class="line"><span class="number">0x58</span> pop2    将栈顶的一个（<span class="keyword">long</span>或<span class="keyword">double</span>类型的)或两个数值弹出（其它）</span><br><span class="line"><span class="number">0x59</span> dup     复制栈顶数值并将复制值压入栈顶</span><br><span class="line"><span class="number">0x5a</span> dup_x1    复制栈顶数值并将两个复制值压入栈顶</span><br><span class="line"><span class="number">0x5b</span> dup_x2    复制栈顶数值并将三个（或两个）复制值压入栈顶</span><br><span class="line"><span class="number">0x5c</span> dup2    复制栈顶一个（<span class="keyword">long</span>或<span class="keyword">double</span>类型的)或两个（其它）数值并将复制值压入栈顶</span><br><span class="line"><span class="number">0x5d</span> dup2_x1    复制栈顶的一个或两个值，将其插入栈顶那两个或三个值的下面</span><br><span class="line"><span class="number">0x5e</span> dup2_x2    复制栈顶的一个或两个值，将其插入栈顶那两个、三个或四个值的下面</span><br><span class="line"><span class="number">0x5f</span> swap    将栈最顶端的两个数值互换(数值不能是<span class="keyword">long</span>或<span class="keyword">double</span>类型的)</span><br><span class="line"><span class="number">0x60</span> iadd    将栈顶两<span class="keyword">int</span>型数值相加并将结果压入栈顶</span><br><span class="line"><span class="number">0x61</span> ladd    将栈顶两<span class="keyword">long</span>型数值相加并将结果压入栈顶</span><br><span class="line"><span class="number">0x62</span> fadd    将栈顶两<span class="keyword">float</span>型数值相加并将结果压入栈顶</span><br><span class="line"><span class="number">0x63</span> dadd    将栈顶两<span class="keyword">double</span>型数值相加并将结果压入栈顶</span><br><span class="line"><span class="number">0x64</span> isub    将栈顶两<span class="keyword">int</span>型数值相减并将结果压入栈顶</span><br><span class="line"><span class="number">0x65</span> lsub    将栈顶两<span class="keyword">long</span>型数值相减并将结果压入栈顶</span><br><span class="line"><span class="number">0x66</span> fsub    将栈顶两<span class="keyword">float</span>型数值相减并将结果压入栈顶</span><br><span class="line"><span class="number">0x67</span> dsub    将栈顶两<span class="keyword">double</span>型数值相减并将结果压入栈顶</span><br><span class="line"><span class="number">0x68</span> imul    将栈顶两<span class="keyword">int</span>型数值相乘并将结果压入栈顶</span><br><span class="line"><span class="number">0x69</span> lmul    将栈顶两<span class="keyword">long</span>型数值相乘并将结果压入栈顶</span><br><span class="line"><span class="number">0x6a</span> fmul    将栈顶两<span class="keyword">float</span>型数值相乘并将结果压入栈顶</span><br><span class="line"><span class="number">0x6b</span> dmul    将栈顶两<span class="keyword">double</span>型数值相乘并将结果压入栈顶</span><br><span class="line"><span class="number">0x6c</span> idiv    将栈顶两<span class="keyword">int</span>型数值相除并将结果压入栈顶</span><br><span class="line"><span class="number">0x6d</span> ldiv    将栈顶两<span class="keyword">long</span>型数值相除并将结果压入栈顶</span><br><span class="line"><span class="number">0x6e</span> fdiv    将栈顶两<span class="keyword">float</span>型数值相除并将结果压入栈顶</span><br><span class="line"><span class="number">0x6f</span> ddiv    将栈顶两<span class="keyword">double</span>型数值相除并将结果压入栈顶</span><br><span class="line"><span class="number">0x70</span> irem    将栈顶两<span class="keyword">int</span>型数值作取模运算并将结果压入栈顶</span><br><span class="line"><span class="number">0x71</span> lrem    将栈顶两<span class="keyword">long</span>型数值作取模运算并将结果压入栈顶</span><br><span class="line"><span class="number">0x72</span> frem    将栈顶两<span class="keyword">float</span>型数值作取模运算并将结果压入栈顶</span><br><span class="line"><span class="number">0x73</span> drem    将栈顶两<span class="keyword">double</span>型数值作取模运算并将结果压入栈顶</span><br><span class="line"><span class="number">0x74</span> ineg    将栈顶<span class="keyword">int</span>型数值取负并将结果压入栈顶</span><br><span class="line"><span class="number">0x75</span> lneg    将栈顶<span class="keyword">long</span>型数值取负并将结果压入栈顶</span><br><span class="line"><span class="number">0x76</span> fneg    将栈顶<span class="keyword">float</span>型数值取负并将结果压入栈顶</span><br><span class="line"><span class="number">0x77</span> dneg    将栈顶<span class="keyword">double</span>型数值取负并将结果压入栈顶</span><br><span class="line"><span class="number">0x78</span> ishl    将<span class="keyword">int</span>型数值左移位指定位数并将结果压入栈顶</span><br><span class="line"><span class="number">0x79</span> lshl    将<span class="keyword">long</span>型数值左移位指定位数并将结果压入栈顶</span><br><span class="line"><span class="number">0x7a</span> ishr    将<span class="keyword">int</span>型数值右（符号）移位指定位数并将结果压入栈顶</span><br><span class="line"><span class="number">0x7b</span> lshr    将<span class="keyword">long</span>型数值右（符号）移位指定位数并将结果压入栈顶</span><br><span class="line"><span class="number">0x7c</span> iushr    将<span class="keyword">int</span>型数值右（无符号）移位指定位数并将结果压入栈顶</span><br><span class="line"><span class="number">0x7d</span> lushr    将<span class="keyword">long</span>型数值右（无符号）移位指定位数并将结果压入栈顶</span><br><span class="line"><span class="number">0x7e</span> iand    将栈顶两<span class="keyword">int</span>型数值作“按位与”并将结果压入栈顶</span><br><span class="line"><span class="number">0x7f</span> land    将栈顶两<span class="keyword">long</span>型数值作“按位与”并将结果压入栈顶</span><br><span class="line"><span class="number">0x80</span> ior     将栈顶两<span class="keyword">int</span>型数值作“按位或”并将结果压入栈顶</span><br><span class="line"><span class="number">0x81</span> lor     将栈顶两<span class="keyword">long</span>型数值作“按位或”并将结果压入栈顶</span><br><span class="line"><span class="number">0x82</span> ixor    将栈顶两<span class="keyword">int</span>型数值作“按位异或”并将结果压入栈顶</span><br><span class="line"><span class="number">0x83</span> lxor    将栈顶两<span class="keyword">long</span>型数值作“按位异或”并将结果压入栈顶</span><br><span class="line"><span class="number">0x84</span> iinc    将指定<span class="keyword">int</span>型变量增加指定值（i++, i--, i+=<span class="number">2</span>）</span><br><span class="line"><span class="number">0x85</span> i2l     将栈顶<span class="keyword">int</span>型数值强制转换成<span class="keyword">long</span>型数值并将结果压入栈顶</span><br><span class="line"><span class="number">0x86</span> i2f     将栈顶<span class="keyword">int</span>型数值强制转换成<span class="keyword">float</span>型数值并将结果压入栈顶</span><br><span class="line"><span class="number">0x87</span> i2d     将栈顶<span class="keyword">int</span>型数值强制转换成<span class="keyword">double</span>型数值并将结果压入栈顶</span><br><span class="line"><span class="number">0x88</span> l2i     将栈顶<span class="keyword">long</span>型数值强制转换成<span class="keyword">int</span>型数值并将结果压入栈顶</span><br><span class="line"><span class="number">0x89</span> l2f     将栈顶<span class="keyword">long</span>型数值强制转换成<span class="keyword">float</span>型数值并将结果压入栈顶</span><br><span class="line"><span class="number">0x8a</span> l2d     将栈顶<span class="keyword">long</span>型数值强制转换成<span class="keyword">double</span>型数值并将结果压入栈顶</span><br><span class="line"><span class="number">0x8b</span> f2i     将栈顶<span class="keyword">float</span>型数值强制转换成<span class="keyword">int</span>型数值并将结果压入栈顶</span><br><span class="line"><span class="number">0x8c</span> f2l     将栈顶<span class="keyword">float</span>型数值强制转换成<span class="keyword">long</span>型数值并将结果压入栈顶</span><br><span class="line"><span class="number">0x8d</span> f2d     将栈顶<span class="keyword">float</span>型数值强制转换成<span class="keyword">double</span>型数值并将结果压入栈顶</span><br><span class="line"><span class="number">0x8e</span> d2i     将栈顶<span class="keyword">double</span>型数值强制转换成<span class="keyword">int</span>型数值并将结果压入栈顶</span><br><span class="line"><span class="number">0x8f</span> d2l     将栈顶<span class="keyword">double</span>型数值强制转换成<span class="keyword">long</span>型数值并将结果压入栈顶</span><br><span class="line"><span class="number">0x90</span> d2f     将栈顶<span class="keyword">double</span>型数值强制转换成<span class="keyword">float</span>型数值并将结果压入栈顶</span><br><span class="line"><span class="number">0x91</span> i2b     将栈顶<span class="keyword">int</span>型数值强制转换成<span class="keyword">byte</span>型数值并将结果压入栈顶</span><br><span class="line"><span class="number">0x92</span> i2c     将栈顶<span class="keyword">int</span>型数值强制转换成<span class="keyword">char</span>型数值并将结果压入栈顶</span><br><span class="line"><span class="number">0x93</span> i2s     将栈顶<span class="keyword">int</span>型数值强制转换成<span class="keyword">short</span>型数值并将结果压入栈顶</span><br><span class="line"><span class="number">0x94</span> lcmp    比较栈顶两<span class="keyword">long</span>型数值大小，并将结果（<span class="number">1</span>，<span class="number">0</span>，-<span class="number">1</span>）压入栈顶</span><br><span class="line"><span class="number">0x95</span> fcmpl    比较栈顶两<span class="keyword">float</span>型数值大小，并将结果（<span class="number">1</span>，<span class="number">0</span>，-<span class="number">1</span>）压入栈顶；当其中一个数值为NaN时，将-<span class="number">1</span>压入栈顶</span><br><span class="line"><span class="number">0x96</span> fcmpg    比较栈顶两<span class="keyword">float</span>型数值大小，并将结果（<span class="number">1</span>，<span class="number">0</span>，-<span class="number">1</span>）压入栈顶；当其中一个数值为NaN时，将<span class="number">1</span>压入栈顶</span><br><span class="line"><span class="number">0x97</span> dcmpl    比较栈顶两<span class="keyword">double</span>型数值大小，并将结果（<span class="number">1</span>，<span class="number">0</span>，-<span class="number">1</span>）压入栈顶；当其中一个数值为NaN时，将-<span class="number">1</span>压入栈顶</span><br><span class="line"><span class="number">0x98</span> dcmpg    比较栈顶两<span class="keyword">double</span>型数值大小，并将结果（<span class="number">1</span>，<span class="number">0</span>，-<span class="number">1</span>）压入栈顶；当其中一个数值为NaN时，将<span class="number">1</span>压入栈顶</span><br><span class="line"><span class="number">0x99</span> ifeq    当栈顶<span class="keyword">int</span>型数值等于<span class="number">0</span>时跳转</span><br><span class="line"><span class="number">0x9a</span> ifne    当栈顶<span class="keyword">int</span>型数值不等于<span class="number">0</span>时跳转</span><br><span class="line"><span class="number">0x9b</span> iflt    当栈顶<span class="keyword">int</span>型数值小于<span class="number">0</span>时跳转</span><br><span class="line"><span class="number">0x9c</span> ifge    当栈顶<span class="keyword">int</span>型数值大于等于<span class="number">0</span>时跳转</span><br><span class="line"><span class="number">0x9d</span> ifgt    当栈顶<span class="keyword">int</span>型数值大于<span class="number">0</span>时跳转</span><br><span class="line"><span class="number">0x9e</span> ifle    当栈顶<span class="keyword">int</span>型数值小于等于<span class="number">0</span>时跳转</span><br><span class="line"><span class="number">0x9f</span> if_icmpeq    比较栈顶两<span class="keyword">int</span>型数值大小，当结果等于<span class="number">0</span>时跳转</span><br><span class="line"><span class="number">0xa0</span> if_icmpne    比较栈顶两<span class="keyword">int</span>型数值大小，当结果不等于<span class="number">0</span>时跳转</span><br><span class="line"><span class="number">0xa1</span> if_icmplt    比较栈顶两<span class="keyword">int</span>型数值大小，当结果小于<span class="number">0</span>时跳转</span><br><span class="line"><span class="number">0xa2</span> if_icmpge    比较栈顶两<span class="keyword">int</span>型数值大小，当结果大于等于<span class="number">0</span>时跳转</span><br><span class="line"><span class="number">0xa3</span> if_icmpgt    比较栈顶两<span class="keyword">int</span>型数值大小，当结果大于<span class="number">0</span>时跳转</span><br><span class="line"><span class="number">0xa4</span> if_icmple    比较栈顶两<span class="keyword">int</span>型数值大小，当结果小于等于<span class="number">0</span>时跳转</span><br><span class="line"><span class="number">0xa5</span> if_acmpeq    比较栈顶两引用型数值，当结果相等时跳转</span><br><span class="line"><span class="number">0xa6</span> if_acmpne    比较栈顶两引用型数值，当结果不相等时跳转</span><br><span class="line"><span class="number">0xa7</span> goto    无条件跳转</span><br><span class="line"><span class="number">0xa8</span> jsr     跳转至指定<span class="number">16</span>位offset位置，并将jsr下一条指令地址压入栈顶</span><br><span class="line"><span class="number">0xa9</span> ret     返回至本地变量指定的index的指令位置（一般与jsr, jsr_w联合使用）</span><br><span class="line"><span class="number">0xaa</span> tableswitch    用于<span class="keyword">switch</span>条件跳转，<span class="keyword">case</span>值连续（可变长度指令）</span><br><span class="line"><span class="number">0xab</span> lookupswitch    用于<span class="keyword">switch</span>条件跳转，<span class="keyword">case</span>值不连续（可变长度指令）</span><br><span class="line"><span class="number">0xac</span> ireturn    从当前方法返回<span class="keyword">int</span></span><br><span class="line"><span class="number">0xad</span> lreturn    从当前方法返回<span class="keyword">long</span></span><br><span class="line"><span class="number">0xae</span> freturn    从当前方法返回<span class="keyword">float</span></span><br><span class="line"><span class="number">0xaf</span> dreturn    从当前方法返回<span class="keyword">double</span></span><br><span class="line"><span class="number">0xb0</span> areturn    从当前方法返回对象引用</span><br><span class="line"><span class="number">0xb1</span> <span class="keyword">return</span>    从当前方法返回<span class="keyword">void</span></span><br><span class="line"><span class="number">0xb2</span> getstatic    获取指定类的静态域，并将其值压入栈顶</span><br><span class="line"><span class="number">0xb3</span> putstatic    为指定的类的静态域赋值</span><br><span class="line"><span class="number">0xb4</span> getfield    获取指定类的实例域，并将其值压入栈顶</span><br><span class="line"><span class="number">0xb5</span> putfield    为指定的类的实例域赋值</span><br><span class="line"><span class="number">0xb6</span> invokevirtual    调用实例方法</span><br><span class="line"><span class="number">0xb7</span> invokespecial    调用超类构造方法，实例初始化方法，私有方法</span><br><span class="line"><span class="number">0xb8</span> invokestatic    调用静态方法</span><br><span class="line"><span class="number">0xb9</span> invokeinterface 调用接口方法</span><br><span class="line"><span class="number">0xba</span> invokedynamic  调用动态链接方法</span><br><span class="line"><span class="number">0xbb</span> <span class="keyword">new</span>     创建一个对象，并将其引用值压入栈顶</span><br><span class="line"><span class="number">0xbc</span> newarray    创建一个指定原始类型（如<span class="keyword">int</span>, <span class="keyword">float</span>, <span class="keyword">char</span>…）的数组，并将其引用值压入栈顶</span><br><span class="line"><span class="number">0xbd</span> anewarray    创建一个引用型（如类，接口，数组）的数组，并将其引用值压入栈顶</span><br><span class="line"><span class="number">0xbe</span> arraylength 获得数组的长度值并压入栈顶</span><br><span class="line"><span class="number">0xbf</span> athrow    将栈顶的异常抛出</span><br><span class="line"><span class="number">0xc0</span> checkcast    检验类型转换，检验未通过将抛出ClassCastException</span><br><span class="line"><span class="number">0xc1</span> <span class="keyword">instanceof</span> 检验对象是否是指定的类的实例，如果是将<span class="number">1</span>压入栈顶，否则将<span class="number">0</span>压入栈顶</span><br><span class="line"><span class="number">0xc2</span> monitorenter    获得对象的锁，用于同步方法或同步块</span><br><span class="line"><span class="number">0xc3</span> monitorexit    释放对象的锁，用于同步方法或同步块</span><br><span class="line"><span class="number">0xc4</span> wide    扩大本地变量索引的宽度</span><br><span class="line"><span class="number">0xc5</span> multianewarray 创建指定类型和指定维度的多维数组（执行该指令时，操作栈中必须包含各维度的长度值），并将其引用值压入栈顶</span><br><span class="line"><span class="number">0xc6</span> ifnull    为<span class="keyword">null</span>时跳转</span><br><span class="line"><span class="number">0xc7</span> ifnonnull    不为<span class="keyword">null</span>时跳转</span><br><span class="line"><span class="number">0xc8</span> goto_w    无条件跳转</span><br><span class="line"><span class="number">0xc9</span> jsr_w    跳转至指定<span class="number">32</span>位offset位置，并将jsr_w下一条指令地址压入栈顶</span><br><span class="line">============================================</span><br><span class="line"><span class="number">0xca</span> breakpoint  调试时的断点标记</span><br><span class="line"><span class="number">0xfe</span> impdep1    为特定软件而预留的语言后门</span><br><span class="line"><span class="number">0xff</span> impdep2    为特定硬件而预留的语言后门</span><br><span class="line">最后三个为保留指令</span><br></pre></td></tr></table></figure>
<hr>
<p>参考文章：</p>
<p><a href="https://blog.csdn.net/u012988901/article/details/99852568" target="_blank" rel="noopener">https://blog.csdn.net/u012988901/article/details/99852568</a></p>
<p><a href="https://www.jianshu.com/p/6a8997560b05" target="_blank" rel="noopener">https://www.jianshu.com/p/6a8997560b05</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot父子工程</title>
    <url>/posts/b59fddd6.html</url>
    <content><![CDATA[<h1>一、SpringBoot聚合项目</h1>
<h2 id="1、创建父工程">1、创建父工程</h2>
<p><strong>新建工程，选择Spring initializer</strong></p>
<p><img src="https://img-blog.csdnimg.cn/b125c40c1b2546b2a1b10094effafb69.png" alt></p>
<p><strong>填写好项目名称等</strong></p>
<p><img src="https://img-blog.csdnimg.cn/051ae22391f1409091e10b105421d6d2.png" alt></p>
<p><strong>不勾选任何依赖，最后选择好项目存储位置，点击创建</strong></p>
<p><img src="https://img-blog.csdnimg.cn/0239a59a4a29431383ca533b5d48b744.png" alt></p>
<p><strong>删除不必要的文件</strong></p>
<p>保留父工程项目必要的文件</p>
<p><img src="https://img-blog.csdnimg.cn/e4c281cdc05340e08b812966e755fd95.png" alt></p>
<p><code>.gitignore</code>：分布式版本控制系统git的配置文件，意思为忽略提交<br>
<code>mvnw</code>：全名是maven wrapper的文件，作用是在maven-wrapper.properties文件中记录你要使用的maven版本，当用户执行mvnw clean 命令时，发现当前用户的maven版本和期望的版本不一致，那么就下载期望的版本，然后用期望的版本来执行mvn命令，比如mvn clean命令。<br>
<code>.mvn</code>文件夹：存放mvnw相关文件<br>
<code>mvnw.cmd</code>：执行mvnw命令的cmd入口。其中mvnw文件适用于Linux（bash），mvnw.cmd适用于Windows 环境。<br>
<code>.iml</code>文件：intellij idea的工程配置文件，里面包含当前project的一些配置信息，如模块开发的相关信息，比如java组件，maven组件，插件组件等，还可能会存储一些模块路径信息，依赖信息以及一些别的信息。<br>
<code>.idea</code>文件夹：存放项目的配置信息，包括数据源，类库，项目字符编码，历史记录，版本控制信息等。<code>pom.xml</code>：项目对象模型（核心重要）</p>
<h2 id="2、创建子工程">2、创建子工程</h2>
<p><strong>新建Module</strong></p>
<p><img src="https://img-blog.csdnimg.cn/45564d3c3b2e46239c0f78c36c1d1f6d.png" alt></p>
<p><strong>选择Spring Initializer，也可直接选择新建空Maven项目</strong></p>
<p><img src="https://img-blog.csdnimg.cn/cce6dbca187645308f30f44771451e9e.png" alt></p>
<p><strong>设置子模块信息</strong></p>
<p><img src="https://img-blog.csdnimg.cn/3d9062abf3314f2f9f34f76f0151cd88.png" alt></p>
<p>类似可以创建多个子模块</p>
<h2 id="3、父子模块配置文件设置">3、父子模块配置文件设置</h2>
<h3 id="3-1-父模块pom-xml文件">3.1 父模块pom.xml文件</h3>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--全局定义springboot父项目版本号--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目描述--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zstu<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lamp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>intelligent-lamp<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>智能灯项目<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--packageing需要指定为pom--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目的打包类型：pom、jar、war</span></span><br><span class="line"><span class="comment">        packing默认是jar类型，</span></span><br><span class="line"><span class="comment">        pom  父类型都为pom类型</span></span><br><span class="line"><span class="comment">        jar  内部调用或者是作服务使用</span></span><br><span class="line"><span class="comment">        war - 需要部署的项目--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--子工程目录，每添加一个model，需要将子工程的model名注册到此--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>childserver<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--定义springcloud使用版本号等属性信息--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">lombok.version</span>&gt;</span>1.18.12<span class="tag">&lt;/<span class="name">lombok.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">fastjson.version</span>&gt;</span>1.2.76<span class="tag">&lt;/<span class="name">fastjson.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--引入全体项目都需要的父依赖，引入后，子项目不需要引入，继承父项目就可以--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--全局管理依赖,并不会引入具体依赖--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--只是依赖的声明，并不实现引入，因此子项目需要显式的声明需要用的依赖，这样做的好处是可以方便进行版本控制--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;lombok.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;fastjson.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="3-2-子模块pom-xml文件">3.2 子模块pom.xml文件</h3>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 确认父子工程继承关系 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--父工程 groupId--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zstu<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--父工程 artifactId--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lamp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--父工程 版本--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zstu<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>childserver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>childserver<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>子工程<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--这里由父工程控制版本信息--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--重命名打包--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>child-module<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            Maven区别对待Java代码文件和资源文件，maven-compiler-plugin用来编译Java代码</span></span><br><span class="line"><span class="comment">            maven-resources-plugin则用来处理资源文件</span></span><br><span class="line"><span class="comment">            --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--如果子项目并不是单独的springboot项目，不能独立启动，则父工程不能使用此插件，应该放在能启动服务的子项目中--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--boot项目使用boot打包插件--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!-- 如果没有该配置，devtools不会生效 --&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!-- 指定该Main Class为全局的唯一入口 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>com.zstu.childserver.ChildserverApplication<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">layout</span>&gt;</span>ZIP<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--分类器：可执行jar包重命名--&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">classifier</span>&gt;</span>exec<span class="tag">&lt;/<span class="name">classifier</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!--可以把依赖的包都打包到生成的可执行Jar包中--&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>repackage<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="4、工程打包">4、工程打包</h2>
<h3 id="4-1-打包流程">4.1 打包流程</h3>
<p>创建好基础的web服务后，首先需要在父工程的maven管理下进行<code>mvn clean</code>，之后进行<code>mvn install</code>，最后可以进行子服务的打包<code>mvn package</code></p>
<p><img src="https://img-blog.csdnimg.cn/af35f3130a2147e39112364097e4ad10.png" alt></p>
<h3 id="4-2-多项目打包常见问题">4.2 多项目打包常见问题</h3>
<ul>
<li>如果子项目并不是单独的springboot项目，不能独立启动，则父工程不能使用此插件，应该放在能启动服务的子项目中</li>
<li>对于多项目，springboot启动类的默认扫描路径是该类所在的包下面的所有java类，若访问的为不同模块，则需要配置扫描包，例如我的配置<code>@SpringBootApplication(scanBasePackages = &quot;com.zstu.*&quot;)</code></li>
<li>若子项目需要依赖另一子项目文件，则需要在<code>pom.xml</code>中配置<code>&lt;dependency&gt;</code>依赖进行引入</li>
<li>聚合项目存在第二个模块依赖第一个模块，需要引入jar包，编码调试一切正常。但<code>mvn install</code>第二个项目的时候会提示找不到jar包里的类。原因  : <strong>spring-boot-maven-plugin打包出来的jar是不可依赖的</strong>，<strong>所以只需要在被依赖的包（也就是第一个模块中）去掉spring-boot-maven-plugin即可打包成功</strong></li>
</ul>
<h2 id="5、Spring打包插件详解">5、Spring打包插件详解</h2>
<blockquote>
<p><a href="https://docs.spring.io/spring-boot/docs/current/maven-plugin/reference/htmlsingle/" target="_blank" rel="noopener">Spring Boot Maven plugin官方文档</a></p>
</blockquote>
<p>Spring Boot Maven plugin的5个Goals</p>
<ul>
<li><strong>spring-boot:repackage</strong>：默认goal。在mvn package之后，再次打包可执行的jar/war，同时保留mvn package生成的jar/war为.origin</li>
<li><strong>spring-boot:run</strong>：运行Spring Boot应用</li>
<li><strong>spring-boot:start</strong>：在mvn integration-test阶段，进行Spring Boot应用生命周期的管理</li>
<li><strong>spring-boot:stop</strong>：在mvn integration-test阶段，进行Spring Boot应用生命周期的管理</li>
<li><strong>spring-boot:build-info</strong>：生成Actuator使用的构建信息文件build-info.properties</li>
</ul>
<p>一旦 <code>spring-boot-maven-plugin</code> 被添加到 <code>pom.xml</code>，就可以使用goal <code>spring-boot:repackage</code> 生成可执行文件。可以通过<code>pom.xml</code>文件的<code>packaging</code>配置节告诉插件生成的是<code>jar</code>包还是<code>war</code>包.</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span> <span class="comment">&lt;!-- 改成provided之后，tomcat 就不会打包进war文件  --&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>repackage<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1>二、多环境配置与切换</h1>
<h2 id="1、介绍">1、介绍</h2>
<p>多环境是最常见的<code>配置隔离</code>方式之一，可以根据不同的运行环境提供不同的配置信息来应对不同的业务场景，在<code>SpringBoot</code>内支持了多种配置隔离的方式，可以激活单个或者多个配置文件</p>
<h2 id="2、spring自带方式切换环境">2、spring自带方式切换环境</h2>
<h3 id="2-1-简单实现步骤">2.1 简单实现步骤</h3>
<p>首先创建几个不同环境的配置文件，<code>application-{profile}.properties(.yaml/.yml)</code>，其中<code>profile</code>可以根据自己的需求来定义，这里我定义了三种环境(开发、测试和生产环境)</p>
<p><img src="https://img-blog.csdnimg.cn/54773f09cce1404f963893246733e82b.png?type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6a2FTGVtb24=,size_16,color_FFFFFF,t_70,g_se,x_16" alt></p>
<p>在<code>application-dev.yml</code>等文件写入相应的信息</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#开发环境</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br></pre></td></tr></table></figure>
<p>在<code>application.yml</code>设置环境</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br></pre></td></tr></table></figure>
<p>最后运行、部署就会按照对应的环境运行</p>
<p>当然这里也可以把多文件内容放在同一个文件中，即<code>application.yml</code>(不推荐)</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开发环境</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">dev</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># 测试环境</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8082</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">test</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># 生产环境</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8083</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">prod</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 用来动态选择 开发、测试、生产的运行环境的配置文件的</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br></pre></td></tr></table></figure>
<h3 id="2-2-其他方式激活profiles">2.2 其他方式激活profiles</h3>
<ul>
<li><strong>命令行方式</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nohup java -jar child-module-exec.jar --spring.profiles.active=dev &gt; child-module-exec.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>系统变量方式</strong></li>
</ul>
<p>系统变量的方式适用于系统下所部署统一环境的<code>SpringBoot</code>应用程序，如统一部署的都是<code>prod</code>环境的应用程序。编辑环境变量配置文件<code>/etc/profile</code>，添加名为<code>SPRING_PROFILES_ACTIVE</code>的环境变量。注意：<code>-D</code>方式设置<code>Java系统属性</code>要在<code>-jar</code>前定义。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># spring 环境激活</span></span><br><span class="line"><span class="built_in">export</span> SPRING_PROFILES_ACTIVE=dev</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Java系统属性方式</strong></li>
</ul>
<p><code>Java系统属性方式</code>也是一种外部配置的方式，在执行<code>java -jar</code>命令时可以通过<code>-Dspring.profiles.active=test</code>的方式进行激活指定的<code>profiles</code>列表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nohup java -Dspring.profiles.active=dev -jar child-module-exec.jar &gt; child-module-exec.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>配置文件方式(2.1已介绍)</strong></li>
</ul>
<p><strong>上述四种方式的优先级为：命令行方式 &gt; Java系统属性方式 &gt; 系统变量方式 &gt; 配置文件方式</strong></p>
<h2 id="3、idea-maven多环境配置">3、idea+maven多环境配置</h2>
<h3 id="3-1-配置步骤">3.1 配置步骤</h3>
<p>首先仍然和2.1一样创建好几种不同的环境配置，但是<code>application.yml</code>需要修改部分内容</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="comment"># 如果不添加引号的话，程序启动无法识别，会报错导致启动失败</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">'@env@'</span></span><br></pre></td></tr></table></figure>
<p>在子模块的<code>pom.xml</code>中配置，<strong>filtering配置必须设置为true</strong>，这样Filtering 默认的过滤符号就从 <code>${*}</code> 改为 <code>@...@</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--重命名打包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>child-module<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        Maven区别对待Java代码文件和资源文件，maven-compiler-plugin用来编译Java代码</span></span><br><span class="line"><span class="comment">        maven-resources-plugin则用来处理资源文件</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--如果子项目并不是单独的springboot项目，不能独立启动，则父工程不能使用此插件，应该放在能启动服务的子项目中--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--boot项目使用boot打包插件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">classifier</span>&gt;</span>exec<span class="tag">&lt;/<span class="name">classifier</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--可以把依赖的包都打包到生成的可执行Jar包中--&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>repackage<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--   指定配置文件的位置  --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--   读取resources下的所有文件，include表示指定文件内的，相对的还有excludes ，排除其下的文件 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 开启替换标签，比如我们的'@env'就是通过这个替换的 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>因为是多模块项目，这里将Profiles配置放在了父模块的<code>pom.xml</code>中</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置不同的profile，对应不同的生产环境--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--开发--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--默认开发环境--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--自定义的变量名称env作为标签，标签内是我们配置文件不同环境的后缀 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">env</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">env</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--生产--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>prod<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">env</span>&gt;</span>prod<span class="tag">&lt;/<span class="name">env</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--测试--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>test<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">env</span>&gt;</span>test<span class="tag">&lt;/<span class="name">env</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>此时在Idea的右侧可以发现Profiles属性，选择相应的环境，子模块打包即为相应环境的配置<br>
<img src="https://img-blog.csdnimg.cn/1587f5e3da6546329aa37709178a2e32.png?type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6a2FTGVtb24=,size_20,color_FFFFFF,t_70,g_se,x_16" alt></p>
<h3 id="3-2-联动原理">3.2 联动原理</h3>
<ul>
<li>首选<code>pom.xml</code>配置了多环境配置</li>
<li>IDEA指定勾选 和 服务器端 <code>mvn -P test</code>  指定maven的profile对应的ID</li>
<li>服务启动/打包编译时候，便根据maven的profile对应的ID  找到对应的<profile>标签，并加载到了内部的<properties>标签</properties></profile></li>
<li><build>标签中的<resources>中的<resource>下，<filtering>一定是设置为true，开启了pom和配置文件之间的通道</filtering></resource></resources></build></li>
<li>对应的<profile>标签中加载到的<properties>标签中的自定义key - value拿上，去找到<code>application.yml</code>中的@XXX@ 或 ${}表达式</properties></profile></li>
<li>spring.profiles.active=@env@，并根据key为env，做了value的替换，最终编译完成，<code>application.yml</code>中的 spring.profiles.active=dev</li>
<li>应用在启动中，就根据 spring.profiles.active=dev，成功加载上了 <code>application-dev.yml</code>文件</li>
<li>最终，完成了 maven的profile和 springboot的profile的联动替换。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud-2020.0.3版本简单入门</title>
    <url>/posts/dcbafa8c.html</url>
    <content><![CDATA[<p><strong>Spring Cloud 2020.0.0版本北京时间2020.12.22发布，彻底删除掉了Netflix除Eureka外的所有组件，支持SpringBoot2.4.x</strong></p>
<p>Netflix 组件替代方案(Feign依旧是可以使用的，OpenFiegn，做REST客户端)</p>
<table>
<thead>
<tr>
<th style="text-align:center">Netflix</th>
<th style="text-align:center">推荐替代品</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Hystrix</td>
<td style="text-align:center">Resilience4j</td>
<td style="text-align:center">Hystrix自己也推荐你使用它代替自己</td>
</tr>
<tr>
<td style="text-align:center">Hystrix Dashboard / Turbine</td>
<td style="text-align:center">Micrometer + Monitoring System</td>
<td style="text-align:center">监控这件事交给更专业的组件去做</td>
</tr>
<tr>
<td style="text-align:center">Ribbon</td>
<td style="text-align:center">Spring Cloud Loadbalancer</td>
<td style="text-align:center">Spring终究亲自出手</td>
</tr>
<tr>
<td style="text-align:center">Zuul 1</td>
<td style="text-align:center">Spring Cloud Gateway</td>
<td style="text-align:center">Spring终究亲自出手</td>
</tr>
<tr>
<td style="text-align:center">Archaius 1</td>
<td style="text-align:center">Spring Boot外部化配置 + Spring Cloud配置</td>
<td style="text-align:center">比Netflix实现的更好、更强大</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<p>这里我简单记录了一下SpringCloud2020.0.3版本的情况，作为学习供以后参考，以后SpringCloud会使用SpringCloud Alibaba的。</p>
<hr>
<h1>Eureka服务注册与发现</h1>
<h2 id="一、概述">一、概述</h2>
<blockquote>
<p><a href="https://docs.spring.io/spring-cloud-netflix/docs/current/reference/html/#service-discovery-eureka-clients" target="_blank" rel="noopener">Eureka官网</a></p>
<p><a href="https://www.springcloud.cc/spring-cloud-greenwich.html#_spring_cloud_netflix" target="_blank" rel="noopener">Eureka中文网</a></p>
</blockquote>
<h3 id="1、CAP原则">1、CAP原则</h3>
<p>CAP原则又称CAP定理，指的是在一个分布式系统中一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）。但这三个要素最多只能同时实现两点，不可能三者兼顾，一般来说是AP和CP。</p>
<h3 id="2、Eureka介绍">2、Eureka介绍</h3>
<p>Eureka是一个基于REST的服务，用于定位服务，以达到负载均衡和中间层服务故障转移的目的。SpringCloud将它集成在其子项目spring-cloud-netflix中，以实现SpringCloud的服务注册与发现功能。功能类似于Dubbo的注册中心，比如Zookeeper。Eureka 包含两个组件：Eureka Server和Eureka Client。<br>
<img src="https://img-blog.csdnimg.cn/7deda8bc601a46acb7c6f0f7f8366bdd.png" alt="请添加图片描述"></p>
<ul>
<li>Eureka Server：服务注册中心（可以是一个集群），对外暴露自己的地址</li>
<li>Service Provider：微服务(可以是java程序，也可以python)，启动后向Eureka注册自己信息（地址等）</li>
<li>Service Consumer：向Eureka订阅服务，Eureka会将对应服务的所有提供者地址列表发送给消费者，并且定期更新</li>
<li>心跳(续约)：提供者定期通过http方式向Eureka刷新自己的状态</li>
<li>Eureka默认在90秒后还未收到服务提供者发来的心跳时，那么它就会认定该服务已经死亡就会注销这个服务。这里注销并不是立即注销，而是会在60秒以后对在这个之间段内“死亡”的服务集中注销，如果立即注销，势必会对Eureka造成极大的负担。这些时间参数都可以自定义配置</li>
<li>自我保护机制，如果在15分钟内超过85%的节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障，所以不会再接收心跳，也不会删除服务。</li>
</ul>
<h2 id="二、服务构建">二、服务构建</h2>
<h3 id="1、建立父子聚合项目">1、建立父子聚合项目</h3>
<p>在父工程<code>pom.xml</code>导入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>2.5.2<span class="tag">&lt;/<span class="name">eureka.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>2020.0.3<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2、建立Eureka注册中心">2、建立Eureka注册中心</h3>
<p>创建springboot模块，引入服务注册服务</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--这里可能会和springboot的tomcat jar包冲突，所以去除；</span></span><br><span class="line"><span class="comment">	另外里面可能会有jar包找不到，一层层进入，找到报错的jar包版本，引入正确的版本即可</span></span><br><span class="line"><span class="comment">    &lt;exclusions&gt;</span></span><br><span class="line"><span class="comment">        &lt;exclusion&gt;</span></span><br><span class="line"><span class="comment">            &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;</span></span><br><span class="line"><span class="comment">            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span></span><br><span class="line"><span class="comment">        &lt;/exclusion&gt;</span></span><br><span class="line"><span class="comment">    &lt;/exclusions&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>进入<code>application.yml</code>文件修改配置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8088</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">eureka-server</span></span><br><span class="line"><span class="comment"># eureka配置</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="comment">#eureka服务端的实例名称</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="comment">## 开启自我保护模式（开启状态下服务停掉eureka不会立即清除掉宕掉的服务，所以false）</span></span><br><span class="line">    <span class="attr">enable-self-preservation:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># 清理无效节点,默认60*1000毫秒,即60秒</span></span><br><span class="line">    <span class="attr">eviction-interval-timer-in-ms:</span> <span class="number">5000</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment">#是否将自己注册到Eureka服务器中，本身是服务器，无需注册</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment">#false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="comment">#设置与Eureka server交互的地址查询服务和注册服务都需要依赖这个defaultzone地址,如果是集群，需要加上其它Server的地址。</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span></span><br></pre></td></tr></table></figure>
<p>最后在启动类上添加<code>@EnableEurekaServer</code>注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaServerApplication</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(EurekaServerApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动<code>localhost:8088</code>即可进入我的注册中心<br>
<img src="https://img-blog.csdnimg.cn/891a903d69af4c14b166e0abea4934ea.png" alt="请添加图片描述"></p>
<ul>
<li>System Status：系统信息</li>
<li>DS Replicas：服务器副本</li>
<li>Instances currently registered with Eureka：已注册的微服务列表</li>
<li>General Info：一般信息</li>
<li>Instance Info：实例信息</li>
</ul>
<h3 id="3、建立Provider服务">3、建立Provider服务</h3>
<p>创建新的springboot模块，引入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>进入<code>application.yml</code>文件修改配置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment"># 应用名称，不要加下划线，否则会找不到服务</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">student</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment">#EurekaServer地址</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="comment">#集群配置多个</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:8088/eureka</span></span><br><span class="line">    <span class="comment">#服务注册，是否向服务端注册,默认是true</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="comment">#服务提供实例的构成信息</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">$&#123;spring.application.name&#125;:$&#123;server.port&#125;</span></span><br><span class="line">    <span class="comment"># 当调用getHostname获取实例的hostname时，返回ip而不是host名称</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 指定自己的ip信息，不指定的话会自己寻找</span></span><br><span class="line">    <span class="comment"># ip-address: 127.0.0.1</span></span><br><span class="line">    <span class="comment">#Eureka服务端在收到最后一次心跳之后等待的时间上限，单位为秒，超过则剔除（客户端告诉服务端按照此规则等待自己），默认90</span></span><br><span class="line">    <span class="attr">lease-expiration-duration-in-seconds:</span> <span class="number">20</span></span><br><span class="line">    <span class="comment">#心跳包，默认30</span></span><br><span class="line">    <span class="attr">lease-renewal-interval-in-seconds:</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>创建服务端服务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello,world!s"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后在启动类上加上<code>@EnableEurekaClient</code>，启动即可加入注册中心</p>
<p><strong>对于python开发的web程序，也可以注册到Eureka注册中心，这里我就举例Flask框架</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> py_eureka_client <span class="keyword">import</span> eureka_client</span><br><span class="line"><span class="keyword">from</span> flask_cors <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setEureka</span><span class="params">()</span>:</span></span><br><span class="line">    server_host = <span class="string">"localhost"</span></span><br><span class="line">    server_port = <span class="number">5000</span></span><br><span class="line">    eureka_client.init(eureka_server=<span class="string">"http://localhost:8088/eureka"</span>,</span><br><span class="line">                       <span class="comment">#不能出现下划线</span></span><br><span class="line">                       app_name=<span class="string">"flaskServer"</span>,</span><br><span class="line">                       <span class="comment"># 当前组件的主机名，可选参数，如果不填写会自动计算一个，如果服务和 eureka 服务器部署在同一台机器，请必须填写，否则会计算出 127.0.0.1</span></span><br><span class="line">                       instance_host=server_host,</span><br><span class="line">                       instance_port=server_port,</span><br><span class="line">                       <span class="comment"># 调用其他服务时的高可用策略，可选，默认为随机</span></span><br><span class="line">                       ha_strategy=eureka_client.HA_STRATEGY_RANDOM)</span><br><span class="line"></span><br><span class="line">setEureka()</span><br><span class="line"><span class="comment"># 跨域配置</span></span><br><span class="line">CORS(app, supports_credentials=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello world'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.debug = <span class="literal">True</span></span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>
<p>启动访问<code>localhost:5000</code>可正常访问，这里作为Provider</p>
<h3 id="4、建立Consumer消费端">4、建立Consumer消费端</h3>
<blockquote>
<p>这里Ribbon替换成Spring Cloud Loadbalancer，可以自定义负载均衡算法，这里默认是轮询。通过@LoadBalanced，程序底层会默认通过ribbon将注册的服务名解析成具体的ip和端口，最后进行访问请求。</p>
<p><a href="https://docs.spring.io/spring-cloud-commons/docs/current/reference/html/#spring-cloud-loadbalancer" target="_blank" rel="noopener">参考文档</a>。</p>
</blockquote>
<p>创建springboot模块，引入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>进入<code>application.yml</code>文件修改配置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">Consumer</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="comment"># EurekaServer地址,多个地址以','隔开</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:8088/eureka</span></span><br><span class="line">    <span class="comment">#服务注册，是否向服务端注册,默认是true</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>在启动类添加注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="comment">// 启动即会被注册到注册中心</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(ApiApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	   <span class="meta">@Bean</span></span><br><span class="line">    <span class="comment">// 启用负载均衡机制，必须</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">(RestTemplateBuilder builder)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//可以自定义</span></span><br><span class="line">        <span class="keyword">return</span> builder</span><br><span class="line">                .setConnectTimeout(Duration.ofMillis(<span class="number">100</span>))</span><br><span class="line">                .setReadTimeout(Duration.ofMillis(<span class="number">500</span>))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后创建Cntroller，远程调用服务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里引的包为org.springframework.cloud.client.discovery.DiscoveryClient</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    DiscoveryClient discoveryClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">discory</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Object template = restTemplate.getForObject(<span class="string">"http://STUDENT/"</span>,Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/py"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">discory1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String template = restTemplate.getForObject(<span class="string">"http://FLASKSERVER/"</span>,String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">discory2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.info(<span class="string">"尝试获取注册中心信息"</span>);</span><br><span class="line">        log.info(<span class="string">"getApplications"</span>+discoveryClient.getServices());</span><br><span class="line">        log.info(<span class="string">"getInstancesById"</span>+discoveryClient.getInstances(<span class="string">"STUDENT"</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"成功"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动后，此时通过8081端口访问即可获取8080以及flask服务端提供的服务<br>
<img src="https://img-blog.csdnimg.cn/474989a917cc4957b277d2a824e106a3.png" alt="请添加图片描述"></p>
<h3 id="5、优化与提高">5、优化与提高</h3>
<p>对于Eureka，info、还有集群、zone、region等</p>
<h1>OpenFeign负载均衡</h1>
<h2 id="一、概述-v2">一、概述</h2>
<p>相对于Ribbon+RestTemplate，其操作过于繁琐，在上面一节中已经简单写明，其通过OpenFeign可以简化开发。</p>
<p>OpenFeign是一个声明式的http客户端，让编写web服务客户端变的非常容易，只需要创建一个接口并在接口上添加注解即可。在底层，OpenFeign集成了Ribbon，利用Ribbon维护了springcloud-Dept的服务列表信息，接口会自动进行http请求相应的服务，其作用的替代RestTemplate，性能比较低，但是可以使代码可读性很强。</p>
<p>OpenFeign的前身是Feign，后者目前已经停更了，OpenFeign是SpringCloud在Feign的基础上支持了Spring MVC的注解，并通过动态代理的方式产生实现类来做负载均衡并进行调用其他服务。</p>
<p><a href="https://spring.io/projects/spring-cloud-openfeign" target="_blank" rel="noopener">springcloud官方文档</a></p>
<h2 id="二、服务构建-v2">二、服务构建</h2>
<h3 id="1、多模块负载均衡搭建">1、多模块负载均衡搭建</h3>
<p>在consumer模块的<code>pom.xml</code>添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在<code>student</code>模块中存在一个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"调用成功"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello,world!s"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>consumer</code>模块打开Feign注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span>(basePackages = <span class="string">"com.zstu.consumer"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConsumerApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="comment">// 启用负载均衡机制，必须</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新建Feign接口类，在类上添加需要远程访问的服务名，方法则是该服务暴露的接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(value = <span class="string">"student"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FeignService</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里调用的是student的helloworld方法</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/"</span>)</span><br><span class="line">    <span class="function">String <span class="title">hello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后在<code>controller</code>新增方法，调用该方法，启动项目即可内部远程调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> FeignService feignService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/test111"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    feignService.hello();</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、优化与提高">2、优化与提高</h3>
<p>服务熔断、降级可以用resilience4j，不过网上实用资料好像不是很多，打算下次直接上sentinel了。</p>
<h1>Spring Cloud Gateway网关</h1>
<h2 id="一、概述-v3">一、概述</h2>
<blockquote>
<p>API Gateway（APIGW / API 网关），顾名思义，是出现在系统边界上的一个面向 API 的、串行集中式的强管控服务，这里的边界是企业 IT 系统的边界，可以理解为企业级应用防火墙，主要起到隔离外部访问与内部系统的作用。</p>
<p><a href="https://www.springcloud.cc/spring-cloud-greenwich.html#_spring_cloud_gateway" target="_blank" rel="noopener">SpringCloudGateway中文网</a></p>
<p><a href="https://spring.io/projects/spring-cloud-gateway#learn" target="_blank" rel="noopener">SpringCloudGateway官网</a></p>
</blockquote>
<p>Spring Cloud Gateway是Spring Cloud官方推出的第二代网关框架，取代Zuul网关。网关作为流量的，在微服务系统中有着非常作用，网关常见的功能有路由转发、权限校验、限流控制等作用。同时有以下特点：</p>
<ul>
<li>基于Spring 5，Reactor(模式) 和 SpringBoot 2.0</li>
<li>能够在任何请求属性上匹配路由</li>
<li>断言和过滤器是特定于路由的</li>
<li>Hystrix断路器集成</li>
<li>SpringCloud DiscoveryClient集成</li>
<li>易于编写断言和过滤器</li>
<li>请求速率限制</li>
<li>路径重写<br>
<img src="https://img-blog.csdnimg.cn/73912c06b369414abfb6091b36fd313e.png" alt="请添加图片描述"></li>
</ul>
<h2 id="二、服务构建-v3">二、服务构建</h2>
<h3 id="1、Gateway网关搭建">1、Gateway网关搭建</h3>
<p><strong>继承Eureka配置</strong></p>
<p>新建springboot模块，我这里取名为api，引入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="comment">&lt;!-- spring cloud gateway 依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><em>SpringCloud中Gateway与SpringBoot Web有jar包冲突，因此这里我没引入SpringBoot Web依赖</em></p>
<p>配置<code>application.yml</code>配置文件</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">Api</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">locator:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span>  <span class="comment">#开启根据微服务名称自动转发</span></span><br><span class="line">          <span class="attr">lower-case-service-id:</span> <span class="literal">true</span>  <span class="comment">#微服务名称以小写形式呈现</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">student</span>           <span class="comment"># 路由id,没有固定规则，建议配合服务名</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">lb://STUDENT</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Path=/**</span>    <span class="comment"># 断言：路径相匹配的进行路由</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">flaskserver</span>           <span class="comment"># 路由id,没有固定规则，建议配合服务名</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">http://localhost:5000</span>  <span class="comment"># 匹配后提供服务的路由地址</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/**</span>    <span class="comment"># 断言：路径相匹配的进行路由</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="comment"># EurekaServer地址,多个地址以','隔开</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:8088/eureka</span></span><br><span class="line">    <span class="comment">#服务注册，是否向服务端注册,默认是true</span></span><br><span class="line">	<span class="comment">#register-with-eureka: false</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="comment">#服务提供实例的构成信息</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">$&#123;spring.application.name&#125;:$&#123;server.port&#125;</span></span><br></pre></td></tr></table></figure>
<p>在启动类上添加注解<code>@EnableEurekaClient</code>，最后启动服务，访问<code>http://localhost:8081/student/</code>,<code>http://localhost:8081/flaskserver</code>，可以发现网关配置成功</p>
<h3 id="2、Gateway网关配置详解">2、Gateway网关配置详解</h3>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">Api</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">locator:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span>  <span class="comment">#开启根据微服务名称自动转发</span></span><br><span class="line">          <span class="attr">lower-case-service-id:</span> <span class="literal">true</span>  <span class="comment">#微服务名称以小写形式呈现</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="comment">#  在gateway中配置uri配置有三种方式，包括</span></span><br><span class="line">      <span class="comment">#第一种：ws(websocket)方式: uri: ws://localhost:9000</span></span><br><span class="line">      <span class="comment">#第二种：http方式: uri: http://localhost:8130/</span></span><br><span class="line">      <span class="comment">#第三种：lb(注册中心中服务名字)方式: uri: lb://brilliance-consumer</span></span><br><span class="line">      <span class="comment">#规则:配置由筛选器名称、等号（=）和用逗号（，）分隔的参数值识别。</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">student</span>           <span class="comment"># 路由id：payment_route，没有固定规则，建议配合服务名</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">lb://STUDENT</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Path=/**</span>    <span class="comment"># 断言：路径相匹配的进行路由</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Method=GET,POST</span></span><br><span class="line">        <span class="comment">#当请求头携带key为X-Request-Id的，值包含数字的情况下转发</span></span><br><span class="line">        <span class="comment">#- Header=X-Request-Id, \d+</span></span><br><span class="line">        <span class="comment">#接受远程资源集合</span></span><br><span class="line">        <span class="comment">#- RemoteAddr=192.168.1.1/24</span></span><br><span class="line">        <span class="comment">#- Cookie=mycookie,mycookievalue</span></span><br><span class="line">        <span class="comment">#接收一个java ZonedDateTime类的时间参数。After表示在这个时间之后的请求才能正确匹配路由，同理还有Before、Between</span></span><br><span class="line">        <span class="comment">#- After=2021-07-31T17:42:47.789-07:00[Asia/Shanghai]</span></span><br><span class="line">        <span class="comment">#- Weight=group1, 2 #做负载均衡</span></span><br><span class="line">        <span class="comment">#- Query=token, abc.       # 匹配请求参数中包含 token 并且其参数值满足正则表达式 abc. 的请求</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#filters:</span></span><br><span class="line">          <span class="comment"># 将 /1 重写为 /product/1</span></span><br><span class="line">          <span class="comment">#- PrefixPath=/product</span></span><br><span class="line">          <span class="comment"># 将 /api/123/product/1 重写为 /product/1</span></span><br><span class="line">          <span class="comment">#- StripPrefix=2</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="comment"># EurekaServer地址,多个地址以','隔开</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:8088/eureka</span></span><br><span class="line">    <span class="comment">#服务注册，是否向服务端注册,默认是true</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="comment">#服务提供实例的构成信息</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">$&#123;spring.application.name&#125;:$&#123;server.port&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="3、优化与提高">3、优化与提高</h3>
<p>Gateway还可以自定义配置过滤、鉴权等</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>java8常用新特性</title>
    <url>/posts/c54dc8f8.html</url>
    <content><![CDATA[<h2 id="1、Lambda-表达式">1、Lambda 表达式</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 不需要参数,返回值为 5  </span></span><br><span class="line">() -&gt; <span class="number">5</span>  </span><br><span class="line"><span class="comment">// 2. 接收一个参数(数字类型),返回其2倍的值  </span></span><br><span class="line">x -&gt; <span class="number">2</span> * x  </span><br><span class="line"><span class="comment">// 3. 接受2个参数(数字),并返回他们的差值  </span></span><br><span class="line">(x, y) -&gt; x – y  </span><br><span class="line"><span class="comment">// 4. 接收2个int型整数,返回他们的和  </span></span><br><span class="line">(<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; x + y  </span><br><span class="line"><span class="comment">// 5. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void)  </span></span><br><span class="line">(String s) -&gt; System.out.print(s)</span><br><span class="line">    </span><br><span class="line"><span class="comment">//输出Hello shawn</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test12</span><span class="params">()</span></span>&#123;</span><br><span class="line">  	<span class="comment">// 用括号</span></span><br><span class="line">  	GreetingService greetService = (message) -&gt;</span><br><span class="line">        System.out.println(<span class="string">"Hello "</span> + message);</span><br><span class="line">  	greetService.sayMessage(<span class="string">"shawn"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">GreetingService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayMessage</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="2、函数式接口">2、函数式接口</h2>
<blockquote>
<p>函数接口是只有一个抽象方法的接口，用作 Lambda 表达式的类型。使用@FunctionalInterface注解修饰的类，编译器会检测该类是否只有一个抽象方法或接口，否则，会报错。可以有多个默认方法，静态方法。</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">函数接口</th>
<th style="text-align:center">抽象接口</th>
<th style="text-align:center">功能</th>
<th style="text-align:center">参数</th>
<th style="text-align:center">返回类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Predicate</td>
<td style="text-align:center">test(T t)</td>
<td style="text-align:center">判断真假</td>
<td style="text-align:center">T</td>
<td style="text-align:center">boolean</td>
</tr>
<tr>
<td style="text-align:center">Consumer</td>
<td style="text-align:center">accept(T t)</td>
<td style="text-align:center">消费消息</td>
<td style="text-align:center">T</td>
<td style="text-align:center">void</td>
</tr>
<tr>
<td style="text-align:center">Function</td>
<td style="text-align:center">R apply(T t)</td>
<td style="text-align:center">将T映射为R</td>
<td style="text-align:center">T</td>
<td style="text-align:center">R</td>
</tr>
<tr>
<td style="text-align:center">Supplier</td>
<td style="text-align:center">T get()</td>
<td style="text-align:center">生产消息</td>
<td style="text-align:center">None</td>
<td style="text-align:center">T</td>
</tr>
<tr>
<td style="text-align:center">UnaryOperator</td>
<td style="text-align:center">T apply(T t)</td>
<td style="text-align:center">一元操作</td>
<td style="text-align:center">T</td>
<td style="text-align:center">T</td>
</tr>
<tr>
<td style="text-align:center">BinaryOperator</td>
<td style="text-align:center">apply(T t,U u)</td>
<td style="text-align:center">二元操作</td>
<td style="text-align:center">（T,U）</td>
<td style="text-align:center">T</td>
</tr>
</tbody>
</table>
<p>常用的方法举例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Java8FunctionalTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Predicate&lt;Integer&gt; predicate = x -&gt; x &gt; <span class="number">170</span>;</span><br><span class="line">        Student student = <span class="keyword">new</span> Student(<span class="string">"shawn"</span>, <span class="number">175</span>);</span><br><span class="line">        System.out.println(<span class="string">"shawn的身高有超过170吗？"</span> + predicate.test(student.getHeight()));</span><br><span class="line"></span><br><span class="line">        Consumer&lt;String&gt; consumer = System.out::println;</span><br><span class="line">        consumer.accept(<span class="string">"我命由我不命天"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Student映射成String</span></span><br><span class="line">        Function&lt;Student, String&gt; function = Student::getName;</span><br><span class="line">        String name = function.apply(student);</span><br><span class="line">        System.out.println(name);</span><br><span class="line"></span><br><span class="line">        Supplier&lt;Integer&gt; supplier =</span><br><span class="line">                () -&gt; Integer.valueOf(BigDecimal.TEN.toString());</span><br><span class="line">        System.out.println(supplier.get());</span><br><span class="line"></span><br><span class="line">        UnaryOperator&lt;Boolean&gt; unaryOperator = flag -&gt; !flag;</span><br><span class="line">        Boolean apply2 = unaryOperator.apply(<span class="keyword">true</span>);</span><br><span class="line">        System.out.println(apply2);</span><br><span class="line"></span><br><span class="line">        BinaryOperator&lt;Integer&gt; operator = (x, y) -&gt; x * y;</span><br><span class="line">        Integer integer = operator.apply(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(integer);</span><br><span class="line"></span><br><span class="line">        test(() -&gt; <span class="string">"我是一个演示的函数式接口"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 演示自定义函数式接口使用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> worker</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Worker worker)</span> </span>&#123;</span><br><span class="line">        String work = worker.work();</span><br><span class="line">        System.out.println(work);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="meta">@FunctionalInterface</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Worker</span> </span>&#123;</span><br><span class="line">        <span class="function">String <span class="title">work</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一种使用就是可以消除大量if-else，给代码解耦合，这里我简单贴部分demo</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 里面可以分几个类，这里我全写在一起了</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里相当于进行了if else操作了，代码更加简洁</span></span><br><span class="line">        <span class="comment">// 有内容输出内容，没有内容输出空字符串</span></span><br><span class="line">        isBlankOrNoBlank(<span class="string">"hello world"</span>)</span><br><span class="line">                .presentOrElseHandle(System.out::println,()-&gt;&#123;</span><br><span class="line">                    System.out.println(<span class="string">"空字符串"</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 空值与非空值分支处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@FunctionalInterface</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BranchHandle</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * if else两种处理函数</span></span><br><span class="line"><span class="comment">         * &lt;? extends T&gt; 表示类型的上界，表示参数化类型的可能是T 或是 T的子类;</span></span><br><span class="line"><span class="comment">         * &lt;? super T&gt; 表示类型下界（Java Core中叫超类型限定），表示参数化类型是此类型的超类型（父类型），直至Object;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">presentOrElseHandle</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action, Runnable emptyAction)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 参数为true或false时，分别进行不同的操作</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> BranchHandle&lt;?&gt; isBlankOrNoBlank(String str)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (consumer, runnable) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>)&#123;</span><br><span class="line">                runnable.run();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                consumer.accept(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3、Stream流式编程">3、Stream流式编程</h2>
<p>Stream（流）是一个来自数据源的元素队列并支持聚合操作</p>
<ul>
<li>元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。</li>
<li><strong>数据源</strong> 流的来源。 可以是集合，数组，I/O channel， 产生器generator 等。</li>
<li><strong>聚合操作</strong> 类似SQL语句一样的操作， 比如filter, map, reduce, find, match, sorted等。</li>
</ul>
<p><strong>1. collect(Collectors.toList())</strong></p>
<p>将流转换为list。还有toSet()，toMap()等。及早求值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;Student&gt; studentList = Stream.of(</span><br><span class="line">        <span class="keyword">new</span> Student(<span class="string">"shawn"</span>,<span class="number">165</span>),</span><br><span class="line">        <span class="keyword">new</span> Student(<span class="string">"shawn22"</span>,<span class="number">170</span>))</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line">    System.out.println(studentList);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//[Student(name=shawn, height=165), Student(name=shawn22, height=170)]</span></span><br></pre></td></tr></table></figure>
<p><strong>2. forEach</strong></p>
<p>Stream 提供了新的方法 <code>forEach</code> 来迭代流中的每个数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Random random = <span class="keyword">new</span> Random();</span><br><span class="line">    random.ints().limit(<span class="number">10</span>).sorted().forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3. filter</strong></p>
<p>过滤筛选的作用。内部就是Predicate接口。惰性求值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;Student&gt; studentList = Stream.of(</span><br><span class="line">        <span class="keyword">new</span> Student(<span class="string">"shawn"</span>,<span class="number">165</span>),</span><br><span class="line">        <span class="keyword">new</span> Student(<span class="string">"shawn22"</span>,<span class="number">170</span>))</span><br><span class="line">        .filter(s -&gt; s.getHeight()&gt;<span class="number">165</span>)</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line">    System.out.println(studentList);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//[Student(name=shawn22, height=170)]</span></span><br></pre></td></tr></table></figure>
<p><strong>3. map</strong></p>
<p>转换功能，内部就是Function接口。惰性求值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;String&gt; studentList = Stream.of(</span><br><span class="line">        <span class="keyword">new</span> Student(<span class="string">"shawn"</span>,<span class="number">165</span>),</span><br><span class="line">        <span class="keyword">new</span> Student(<span class="string">"shawn22"</span>,<span class="number">170</span>))</span><br><span class="line">        .filter(s -&gt; s.getHeight() &gt; <span class="number">165</span>)</span><br><span class="line">        .map(s-&gt; s.getName())</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line">    System.out.println(studentList);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//[shawn22]</span></span><br></pre></td></tr></table></figure>
<p><strong>5. flatMap</strong></p>
<p>将多个Stream合并为一个Stream。惰性求值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test05</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;Student&gt; studentList = Arrays.asList(</span><br><span class="line">        <span class="keyword">new</span> Student(<span class="string">"shawn"</span>,<span class="number">165</span>),</span><br><span class="line">        <span class="keyword">new</span> Student(<span class="string">"shawn22"</span>,<span class="number">170</span>));</span><br><span class="line"></span><br><span class="line">    Stream.of(studentList, Collections.singletonList(</span><br><span class="line">        <span class="keyword">new</span> Student(<span class="string">"shawn222"</span>, <span class="number">180</span>)))</span><br><span class="line">        .flatMap(Collection::stream)</span><br><span class="line">        .map(s-&gt;s.getName())</span><br><span class="line">        .forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//shawn</span></span><br><span class="line"><span class="comment">//shawn22</span></span><br><span class="line"><span class="comment">//shawn222</span></span><br></pre></td></tr></table></figure>
<p><strong>6. max和min</strong></p>
<p>集合中求最大值和最小值，及早求值。maxBy或者minBy就是求最大值与最小值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test06</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;Student&gt; studentList = Arrays.asList(</span><br><span class="line">        <span class="keyword">new</span> Student(<span class="string">"shawn"</span>,<span class="number">165</span>),</span><br><span class="line">        <span class="keyword">new</span> Student(<span class="string">"shawn22"</span>,<span class="number">170</span>));</span><br><span class="line"></span><br><span class="line">    Optional&lt;Student&gt; student = studentList.stream()</span><br><span class="line">        .min(Comparator.comparing(Student::getHeight));</span><br><span class="line">    <span class="keyword">if</span>(student.isPresent())&#123;</span><br><span class="line">        System.out.println(student.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Student(name=shawn, height=165)</span></span><br></pre></td></tr></table></figure>
<p><strong>7. count</strong></p>
<p>统计功能，一般都是结合filter使用，因为先筛选出我们需要的再统计即可。及早求值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test07</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;Student&gt; studentList = Arrays.asList(</span><br><span class="line">        <span class="keyword">new</span> Student(<span class="string">"shawn"</span>,<span class="number">165</span>),</span><br><span class="line">        <span class="keyword">new</span> Student(<span class="string">"shawn22"</span>,<span class="number">170</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> count = studentList.stream().filter(s -&gt; s.getHeight() &gt; <span class="number">165</span>).count();</span><br><span class="line">    System.out.println(count);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<p><strong>8. reduce</strong></p>
<p>reduce 操作可以实现从一组值中生成一个值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test08</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).reduce(<span class="number">10</span>, Integer::sum));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//25</span></span><br></pre></td></tr></table></figure>
<p><strong>9. collect高级用法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将分成true和false两个集合</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test09</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;Student&gt; studentList = Arrays.asList(</span><br><span class="line">        <span class="keyword">new</span> Student(<span class="string">"shawn"</span>,<span class="number">165</span>),</span><br><span class="line">        <span class="keyword">new</span> Student(<span class="string">"shawn22"</span>,<span class="number">170</span>));</span><br><span class="line">    System.out.println(studentList.stream()</span><br><span class="line">                       .collect(Collectors.partitioningBy(s -&gt; s.getName().contains(<span class="string">"shawn"</span>))));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//&#123;false=[], true=[Student(name=shawn, height=165), Student(name=shawn22, height=170)]&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Collectors.groupingBy与SQL 中的 group by 操作是一样的。</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test010</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;Student&gt; studentList = Arrays.asList(</span><br><span class="line">        <span class="keyword">new</span> Student(<span class="string">"shawn"</span>,<span class="number">165</span>),</span><br><span class="line">        <span class="keyword">new</span> Student(<span class="string">"shawn22"</span>,<span class="number">170</span>));</span><br><span class="line">    System.out.println(studentList.stream()</span><br><span class="line">                       .collect(Collectors.groupingBy(Student::getName)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串拼接</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test011</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;Student&gt; studentList = Arrays.asList(</span><br><span class="line">        <span class="keyword">new</span> Student(<span class="string">"shawn"</span>,<span class="number">165</span>),</span><br><span class="line">        <span class="keyword">new</span> Student(<span class="string">"shawn22"</span>,<span class="number">170</span>));</span><br><span class="line">    System.out.println(studentList.stream().map(Student::getName)</span><br><span class="line">                       .collect(Collectors.joining(<span class="string">","</span>,<span class="string">"["</span>,<span class="string">"]"</span>)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//[shawn,shawn22]</span></span><br></pre></td></tr></table></figure>
<h2 id="4、Optional类">4、Optional类</h2>
<blockquote>
<p>Optional 类是一个可以为null的容器对象。目的是为了解决空指针异常。</p>
</blockquote>
<p><strong>1. empty()</strong></p>
<p>返回一个<code>Optional</code>容器对象，而不是 null。<strong>建议常用⭐⭐⭐⭐</strong></p>
<p><strong>2. get()</strong></p>
<p>如果创建的Optional中有值存在，则返回此值，否则抛出<code>NoSuchElementException</code>。在判空之前，千万不要直接使用！<strong>尽量别用！⭐</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//会报错java.util.NoSuchElementException: No value present</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Optional&lt;User&gt; opt = Optional.empty();</span><br><span class="line">    System.out.println(opt.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3. of(T value)</strong></p>
<p>创建一个<code>Optional</code>对象，如果 value 是 null，则抛出 NPE。<strong>不建议用⭐⭐</strong></p>
<p><strong>4. ofNullable(T value)</strong></p>
<p>同上，创建一个<code>Optional</code>对象，但 value 为空时返回<code>Optional.empty()</code>。<strong>推荐使用⭐⭐⭐⭐⭐</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">    User user = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//输出Optional.empty，若存在就输出值</span></span><br><span class="line">    System.out.println(Optional.ofNullable(user));</span><br><span class="line">    <span class="comment">//会报错java.lang.NullPointerException</span></span><br><span class="line">    System.out.println(Optional.of(user));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>5. orElse(T other)</strong></p>
<p>同样是返回<code>Optional</code>中包装的值，但不同的是当取不到值时，返回你指定的 default。<strong>可以用⭐⭐⭐</strong></p>
<p><strong>6. orElseGet(Supplier&lt;? extends T&gt; other)</strong></p>
<p>如果创建的Optional中有值存在，则返回此值，否则返回一个由Supplier接口生成的值。<strong>推荐使用⭐⭐⭐⭐⭐</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> User <span class="title">createNewUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"user方法创建"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="string">"shawn"</span>, <span class="string">"男"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//下面两个若是空，都会调用本地方法创建新的，但是orElse无论是否存在值，都会执行方法，另一个却不会</span></span><br><span class="line">    User result = Optional.ofNullable(user).orElse(createNewUser());</span><br><span class="line">    User result2 = Optional.ofNullable(user).orElseGet(<span class="keyword">this</span>::createNewUser);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">    System.out.println(result2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*结果显示</span></span><br><span class="line"><span class="comment">user方法创建</span></span><br><span class="line"><span class="comment">user方法创建</span></span><br><span class="line"><span class="comment">User(name=shawn, sex=男)</span></span><br><span class="line"><span class="comment">User(name=shawn, sex=男)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><strong>7. orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)</strong></p>
<p>如果创建的Optional中有值存在，则返回此值，否则抛出一个由指定的Supplier接口生成的异常。<strong>阻塞性业务场景推荐使用⭐⭐⭐⭐</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">null</span>;</span><br><span class="line">    User result = Optional.ofNullable(user).orElseThrow(NullPointerException::<span class="keyword">new</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出java.lang.NullPointerException</span></span><br></pre></td></tr></table></figure>
<p><strong>8. isPresent()</strong></p>
<p>如果创建的Optional中的值存在，返回true，否则返回false。在某些情况下很有用，但尽量不要用在 if 判断体中。<strong>可以用⭐⭐⭐</strong></p>
<p><strong>9. ifPresent(Consumer&lt;? super T&gt; consumer)</strong></p>
<p>判断<code>Optional</code>中是否有值，有值则执行 consumer，否则什么都不干。<strong>日常情况下请使用这个⭐⭐⭐⭐</strong></p>
<p><strong>10. filter(Predicate&lt;? super T&gt; predicate)</strong></p>
<p>如果创建的Optional中的值满足filter中的条件，则返回包含该值的Optional对象，否则返回一个空的Optional对象</p>
<p><strong>11. map</strong></p>
<p>如果创建的Optional中的值存在，对该值执行提供的Function函数调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test05</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User(<span class="string">"shawn"</span>, <span class="string">"男"</span>);</span><br><span class="line">    String sex = Optional.ofNullable(user)</span><br><span class="line">        .map(User::getSex).orElse(<span class="string">"女"</span>);</span><br><span class="line">    System.out.println(sex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出男</span></span><br></pre></td></tr></table></figure>
<p><strong>12. flagMap</strong></p>
<p>如果创建的Optional中的值存在，就对该值执行提供的Function函数调用，返回一个Optional类型的值，否则就返回一个空的Optional对象，其返回的值是解除包装的值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//该方法在User类中定义</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Optional&lt;String&gt; <span class="title">getPosition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Optional.ofNullable(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test06</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User(<span class="string">"shawn"</span>, <span class="string">"男"</span>);</span><br><span class="line">    String sex = Optional.ofNullable(user)</span><br><span class="line">        .flatMap(User::getPosition).orElse(<span class="string">"女"</span>);</span><br><span class="line">    System.out.println(sex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出男</span></span><br></pre></td></tr></table></figure>
<p><strong>13. filter</strong></p>
<p>filter() 接受一个 Predicate 参数，返回测试结果为 true 的值。如果测试结果为 false，会返回一个空的 Optional。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test07</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User(<span class="string">"shawn"</span>, <span class="string">"男"</span>);</span><br><span class="line">    Optional&lt;User&gt; result = Optional.ofNullable(user)</span><br><span class="line">        .filter(u -&gt; u.getName() != <span class="keyword">null</span> &amp;&amp; u.getSex().contains(<span class="string">"女"</span>));</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回Optional.empty</span></span><br></pre></td></tr></table></figure>
<p><strong>14. 其他</strong></p>
<p>Java 9 为 Optional 类添加了三个方法：or()、ifPresentOrElse() 和 stream()。or() 方法与 orElse() 和 orElseGet() 类似，它们都在对象为空的时候提供了替代情况。or() 的返回值是由 Supplier 参数产生的另一个 Optional 对象。</p>
<h2 id="5、Base64">5、Base64</h2>
<p>Base64工具类提供了一套静态方法获取下面三种BASE64编解码器：</p>
<ul>
<li>**基本：**输出被映射到一组字符A-Za-z0-9+/，编码不添加任何行标，输出的解码仅支持A-Za-z0-9+/。</li>
<li>**URL：**输出映射到一组字符A-Za-z0-9+_，输出是URL和文件。</li>
<li>**MIME：**输出隐射到MIME友好格式。输出每行不超过76字符，并且使用’\r’并跟随’\n’作为分割。编码输出最后没有行分割。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 编码</span></span><br><span class="line">    String B64 = Base64.getEncoder().encodeToString(<span class="string">"hello?world"</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">    System.out.println(B64); <span class="comment">// 输出为: aGVsbG8/d29ybGQ=</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解码</span></span><br><span class="line">    <span class="keyword">byte</span>[] baseBytes = Base64.getDecoder().decode(<span class="string">"aGVsbG8/d29ybGQ="</span>);</span><br><span class="line">    System.out.println(<span class="keyword">new</span> String(baseBytes, StandardCharsets.UTF_8)); <span class="comment">// 输出为: hello?world</span></span><br><span class="line"></span><br><span class="line">    String urlB64 = Base64.getUrlEncoder().encodeToString(<span class="string">"hello?world"</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">    System.out.println(urlB64); <span class="comment">// 输出为: aGVsbG8_d29ybGQ=</span></span><br><span class="line"></span><br><span class="line">    String mineB64 = Base64.getMimeEncoder().encodeToString(<span class="string">"hello?world"</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">    System.out.println(mineB64); <span class="comment">// 输出为: aGVsbG8/d29ybGQ=</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6、Java-8-日期时间">6、Java 8 日期时间</h2>
<blockquote>
<p>新的java.time包涵盖了所有处理日期，时间，日期/时间，时区，时刻（instants），过程（during）与时钟（clock）的操作。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前的日期时间</span></span><br><span class="line">    LocalDateTime currentTime = LocalDateTime.now();</span><br><span class="line">    <span class="comment">//当前时间: 2021-08-05T12:06:15.590185</span></span><br><span class="line">    System.out.println(<span class="string">"当前时间: "</span> + currentTime);</span><br><span class="line"></span><br><span class="line">    LocalDate date1 = currentTime.toLocalDate();</span><br><span class="line">    <span class="comment">//当前日期: 2021-08-05</span></span><br><span class="line">    System.out.println(<span class="string">"当前日期: "</span> + date1);</span><br><span class="line"></span><br><span class="line">    Month month = currentTime.getMonth();</span><br><span class="line">    <span class="keyword">int</span> month1 = currentTime.get(ChronoField.MONTH_OF_YEAR);</span><br><span class="line">    <span class="keyword">int</span> day = currentTime.getDayOfMonth();</span><br><span class="line">    <span class="keyword">int</span> seconds = currentTime.getSecond();</span><br><span class="line">    <span class="comment">//月: 8, 日: 5, 秒: 15</span></span><br><span class="line">    System.out.println(<span class="string">"月: "</span> + month1 +<span class="string">", 日: "</span> + day +<span class="string">", 秒: "</span> + seconds);</span><br><span class="line"></span><br><span class="line">    LocalDateTime date2 = currentTime.withDayOfMonth(<span class="number">10</span>).withYear(<span class="number">2022</span>);</span><br><span class="line">    <span class="comment">//date2: 2022-08-10T12:06:15.590185</span></span><br><span class="line">    System.out.println(<span class="string">"date2: "</span> + date2);</span><br><span class="line"></span><br><span class="line">    LocalDate date3 = LocalDate.of(<span class="number">2022</span>, Month.DECEMBER, <span class="number">12</span>);</span><br><span class="line">    <span class="comment">//date3: 2022-12-12</span></span><br><span class="line">    System.out.println(<span class="string">"date3: "</span> + date3);</span><br><span class="line"></span><br><span class="line">    LocalTime date4 = LocalTime.of(<span class="number">22</span>, <span class="number">15</span>);</span><br><span class="line">    <span class="comment">//date4: 22:15</span></span><br><span class="line">    System.out.println(<span class="string">"date4: "</span> + date4);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析字符串</span></span><br><span class="line">    LocalTime date5 = LocalTime.parse(<span class="string">"20:15:30"</span>);</span><br><span class="line">    <span class="comment">//date5: 20:15:30</span></span><br><span class="line">    System.out.println(<span class="string">"date5: "</span> + date5);</span><br><span class="line"></span><br><span class="line">    Instant instant = Instant.now();</span><br><span class="line">    <span class="keyword">long</span> currentMilli = instant.toEpochMilli();</span><br><span class="line">    <span class="comment">//当前毫秒数：1628136375597</span></span><br><span class="line">    System.out.println(<span class="string">"当前毫秒数："</span>+currentMilli);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前时间日期</span></span><br><span class="line">    ZonedDateTime date6 = ZonedDateTime.parse(<span class="string">"2015-12-03T10:15:30+05:30[Asia/Shanghai]"</span>);</span><br><span class="line">    <span class="comment">//date6: 2021-08-05</span></span><br><span class="line">    System.out.println(<span class="string">"date6: "</span> + date1);</span><br><span class="line"></span><br><span class="line">    ZoneId id = ZoneId.of(<span class="string">"Europe/Paris"</span>);</span><br><span class="line">    <span class="comment">//ZoneId: Europe/Paris</span></span><br><span class="line">    System.out.println(<span class="string">"ZoneId: "</span> + id);</span><br><span class="line"></span><br><span class="line">    ZoneId currentZone = ZoneId.systemDefault();</span><br><span class="line">    <span class="comment">//当期时区: Asia/Shanghai</span></span><br><span class="line">    System.out.println(<span class="string">"当期时区: "</span> + currentZone);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>参考文章：</p>
<p><a href="https://www.matools.com/api/java8" target="_blank" rel="noopener">https://www.matools.com/api/java8</a></p>
<p><a href="https://www.runoob.com/java/java8-new-features.html" target="_blank" rel="noopener">https://www.runoob.com/java/java8-new-features.html</a></p>
<p><a href="https://mp.weixin.qq.com/s/8n_3VaAcwauGHgoSG1K14g" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/8n_3VaAcwauGHgoSG1K14g</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3打包后部分页面空白</title>
    <url>/posts/4c4cc90e.html</url>
    <content><![CDATA[<h3 id="一、问题描述">一、问题描述</h3>
<p>在开发模式下，使用命令<code>npm run serve</code>运行可以正常显示，但使用<code>npm run bulid</code>打包后打开index.html文件发现显示白屏，但是资源都能正常获取，其他页面也显示正常。<br>
<img src="https://img-blog.csdnimg.cn/1bddb29ab3924cc098a2a364dd2596e3.png" alt="请添加图片描述"></p>
<a id="more"></a>
<p><img src="https://img-blog.csdnimg.cn/a6cc41472c9b42b9be84132825a9b28e.png" alt="请添加图片描述"></p>
<h3 id="二、问题解决">二、问题解决</h3>
<p>查找了很长时间。发现问题是透明度的问题，原来我在一个页面设置的透明度为75%，但是打包后显示则为1%，原因好像是预处理器无视了百分号，把75这个值clip到1%，因此无法显示出来。这里把opacity设置为小数，把75%设置为0.75重新打包即可正常显示。</p>
<p><img src="https://img-blog.csdnimg.cn/bed1a1bb95114c98ac341ec9fd46bf7c.png" alt="请添加图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/eee10644eb234a7494926f7260bdaa0b.png" alt="请添加图片描述"></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>EAIBOT小车树莓派3B网络问题</title>
    <url>/posts/202ae1e9.html</url>
    <content><![CDATA[<h2 id="一、问题描述">一、问题描述</h2>
<p>电脑和EAIBOT小车的树莓派3b连接好路由器WIFI后，树莓派和电脑能够正常通信，电脑能正常上网，但是发现树莓派无法上网。命令<code>ping baidu.com</code>显示找不到主机，在修改<code>/etc/resolv.conf</code>中的<code>nameserver 8.8.8.8</code>DNS配置后仍显示网络不可达。</p>
<p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/image-20210727144414044.png" alt="image-20210727144414044"></p>
<a id="more"></a>
<h2 id="二、问题分析">二、问题分析</h2>
<p>输入<code>ifconfig</code>命令后，eth0是以太网网卡，lo指的是本地回环，wlan0是无线网卡，我无线路由器网段为192.168.32.x，现在是无线网进行连接，局域网能正常通讯。</p>
<p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/image-20210727150148403.png" alt="image-20210727150148403"></p>
<p>因为我连接了wlan0的wifi，因此可以正常通信，但是要访问外部网络时，由于我的以太网网卡优先级高于无线网卡，且以太网网段不在和路由器同一个网段中，此时通过eth0无法访问外网！</p>
<h2 id="三、解决方案">三、解决方案</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#方案一：禁用以太网卡</span></span><br><span class="line">sudo ifconfig eth0 down</span><br><span class="line"><span class="comment">#方案二：设置eth0网卡ip到同网段</span></span><br><span class="line"><span class="comment">#打卡网卡</span></span><br><span class="line">sudo ifconfig eth0 up</span><br><span class="line"><span class="comment">#设置ip</span></span><br><span class="line">sudo ifconfig eth0 192.168.32.203</span><br><span class="line"><span class="comment">#配置好即可上网</span></span><br></pre></td></tr></table></figure>
<h2 id="四、ip静态配置">四、ip静态配置</h2>
<p>静态的IP地址，一来可以防范DHCP自动分配的IP来回变动，导致远程SSH时常无法连接；二来还可以提高树莓派的网络连接速度。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#注意: wifi需要将网卡设置为 wlan0 而不是 eth0</span></span><br><span class="line"><span class="comment"># 打开配置文件</span></span><br><span class="line">sudo vim /etc/dhcpcd.conf</span><br><span class="line"><span class="comment"># 指定接口 eth0</span></span><br><span class="line">interface eth0</span><br><span class="line"><span class="comment"># 指定静态IP，/24表示子网掩码为 255.255.255.0</span></span><br><span class="line">static ip_address=192.168.32.203/24</span><br><span class="line"><span class="comment"># 路由器/网关IP地址</span></span><br><span class="line"><span class="comment"># 手动自定义DNS服务器，这是我路由器默认网关</span></span><br><span class="line">static routers=192.168.32.1 </span><br><span class="line">static domain_name_servers=114.114.114.114</span><br><span class="line"><span class="comment"># 最后重启</span></span><br><span class="line">sudo reboot</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux基础</tag>
      </tags>
  </entry>
  <entry>
    <title>docker学习笔记</title>
    <url>/posts/177bfdaa.html</url>
    <content><![CDATA[<p>@[TOC]</p>
<h2 id="一、Docker概述">一、Docker概述</h2>
<h3 id="1、Docker历史">1、Docker历史</h3>
<blockquote>
<p>更详细的关于Docker历史详见<a href="https://baike.baidu.com/item/Docker/13344470?fr=aladdin" target="_blank" rel="noopener">百度百科</a></p>
</blockquote>
<p>Docker 公司起初是一家名为 <code>dotCloud</code> 的平台即服务（Platform-as-a-Service, PaaS）提供商。底层技术上，dotCloud平台利用了 Linux 容器技术。2013年，dotCloud 的 PaaS 业务并不景气，公司需要寻求新的突破。2013 年 3 月，dotCloud 公司的创始人之一，Docker 之父，28 岁的 <strong>Solomon Hykes</strong> 正式决定，将 Docker 项目开源。开源当月， Docker 0.1 版本发布。此后的每一个月， Docker 都会发布一个版本。到 2014 年 6 月 9 日， Docker 1.0 版本正式发布。而在Docker火了之后，<code>dotCloud</code>公司干脆把公司名字也改成了 <code>Docker Inc</code>。</p>
<a id="more"></a>
<h3 id="2、Docker介绍">2、Docker介绍</h3>
<p>Docker是基于Go语言实现的云开源项目。Docker的主要目标是“Build，Ship and Run Any App , Anywhere”，也就是通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的APP（可以是一个WEB应用或数据库应用等等）及其运行环境能够做到“一次封装，到处运行”。</p>
<h3 id="3、Docker与虚拟机对比">3、Docker与虚拟机对比</h3>
<ul>
<li>
<p>虚拟机属于虚拟化技术；而Docker这样的容器技术，也是虚拟化技术，属于轻量级的虚拟化。</p>
</li>
<li>
<p>虚拟机虽然可以隔离出很多“子电脑”，但占用空间更大，启动更慢；而容器技术恰好没有这些缺点。它不需要虚拟出整个操作系统，只需要虚拟一个小规模的环境（类似“沙箱”）。</p>
</li>
<li>
<p>Docker启动时间很快，几秒钟就能完成，而且，它对资源的利用率很高（一台主机可以同时运行几千个Docker容器）；此外，它占的空间很小，虚拟机一般要几GB到几十GB的空间，而容器只需要MB级甚至KB级。</p>
</li>
<li>
<p>传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。</p>
</li>
<li>
<p>每个容器之间互相隔离，每个容器有自己的文件系统 ，容器之间进程不会相互影响，能区分计算资源。</p>
</li>
</ul>
<blockquote>
<p>Docker官网：<a href="http://www.docker.com" target="_blank" rel="noopener">http://www.docker.com</a><br>
Docker中文网站：<a href="https://www.docker-cn.com" target="_blank" rel="noopener">https://www.docker-cn.com</a><br>
Docker Hub官网：<a href="https://hub.docker.com" target="_blank" rel="noopener">https://hub.docker.com</a>  （仓库）</p>
</blockquote>
<h2 id="二、Docker安装">二、Docker安装</h2>
<h3 id="1、Docker的基本组成">1、Docker的基本组成</h3>
<p><strong>Docker架构图</strong><br>
<img src="https://img-blog.csdnimg.cn/20210617101257800.png" alt="在这里插入图片描述"></p>
<ul>
<li>Docker 本身是一个容器运行载体或称之为管理引擎。我们把应用程序和配置依赖打包好形成一个可交付的运行环境，这个打包好的运行环境就是 image镜像文件。只有通过这个镜像文件才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。</li>
<li>image 文件生成的容器实例，本身也是一个文件，称为镜像文件。</li>
<li>一个容器运行一种服务，当我们需要的时候，就可以通过docker客户端创建一个对应的运行实例，也就是我们的容器</li>
<li>仓库是放了一堆镜像的地方，我们可以把镜像发布到仓库中，需要的时候从仓库中拉下来就可以了。</li>
</ul>
<h3 id="2、安装过程">2、安装过程</h3>
<ol>
<li>
<p>官网安装手册：<a href="https://docs.docker.com/engine/install/centos/" target="_blank" rel="noopener">https://docs.docker.com/engine/install/centos/</a></p>
</li>
<li>
<p>linux内核推荐3.8及以上，这里我使用了centos8</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看内核版本</span></span><br><span class="line">uname -r</span><br><span class="line"><span class="comment">#查看系统版本信息</span></span><br><span class="line">cat /etc/os-release</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>yum安装gcc相关环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install gcc </span><br><span class="line">yum -y install gcc-c++</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>卸载旧环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum remove docker \</span><br><span class="line">    docker-client \</span><br><span class="line">    docker-client-latest \</span><br><span class="line">    docker-common \</span><br><span class="line">    docker-latest \</span><br><span class="line">    docker-latest-logrotate \</span><br><span class="line">    docker-logrotate \</span><br><span class="line">    docker-engine</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>安装需要的软件包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y yum-utils</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>设置仓库镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 官方源是国外的，用国内源代替</span></span><br><span class="line">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>更新yum软件包索引</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#centos8使用该命令，其他版本可能会有些许不同</span></span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>安装Docker CE（社区版）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Docker启动、测试</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#启动</span></span><br><span class="line">systemctl start docker</span><br><span class="line"><span class="comment">#查看版本信息</span></span><br><span class="line">docker version</span><br><span class="line"><span class="comment">#运行hello-word，在这里因为本地镜像没有会先拉远程镜像然后启动容器，如果没有找到就报错</span></span><br><span class="line">docker run hello-world</span><br><span class="line"><span class="comment">#查看镜像</span></span><br><span class="line">docker images</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Docker卸载</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#先停止docker</span></span><br><span class="line">systemctl stop docker</span><br><span class="line"><span class="comment">#卸载docker</span></span><br><span class="line">yum -y remove docker-ce docker-ce-cli containerd.io</span><br><span class="line"><span class="comment">#删除目录</span></span><br><span class="line">rm -rf /var/lib/docker</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="3、阿里云镜像加速">3、阿里云镜像加速</h3>
<p>进入阿里云搜索镜像容器服务，选择管理控制台，找到镜像工具下的镜像加速器，找到相应版本的，每个人都有自己的加速器地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建目录</span></span><br><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line"><span class="comment">#设置加速</span></span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-<span class="string">'EOF'</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"registry-mirrors"</span>: [<span class="string">"https://raw0m61v.mirror.aliyuncs.com"</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"><span class="comment">#重载配置</span></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line"><span class="comment">#重启</span></span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>
<h2 id="三、Docker常用命令">三、Docker常用命令</h2>
<h3 id="1、帮助命令">1、帮助命令</h3>
<blockquote>
<p>官方文档：<a href="https://docs.docker.com/engine/reference/commandline/docker/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/docker/</a></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker version  <span class="comment"># 显示 Docker 版本信息</span></span><br><span class="line">docker info		<span class="comment"># 显示 Docker 系统信息，包括镜像和容器数</span></span><br><span class="line">docker &lt;命令&gt; --<span class="built_in">help</span>  	<span class="comment"># 帮助命令</span></span><br></pre></td></tr></table></figure>
<h3 id="2、镜像命令">2、镜像命令</h3>
<p><strong>docker images</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出本地主机上的镜像 </span></span><br><span class="line">docker images</span><br><span class="line"><span class="comment"># 同一个仓库源可以有多个 TAG，代表这个仓库源的不同版本，我们使用REPOSITORY：TAG 定义不同的镜像，如果你不定义镜像的标签版本，docker将默认使用 lastest 镜像！</span></span><br><span class="line"><span class="comment"># 可选项</span></span><br><span class="line">-a 		<span class="comment">#列出本地所有镜像</span></span><br><span class="line">-q 		<span class="comment">#只显示镜像id</span></span><br></pre></td></tr></table></figure>
<p><strong>docker search</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#搜索镜像</span></span><br><span class="line">docker search mysql</span><br><span class="line"><span class="comment"># docker search 某个镜像的名称, 对应DockerHub仓库中的镜像</span></span><br><span class="line"><span class="comment"># 可选项</span></span><br><span class="line">--filter=stars=50  		<span class="comment">#列出收藏数不小于指定值的镜像。</span></span><br></pre></td></tr></table></figure>
<p><strong>docker pull</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#拉取镜像，不写tag，默认是latest</span></span><br><span class="line">docker pull mysql</span><br><span class="line"><span class="comment"># 指定版本下载</span></span><br><span class="line">docker pull mysql:5.7</span><br></pre></td></tr></table></figure>
<p><strong>docker rmi</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除镜像</span></span><br><span class="line">docker rmi -f 镜像id  		<span class="comment">#删除单个</span></span><br><span class="line">docker rmi -f 镜像名:tag 镜像名:tag   <span class="comment">#删除多个</span></span><br><span class="line">docker rmi -f $(docker images -qa)   <span class="comment"># 删除全部</span></span><br></pre></td></tr></table></figure>
<h3 id="3、容器命令">3、容器命令</h3>
<blockquote>
<p><a href="https://docs.docker.com/engine/reference/run/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/run/</a></p>
</blockquote>
<p>==有镜像才能创建容器==</p>
<p><strong>新建容器并启动</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#首先拉取一下镜像</span></span><br><span class="line">docker pull centos</span><br><span class="line"><span class="comment"># 命令</span></span><br><span class="line">docker run [OPTIONS] IMAGE [COMMAND][ARG...]</span><br><span class="line"><span class="comment"># 常用参数说明</span></span><br><span class="line">--name=<span class="string">"Name"</span>		<span class="comment"># 给容器指定一个名字</span></span><br><span class="line">-d					<span class="comment"># 后台方式运行容器，并返回容器的id！</span></span><br><span class="line">-i					<span class="comment"># 以交互模式运行容器，通过和 -t 一起使用</span></span><br><span class="line">-t					<span class="comment"># 给容器重新分配一个终端，通常和 -i 一起使用</span></span><br><span class="line">-P					<span class="comment"># 随机端口映射（大写）</span></span><br><span class="line">-p					<span class="comment"># 指定端口映射（小结），一般可以有四种写法</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用centos进行用交互模式启动容器，在容器内执行/bin/bash命令！</span></span><br><span class="line">docker run -it centos /bin/bash</span><br><span class="line"><span class="comment">#退出容器可以使用exit</span></span><br></pre></td></tr></table></figure>
<p><strong>列出所有运行的容器</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 命令</span></span><br><span class="line">docker ps [OPTIONS]</span><br><span class="line"><span class="comment"># 常用参数说明</span></span><br><span class="line">-a      <span class="comment"># 列出当前所有正在运行的容器 + 历史运行过的容器 </span></span><br><span class="line">-l      <span class="comment"># 显示最近创建的容器</span></span><br><span class="line">-n=?    <span class="comment"># 显示最近n个创建的容器</span></span><br><span class="line">-q      <span class="comment"># 静默模式，只显示容器编号。</span></span><br></pre></td></tr></table></figure>
<p><strong>退出容器</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exit</span> 			<span class="comment"># 容器停止退出 </span></span><br><span class="line">ctrl+P+Q 		<span class="comment"># 容器不停止退出</span></span><br></pre></td></tr></table></figure>
<p><strong>启动停止容器</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker start (容器id or 容器名)   	 <span class="comment"># 启动容器  </span></span><br><span class="line">docker restart (容器id or 容器名) 	 <span class="comment"># 重启容器  </span></span><br><span class="line">docker stop (容器id or 容器名)   	 <span class="comment"># 停止容器</span></span><br><span class="line">docker <span class="built_in">kill</span> (容器id or 容器名)  		 <span class="comment"># 强制停止容器</span></span><br></pre></td></tr></table></figure>
<p><strong>删除容器</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker rm 容器id                  <span class="comment"># 删除指定容器</span></span><br><span class="line">docker rm -f $(docker ps -a -q)  <span class="comment"># 删除所有容器</span></span><br><span class="line">docker ps -a -q|xargs docker rm  <span class="comment"># 删除所有容器</span></span><br></pre></td></tr></table></figure>
<h3 id="4、常用其他命令">4、常用其他命令</h3>
<p><strong>后台启动容器</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 命令</span></span><br><span class="line">docker run -d 容器名</span><br><span class="line"><span class="comment"># 例子</span></span><br><span class="line">docker run -d centos <span class="comment"># 启动centos，使用后台方式启动</span></span><br><span class="line"><span class="comment"># 问题： 使用docker ps 查看，发现容器已经退出了！</span></span><br><span class="line"><span class="comment"># 解释：Docker容器后台运行，就必须有一个前台进程，容器运行的命令如果不是那些一直挂起的命令，就会自动退出。</span></span><br><span class="line"><span class="comment"># 比如，你运行了nginx服务，但是docker前台没有运行应用，这种情况下，容器启动后，会立即自杀，因为他觉得没有程序了，所以最好的情况是，将你的应用使用前台进程的方式运行启动。</span></span><br><span class="line"><span class="comment">#因为没有后台命令，要启动容器必须使用前台进程启动,同时--rm参数表示如果存在该容器将自动删除</span></span><br><span class="line">docker run -it --rm centos</span><br></pre></td></tr></table></figure>
<p><strong>容器的重启策略</strong></p>
<p>Docker容器的重启策略如下：</p>
<ul>
<li>no，默认策略，在容器退出时不重启容器</li>
<li>on-failure，在容器非正常退出时（退出状态非0），才会重启容器</li>
<li>on-failure:3，在容器非正常退出时重启容器，最多重启3次</li>
<li>always，在容器退出时总是重启容器</li>
<li>unless-stopped，在容器退出时总是重启容器，但是不考虑在Docker守护进程启动时就已经停止了的容器</li>
</ul>
<p>docker run的退出状态码如下：</p>
<ul>
<li>0，表示正常退出</li>
<li>非0，表示异常退出（退出状态码采用chroot标准）</li>
<li>125，Docker守护进程本身的错误</li>
<li>126，容器启动后，要执行的默认命令无法调用</li>
<li>127，容器启动后，要执行的默认命令不存在</li>
<li>其他命令状态码，容器启动后正常执行命令，退出命令时该命令的返回状态码作为容器的退出状态码</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#这将以总是的重启策略运行redis容器，这样如果容器退出，Docker将重启它重试10次</span></span><br><span class="line">docker run --restart=on-failure:10 redis</span><br></pre></td></tr></table></figure>
<p><strong>查看日志</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 命令</span></span><br><span class="line">docker logs -f -t --tail 容器id</span><br></pre></td></tr></table></figure>
<p><strong>查看容器中运行的进程信息，支持 ps 命令参数。</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 命令</span></span><br><span class="line">docker inspect 容器id</span><br></pre></td></tr></table></figure>
<p><strong>进入正在运行的容器</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 命令1</span></span><br><span class="line">docker <span class="built_in">exec</span> -it [容器id or容器名] /bin/bash</span><br><span class="line"><span class="comment"># 命令2</span></span><br><span class="line">docker attach 容器id</span><br><span class="line"><span class="comment"># 区别</span></span><br><span class="line"><span class="comment"># exec   是在容器中打开新的终端，并且可以启动新的进程</span></span><br><span class="line"><span class="comment"># attach 直接进入容器启动命令的终端，不会启动新的进程</span></span><br></pre></td></tr></table></figure>
<p><strong>从容器文件拷贝</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 命令，反之亦可</span></span><br><span class="line">docker cp 容器id:容器内路径 目的主机路径</span><br><span class="line"><span class="comment"># linux复制查看，是否复制成功，举例</span></span><br><span class="line">docker cp c8530dbbe3b4:/home/f1 /home</span><br></pre></td></tr></table></figure>
<h3 id="5、小结">5、小结</h3>
<p><img src="https://img-blog.csdnimg.cn/img_convert/085c7dc4c3eb49044e133cd8aa2c3517.png" alt="image-20210415171859489"></p>
<h2 id="四、Docker简单实例">四、Docker简单实例</h2>
<h3 id="1、Docker安装nginx">1、Docker安装nginx</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#搜索stars大于等于1000的nginx镜像</span></span><br><span class="line">docker search nginx -f=stars=1000</span><br><span class="line"><span class="comment">#拉取nginx最新镜像</span></span><br><span class="line">docker pull nginx</span><br><span class="line"><span class="comment">#运行docker容器，指定容器名字以及映射端口，容器80映射到本机3500</span></span><br><span class="line">docker run -d --name mynginx -p 3500:80 nginx</span><br><span class="line"><span class="comment">#测试是否成功</span></span><br><span class="line">curl localhost:3500</span><br><span class="line"><span class="comment">#进入容器终端</span></span><br><span class="line">docker <span class="built_in">exec</span> -it mynginx /bin/bash</span><br><span class="line"><span class="comment">#寻找nginx,/usr/share/nginx里可以修改Index.html</span></span><br><span class="line">whereis nginx</span><br></pre></td></tr></table></figure>
<h3 id="2、Docker安装tomcat">2、Docker安装tomcat</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 官方文档解释</span></span><br><span class="line"><span class="comment"># -it ：交互模式</span></span><br><span class="line"><span class="comment"># --rm：容器启动成功并退出以后容器就自动移除，一般在测试情况下使用！</span></span><br><span class="line">docker run -it --rm tomcat:9.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1、下载最新版tomcat镜像</span></span><br><span class="line">docker pull tomcat</span><br><span class="line"><span class="comment"># 2、启动</span></span><br><span class="line">docker run -d -p 8555:8080 --name tomcat9 tomcat</span><br><span class="line"><span class="comment"># 3、进入容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it tomcat9 /bin/bash</span><br></pre></td></tr></table></figure>
<h2 id="五、Docker镜像和容器数据卷">五、Docker镜像和容器数据卷</h2>
<h3 id="1、镜像加载原理">1、镜像加载原理</h3>
<blockquote>
<p>镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。</p>
</blockquote>
<p><strong>UnionFS（联合文件系统）</strong>：Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual ﬁlesystem)。Union 文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。<br>
<strong>特性</strong>：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/616dda39f76d07c18c29097ad16ebcfc.png" alt="img"><br>
bootfs(boot ﬁle system)主要包含bootloader和kernel, bootloader主要是引导加载kernel, Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是bootfs。这一层与我们典型的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。<br>
rootfs (root ﬁle system) ，在bootfs之上。包含的就是典型 Linux 系统中的 /dev, /proc, /bin, /etc 等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。</p>
<p>Docker镜像都是只读的，当容器启动时，一个新的可写层被加载到镜像的顶部！这一层就是我们通常说的容器层，容器之下的都叫镜像层。</p>
<h3 id="2、镜像commit命令">2、镜像commit命令</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#提交容器副本使之成为一个新的镜像！</span></span><br><span class="line">docker commit </span><br><span class="line"><span class="comment"># 语法</span></span><br><span class="line">docker commit -m=<span class="string">"提交的描述信息"</span> -a=<span class="string">"作者"</span> 容器id 要创建的目标镜像名:[标签名]</span><br></pre></td></tr></table></figure>
<h3 id="3、容器数据卷">3、容器数据卷</h3>
<blockquote>
<p>容器的数据持久化，以及容器间的继承和数据共享，相当于双向绑定</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 命令</span></span><br><span class="line">docker run -it -v 宿主机绝对路径目录:容器内目录 镜像名</span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line">docker run -it -v /home/ceshi:/home centos /bin/bash</span><br><span class="line"><span class="comment">#查看数据卷是否挂载成功 docker inspect 容器id 找到mounts</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 匿名挂载</span></span><br><span class="line"><span class="comment">#-v 容器内路径</span></span><br><span class="line">docker run -d -P --name nginx01 -v /etc/nginx nginx</span><br><span class="line"><span class="comment"># 匿名挂载的缺点，就是不好维护，通常使用命令 docker volume维护</span></span><br><span class="line">docker volume ls</span><br><span class="line"><span class="comment"># 具名挂载</span></span><br><span class="line"><span class="comment">#-v 卷名:/容器内路径</span></span><br><span class="line">docker run -d -P --name nginx02 -v nginxconfig:/etc/nginx nginx</span><br><span class="line"><span class="comment"># 查看挂载的路径，也可以docker inspect 容器id 查看容器信息</span></span><br><span class="line">docker volume inspect nginxconfig</span><br><span class="line"></span><br><span class="line"><span class="comment">#--volumes-from可以实现多个容器数据同步,举例</span></span><br><span class="line">docker run -it --name docker03 --volumes-from docker01 centos:1.0</span><br></pre></td></tr></table></figure>
<h2 id="六、DockerFile">六、DockerFile</h2>
<blockquote>
<p>dockerﬁle是用来构建Docker镜像的构建文件，是由一系列命令和参数构成的脚本。<br>
地址：<a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a></p>
</blockquote>
<h3 id="1、DockerFile构建">1、DockerFile构建</h3>
<p><strong>基础知识：</strong><br>
1、每条保留字指令都必须为==大写字母==且后面要跟随至少一个参数<br>
2、指令按照从上到下，顺序执行<br>
3、# 表示注释<br>
4、每条指令都会创建一个新的镜像层，并对镜像进行提交<br>
<strong>构建流程：</strong><br>
1、docker从基础镜像运行一个容器<br>
2、执行一条指令并对容器做出修改<br>
3、执行类似 docker commit 的操作提交一个新的镜像层<br>
4、Docker再基于刚提交的镜像运行一个新容器<br>
5、执行dockerﬁle中的下一条指令直到所有指令都执行完成！</p>
<h3 id="2、DockerFile指令">2、DockerFile指令</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM    	  <span class="comment"># 基础镜像，当前新镜像是基于哪个镜像的</span></span><br><span class="line">MAINTAINER    <span class="comment"># 镜像维护者的姓名混合邮箱地址</span></span><br><span class="line">RUN  		  <span class="comment"># 容器构建时需要运行的命令</span></span><br><span class="line">EXPOSE   	  <span class="comment"># 当前容器对外保留出的端口</span></span><br><span class="line">WORKDIR  	  <span class="comment"># 指定在创建容器后，终端默认登录的进来工作目录，一个落脚点</span></span><br><span class="line">ENV  		  <span class="comment"># 用来在构建镜像过程中设置环境变量</span></span><br><span class="line">ADD   		  <span class="comment"># 将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar压缩包</span></span><br><span class="line">COPY  		  <span class="comment"># 类似ADD，拷贝文件和目录到镜像中！</span></span><br><span class="line">VOLUME  	  <span class="comment"># 容器数据卷，用于数据保存和持久化工作</span></span><br><span class="line">CMD  		  <span class="comment"># 指定一个容器启动时要运行的命令，dockerFile中可以有多个CMD指令，但只有最后一个生效！docker run时参数可以被覆盖，一般指定默认的运行参数</span></span><br><span class="line">ENTRYPOINT    <span class="comment"># 指定一个容器启动时要运行的命令！和CMD一样，但无法覆盖，一般指定默认的运行命令</span></span><br><span class="line">ONBUILD   	  <span class="comment"># 当构建一个被继承的DockerFile时运行命令，父镜像在被子镜像继承后，父镜像的ONBUILD被触发</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/img_convert/9b70944cd4117093c3bb75565704156e.png" alt="image-20210417150051303"></p>
<h3 id="3、创建自己的Centos镜像">3、创建自己的Centos镜像</h3>
<p>1、编写dockerfile文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">MAINTAINER shawn&lt;shawn955@163.com&gt;</span><br><span class="line"></span><br><span class="line">ENV MYPATH /usr/<span class="built_in">local</span></span><br><span class="line">WORKDIR <span class="variable">$MYPATH</span></span><br><span class="line"></span><br><span class="line">RUN yum -y install vim</span><br><span class="line">RUN yum -y install net-tools</span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line">CMD <span class="built_in">echo</span> <span class="string">"---构建完毕---"</span></span><br><span class="line">CMD /bin/bash</span><br></pre></td></tr></table></figure>
<p>2、构建</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#. 表示当前目录，如果名字是Dockerfile，则可以不需要命令-f dockerfile地址</span></span><br><span class="line">docker build -f dockerfile地址 -t 新镜像名字:TAG .</span><br><span class="line"><span class="comment">#实例</span></span><br><span class="line">docker build -f dockerfile -t mycentos:1.0 .</span><br><span class="line"><span class="comment">#可以查看构建历史</span></span><br><span class="line">docker <span class="built_in">history</span> mycentos</span><br></pre></td></tr></table></figure>
<h3 id="4、构建自己的tomcat镜像">4、构建自己的tomcat镜像</h3>
<p>1、准备文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 准备好以下文件，创建Dockerfile文件，用这个文件名构建时默认不用指定文件了</span></span><br><span class="line">-rw-r--r-- 1 root root  11486964 3月  30 18:46 apache-tomcat-9.0.45.tar.gz</span><br><span class="line">-rw-r--r-- 1 root root 189756259 4月  17 15:58 jdk-8u161-linux-x64.tar.gz</span><br><span class="line">-rw-r--r-- 1 root root         0 4月  17 16:05 README.md</span><br></pre></td></tr></table></figure>
<p>2、构建Dockerfile文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">MAINTAINER shawn&lt;shawn955@163.com&gt;</span><br><span class="line"><span class="comment">#拷贝</span></span><br><span class="line">COPY README.md /usr/<span class="built_in">local</span>/README.md</span><br><span class="line"><span class="comment">#把java与tomcat添加到容器中，会自动解压</span></span><br><span class="line">ADD jdk-8u161-linux-x64.tar.gz /usr/<span class="built_in">local</span>/</span><br><span class="line">ADD apache-tomcat-9.0.45.tar.gz /usr/<span class="built_in">local</span>/</span><br><span class="line"><span class="comment">#设置工作访问时候的WORKDIR路径，登录落脚点</span></span><br><span class="line">ENV MYPATH /usr/<span class="built_in">local</span></span><br><span class="line">WORKDIR <span class="variable">$MYPATH</span></span><br><span class="line"><span class="comment">#安装vim编辑器</span></span><br><span class="line">RUN yum -y install vim</span><br><span class="line"><span class="comment">#配置java与tomcat环境变量</span></span><br><span class="line">ENV JAVA_HOME /usr/<span class="built_in">local</span>/jdk1.8.0_161</span><br><span class="line">ENV CLASSPATH <span class="variable">$JAVA_HOME</span>/lib/dt.jar:<span class="variable">$JAVA_HOME</span>/lib/tools.jar</span><br><span class="line">ENV CATALINA_HOME /usr/<span class="built_in">local</span>/apache-tomcat-9.0.45</span><br><span class="line">ENV PATH <span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$CATALINA_HOME</span>/lib:<span class="variable">$CATALINA_HOME</span>/bin</span><br><span class="line"><span class="comment">#容器运行时监听的端口</span></span><br><span class="line">EXPOSE 8080</span><br><span class="line"><span class="comment">#启动时运行tomcat</span></span><br><span class="line">CMD /usr/<span class="built_in">local</span>/apache-tomcat-9.0.45/bin/startup.sh &amp;&amp; tail -F /usr/<span class="built_in">local</span>/apache-tomcat-9.0.45/bin/logs/catalina.out</span><br></pre></td></tr></table></figure>
<p>3、构建镜像以及启动挂载</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#构建镜像</span></span><br><span class="line">docker build -t mytomcat .</span><br><span class="line"><span class="comment">#启动并挂载容器卷，最后只需要在本地宿主机上传java文件即可</span></span><br><span class="line">docker run -d -p 9090:8080 --name mytomcat -v /home/tomcat/<span class="built_in">test</span>:/usr/<span class="built_in">local</span>/apache-tomcat-9.0.45/webapps/<span class="built_in">test</span> -v /home/tomcat/build/tomcat/tomcat9logs/:/usr/<span class="built_in">local</span>/apache-tomcat-9.0.45/logs --privileged=<span class="literal">true</span> mytomcat</span><br></pre></td></tr></table></figure>
<h3 id="5、发布镜像">5、发布镜像</h3>
<p><strong>发布到Docker Hub官网</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看docker login 命令</span></span><br><span class="line">docker login --<span class="built_in">help</span></span><br><span class="line"><span class="comment">#登录</span></span><br><span class="line">docker login -u [用户名] -p [密码]</span><br><span class="line"><span class="comment">#发布，需要带标签</span></span><br><span class="line">docker push mytomcat:latest</span><br><span class="line"><span class="comment">#若报错denied: requested access to the resource is denied</span></span><br><span class="line"><span class="comment">#问题：本地镜像名无帐号信息，解决加 tag即可，另外需要加上用户名才能push</span></span><br><span class="line">docker tag [镜像id] shawn222/mytomcat:v1</span><br><span class="line"><span class="comment">#发布</span></span><br><span class="line">docker push shawn222/mytomcat:v1</span><br><span class="line"><span class="comment">#下线</span></span><br><span class="line">docker <span class="built_in">logout</span></span><br></pre></td></tr></table></figure>
<p><strong>发布到阿里云</strong></p>
<p><code>登录阿里云&gt;找到容器镜像服务&gt;创建命名空间&gt;创建镜像仓库&gt;点击进入这个镜像仓库</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#登录</span></span><br><span class="line">docker login --username=[账号] registry.cn-hangzhou.aliyuncs.com</span><br><span class="line"><span class="comment">#标记</span></span><br><span class="line">docker tag [ImageId] registry.cn-hangzhou.aliyuncs.com/shawn222/ownwarehouse:[镜像版本号]</span><br><span class="line"><span class="comment">#发布</span></span><br><span class="line">docker push registry.cn-hangzhou.aliyuncs.com/shawn222/ownwarehouse:[镜像版本号]</span><br></pre></td></tr></table></figure>
<h2 id="七、Docker网络">七、Docker网络</h2>
<h3 id="1、网络详解">1、网络详解</h3>
<p>查看本地ip地址<code>ip addr</code>，docker 采用了veth-pair协议，docker每启动一个容器都会生成一对虚拟接口进行通信（这样一对接口叫veth pair）；如同路由器一样进行与容器间的通信。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lo        127.0.0.1         <span class="comment"># 本机回环地址</span></span><br><span class="line">eth0      172.20.49.98/20   <span class="comment"># 服务器私有ip地址</span></span><br><span class="line">docker0   172.17.0.1/16     <span class="comment"># docker网桥</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/img_convert/0f5be5ff2ea23adfcd03641c8c4fca75.png" alt="image-20210517165039059"></p>
<blockquote>
<p>在容器启动时使用–link已经过时，原理是在主机的域名和ip直接配置到了hosts文件中</p>
</blockquote>
<h3 id="2、自定义网络">2、自定义网络</h3>
<p>因为使用默认网络创建的容器不能ping通容器名，而使用自定义网络可以ping通</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看所有网络，默认桥接</span></span><br><span class="line">docker network ls</span><br><span class="line"><span class="comment"># 默认我们不配置网络，也就相当于默认值 --net bridge  使用的docker0 </span></span><br><span class="line">docker run -d -P --name tomcat01 --net bridge tomcat</span><br><span class="line">docker run -d -P --name tomcat02 --net bridge tomcat</span><br><span class="line"><span class="comment"># docker0网络的特点</span></span><br><span class="line">1.	它是默认的</span><br><span class="line">2.	域名访问不通</span><br><span class="line">3.  可以使用--link，但是有问题</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">Docker网络模式</th>
<th>配置</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">host模式</td>
<td>–net=host</td>
<td style="text-align:center">容器和宿主机共享Network namespace。</td>
</tr>
<tr>
<td style="text-align:center">container模式</td>
<td>-net=container:NAME_or_ID</td>
<td style="text-align:center">容器和另外一个容器共享Network namespace。 kubernetes中的pod就是多个容器共享一个Network namespace。</td>
</tr>
<tr>
<td style="text-align:center">Docker网络模式</td>
<td>–net=none</td>
<td style="text-align:center">容器有独立的Network namespace，但并没有对其进行任何网络设置，如分配veth pair 和网桥连接，配置IP等。</td>
</tr>
<tr>
<td style="text-align:center">bridge模式</td>
<td>–net=bridge</td>
<td style="text-align:center">（默认为该模式）</td>
</tr>
<tr>
<td style="text-align:center">自定义模式</td>
<td>-net=自定义</td>
<td style="text-align:center">用户自己使用network相关命令定义网络，创建容器的时候可以指定为自己定</td>
</tr>
</tbody>
</table>
<p><strong>创建自定义网络</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建</span></span><br><span class="line">docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet</span><br><span class="line"><span class="comment"># 查看一下是否成功创建</span></span><br><span class="line">docker network ls</span><br><span class="line">docker network inspect mynet</span><br><span class="line"><span class="comment"># 使用自定义网络创建两个容器</span></span><br><span class="line">docker run -d -P --name tomcat-net-01 --net mynet tomcat</span><br><span class="line">docker run -d -P --name tomcat-net-02 --net mynet tomcat</span><br><span class="line"><span class="comment"># 进入容器内，发现使用容器名也可以ping通</span></span><br><span class="line">docker <span class="built_in">exec</span> -it tomcat-net-01 ping tomcat-net-02</span><br></pre></td></tr></table></figure>
<h3 id="3、网络连通">3、网络连通</h3>
<p>默认的docker01网络和自定义的网络无法连通，这就是网络隔离，若要一个网段的容器与另一个网段进行通信，则需要使用<code>docker network connect</code>命令</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/12002d46e97e2f46373ad0ca9170b8cc.png" alt="image-20210517203104154"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看帮助文档，发现connect以及详情</span></span><br><span class="line">docker network --<span class="built_in">help</span></span><br><span class="line">docker network connect --<span class="built_in">help</span></span><br><span class="line"><span class="comment"># docker network connect [OPTIONS] NETWORK CONTAINER</span></span><br><span class="line"><span class="comment"># 运行以下命令，tomcat01即可与mynet通信，这相当于服务器的公网和私网</span></span><br><span class="line">docker network connect mynet tomcat01</span><br><span class="line"><span class="comment"># 检查发现容器已被自定义网络记录</span></span><br><span class="line">docker network inspect mynet</span><br></pre></td></tr></table></figure>
<h2 id="八、Docker实战">八、Docker实战</h2>
<h3 id="1、Idea整合Docker发布自己镜像">1、Idea整合Docker发布自己镜像</h3>
<p><strong>创建springboot项目</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建最基本的springboot项目</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloCintroller</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello shawn"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进行package打包，就会有一个jar包生成</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/98f17c5480e8c7fd5aa07bc1151fa261.png" alt="image-20210517212259595"></p>
<p><strong>打包镜像并启动容器</strong></p>
<p>在项目下编写 Dockerﬁle 文件，将打包好的jar包拷贝到Dockerﬁle同级目录</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> java:<span class="number">8</span></span><br><span class="line"><span class="comment"># 先移动到同级目录下</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ./*.jar /app.jar</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"--server.port=8080"</span>]</span></span><br><span class="line"><span class="comment"># 指定暴露的端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"java"</span>,<span class="string">"-jar"</span>,<span class="string">"/app.jar"</span>]</span></span><br></pre></td></tr></table></figure>
<p>上传jar包和Dockerfile到服务器，保证在同一目录下，构建镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 构建镜像名为shawn666的镜像</span></span><br><span class="line">docker build -t shawn666 .</span><br><span class="line"><span class="comment"># 启动容器</span></span><br><span class="line">docker run -d -p 8083:8080 --name shawn-springboot shawn666</span><br><span class="line"><span class="comment"># 测试成功</span></span><br><span class="line">curl localhost:8083/hello</span><br></pre></td></tr></table></figure>
<h3 id="2、Redis集群部署">2、Redis集群部署</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#shell脚本循环生成配置文件</span></span><br><span class="line"><span class="keyword">for</span> port <span class="keyword">in</span> $(seq 1 6);\</span><br><span class="line"><span class="keyword">do</span> \</span><br><span class="line">mkdir -p /mydata/redis/node-<span class="variable">$&#123;port&#125;</span>/conf</span><br><span class="line">touch /mydata/redis/node-<span class="variable">$&#123;port&#125;</span>/conf/redis.conf</span><br><span class="line">cat &lt;&lt;EOF&gt;&gt;/mydata/redis/node-<span class="variable">$&#123;port&#125;</span>/conf/redis.conf</span><br><span class="line">port 6379</span><br><span class="line"><span class="built_in">bind</span> 0.0.0.0</span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file nodes.conf</span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line">cluster-announce-ip 172.38.0.1<span class="variable">$&#123;port&#125;</span></span><br><span class="line">cluster-announce-port 6379</span><br><span class="line">cluster-announce-bus-port 16379</span><br><span class="line">appendonly yes</span><br><span class="line">EOF</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#分别启动docker容器，这里也可以用shell脚本编写</span></span><br><span class="line">docker pull redis</span><br><span class="line">docker run -p 6371:6379 -p 16371:16379 --name redis-1 -v /mydata/redis/node-1/data:/data -v /mydata/redis/node-1/conf/redis.conf:/etc/redis/redis.conf -d --net redis --ip 172.38.0.11 redis redis-server /etc/redis/redis.conf</span><br><span class="line">docker run -p 6372:6379 -p 16372:16379 --name redis-2 -v /mydata/redis/node-2/data:/data -v /mydata/redis/node-2/conf/redis.conf:/etc/redis/redis.conf -d --net redis --ip 172.38.0.12 redis redis-server /etc/redis/redis.conf</span><br><span class="line">docker run -p 6373:6379 -p 16373:16379 --name redis-3 -v /mydata/redis/node-3/data:/data -v /mydata/redis/node-3/conf/redis.conf:/etc/redis/redis.conf -d --net redis --ip 172.38.0.13 redis redis-server /etc/redis/redis.conf</span><br><span class="line">docker run -p 6374:6379 -p 16374:16379 --name redis-4 -v /mydata/redis/node-4/data:/data -v /mydata/redis/node-4/conf/redis.conf:/etc/redis/redis.conf -d --net redis --ip 172.38.0.14 redis redis-server /etc/redis/redis.conf</span><br><span class="line">docker run -p 6375:6379 -p 16375:16379 --name redis-5 -v /mydata/redis/node-5/data:/data -v /mydata/redis/node-5/conf/redis.conf:/etc/redis/redis.conf -d --net redis --ip 172.38.0.15 redis redis-server /etc/redis/redis.conf</span><br><span class="line">docker run -p 6376:6379 -p 16376:16379 --name redis-6 -v /mydata/redis/node-6/data:/data -v /mydata/redis/node-6/conf/redis.conf:/etc/redis/redis.conf -d --net redis --ip 172.38.0.16 redis redis-server /etc/redis/redis.conf</span><br><span class="line"><span class="comment">#随机进入一个容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it redis-1 /bin/bash</span><br><span class="line"><span class="comment">#生成集群</span></span><br><span class="line">redis-cli --cluster create 172.38.0.11:6379 172.38.0.12:6379 172.38.0.13:6379 172.38.0.14:6379 172.38.0.15:6379 172.38.0.16:6379 --cluster-replicas 1   </span><br><span class="line"><span class="comment">#查看集群结点</span></span><br><span class="line">cluster nodes</span><br><span class="line"><span class="comment">#查看集群信息</span></span><br><span class="line">cluster info</span><br><span class="line"><span class="comment">#集群会自动计算存储位置，若主节点宕机，从节点会成为主节点</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> a b</span><br><span class="line">-&gt; Redirected to slot [15495] located at 172.38.0.13:6379</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
<h2 id="九、Docker-Compose">九、Docker Compose</h2>
<h3 id="1、Docker-Compose">1、Docker Compose</h3>
<blockquote>
<p>Compose是一个用于定义和运行多容器Docker应用程序的工具。使用Compose，可以使用YAML文件来配置应用程序的服务。然后使用一个命令，从配置中创建并启动所有服务。Compose适用于所有环境：生产、暂存、开发、测试以及CI工作流。</p>
<p>官网地址：<a href="https://docs.docker.com/compose/" target="_blank" rel="noopener">https://docs.docker.com/compose/</a></p>
</blockquote>
<h3 id="2、Compoese安装">2、Compoese安装</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#因为compose是docker开源第三方软件，需要额外下载</span></span><br><span class="line">sudo curl -L <span class="string">"https://github.com/docker/compose/releases/download/1.29.2/docker-compose-<span class="variable">$(uname -s)</span>-<span class="variable">$(uname -m)</span>"</span> -o /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line"><span class="comment">#获取可执行权限</span></span><br><span class="line">chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line"><span class="comment">#进入目录</span></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/bin/</span><br><span class="line"><span class="comment">#查看版本</span></span><br><span class="line">docker-compose -v</span><br></pre></td></tr></table></figure>
<h3 id="3、yaml配置文件规则">3、yaml配置文件规则</h3>
<p><code>docker-compose.yml</code>配置文件作为核心文件。详细配置文件官网：<a href="https://docs.docker.com/compose/compose-file/compose-file-v3/" target="_blank" rel="noopener">https://docs.docker.com/compose/compose-file/compose-file-v3/</a></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#yaml文件是三层</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">''</span> <span class="comment">#1、版本</span></span><br><span class="line"><span class="attr">services:</span>  <span class="string">/2、服务</span></span><br><span class="line">  <span class="string">服务1:</span>   </span><br><span class="line">  	<span class="comment">#服务配置，和docker很像</span></span><br><span class="line">  	<span class="attr">image:</span></span><br><span class="line">    <span class="attr">build:</span> </span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="comment">#有依赖关系先启动依赖，最后启动本服务</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">    <span class="string">......</span></span><br><span class="line">  <span class="string">服务2:</span></span><br><span class="line">    <span class="string">......</span></span><br><span class="line"><span class="comment">#3、其他配置 网络/卷、全局规则</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line"><span class="attr">configs:</span></span><br></pre></td></tr></table></figure>
<h3 id="4、Compose体验">4、Compose体验</h3>
<p>官网demo地址：<a href="https://docs.docker.com/compose/gettingstarted/" target="_blank" rel="noopener">https://docs.docker.com/compose/gettingstarted/</a></p>
<p><strong>1、前期准备</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir composetest</span><br><span class="line"><span class="built_in">cd</span> composetest</span><br><span class="line"><span class="comment">#创建py文件</span></span><br><span class="line">vim app.py</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在py文件里写入以下内容，这里是一个简单的web服务</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"><span class="comment">#这里host主机使用了redis域名，因为docker在同一网络下，可以使用域名进行访问</span></span><br><span class="line">cache = redis.Redis(host=<span class="string">'redis'</span>, port=<span class="number">6379</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_hit_count</span><span class="params">()</span>:</span></span><br><span class="line">    retries = <span class="number">5</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> cache.incr(<span class="string">'hits'</span>)</span><br><span class="line">        <span class="keyword">except</span> redis.exceptions.ConnectionError <span class="keyword">as</span> exc:</span><br><span class="line">            <span class="keyword">if</span> retries == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">raise</span> exc</span><br><span class="line">            retries -= <span class="number">1</span></span><br><span class="line">            time.sleep(<span class="number">0.5</span>)</span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    count = get_hit_count()</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello World! I have been seen &#123;&#125; times.\n'</span>.format(count)</span><br></pre></td></tr></table></figure>
<p>之后<code>vim requirements.txt</code>文件，写入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">flask</span><br><span class="line">redis</span><br></pre></td></tr></table></figure>
<p><strong>2、创建Dockerfile</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># syntax=docker/dockerfile:1</span></span><br><span class="line">FROM python:3.7-alpine</span><br><span class="line">WORKDIR /code</span><br><span class="line">ENV FLASK_APP=app.py</span><br><span class="line">ENV FLASK_RUN_HOST=0.0.0.0</span><br><span class="line">RUN apk add --no-cache gcc musl-dev linux-headers</span><br><span class="line">COPY requirements.txt requirements.txt</span><br><span class="line">RUN pip install -r requirements.txt</span><br><span class="line">EXPOSE 5000</span><br><span class="line">COPY . .</span><br><span class="line">CMD [<span class="string">"flask"</span>, <span class="string">"run"</span>]</span><br></pre></td></tr></table></figure>
<p><strong>3、定义Compose服务（docker-compose.yml）</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">version: <span class="string">"3.9"</span></span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">"5000:5000"</span></span><br><span class="line">  redis:</span><br><span class="line">    image: <span class="string">"redis:alpine"</span></span><br></pre></td></tr></table></figure>
<p><strong>4、输入<code>docker-compose up</code>运行Compose服务，<code>docker-compose stop</code>停止服务</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#这是生成后的四个文件</span></span><br><span class="line">-rw-r--r-- 1 root root 683 6月  12 19:56 app.py</span><br><span class="line">-rw-r--r-- 1 root root 111 6月  12 19:55 docker-compose.yml</span><br><span class="line">-rw-r--r-- 1 root root 281 6月  12 19:53 Dockerfile</span><br><span class="line">-rw-r--r-- 1 root root  12 6月  12 19:53 requirements.txt</span><br></pre></td></tr></table></figure>
<p>到如图所示情况后，最后在浏览器输入<code>http://MACHINE_VM_IP:5000</code>即可访问(注意端口的开放)<br>
<img src="https://img-blog.csdnimg.cn/20210617100654718.png" alt="在这里插入图片描述"></p>
<h3 id="5、Cpmpose实战">5、Cpmpose实战</h3>
<blockquote>
<p>快速搭建wordpress的demo:<a href="https://docs.docker.com/samples/wordpress/" target="_blank" rel="noopener">https://docs.docker.com/samples/wordpress/</a></p>
<p>对于springboot实战如下</p>
</blockquote>
<p><strong>1、创建springboot项目</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- pom.xml的依赖，要选择web和redis依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>2、编写<code>application.yml</code>文件</strong></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">  <span class="comment">#这里主机使用了名字，因为在docker联通的网络中，可以用主机名代替ip。</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">redis</span></span><br></pre></td></tr></table></figure>
<p><strong>3、编写java文件</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComposeController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RedisTemplate&lt;String, String&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"view"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        redisTemplate.opsForValue().increment(<span class="string">"view"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"您已访问次数"</span>+ redisTemplate.opsForValue().get(<span class="string">"view"</span>)+<span class="string">"次"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4、maven打包</strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/648a0913b9b0ed4f96c6626869b04b06.png" alt="image-20210614173849606"></p>
<p><strong>5、在根目录编写dockerfile文件</strong></p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> java:<span class="number">8</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ./*.jar /app.jar</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"--server=8080"</span>]</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8808</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"java"</span>,<span class="string">"-jar"</span>,<span class="string">"./app.jar"</span>]</span></span><br></pre></td></tr></table></figure>
<p><strong>6、在根目录编写<code>docker-compose.yml</code>文件</strong></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3.9"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">shawnapp:</span></span><br><span class="line">    <span class="attr">build:</span></span><br><span class="line">      <span class="attr">context:</span> <span class="string">.</span></span><br><span class="line">      <span class="attr">dockerfile:</span> <span class="string">dockerfile</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">shawnapp</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"8080:8080"</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span></span><br></pre></td></tr></table></figure>
<p><strong>7、上传部署，启动服务</strong></p>
<p>将<code>docker-compose.yml</code>，<code>dockerfile</code>和jar包上传服务器，启动后即可访问</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#前台启动</span></span><br><span class="line">docker-compose  up </span><br><span class="line"><span class="comment">#后台启动</span></span><br><span class="line">docker-compose  up -d</span><br><span class="line"><span class="comment"># 重新构建</span></span><br><span class="line">docker-compose  up --build</span><br></pre></td></tr></table></figure>
<h2 id="十、Docker-Swarm">十、Docker Swarm</h2>
<blockquote>
<p>Docker Swarm 是 Docker 的集群管理工具。它将 Docker 主机池转变为单个虚拟 Docker 主机。 Docker Swarm 提供了标准的 Docker API，所有任何已经与 Docker 守护程序通信的工具都可以使用 Swarm 轻松地扩展到多个主机，Docker Swarm代码开源在https://github.com/docker/swarm。Docker Swarm 和 Docker Compose 一样，都是 Docker 官方容器编排项目，但不同的是，Docker Compose 是一个在单个服务器或主机上创建多个容器的工具，而 Docker Swarm 则可以在多个服务器或主机上创建容器集群服务，对于微服务的部署，Docker Swarm 会更加适合。</p>
</blockquote>
<p>swarm分为管理节点和工作结点，所有操作都在manager节点上，并且集群的管理节点数量至少为3，manager节点使用raft协议进行管理。</p>
<p>官网：<a href="https://docs.docker.com/engine/swarm/" target="_blank" rel="noopener">https://docs.docker.com/engine/swarm/</a></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/6bcf2d73e2570c95c0f72035ee4f39c2.png" alt="image-20210615164041790"></p>
<h3 id="1、服务器的购买和docker安装">1、服务器的购买和docker安装</h3>
<p>因为至少购买4台云服务器，考虑经济成本，这里我选择了腾讯云的按量计费，云以及按使用流量计费，操作系统使用centos8，云服务器硬件配置为1核2G。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install gcc </span><br><span class="line">yum -y install gcc-c++</span><br><span class="line">yum install -y yum-utils</span><br><span class="line"><span class="comment"># 官方源是国外的，用国内源代替</span></span><br><span class="line">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">yum makecache</span><br><span class="line">yum install -y docker-ce docker-ce-cli containerd.io</span><br><span class="line"><span class="comment">#启动docker</span></span><br><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>
<p>四台云服务器可以一个命令同时执行，这里我使用了finalShell，打开四个不同的服务器后同时进行操作<br>
<img src="https://img-blog.csdnimg.cn/20210617100608909.png" alt="在这里插入图片描述"></p>
<h3 id="2、Swarm集群搭建">2、Swarm集群搭建</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看网络</span></span><br><span class="line">docker network ls</span><br><span class="line"><span class="comment">#帮助命令</span></span><br><span class="line">docker swarm --<span class="built_in">help</span></span><br><span class="line">docker swarm init --<span class="built_in">help</span></span><br><span class="line"><span class="comment">#从帮助文档库看出需要init，这里使用内网进行搭建，可以ip addr命令查看，也可以登录云平台查看内网地址</span></span><br><span class="line"><span class="comment">#搭建主节点manager</span></span><br><span class="line">docker swarm init --advertise-addr 10.206.0.14</span><br><span class="line"><span class="comment">#work节点在另外两台机器输入相应命令即可</span></span><br><span class="line"><span class="comment">#若想创建主节点，运行，之后复制相应命令到第四台机器即可加入</span></span><br><span class="line">docker swarm join-token manager</span><br><span class="line"><span class="comment">#查看节点情况，这里完成了二主二从，这里即可灵活加入节点</span></span><br><span class="line">docker node ls</span><br></pre></td></tr></table></figure>
<p>搭建完主节点后，会自动进行提示如何加入工作节点和新的管理节点，在新的服务器上运行即可成为work或manager节点。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/b976ee3615ae0ff8694006dd946fae77.png" alt="image-20210615192237766"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/c2f3a0d37364645a2cd95ebd8c891fac.png" alt="image-20210615193015971"></p>
<h3 id="3、Raft协议">3、Raft协议</h3>
<blockquote>
<p>Raft协议：保证大多数节点存活；当存活节点数&gt;1时能正常运行，故集群数量必须&gt;3台，保证高可用</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#双主双从时，当停止一个manager节点时，另一个也无法正常使用</span></span><br><span class="line"><span class="comment">#修改为三主一从，down掉一个manager节点时，集群仍可正常访问</span></span><br><span class="line">systemctl stop docker</span><br><span class="line">systemctl start docker</span><br><span class="line"><span class="comment">#离开节点</span></span><br><span class="line">[root@shawn2 ~]<span class="comment"># docker swarm leave</span></span><br><span class="line">Node left the swarm.</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/img_convert/f119d910f70e31deed044f3d93cd24db.png" alt="image-20210615194703767"></p>
<h3 id="4、Service服务实例">4、Service服务实例</h3>
<blockquote>
<p>使用swarm的优点是可以弹性的进行扩缩容集群，因为可以使用名字作为host主机，可以随时增加或者缩减容器；而docker-compose 是单机项目</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#容器启动！不具有扩缩容器</span></span><br><span class="line">docker run  </span><br><span class="line"><span class="comment">#服务！ 具有扩缩容器，可以滚动更新</span></span><br><span class="line">docker service </span><br><span class="line"><span class="comment">#查看命令帮助！要多使用</span></span><br><span class="line">docker service --<span class="built_in">help</span></span><br><span class="line"><span class="comment">#和docker run类似的命令，创建服务，只能在主节点上创建服务，创建完可以进行访问</span></span><br><span class="line">docker service create --replicas 1 -p 8888:80 --name mynginx nginx</span><br><span class="line"><span class="comment">#查看某个服务，可以查看节点分布在哪几个服务器上</span></span><br><span class="line">docker service ps mynginx</span><br><span class="line"><span class="comment">#查看服务副本数</span></span><br><span class="line">docker service ls</span><br><span class="line"><span class="comment">#查看服务日志</span></span><br><span class="line">docker service logs mynginx</span><br><span class="line"><span class="comment">#扩容至5个副本以及缩小至2个副本，缩扩容都可用</span></span><br><span class="line">docker service scale mynginx=5</span><br><span class="line">docker service update --replicas 2 mynginx</span><br><span class="line"><span class="comment">#删除服务</span></span><br><span class="line">docker service rm mynginx</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210617100810621.png" alt="在这里插入图片描述"></p>
<h3 id="5、服务、任务简单小结">5、服务、任务简单小结</h3>
<p><strong>Swarm</strong><br>
集群的管理和编号。  docker可以初始化一个 swarm 集群，其他节点可以加入。（管理、工作者）<br>
<strong>Node</strong><br>
就是一个docker节点。多个节点就组成了一个网络集群。（管理、工作者）<br>
<strong>Service</strong></p>
<p>服务 （Services） 是指一组任务的集合，服务定义了任务的属性。服务有两种模式：</p>
<ul>
<li><code>replicated services</code> 按照一定规则在各个工作节点上运行指定个数的任务。</li>
<li><code>global services</code> 每个工作节点上运行一个任务</li>
</ul>
<p>两种模式通过 <code>docker service create</code> 的 <code>--mode</code> 参数指定。</p>
<p><strong>Task</strong><br>
任务 （Task）是Swarm中的最小的调度单位，目前来说就是一个单一的容器。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/1f1dee52f056b5fb36118044d13426b4.png" alt="image-20210616114530443"></p>
<h3 id="6、Docker-Stack">6、Docker Stack</h3>
<blockquote>
<p>docker-compose.yml 来一次配置、启动多个容器，在 Swarm集群中也可以使用 compose 文件 （<code>docker-compose.yml</code>） 来配置、启动多个服务。而<code>docker service create</code> 一次只能部署一个服务，使用stack部署 <code>docker-compose.yml</code> 我们可以一次启动多个关联的服务。</p>
</blockquote>
<p>首先创建<code>docker-compose.yml</code>文件，首先要启动swarm集群服务，其中的 <code>visualizer</code> 服务提供一个可视化页面，我们可以从浏览器中很直观的查看集群中各个服务的运行节点。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">wordpress:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">wordpress</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">80</span><span class="string">:80</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">overlay</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">WORDPRESS_DB_HOST:</span> <span class="string">db:3306</span></span><br><span class="line">      <span class="attr">WORDPRESS_DB_USER:</span> <span class="string">wordpress</span></span><br><span class="line">      <span class="attr">WORDPRESS_DB_PASSWORD:</span> <span class="string">wordpress</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">mode:</span> <span class="string">replicated</span></span><br><span class="line">      <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">overlay</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db-data:/var/lib/mysql</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">somewordpress</span></span><br><span class="line">      <span class="attr">MYSQL_DATABASE:</span> <span class="string">wordpress</span></span><br><span class="line">      <span class="attr">MYSQL_USER:</span> <span class="string">wordpress</span></span><br><span class="line">      <span class="attr">MYSQL_PASSWORD:</span> <span class="string">wordpress</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">placement:</span></span><br><span class="line">        <span class="attr">constraints:</span> <span class="string">[node.role</span> <span class="string">==</span> <span class="string">manager]</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">visualizer:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">dockersamples/visualizer:stable</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"8080:8080"</span></span><br><span class="line">    <span class="attr">stop_grace_period:</span> <span class="string">1m30s</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"/var/run/docker.sock:/var/run/docker.sock"</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">placement:</span></span><br><span class="line">        <span class="attr">constraints:</span> <span class="string">[node.role</span> <span class="string">==</span> <span class="string">manager]</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">db-data:</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">overlay:</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#帮助命令</span></span><br><span class="line">docker stack --<span class="built_in">help</span></span><br><span class="line"><span class="comment">#集群化方式部署cpmpose，-c指定某个文件</span></span><br><span class="line"><span class="comment">#命令启动后，浏览器输入 ip:8080即可查看各个节点的情况</span></span><br><span class="line">docker stack deploy -c docker-compose.yml wordpress</span><br><span class="line"><span class="comment">#移除服务</span></span><br><span class="line">docker stack rm wordpress</span><br></pre></td></tr></table></figure>
<h3 id="7、Docker-Secret">7、Docker Secret</h3>
<p>用户可以在 Swarm 集群中安全地管理密码、密钥证书等敏感数据，并允许在多个 Docker 容器实例之间共享访问指定的敏感数据。</p>
<h3 id="8、Docker-Config">8、Docker Config</h3>
<p>Config无需将配置文件放入镜像或挂载到容器中就可实现对服务的配置，提高了集群的通用性。</p>
<hr>
<p>参考文章：</p>
<p><a href="https://yeasy.gitbook.io/docker_practice/" target="_blank" rel="noopener">https://yeasy.gitbook.io/docker_practice/</a></p>
<p><a href="https://www.bilibili.com/video/BV1og4y1q7M4?from=search&amp;seid=16621290913010547469" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1og4y1q7M4?from=search&amp;seid=16621290913010547469</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis学习笔记</title>
    <url>/posts/8eda3648.html</url>
    <content><![CDATA[<h2 id="一、Redis概述入门">一、Redis概述入门</h2>
<h3 id="1、NoSQL概述">1、NoSQL概述</h3>
<p><code>NoSQL</code>是指<code>not only Sql</code>，是一种非关系型数据库。其中NoSQL共有四种分类</p>
<ul>
<li>KV键值</li>
<li>文档型数据库(bson、MongoDB)</li>
<li>列存储数据库(HBase、分布式文件系统)</li>
<li>图关系数据库(存放关系、例如Neo4j)</li>
</ul>
<a id="more"></a>
<h3 id="2、Redis介绍">2、Redis介绍</h3>
<blockquote>
<p>Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI <a href="https://baike.baidu.com/item/C%E8%AF%AD%E8%A8%80" target="_blank" rel="noopener">C语言</a>编写、支持网络、可基于内存亦可持久化的日志型、Key-Value<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93/103728" target="_blank" rel="noopener">数据库</a>，并提供多种语言的API。</p>
</blockquote>
<p>Redis官网:<a href="https://redis.io/" target="_blank" rel="noopener">https://redis.io/</a></p>
<p>Redis中文官网:<a href="http://www.redis.cn/" target="_blank" rel="noopener">http://www.redis.cn/</a></p>
<h3 id="3、Redis安装">3、Redis安装</h3>
<p>windows安装：<a href="https://github.com/dmajkic/redis/downloads%EF%BC%88%E4%B8%8D%E6%8E%A8%E8%8D%90win%E5%BC%80%E5%8F%91%EF%BC%89" target="_blank" rel="noopener">https://github.com/dmajkic/redis/downloads（不推荐win开发）</a></p>
<p>Linux安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从官网下载redis最新版</span></span><br><span class="line">wget https://download.redis.io/releases/redis-6.2.4.tar.gz</span><br><span class="line"><span class="comment">#移动到opt目录下</span></span><br><span class="line">mv redis-6.2.4.tar.gz /opt/</span><br><span class="line"><span class="comment"># 解压即可</span></span><br><span class="line">tar -zxvf redis-6.2.4.tar.gz</span><br><span class="line"><span class="comment">#安装基本环境</span></span><br><span class="line">yum install gcc-c++</span><br><span class="line"><span class="comment">#进入安装包</span></span><br><span class="line"><span class="built_in">cd</span> redis-6.2.4/</span><br><span class="line"><span class="comment"># 进行编译安装，Redis默认安装路径(和大多数软件一样) /usr/local/bin</span></span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line"><span class="comment">#进入redis服务目录</span></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/bin</span><br><span class="line"><span class="comment">#创建配置文件目录</span></span><br><span class="line">mkdir conf</span><br><span class="line"><span class="comment">#将/opt/redis-6.2.4/redis.conf进行备份</span></span><br><span class="line">cp /opt/redis-6.2.4/redis.conf conf/myredis.conf</span><br><span class="line"><span class="comment">#修改为后台启动，进入myredis.conf修改daemonize为yes</span></span><br><span class="line">redis-server conf/myredis.conf </span><br><span class="line"><span class="comment">#客户端连接测试</span></span><br><span class="line">redis-cli -p 6379</span><br><span class="line"><span class="comment">#关闭程序，cli中先shutdown，后exit</span></span><br><span class="line"><span class="comment">#查看进程</span></span><br><span class="line">ps -ef|grep redis</span><br></pre></td></tr></table></figure>
<h3 id="4、Redis压力测试">4、Redis压力测试</h3>
<blockquote>
<p>Redis-benchmark官方默认压测工具</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">选项</th>
<th style="text-align:left">描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">-h</td>
<td style="text-align:left">指定服务器主机名</td>
<td>127.0.0.1</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">-p</td>
<td style="text-align:left">指定服务器端口号</td>
<td>6379</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">-s</td>
<td style="text-align:left">指定服务器socket</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">-c</td>
<td style="text-align:left">指定并发连接数</td>
<td>50</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">-n</td>
<td style="text-align:left">指定请求数</td>
<td>10000</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">-d</td>
<td style="text-align:left">以字节的形式指定SET/GET值的数据大小</td>
<td>3</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left">-k</td>
<td style="text-align:left">1=keep alive 0=reconnect</td>
<td>1</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left">-r</td>
<td style="text-align:left">SET/GET/INCR使用随机key,SADD使用随机值</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td style="text-align:left">-P</td>
<td style="text-align:left">通过管道传输</td>
<td>1</td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td style="text-align:left">-q</td>
<td style="text-align:left">强制退出redis。仅显示query/sec值</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">11</td>
<td style="text-align:left">–csv</td>
<td style="text-align:left">以CSV格式输出</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">12</td>
<td style="text-align:left">-l</td>
<td style="text-align:left">生成循环，永久执行</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">13</td>
<td style="text-align:left">-t</td>
<td style="text-align:left">仅运行以逗号分隔的测试命令列表</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">14</td>
<td style="text-align:left">-I</td>
<td style="text-align:left">Idle模式。仅打开N个idle连接并等待</td>
<td></td>
</tr>
</tbody>
</table>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开启服务后在当前目录进行测试</span></span><br><span class="line">redis-benchmark -h localhost -p 6379 -c 100 -n 100000</span><br></pre></td></tr></table></figure>
<h3 id="5、基础知识">5、基础知识</h3>
<p>redis默认16个数据库，默认使用第一个，使用<code>select</code>进行切换数据库，Redis6之前是单线程的，因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽，而单线程复杂度低，又不需要CPU上下文切换，也无需加锁。而在Redis6开始支持多线程，默认仍然是不开启，开启需要在<code>redis.conf </code>进行设置，其中Redis 的多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程顺序执行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; PING</span><br><span class="line">PONG</span><br><span class="line"><span class="comment">#切换数据库</span></span><br><span class="line">127.0.0.1:6379&gt; SELECT 1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[1]&gt; DBSIZE</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379[1]&gt; <span class="built_in">set</span> name shawn</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[1]&gt; get name</span><br><span class="line"><span class="string">"shawn"</span></span><br><span class="line">127.0.0.1:6379[1]&gt; keys *</span><br><span class="line">1) <span class="string">"name"</span></span><br><span class="line"><span class="comment">#清除数据库</span></span><br><span class="line">127.0.0.1:6379[1]&gt; FLUSHDB</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[1]&gt; keys *</span><br><span class="line">(empty array)</span><br><span class="line"><span class="comment">#清除全部数据库</span></span><br><span class="line">127.0.0.1:6379[1]&gt; FLUSHALL</span><br><span class="line">OK</span><br><span class="line"><span class="comment">#关闭服务并退出</span></span><br><span class="line">127.0.0.1:6379[1]&gt; SHUTDOWN</span><br><span class="line">not connected&gt; <span class="built_in">exit</span></span><br></pre></td></tr></table></figure>
<h2 id="二、Redis五大基本数据类型">二、Redis五大基本数据类型</h2>
<blockquote>
<p>Redis 是一种开源（BSD 许可）、内存中数据结构存储，用作数据库、缓存和消息代理。 Redis 提供了诸如字符串、散列、列表、集合、带范围查询的排序集合、位图、超级日志、地理空间索引和流等数据结构。 Redis 内置复制、Lua 脚本、LRU 驱逐、事务和不同级别的磁盘持久化，并通过 Redis Sentinel 和 Redis Cluster 自动分区提供高可用性。</p>
</blockquote>
<p>Redis有五大基本数据类型：</p>
<ul>
<li>String(字符串类型)</li>
<li>Hash(哈希，类似java的Map)</li>
<li>List(列表)</li>
<li>Set(集合)</li>
<li>ZSet(有序集合)</li>
</ul>
<h3 id="1、Redis-key">1、Redis-key</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name shawn</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">"name"</span></span><br><span class="line">127.0.0.1:6379&gt; exists name <span class="comment">#是否存在</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">type</span> name <span class="comment">#类型</span></span><br><span class="line">string</span><br><span class="line">127.0.0.1:6379&gt; move name 1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> age 1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">"age"</span></span><br><span class="line">127.0.0.1:6379&gt; expire age 10 <span class="comment">#设置过期时间</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; ttl age <span class="comment">#查看还有多久过期</span></span><br><span class="line">(<span class="built_in">integer</span>) 7</span><br><span class="line">127.0.0.1:6379&gt; get age</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>
<h3 id="2、String类型">2、String类型</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ======================================================</span></span><br><span class="line"><span class="comment"># set、get、del、append、strlen</span></span><br><span class="line"><span class="comment"># ======================================================</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name shawn</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; append name ,hello <span class="comment">#追加</span></span><br><span class="line">(<span class="built_in">integer</span>) 11</span><br><span class="line">127.0.0.1:6379&gt; strlen name <span class="comment">#字符串长度</span></span><br><span class="line">(<span class="built_in">integer</span>) 11</span><br><span class="line">127.0.0.1:6379&gt; get name </span><br><span class="line"><span class="string">"shawn,hello"</span></span><br><span class="line">127.0.0.1:6379&gt; del name <span class="comment">#删除</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty array)</span><br><span class="line"><span class="comment"># ======================================================</span></span><br><span class="line"><span class="comment"># incr、decr      一定要是数字才能进行加减，+1 和 -1。</span></span><br><span class="line"><span class="comment"># incrby、decrby  命令将 key 中储存的数字加上指定的增量值。</span></span><br><span class="line"><span class="comment"># ======================================================</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> views 0</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; incr views <span class="comment">#自增1</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; decr views <span class="comment">#自减1</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; incrby views 10 <span class="comment">#自增10</span></span><br><span class="line">(<span class="built_in">integer</span>) 10</span><br><span class="line">127.0.0.1:6379&gt; decrby views 5 <span class="comment">#自减5</span></span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; get views</span><br><span class="line"><span class="string">"5"</span></span><br><span class="line"><span class="comment"># ======================================================</span></span><br><span class="line"><span class="comment"># range [范围]</span></span><br><span class="line"><span class="comment"># getrange 获取指定区间范围内的值，类似between...and的关系，从零到负一表示全部</span></span><br><span class="line"><span class="comment"># setrange 设置指定区间范围内的值，格式是setrange key值 具体值</span></span><br><span class="line"><span class="comment"># ======================================================</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name hello,shawn</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; getrange name 6 11</span><br><span class="line"><span class="string">"shawn"</span></span><br><span class="line">127.0.0.1:6379&gt; setrange name 6 shanw22</span><br><span class="line">(<span class="built_in">integer</span>) 13</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line"><span class="string">"hello,shanw22"</span></span><br><span class="line"><span class="comment"># ======================================================</span></span><br><span class="line"><span class="comment"># setex（set with expire） 设置过期时间</span></span><br><span class="line"><span class="comment"># setnx（set if not exist）不存在就设置(分布式锁常用)</span></span><br><span class="line"><span class="comment"># ======================================================</span></span><br><span class="line">127.0.0.1:6379&gt; setex key1 30 hello <span class="comment">#设置key1值为hello，过期时间30s</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; ttl key1</span><br><span class="line">(<span class="built_in">integer</span>) 25</span><br><span class="line">127.0.0.1:6379&gt; setnx key1 hello <span class="comment">#过期后成功进行设置</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; setnx key1 hello <span class="comment">#设置失败</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"><span class="comment"># ======================================================</span></span><br><span class="line"><span class="comment"># mset   同时设置多组k-v</span></span><br><span class="line"><span class="comment"># mget   同时获取多组k-v</span></span><br><span class="line"><span class="comment"># msetnx 当所有 key 都成功设置，返回 1。如果所有给定 key 都设置失败(至少有一个 key 已经存在)，那么返回 # 0。该操作为原子性操作，要么都成功，要么失败</span></span><br><span class="line"><span class="comment"># ======================================================</span></span><br><span class="line">127.0.0.1:6379&gt; mset k1 v1 k2 v2 k3 v3</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">"k3"</span></span><br><span class="line">2) <span class="string">"k2"</span></span><br><span class="line">3) <span class="string">"k1"</span></span><br><span class="line">127.0.0.1:6379&gt; msetnx k1 v1 k4 v4 <span class="comment">#原子操作</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">"k3"</span></span><br><span class="line">2) <span class="string">"k2"</span></span><br><span class="line">3) <span class="string">"k1"</span></span><br><span class="line"><span class="comment"># 可以缓存对象</span></span><br><span class="line">127.0.0.1:6379&gt; msetnx user:1:name shawn user:1:age 18</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; mget user:1:name user:1:age</span><br><span class="line">1) <span class="string">"shawn"</span></span><br><span class="line">2) <span class="string">"18"</span></span><br><span class="line"><span class="comment"># ======================================================</span></span><br><span class="line"><span class="comment"># getset（先get再set）</span></span><br><span class="line"><span class="comment"># ======================================================</span></span><br><span class="line">127.0.0.1:6379&gt; getset db redis</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; getset db mysql</span><br><span class="line"><span class="string">"redis"</span></span><br><span class="line"><span class="comment">#=======================================================</span></span><br><span class="line"><span class="comment">#Redis中的Value可以是字符串，也可以是数字</span></span><br></pre></td></tr></table></figure>
<h3 id="3、列表List">3、列表List</h3>
<p>list相当于双向链表，可以用作队列，也可以作栈，可以做消息队列，在两端操作效率高，最中间操作效率会低</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ======================================================</span></span><br><span class="line"><span class="comment"># Lpush：将一个或多个值插入到列表头部。（左）</span></span><br><span class="line"><span class="comment"># rpush：将一个或多个值插入到列表尾部。（右）</span></span><br><span class="line"><span class="comment"># lrange：返回列表中指定区间内的元素，区间以偏移量 START 和 END 指定。</span></span><br><span class="line"><span class="comment"># 其中 0 表示列表的第一个元素， 1 表示列表的第二个元素，以此类推。</span></span><br><span class="line"><span class="comment"># 你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。 </span></span><br><span class="line"><span class="comment"># lpop 命令用于移除并返回列表的第一个元素。当列表 key 不存在时，返回 nil</span></span><br><span class="line"><span class="comment"># rpop 移除列表的最后一个元素，返回值为移除的元素</span></span><br><span class="line"><span class="comment"># ======================================================</span></span><br><span class="line">127.0.0.1:6379&gt; lpush list one</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; lpush list two</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1 <span class="comment">#获取list中的值</span></span><br><span class="line">1) <span class="string">"two"</span></span><br><span class="line">2) <span class="string">"one"</span></span><br><span class="line">127.0.0.1:6379&gt; rpush list three</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">"two"</span></span><br><span class="line">2) <span class="string">"one"</span></span><br><span class="line">3) <span class="string">"three"</span></span><br><span class="line">127.0.0.1:6379&gt; lpop list</span><br><span class="line"><span class="string">"two"</span></span><br><span class="line">127.0.0.1:6379&gt; rpop list</span><br><span class="line"><span class="string">"three"</span></span><br><span class="line"><span class="comment"># ======================================================</span></span><br><span class="line"><span class="comment"># lindex，按照索引下标获得元素（-1代表最后一个，0代表是第一个）</span></span><br><span class="line"><span class="comment"># llen 用于返回列表的长度。</span></span><br><span class="line"><span class="comment"># lrem key 根据参数 COUNT 的值，移除列表中与参数 VALUE 相等的元素</span></span><br><span class="line"><span class="comment"># ltrim key 对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被 删除。</span></span><br><span class="line"><span class="comment"># rpoplpush 移除列表的最后一个元素，并将该元素添加到另一个列表并返回</span></span><br><span class="line"><span class="comment"># lset key index value 将列表 key 下标为 index 的元素的值设置为 value</span></span><br><span class="line"><span class="comment"># ======================================================</span></span><br><span class="line">127.0.0.1:6379&gt; lindex list 0</span><br><span class="line"><span class="string">"one"</span></span><br><span class="line">127.0.0.1:6379&gt; llen list</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; lrem list 2 one <span class="comment">#移除2个one的值，这里只有一个，故删除了1个</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; rpoplpush list mylist</span><br><span class="line"><span class="string">"hello"</span></span><br><span class="line">127.0.0.1:6379&gt; lset list 0 hi <span class="comment">#第0个value更新，key不存在会报错</span></span><br><span class="line">OK</span><br><span class="line"><span class="comment"># ======================================================</span></span><br><span class="line"><span class="comment"># linsert key before/after pivot value 用于在列表的元素前或者后插入元素 </span></span><br><span class="line"><span class="comment"># 将值 value 插入到列表 key 当中，位于值 pivot 之前或之后。</span></span><br><span class="line"><span class="comment"># ======================================================</span></span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">"hi"</span></span><br><span class="line">2) <span class="string">"hello1"</span></span><br><span class="line">127.0.0.1:6379&gt; linsert list after hi new <span class="comment">#在hi后插入new</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">"hi"</span></span><br><span class="line">2) <span class="string">"new"</span></span><br><span class="line">3) <span class="string">"hello1"</span></span><br></pre></td></tr></table></figure>
<h3 id="4、集合Set">4、集合Set</h3>
<p>set中的值不能重复，是无序不重复的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ======================================================</span></span><br><span class="line"><span class="comment"># sadd 将一个或多个成员元素加入到集合中，不能重复</span></span><br><span class="line"><span class="comment"># smembers 返回集合中的所有的成员。</span></span><br><span class="line"><span class="comment"># sismember 命令判断成员元素是否是集合的成员。</span></span><br><span class="line"><span class="comment"># scard，获取集合里面的元素个数</span></span><br><span class="line"><span class="comment"># rem key value 用于移除集合中的一个或多个成员元素</span></span><br><span class="line"><span class="comment"># ======================================================</span></span><br><span class="line">127.0.0.1:6379&gt; sadd myset hello</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd myset shawn</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; smembers myset </span><br><span class="line">1) <span class="string">"shawn"</span></span><br><span class="line">2) <span class="string">"hello"</span></span><br><span class="line">127.0.0.1:6379&gt; sismember myset hello</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; scard myset</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; srem myset hello</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment"># ======================================================</span></span><br><span class="line"><span class="comment"># randmember key 命令用于返回集合中的一个随机元素。</span></span><br><span class="line"><span class="comment"># spop key 用于移除集合中的指定 key 的一个或多个随机元素</span></span><br><span class="line"><span class="comment"># smove SOURCE DESTINATION MEMBER，将指定成员 member 元素从 source 集合移动到 destination 集合。</span></span><br><span class="line"><span class="comment"># 数字集合类 差集:sdiff;交集:sinter;并集:sunion(社交软件共同关注等操作)</span></span><br><span class="line"><span class="comment"># ======================================================</span></span><br><span class="line">127.0.0.1:6379&gt; sadd k1 a b c</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; sadd k2 b c d</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; sdiff k1 k2</span><br><span class="line">1) <span class="string">"a"</span></span><br><span class="line">127.0.0.1:6379&gt; sinter k1 k2</span><br><span class="line">1) <span class="string">"b"</span></span><br><span class="line">2) <span class="string">"c"</span></span><br><span class="line">127.0.0.1:6379&gt;  sunion k1 k2</span><br><span class="line">1) <span class="string">"a"</span></span><br><span class="line">2) <span class="string">"c"</span></span><br><span class="line">3) <span class="string">"b"</span></span><br><span class="line">4) <span class="string">"d"</span></span><br></pre></td></tr></table></figure>
<h3 id="5、哈希Hash">5、哈希Hash</h3>
<p>Map集合，相当于key-Map，通常来存储经常变动的对象</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ======================================================</span></span><br><span class="line"><span class="comment"># hset、hget 命令用于为哈希表中的字段赋值 。</span></span><br><span class="line"><span class="comment"># hmset、hmget 同时将多个field-value对设置到哈希表中。会覆盖哈希表中已存在的字段。 # hgetall 用于返回哈希表中，所有的字段和值。</span></span><br><span class="line"><span class="comment"># hdel    用于删除哈希表 key 中的一个或多个指定字段</span></span><br><span class="line"><span class="comment"># ======================================================</span></span><br><span class="line">127.0.0.1:6379&gt; hset myhash field shawn</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hget myhash field</span><br><span class="line"><span class="string">"shawn"</span></span><br><span class="line">127.0.0.1:6379&gt; hmset myhash field hello field1 world</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; hmget myhash field  field1 </span><br><span class="line">1) <span class="string">"hello"</span></span><br><span class="line">2) <span class="string">"world"</span></span><br><span class="line">127.0.0.1:6379&gt; hgetall myhash</span><br><span class="line">1) <span class="string">"field"</span></span><br><span class="line">2) <span class="string">"hello"</span></span><br><span class="line">3) <span class="string">"field1"</span></span><br><span class="line">4) <span class="string">"world"</span></span><br><span class="line">127.0.0.1:6379&gt; hdel myhash field</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment"># ======================================================</span></span><br><span class="line"><span class="comment"># hlen 获取哈希表中字段的数量。</span></span><br><span class="line"><span class="comment"># hexists 查看哈希表的指定字段是否存在。</span></span><br><span class="line"><span class="comment"># hkeys 获取哈希表中的所有域（field）。</span></span><br><span class="line"><span class="comment"># hvals 返回哈希表所有域(field)的值。</span></span><br><span class="line"><span class="comment"># ======================================================</span></span><br><span class="line">127.0.0.1:6379&gt; hlen myhash <span class="comment">#字段数</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hexists myhash field</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; hkeys myhash</span><br><span class="line">1) <span class="string">"field1"</span></span><br><span class="line">127.0.0.1:6379&gt; hvals myhash</span><br><span class="line">1) <span class="string">"world"</span></span><br><span class="line"><span class="comment"># ======================================================</span></span><br><span class="line"><span class="comment"># hincrby 为哈希表中的字段值加上指定增量值</span></span><br><span class="line"><span class="comment"># hsetnx 为哈希表中不存在的的字段赋值</span></span><br><span class="line"><span class="comment"># ======================================================</span></span><br><span class="line">127.0.0.1:6379&gt; hset myhash field 1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hincrby myhash field 1</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; hsetnx myhash field shawn</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure>
<h3 id="6、有序集合Zset">6、有序集合Zset</h3>
<p>Zset增加了权重参数score，可以用来设置任务的重要程度，例如排行榜应用，Top N</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ======================================================</span></span><br><span class="line"><span class="comment"># zadd    将一个或多个成员元素及其分数值加入到有序集当中。</span></span><br><span class="line"><span class="comment"># zrange  返回有序集中，指定区间内的成员</span></span><br><span class="line"><span class="comment"># ======================================================</span></span><br><span class="line">127.0.0.1:6379&gt; zadd myset 1 one 2 two</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">(integ127.0.0.1:6379&gt; zrange myset 0 -1</span><br><span class="line">1) <span class="string">"one"</span></span><br><span class="line">2) <span class="string">"two"</span></span><br><span class="line"><span class="comment"># ======================================================</span></span><br><span class="line"><span class="comment"># zrangebyscore 返回有序集合中指定分数区间的成员列表。有序集成员按分数值递增(从小到大)次序排列。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ======================================================</span></span><br><span class="line">127.0.0.1:6379&gt; zadd salary 2500 Amy 3500 Mike 200 Shawn</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; zrangebyscore salary -inf +inf <span class="comment">#正序</span></span><br><span class="line">1) <span class="string">"Shawn"</span></span><br><span class="line">2) <span class="string">"Amy"</span></span><br><span class="line">3) <span class="string">"Mike"</span></span><br><span class="line">127.0.0.1:6379&gt; zrangebyscore salary -inf 2500 WITHSCORES <span class="comment">#带上score进行查询</span></span><br><span class="line">1) <span class="string">"Shawn"</span></span><br><span class="line">2) <span class="string">"200"</span></span><br><span class="line">3) <span class="string">"Amy"</span></span><br><span class="line">4) <span class="string">"2500"</span></span><br><span class="line"><span class="comment"># ======================================================</span></span><br><span class="line"><span class="comment"># zrem 移除有序集中的一个或多个成员</span></span><br><span class="line"><span class="comment"># zcard   命令用于计算集合中元素的数量。</span></span><br><span class="line"><span class="comment"># zcount  计算有序集合中指定分数区间的成员数量。</span></span><br><span class="line"><span class="comment"># zrank  返回有序集中指定成员的排名。其中有序集成员按分数值递增(从小到大)顺序排列。</span></span><br><span class="line"><span class="comment"># zrevrank 返回有序集中成员的排名。其中有序集成员按分数值递减(从大到小)排序。</span></span><br><span class="line"><span class="comment"># ======================================================</span></span><br><span class="line">127.0.0.1:6379&gt; zrem salary Shawn</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zcard salary</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; zcount salary -inf 2500</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zrank salary Mike <span class="comment">#Mike的薪水排名</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zrevrank salary Mike</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure>
<h2 id="三、Redis三种特殊数据类型">三、Redis三种特殊数据类型</h2>
<h3 id="1、GEO地理位置">1、GEO地理位置</h3>
<blockquote>
<p>GEO 的数据结构总共有六个常用命令：geoadd、geopos、geodist、georadius、 georadiusbymember、gethash<br>
官方文档：<a href="https://www.redis.net.cn/order/3685.html" target="_blank" rel="noopener">https://www.redis.net.cn/order/3685.html</a></p>
</blockquote>
<p>因为存在中文，redis客户端启动时命令<code>redis-cli -p 6379 --raw</code></p>
<p><strong>geoadd</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语法</span></span><br><span class="line">geoadd key longitude latitude member ...</span><br><span class="line"><span class="comment"># 将给定的空间元素(纬度、经度、名字)添加到指定的键里面。</span></span><br><span class="line"><span class="comment"># 这些数据会以有序集he的形式被储存在键里面，从而使得georadius和georadiusbymember这样的命令可以在之后通过位置查询取得这些元素。</span></span><br><span class="line"><span class="comment"># geoadd命令以标准的x,y格式接受参数,所以用户必须先输入经度,然后再输入纬度。</span></span><br><span class="line"><span class="comment"># geoadd能够记录的坐标是有限的:非常接近两极的区域无法被索引。</span></span><br><span class="line"><span class="comment"># 有效的经度介于-180-180度之间，有效的纬度介于-85.05112878 度至 85.05112878 度之间。当用户尝试输入一个超出范围的经度或者纬度时,geoadd命令将返回一个错误。</span></span><br><span class="line"><span class="comment">#===============================================</span></span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 116.23 40.22 北京</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 106.54 29.40 重庆 108.93 34.23 西安 114.02 30.58 武汉</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure>
<p><strong>geopos</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语法</span></span><br><span class="line">geopos key member [member...]</span><br><span class="line"><span class="comment">#从key里返回所有给定位置元素的位置（经度和纬度）</span></span><br><span class="line"><span class="comment">#===============================================</span></span><br><span class="line">127.0.0.1:6379&gt; geopos china:city 北京</span><br><span class="line">1) 1) <span class="string">"116.23000055551528931"</span></span><br><span class="line">   2) <span class="string">"40.2200010338739844"</span></span><br></pre></td></tr></table></figure>
<p><strong>geodist</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定单位的参数 unit 必须是以下单位的其中一个：</span></span><br><span class="line"><span class="comment"># m 表示单位为米。</span></span><br><span class="line"><span class="comment"># km 表示单位为千米。</span></span><br><span class="line"><span class="comment"># mi 表示单位为英里。</span></span><br><span class="line"><span class="comment"># ft 表示单位为英尺。</span></span><br><span class="line"><span class="comment"># 如果用户没有显式地指定单位参数， 那么 GEODIST 默认使用米作为单位。</span></span><br><span class="line"><span class="comment">#==================================================</span></span><br><span class="line">127.0.0.1:6379&gt; geodist china:city 北京 重庆 km</span><br><span class="line"><span class="string">"1491.6716"</span></span><br></pre></td></tr></table></figure>
<p><strong>georadious</strong></p>
<p>以给定的经纬度为中心， 找出某一半径内的元素</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 附近范围内查询，比如附近的人功能的实现,count限制查询出来的数量</span></span><br><span class="line">127.0.0.1:6379&gt; georadius china:city 100 30 1000 km </span><br><span class="line">重庆</span><br><span class="line">西安</span><br><span class="line">127.0.0.1:6379&gt; georadius china:city 100 30 1000 km withcoord withdist count 2</span><br><span class="line">重庆</span><br><span class="line">635.2850</span><br><span class="line">106.54000014066696167</span><br><span class="line">29.39999880018641676</span><br><span class="line">西安</span><br><span class="line">963.3171</span><br><span class="line">108.92999857664108276</span><br><span class="line">34.23000121926852302</span><br></pre></td></tr></table></figure>
<p><strong>georadiusbymember</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#找出指定元素旁边的位置</span></span><br><span class="line">127.0.0.1:6379&gt; georadiusbymember china:city 北京 1000 km</span><br><span class="line">北京</span><br><span class="line">西安</span><br></pre></td></tr></table></figure>
<p><strong>geohash</strong></p>
<p>该命令将返回11个字符的Geohash字符串</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Redis使用geohash将二维经纬度转换为一维字符串，字符串越长表示位置更精确,两个字符串越相似表示距离越近。很少使用</span></span><br><span class="line">127.0.0.1:6379&gt; geohash china:city 北京 重庆</span><br><span class="line">wx4sucu47r0</span><br><span class="line">wm5z22h53v0</span><br></pre></td></tr></table></figure>
<p><strong>zrem</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># geo底层使用了zset，故可以用此方法进行删除</span></span><br><span class="line">127.0.0.1:6379&gt; zrange china:city 0 -1</span><br><span class="line">重庆</span><br><span class="line">西安</span><br><span class="line">武汉</span><br><span class="line">北京</span><br><span class="line">127.0.0.1:6379&gt; zrem china:city 北京</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<h3 id="2、Hyperloglog">2、Hyperloglog</h3>
<blockquote>
<p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的，固定12KB。可以用来计数网站用户量(允许小量容错)</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; pfadd mykey a b c d e f g <span class="comment">#创建第一组元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; pfcount mykey <span class="comment">#统计元素的基数数量</span></span><br><span class="line">(<span class="built_in">integer</span>) 7</span><br><span class="line">127.0.0.1:6379&gt; pfadd mykey1 s f v b r t y u a  <span class="comment">#创建第二组</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; pfmerge mykey2 mykey mykey1 <span class="comment">#并集</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; pfcount mykey2</span><br><span class="line">(<span class="built_in">integer</span>) 12</span><br></pre></td></tr></table></figure>
<h3 id="3、Bitmaps">3、Bitmaps</h3>
<p>位存储。统计用户信息，活跃，不活跃，未登录等两个状态，都可以使用Bitmaps(只有0和1)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用 bitmap 来记录上述事例中一周的打卡记录如下所示：</span></span><br><span class="line"><span class="comment"># 周一：1，周二：0，周三：0，周四：1，周五：1，周六：0，周天：0 （1 为打卡，0 为不打卡）</span></span><br><span class="line">127.0.0.1:6379&gt; setbit sign 0 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 1 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 2 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 3 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 4 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 5 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 6 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; getbit sign 1 <span class="comment">#查询某一天是否打卡</span></span><br><span class="line">(<span class="built_in">integer</span>) 1  </span><br><span class="line">127.0.0.1:6379&gt; bitcount sign  <span class="comment">#统计本周打卡天数</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br></pre></td></tr></table></figure>
<h2 id="四、事务">四、事务</h2>
<p>Redis中，单条命令是原子性执行的，但事务不保证原子性，且没有回滚。事务中任意命令执行失败，其余的命令仍会被执行。若为编译型错误，则事务无法执行。事务的执行是按顺序执行的，且事务没有隔离级别概念。</p>
<p>Redis事务：</p>
<ul>
<li>开启事务()</li>
<li>命令入队()</li>
<li>执行事务()</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi <span class="comment">#开启事务</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; get k1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">exec</span> <span class="comment">#执行事务</span></span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line">3) <span class="string">"v1"</span></span><br><span class="line"><span class="comment">#=================================</span></span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; discard  <span class="comment">#放弃事务</span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
<p><strong>悲观锁</strong></p>
<blockquote>
<p>悲观锁(Pessimistic Lock),顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿到这个数据就会block直到它拿到锁。传统的关系型数据库里面就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在操作之前先上锁。</p>
</blockquote>
<p><strong>乐观锁</strong></p>
<blockquote>
<p>乐观锁(Optimistic Lock),顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁。但是在更新的时候会判断一下再此期间别人有没有去更新这个数据，可以使用版本号等机制，乐观锁适用于多读的应用类型，这样可以提高吞吐量，乐观锁策略：提交版本必须大于记录当前版本才能执行更新。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用watch监视，成功就修改，可以用来做乐观锁</span></span><br><span class="line">127.0.0.1:6379&gt; watch money</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> money 100</span><br><span class="line">QUEUED</span><br><span class="line"><span class="comment">#此时新开一个客户端，运行</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> money 500</span><br><span class="line">OK</span><br><span class="line"><span class="comment">#回到第一个，执行事务，发现监视内容发送变化，修改失败</span></span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">exec</span></span><br><span class="line">(nil)</span><br><span class="line"><span class="comment"># 若要放弃监视，使用unwatch</span></span><br><span class="line"><span class="comment"># 一但执行 EXEC 开启事务的执行后，无论事务使用执行成功， WARCH 对变量的监控都将被取消。故当事务执行失败后，需重新执行WATCH命令对变量进行监控，并开启新的事务进行操作。</span></span><br></pre></td></tr></table></figure>
<h2 id="五、Java连接Redis操作">五、Java连接Redis操作</h2>
<h3 id="1、Jedis">1、Jedis</h3>
<blockquote>
<p>Jedis是Redis官方推荐的Java连接开发工具。</p>
</blockquote>
<p>首先新建一个空的maven项目</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--进入maven仓库查找最新版--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 成功连接，输出pong,jedis中已经集成了常用的API，使用.即可查询</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//连接本地的 Redis 服务</span></span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"localhost"</span>,<span class="number">6379</span>);</span><br><span class="line">        <span class="comment">// 如果 Redis 服务设置了密码，需要下面这行，没有就不需要</span></span><br><span class="line">        <span class="comment">// jedis.auth("123456");</span></span><br><span class="line">        System.out.println(<span class="string">"连接成功"</span>);</span><br><span class="line">        <span class="comment">//查看服务是否运行</span></span><br><span class="line">        System.out.println(<span class="string">"服务正在运行: "</span>+jedis.ping());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、SpringBoot整合Redis">2、SpringBoot整合Redis</h3>
<h4 id="2-1-简单使用">2.1 <strong>简单使用</strong></h4>
<p>首先在<code>pom.xml</code>中导入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--spring2.0后底层使用lettuce,性能更高，2.0之前采用jedis--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>配置<code>application.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#配置redis</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedisSpringApplicationTests</span> </span>&#123;</span><br><span class="line">  <span class="comment">//redisTemplate 操作不同的数据类型，api和我们的指令是一样的</span></span><br><span class="line">  <span class="comment">//opsForValue 操作字符申类似string</span></span><br><span class="line">  <span class="comment">//opsForList 操作list 类List</span></span><br><span class="line">  <span class="comment">//opsForSet</span></span><br><span class="line">  <span class="comment">//opsForHash</span></span><br><span class="line">  <span class="comment">//opsForZSet</span></span><br><span class="line">  <span class="comment">//opsForGeo</span></span><br><span class="line">  <span class="comment">//opsForHyperLogLog</span></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  RedisTemplate&lt;String, String&gt; redisTemplate;</span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">"k"</span>,<span class="string">"v"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-源码分析">2.2 <strong>源码分析</strong></h4>
<p>在<code>External Libraries</code>中找到Redis的自动配置类，在<code>RedisProperties.class</code>也可以看到配置信息</p>
<p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/image-20210605140429685.png" alt="image-20210607170901524"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(&#123;RedisOperations<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class">@<span class="title">EnableConfigurationProperties</span>(</span>&#123;RedisProperties<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class">@<span class="title">Import</span>(</span>&#123;LettuceConnectionConfiguration<span class="class">.<span class="keyword">class</span>, <span class="title">JedisConnectionConfiguration</span>.<span class="title">class</span>&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">RedisAutoConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedisAutoConfiguration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="comment">//我们可以自定义一个redisTemplate替换默认。下面注解意思是如果Spring容器中有了RedisTemplate对象了，这个自动配置的RedisTemplate不会实例化。</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span>(name = &#123;<span class="string">"redisTemplate"</span>&#125;)</span><br><span class="line">    <span class="meta">@ConditionalOnSingleCandidate</span>(RedisConnectionFactory<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">RedisTemplate</span>&lt;<span class="title">Object</span>, <span class="title">Object</span>&gt; <span class="title">redisTemplate</span>(<span class="title">RedisConnectionFactory</span> <span class="title">redisConnectionFactory</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//默认的没有进行过多操作，也没有序列化，不能进行对象传输</span></span><br><span class="line">        <span class="comment">//我们一般使用&lt;String,Object&gt;</span></span><br><span class="line">        RedisTemplate&lt;Object, Object&gt; template = <span class="keyword">new</span> RedisTemplate();</span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">  <span class="comment">//String类型常用，单独提出来一个方法</span></span><br><span class="line">    <span class="meta">@ConditionalOnSingleCandidate</span>(RedisConnectionFactory<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">StringRedisTemplate</span> <span class="title">stringRedisTemplate</span>(<span class="title">RedisConnectionFactory</span> <span class="title">redisConnectionFactory</span>) </span>&#123;</span><br><span class="line">        StringRedisTemplate template = <span class="keyword">new</span> StringRedisTemplate();</span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-3-序列化工具封装">2.3 <strong>序列化工具封装</strong></h4>
<p>自定义序列化<code>RedisTemplate</code>，这里提供两种，一种是jackson，另一种是fastjson</p>
<p><strong>jackson序列化</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 编写自己的RedisTemplate</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"all"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="comment">//序列化配置</span></span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer&lt;&gt;(Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        <span class="comment">// 指定要序列化的域，field,get和set,以及修饰符范围，ANY是都有包括private和public</span></span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        <span class="comment">// 指定序列化输入的类型，类必须是非final修饰的，final修饰的类，比如String,Integer等会跑出异常</span></span><br><span class="line">        <span class="comment">// 序列化时会自动增加类类型，否则无法反序列化</span></span><br><span class="line">        om.activateDefaultTyping(LaissezFaireSubTypeValidator.instance, ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">        <span class="comment">//String的序列化</span></span><br><span class="line">        StringRedisSerializer stringRedisSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line">        <span class="comment">// key采用String的序列化方式</span></span><br><span class="line">        template.setKeySerializer(stringRedisSerializer);</span><br><span class="line">        <span class="comment">// hash采用String序列方式</span></span><br><span class="line">        template.setHashKeySerializer(stringRedisSerializer);</span><br><span class="line">        <span class="comment">// value采用jackson</span></span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        <span class="comment">// hash的value采用jackson</span></span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>fastjson序列化</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.parser.ParserConfig;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.serializer.SerializerFeature;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.RedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.SerializationException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FastJson2JsonRedisSerializer</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">RedisSerializer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Charset DEFAULT_CHARSET = StandardCharsets.UTF_8;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        ParserConfig.getGlobalInstance().setAutoTypeSupport(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; clazz;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FastJson2JsonRedisSerializer</span><span class="params">(Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.clazz = clazz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] serialize(T t) <span class="keyword">throws</span> SerializationException &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == t) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 序列化时写入类型信息，默认为false,反序列化是需用到</span></span><br><span class="line">        <span class="comment">// 如果序列化是没有加入类型信息SerializerFeature.WriteClassName，就会报错java.lang.ClassCastException</span></span><br><span class="line">        <span class="keyword">return</span> JSON.toJSONString(t, SerializerFeature.WriteClassName).getBytes(DEFAULT_CHARSET);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 反序列化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> <span class="keyword">throws</span> SerializationException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == bytes || bytes.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String str = <span class="keyword">new</span> String(bytes, DEFAULT_CHARSET);</span><br><span class="line">        <span class="keyword">return</span> (T) JSON.parseObject(str, clazz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编写自己的RedisTemplate</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> </span>&#123;</span><br><span class="line">        RedisTemplate&lt;Object, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line">        <span class="comment">// fastjson序列化</span></span><br><span class="line">        FastJson2JsonRedisSerializer&lt;Object&gt; fastJsonRedisSerializer = <span class="keyword">new</span> FastJson2JsonRedisSerializer&lt;&gt;(Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">// String序列化</span></span><br><span class="line">        StringRedisSerializer stringRedisSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line">        <span class="comment">// key采用String的序列化方式</span></span><br><span class="line">        template.setKeySerializer(stringRedisSerializer);</span><br><span class="line">        <span class="comment">// hash的key也采用String的序列化方式</span></span><br><span class="line">        template.setHashKeySerializer(stringRedisSerializer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// value序列化方式采用fastJson</span></span><br><span class="line">        template.setValueSerializer(fastJsonRedisSerializer);</span><br><span class="line">        <span class="comment">// hash的value序列化方式采用fastJson</span></span><br><span class="line">        template.setHashValueSerializer(fastJsonRedisSerializer);</span><br><span class="line"></span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建工具类(可自定义取舍，这里仅供参考)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// =============================common============================</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定缓存失效时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 时间(秒)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">expire</span><span class="params">(String key, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                redisTemplate.expire(key, time, TimeUnit.SECONDS);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据key 获取过期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 时间(秒) 返回0代表为永久有效</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getExpire</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.getExpire(key, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断key是否存在</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 存在 false不存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasKey</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.hasKey(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除缓存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 可以传一个值 或多个</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(String... key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key != <span class="keyword">null</span> &amp;&amp; key.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (key.length == <span class="number">1</span>) &#123;</span><br><span class="line">                redisTemplate.delete(key[<span class="number">0</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                redisTemplate.delete((Collection&lt;String&gt;) CollectionUtils.arrayToList(key));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ============================String=============================</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通缓存获取</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key == <span class="keyword">null</span> ? <span class="keyword">null</span> : redisTemplate.opsForValue().get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通缓存放入</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true成功 false失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">set</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForValue().set(key, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通缓存放入并设置时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time  时间(秒) time要大于0 如果time小于等于0 将设置无限期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true成功 false 失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">set</span><span class="params">(String key, Object value, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                set(key, value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递增</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delta 要增加几(大于0)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">incr</span><span class="params">(String key, <span class="keyword">long</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (delta &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"递增因子必须大于0"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().increment(key, delta);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递减</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delta 要减少几(小于0)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">decr</span><span class="params">(String key, <span class="keyword">long</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (delta &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"递减因子必须大于0"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().increment(key, -delta);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ================================Map=================================</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashGet</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项 不能为null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">hget</span><span class="params">(String key, String item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().get(key, item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取hashKey对应的所有键值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 对应的多个键值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;Object, Object&gt; <span class="title">hmget</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().entries(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashSet</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map 对应多个键值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hmset</span><span class="params">(String key, Map&lt;String, Object&gt; map)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForHash().putAll(key, map);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashSet 并设置时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map  对应多个键值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 时间(秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true成功 false失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hmset</span><span class="params">(String key, Map&lt;String, Object&gt; map, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForHash().putAll(key, map);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                expire(key, time);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向一张hash表中放入数据,如果不存在将创建</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item  项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 成功 false失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hset</span><span class="params">(String key, String item, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForHash().put(key, item, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向一张hash表中放入数据,如果不存在将创建</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item  项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time  时间(秒) 注意:如果已存在的hash表有时间,这里将会替换原有的时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 成功 false失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hset</span><span class="params">(String key, String item, Object value, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForHash().put(key, item, value);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                expire(key, time);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除hash表中的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项 可以使多个 不能为null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hdel</span><span class="params">(String key, Object... item)</span> </span>&#123;</span><br><span class="line">        redisTemplate.opsForHash().delete(key, item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断hash表中是否有该项的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 存在 false不存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hHasKey</span><span class="params">(String key, String item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().hasKey(key, item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * hash递增 如果不存在,就会创建一个 并把新增后的值返回</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> by   要增加几(大于0)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">hincr</span><span class="params">(String key, String item, <span class="keyword">double</span> by)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().increment(key, item, by);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * hash递减</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> by   要减少记(小于0)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">hdecr</span><span class="params">(String key, String item, <span class="keyword">double</span> by)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().increment(key, item, -by);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ============================set=============================</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据key获取Set中的所有值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Object&gt; <span class="title">sGet</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForSet().members(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据value从一个set中查询,是否存在</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 存在 false不存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sHasKey</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForSet().isMember(key, value);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将数据放入set缓存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key    键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values 值 可以是多个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 成功个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sSet</span><span class="params">(String key, Object... values)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForSet().add(key, values);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将set数据放入缓存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key    键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time   时间(秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values 值 可以是多个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 成功个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sSetAndTime</span><span class="params">(String key, <span class="keyword">long</span> time, Object... values)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Long count = redisTemplate.opsForSet().add(key, values);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                expire(key, time);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取set缓存的长度</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sGetSetSize</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForSet().size(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除值为value的</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key    键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values 值 可以是多个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 移除的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">setRemove</span><span class="params">(String key, Object... values)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Long count = redisTemplate.opsForSet().remove(key, values);</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ===============================list=================================</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取list缓存的内容</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 开始</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end   结束 0 到 -1代表所有值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">lGet</span><span class="params">(String key, <span class="keyword">long</span> start, <span class="keyword">long</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForList().range(key, start, end);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取list缓存的长度</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">lGetListSize</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForList().size(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过索引 获取list中的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 索引 index&gt;=0时， 0 表头，1 第二个元素，依次类推；index&lt;0时，-1，表尾，-2倒数第二个元素，依次类推</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">lGetIndex</span><span class="params">(String key, <span class="keyword">long</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForList().index(key, index);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将list放入缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lSet</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().rightPush(key, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将list放入缓存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time  时间(秒)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lSet</span><span class="params">(String key, Object value, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().rightPush(key, value);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                expire(key, time);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将list放入缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lSet</span><span class="params">(String key, List&lt;Object&gt; value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().rightPushAll(key, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将list放入缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time  时间(秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lSet</span><span class="params">(String key, List&lt;Object&gt; value, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().rightPushAll(key, value);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                expire(key, time);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据索引修改list中的某条数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lUpdateIndex</span><span class="params">(String key, <span class="keyword">long</span> index, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().set(key, index, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除N个值为value</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> count 移除多少个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 移除的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">lRemove</span><span class="params">(String key, <span class="keyword">long</span> count, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Long remove = redisTemplate.opsForList().remove(key, count, value);</span><br><span class="line">            <span class="keyword">return</span> remove;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="六、Redis-conf配置信息">六、Redis.conf配置信息</h2>
<p><code>config get *</code>获取全部配置信息</p>
<p>配置文件信息在<code>/opt/redis-6.2.4/redis.conf</code>，常用配置信息如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 绑定IP，这里指所有ipv4和ipv6都可以访问</span></span><br><span class="line"><span class="built_in">bind</span> * -::* </span><br><span class="line"><span class="comment"># 受保护的 默认开启，若想外网连接必须关闭</span></span><br><span class="line">protected-mode yes</span><br><span class="line"><span class="comment"># 端口号</span></span><br><span class="line">port 6379</span><br><span class="line"><span class="comment"># 客户端闲置N秒后关闭连接（0禁用）</span></span><br><span class="line">timeout 0</span><br><span class="line"><span class="comment"># 向客户端发送 TCP ACK 检测连接是否断开，保证连接活跃。单位秒，默认300秒发送一次，如果等于0 就是禁用。</span></span><br><span class="line">tcp-keepalive 300</span><br><span class="line"><span class="comment">#==================general=================</span></span><br><span class="line"><span class="comment"># 默认情况下，Redis不会作为守护程序运行。如果需要，请设置为 yes</span></span><br><span class="line">daemonize yes</span><br><span class="line"><span class="comment"># 可通过upstart和systemd管理Redis守护进程</span></span><br><span class="line">supervised no</span><br><span class="line"><span class="comment"># 以后台进程方式运行redis，则需要指定pid文件</span></span><br><span class="line">pidfile /var/run/redis_6379.pid</span><br><span class="line"><span class="comment"># 日志级别</span></span><br><span class="line">loglevel notice</span><br><span class="line"><span class="comment"># 指定日志文件名称。指定为空时将输出到标准输出设备中。如果Redis以守护进程启动，当日志文件名称为空时，日志将会输出到 /dev/null。</span></span><br><span class="line">logfile <span class="string">""</span></span><br><span class="line"><span class="comment"># 数据库个数</span></span><br><span class="line">databases 16</span><br><span class="line"><span class="comment"># redis 启动的时候显示日志</span></span><br><span class="line">always-show-logo no</span><br><span class="line"><span class="comment">#==================snapshotting 快照=================</span></span><br><span class="line">save 900 1 <span class="comment">#900s有一个key发生改变，触发save</span></span><br><span class="line">save 300 10 <span class="comment">#300s有10个key发生改变，触发save</span></span><br><span class="line">save 60 10000 <span class="comment">#60s有10000个key发生改变，触发save</span></span><br><span class="line"><span class="comment"># 默认值为yes。当启用了RDB且最后一次后台保存数据失败，Redis是否停止接收数据。</span></span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"><span class="comment"># 使用压缩rdb文件 yes：压缩，但是需要一些cpu的消耗。no：不压缩，需要更多的磁盘空间</span></span><br><span class="line">rdbcompression yes</span><br><span class="line"><span class="comment"># 是否校验rdb文件，更有利于文件的容错性，但是在保存rdb文件的时候，会有大概10%的性能损耗</span></span><br><span class="line">rdbchecksum yes</span><br><span class="line"><span class="comment"># rdb 文件得文件名称</span></span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"><span class="comment"># rdb文件是否删除同步锁</span></span><br><span class="line">rdb-del-sync-files no</span><br><span class="line"><span class="comment"># 设置 rdb 文件存放得路径</span></span><br><span class="line">dir ./</span><br><span class="line"><span class="comment">#==================replication 主从复制=================</span></span><br><span class="line"><span class="comment">#当本机为从服务时，设置主服务的IP及端口</span></span><br><span class="line">replicaof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class="line"><span class="comment">#当本机为从服务时，设置主服务的连接密码。</span></span><br><span class="line">masterauth &lt;master-password&gt;</span><br><span class="line"><span class="comment">#本机为从服务时，设置主服务的用户名。</span></span><br><span class="line">masteruser &lt;username&gt;</span><br><span class="line"><span class="comment">#当slave失去与master的连接，或正在拷贝中，如果为yes，slave会响应客户端的请求，数据可能不同步甚至没有数据，如果为no，slave会返回错误"SYNC with master in progress"</span></span><br><span class="line">replica-serve-stale-data yes</span><br><span class="line"><span class="comment">#如果为yes，slave实例只读，如果为no，slave实例可读可写。</span></span><br><span class="line">replica-read-only yes</span><br><span class="line"><span class="comment">#指定slave定期ping master的周期，默认10秒钟。</span></span><br><span class="line">repl-ping-replica-period 10</span><br><span class="line"><span class="comment">#从服务ping主服务的超时时间，若超过repl-timeout设置的时间，slave就会认为master已经宕了。</span></span><br><span class="line">repl-timeout 60</span><br><span class="line"><span class="comment">#在slave和master同步后（发送psync/sync），后续的同步是否设置成TCP_NODELAY.假如设置成yes，则redis会合并小的TCP包从而节省带宽，但会增加同步延迟(40ms),造成master与slave数据不一致 假如设置成no，则redis master会立即发送同步数据，没有延迟。</span></span><br><span class="line">repl-disable-tcp-nodelay no</span><br><span class="line"><span class="comment">#当 master 不能正常工作的时候，Redis Sentinel 会从 slaves 中选出一个新的 master，这个值越小，就越会被优先选中，但是如果是 0 那是意味着这个 slave 不可能被选中。默认优先级为 100。</span></span><br><span class="line">replica-priority 100</span><br><span class="line"><span class="comment">#==================security 安全=================</span></span><br><span class="line"><span class="comment">#ACL日志的最大长度，默认是128M</span></span><br><span class="line">acllog-max-len 128</span><br><span class="line"><span class="comment">#ACL外部配置文件所在位置</span></span><br><span class="line">aclfile /etc/redis/users.acl</span><br><span class="line"><span class="comment">#当前redis服务的访问密码，默认是不需要密码</span></span><br><span class="line">requirepass 123456</span><br><span class="line"><span class="comment">#也可以命令行设置</span></span><br><span class="line">config <span class="built_in">set</span> requirepass <span class="string">"123456"</span></span><br><span class="line"><span class="comment">#测试ping，发现需要验证127.0.0.1:6379&gt; ping</span></span><br><span class="line">NOAUTH Authentication required. <span class="comment"># 验证</span></span><br><span class="line">127.0.0.1:6379&gt; auth 123456</span><br><span class="line">OK</span><br><span class="line"><span class="comment">#==================限制=================</span></span><br><span class="line"><span class="comment"># 设置最大客户连接数</span></span><br><span class="line">maxclients 10000</span><br><span class="line"><span class="comment"># 内存限制字节数</span></span><br><span class="line">maxmemory &lt;bytes&gt;</span><br><span class="line"><span class="comment"># maxmemory-policy 内存达到上限的处理策略</span></span><br><span class="line"><span class="comment">#volatile-lru：利用LRU算法移除设置过过期时间的key。</span></span><br><span class="line"><span class="comment">#volatile-random：随机移除设置过过期时间的key。</span></span><br><span class="line"><span class="comment">#volatile-ttl：移除即将过期的key，根据最近过期时间来删除（辅以TTL）  </span></span><br><span class="line"><span class="comment">#allkeys-lru：利用LRU算法移除任何key。</span></span><br><span class="line"><span class="comment">#allkeys-random：随机移除任何key。</span></span><br><span class="line"><span class="comment">#noeviction：不移除任何key，只是返回一个写错误。</span></span><br><span class="line">maxmemory-policy noeviction</span><br><span class="line"><span class="comment">#==================append only模式=================</span></span><br><span class="line"><span class="comment">#Redis的持久化存储提供两种方式：RDB与AOF。RDB是默认配置(常用)AOF需要手动开启</span></span><br><span class="line">appendonly no</span><br><span class="line"><span class="comment"># 配置文件名字</span></span><br><span class="line">appendfilename <span class="string">"appendonly.aof"</span></span><br><span class="line"><span class="comment"># appendfsync aof持久化策略的配置</span></span><br><span class="line"><span class="comment"># no表示不执行fsync，由操作系统保证数据同步到磁盘，速度最快</span></span><br><span class="line"><span class="comment"># always表示每次写入都执行fsync，以保证数据同步到磁盘</span></span><br><span class="line"><span class="comment"># everysec表示每秒执行一次fsync，可能会导致丢失这1s数据</span></span><br><span class="line">appendfsync everysec</span><br><span class="line"><span class="comment">#重写时是否可以运用Appendfsync，用默认no即可，保证数据安全性</span></span><br><span class="line">No-appendfsync-on-rewrite no</span><br><span class="line"><span class="comment"># 设置重写的基准值</span></span><br><span class="line">Auto-aof-rewrite-min-size 100</span><br><span class="line"><span class="comment">#设置重写的基准值</span></span><br><span class="line">Auto-aof-rewrite-percentage 64mb</span><br><span class="line"><span class="comment">#==================cluster 集群=====================</span></span><br><span class="line"><span class="comment"># 启用集群模式</span></span><br><span class="line">cluster-enabled yes      </span><br><span class="line"><span class="comment"># 设置当前节点连接超时毫秒数</span></span><br><span class="line">cluster-node-timeout 15000     </span><br><span class="line"><span class="comment">#设置当前节点集群配置文件路径</span></span><br><span class="line">cluster-config-file node_6381.conf</span><br></pre></td></tr></table></figure>
<h2 id="七、Redis持久化">七、Redis持久化</h2>
<p>Redis 是内存数据库，如果不将内存中的数据库状态保存到磁盘，那么一旦服务器进程退出，服务器中的数据库状态也会消失。所以 Redis 提供了持久化功能！</p>
<h3 id="1、RDB-Redis-DataBase">1、RDB(Redis DataBase)</h3>
<blockquote>
<p>在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里</p>
</blockquote>
<p>Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的。这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失，且备份时需要消耗内存。</p>
<p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/image-20210605195534013.png" alt="image-20210605140429685"></p>
<p><strong>RDB快照</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对于RDB来说，提供了三种机制：save、bgsave、自动触发。</span></span><br><span class="line"><span class="comment"># 自动触发在redis.conf下进行配置</span></span><br><span class="line"><span class="comment"># 三种情况保存的rdb文件可以进行配置，默认在当前目录</span></span><br><span class="line">127.0.0.1:6379&gt; bgsave</span><br><span class="line">Background saving started</span><br><span class="line">127.0.0.1:6379&gt; save</span><br><span class="line">OK</span><br><span class="line"><span class="comment"># 若要恢复Redis数据，只需要将dump.rdb文件放到对应dir目录下，Redis会自动进行数据恢复</span></span><br><span class="line">127.0.0.1:6379&gt; config get dir</span><br><span class="line">1) <span class="string">"dir"</span></span><br><span class="line">2) <span class="string">"/usr/local/bin"</span></span><br></pre></td></tr></table></figure>
<h3 id="2、AOF-Append-Only-File">2、AOF(Append Only File)</h3>
<blockquote>
<p>以日志的形式来记录每个写操作，将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#若需要使用aof，需要在配置信息里开启</span></span><br><span class="line"><span class="comment">#aof正常恢复</span></span><br><span class="line"><span class="comment">#将有数据的aof文件复制一份保存到对应目录（conﬁg get dir）恢复：重启redis然后重新加载</span></span><br><span class="line"><span class="comment">#若aof文件异常，redis将无法启动，可进行修复</span></span><br><span class="line">redis-check-aof --fix appendonly.aof</span><br></pre></td></tr></table></figure>
<h3 id="3、总结">3、总结</h3>
<p>1、RDB 持久化方式能够在指定的时间间隔内对数据进行快照存储<br>
2、AOF 持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，AOF命令以Redis 协议追加保存每次写的操作到文件末尾，Redis还能对AOF文件进行后台重写，使得AOF文件的体积不至于过大。<br>
3、只做缓存，可以不使用任何持久化<br>
4、同时开启两种持久化方式时</p>
<ul>
<li>在这种情况下，当redis重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。</li>
<li>RDB 的数据不实时，同时使用两者时服务器重启也只会找AOF文件，建议不要只使用AOF，因为RDB更适合用于备份数据库（AOF在不断变化不好备份），快速重启，而且不会有AOF可能潜在的Bug，留着作为一个万一的手段。</li>
</ul>
<p>5、性能建议</p>
<ul>
<li>因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留 save 900 1 这条规则。</li>
<li>如果Enable AOF ，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了，代价一是带来了持续的IO，二是AOF rewrite 的最后将 rewrite 过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上，默认超过原大小100%大小重写可以改到适当的数值。</li>
<li>如果不Enable AOF ，仅靠 Master-Slave Repllcation 实现高可用性也可以，能省掉一大笔IO，也减少了rewrite时带来的系统波动。代价是如果Master/Slave 同时倒掉，会丢失十几分钟的数据，启动脚本也要比较两个 Master/Slave 中的 RDB文件，载入较新的那个，微博就是这种架构。</li>
</ul>
<h2 id="八、Redis发布订阅">八、Redis发布订阅</h2>
<blockquote>
<p>Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。 Redis 客户端可以订阅任意数量的频道。</p>
</blockquote>
<p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/pubsub2.png" alt="image-20210605195534013"></p>
<p><strong>redis发布订阅常用命令</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">序号</th>
<th style="text-align:left">命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:left">PSUBSCRIBE pattern [pattern …]</td>
<td>订阅一个或多个符合给定模式的频道</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:left">PUBSUB subcommand [argument [argument …]]</td>
<td>查看订阅与发布系统状态</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:left">PUBLISH channel message</td>
<td>将信息发送到指定的频道</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:left">PUNSUBSCRIBE [pattern [pattern …]]</td>
<td>退订所有给定模式的频道</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:left">SUBSCRIBE channel [channel …]</td>
<td>订阅给定的一个或多个频道的信息</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:left">UNSUBSCRIBE [channel [channel …]]</td>
<td>退订给定的频道</td>
</tr>
</tbody>
</table>
<p><strong>测试</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#开启一个客户端，订阅一个频道</span></span><br><span class="line">127.0.0.1:6379&gt; SUBSCRIBE shawn</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) <span class="string">"subscribe"</span></span><br><span class="line">2) <span class="string">"shawn"</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment">#打开另一个客户端，发送消息</span></span><br><span class="line">127.0.0.1:6379&gt; PUBLISH shawn hello</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment">#第一个客户端收到订阅消息</span></span><br><span class="line">1) <span class="string">"message"</span></span><br><span class="line">2) <span class="string">"shawn"</span></span><br><span class="line">3) <span class="string">"hello"</span></span><br></pre></td></tr></table></figure>
<p><strong>原理</strong></p>
<ul>
<li>
<p>Redis是使用C实现的，通过分析 Redis 源码里的 pubsub.c 文件，了解发布和订阅机制的底层实现，籍此加深对 Redis 的理解</p>
</li>
<li>
<p>Redis 通过 PUBLISH 、SUBSCRIBE 和 PSUBSCRIBE 等命令实现发布和订阅功能</p>
</li>
<li>
<p>通过 SUBSCRIBE 命令订阅某频道后，redis-server 里维护了一个字典，字典的键就是一个个 channel ，而字典的值则是一个链表，链表中保存了所有订阅这个 channel 的客户端。SUBSCRIBE 命令的关键，就是将客户端添加到给定 channel 的订阅链表中</p>
</li>
<li>
<p>通过 PUBLISH 命令向订阅者发送消息，redis-server 会使用给定的频道作为键，在它所维护的 channel 字典中查找记录了订阅这个频道的所有客户端的链表，遍历这个链表，将消息发布给所有订阅者</p>
</li>
<li>
<p>Pub/Sub 从字面上理解就是发布（Publish）与订阅（Subscribe），在Redis中，你可以设定对某一个key值进行消息发布及消息订阅，当一个key值上进行了消息发布后，所有订阅它的客户端都会收到相应的消息</p>
</li>
</ul>
<p><strong>使用场景</strong></p>
<ul>
<li>Pub/Sub构建实时消息系统</li>
<li>Pub/Sub构建的实时聊天系统</li>
</ul>
<h2 id="九、Redis主从、哨兵和集群">九、Redis主从、哨兵和集群</h2>
<p><em>这里实验都在一台机器上，故只修改端口，正式操作时应该分布在不同的机器中</em></p>
<h3 id="1、主从复制">1、主从复制</h3>
<blockquote>
<p>主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master/leader)，后者称为从节点(slave/follower)；数据的复制是单向的，只能由主节点到从节点。 Master以写为主，Slave 以读为主。默认每台Redis服务器都是主节点，单台Redis内存不应超过20G。</p>
</blockquote>
<p>对于读多写少的电商</p>
<p><strong>主从复制作用</strong></p>
<ul>
<li>数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</li>
<li>故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。</li>
<li>负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。</li>
<li>高可用基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。</li>
</ul>
<p><strong>环境配置</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看信息</span></span><br><span class="line">127.0.0.1:6379&gt; INFO replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:c75ea02227de8882aa3c60c9b22559e3076270b0</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:0</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:0</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:0</span><br><span class="line">repl_backlog_histlen:0</span><br></pre></td></tr></table></figure>
<p>配置主从复制，至少一主二从</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#生成三份配置文件，myredis.conf这里我已经存在了</span></span><br><span class="line">cp conf/myredis.conf conf/myredis01.conf </span><br><span class="line">cp conf/myredis.conf conf/myredis02.conf</span><br><span class="line"><span class="comment">#其次修改配置文件，下面是我其中一个配置</span></span><br><span class="line"><span class="comment">#依次修改port端口号、daemonize为yes、pidfile文件、logfile文件、dbfilename文件</span></span><br><span class="line">port 6370</span><br><span class="line">daemonize yes</span><br><span class="line">pidfile /var/run/redis_6370.pid</span><br><span class="line">logfile <span class="string">"6370.log"</span></span><br><span class="line">dbfilename <span class="string">"dump6370.rdb"</span></span><br><span class="line"><span class="comment">#保证文件不会重复，最后开启服务，开启三个终端</span></span><br><span class="line">redis-server conf/myredis.conf </span><br><span class="line">redis-server conf/myredis01.conf </span><br><span class="line">redis-server conf/myredis02.conf </span><br><span class="line"><span class="comment">#查看是否成功开启</span></span><br><span class="line">ps -ef|grep redis</span><br></pre></td></tr></table></figure>
<p><strong>命令行配置(效果暂时，一般是配置文件配置)</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#仅在从机进行配置即可，我的两个从机端口为6370和6371</span></span><br><span class="line">127.0.0.1:6370&gt; SLAVEOF 127.0.0.1 6379</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6371&gt; SLAVEOF 127.0.0.1 6379</span><br><span class="line">OK</span><br><span class="line"><span class="comment">#此时查看主机信息可以看见两个从机已经连接</span></span><br><span class="line">127.0.0.1:6379&gt; INFO replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:2</span><br><span class="line">slave0:ip=127.0.0.1,port=6371,state=online,offset=280,lag=1</span><br><span class="line">slave1:ip=127.0.0.1,port=6370,state=online,offset=280,lag=1</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:d0f2fce55c4ee9f4403b7ff342ca7e43ef38d470</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:280</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:280</span><br><span class="line"><span class="comment"># 从机使用此命令可以重新变为主机</span></span><br><span class="line">127.0.0.1:6371&gt; SLAVEOF no one</span><br></pre></td></tr></table></figure>
<p><strong>配置文件配置</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入REPLICATION部分，修改从机配置文件</span></span><br><span class="line">replicaof &lt;masterip&gt; &lt;masterport&gt;</span><br></pre></td></tr></table></figure>
<p><strong>测试细节</strong></p>
<ul>
<li>主机能读写，从机只能读，且从机会自动复制主机内容</li>
<li>主机宕机，从机只能进行读操作</li>
<li>若命令行操作，从机宕机，重新启动后变为主机，重新设置变为从机后可获取主机最新信息</li>
</ul>
<p><strong>复制原理</strong></p>
<p>Slave 启动成功连接到 master 后会发送一个sync命令，Master 接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，master将传送整个数据文件到slave，并完成一次完全同步。但是只要是重新连接master，一次完全同步（全量复制）将被自动执行</p>
<ul>
<li>全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。</li>
<li>增量复制：Master 继续将新的所有收集到的修改命令依次传给slave，完成同步</li>
</ul>
<h3 id="2、哨兵模式">2、哨兵模式</h3>
<blockquote>
<p>哨兵模式能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库。哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行。其原理是哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。</p>
</blockquote>
<p>一般哨兵模式要开启6个进程，假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象成为==主观下线==。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover[故障转移]操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为==客观下线==。</p>
<p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/image-20210607155751506.png" alt="img"></p>
<p><strong>测试配置</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一主二从配置不变，加入哨兵进程</span></span><br><span class="line"><span class="comment"># 进入redis目录</span></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/bin/</span><br><span class="line"><span class="comment"># 复制3个哨兵配置文件sentinel.conf</span></span><br><span class="line">cp /opt/redis-6.2.4/sentinel.conf conf/sentinel1.conf </span><br><span class="line">cp /opt/redis-6.2.4/sentinel.conf conf/sentinel2.conf </span><br><span class="line">cp /opt/redis-6.2.4/sentinel.conf conf/sentinel3.conf</span><br></pre></td></tr></table></figure>
<p>依次修改3份哨兵配置文件，保证端口、pid文件和日志文件不重名，日志文件在/tmp目录下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">port 26381</span><br><span class="line">daemonize yes</span><br><span class="line">pidfile <span class="string">"/var/run/redis-sentinel26381.pid"</span></span><br><span class="line">logfile <span class="string">"26381.log"</span></span><br><span class="line">dir <span class="string">"/tmp"</span></span><br><span class="line"><span class="comment">#这里是最重要的，后四个依次是master别名，master的ip、端口号以及得票多少才能成为主机，一般是哨兵一半加一</span></span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在当前目录下依次启动，即完成哨兵模式</span></span><br><span class="line">redis-sentinel conf/sentinel1.conf</span><br><span class="line">redis-sentinel conf/sentinel2.conf</span><br><span class="line">redis-sentinel conf/sentinel3.conf</span><br><span class="line"><span class="comment">#此时若6379主机宕机后，哨兵模式会自动选举产生新的主服务器，当6379重启后，自动变成从机，可以进入/tmp查看日志</span></span><br></pre></td></tr></table></figure>
<p><strong>配置文件详解</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 哨兵sentinel实例运行的端口 默认26379</span></span><br><span class="line">port 26379</span><br><span class="line"><span class="comment"># 是否后台启动</span></span><br><span class="line">daemonize yes</span><br><span class="line"><span class="comment"># 运行时PID文件</span></span><br><span class="line">pidfile /var/run/redis-sentinel.pid</span><br><span class="line"><span class="comment"># 日志文件(绝对路径)</span></span><br><span class="line">logfile <span class="string">"/opt/app/redis6/sentinel.log"</span></span><br><span class="line"><span class="comment"># 数据目录</span></span><br><span class="line">dir <span class="string">"/tmp"</span></span><br><span class="line"><span class="comment"># 哨兵sentinel监控的redis主节点的 ip port </span></span><br><span class="line"><span class="comment"># master-name  可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符".-_"组成。</span></span><br><span class="line"><span class="comment"># quorum 当这些quorum个数sentinel哨兵认为master主节点失联 那么这时 客观上认为主节点失联了</span></span><br><span class="line"><span class="comment"># sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span></span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2</span><br><span class="line"><span class="comment"># 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供密码</span></span><br><span class="line"><span class="comment"># 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码</span></span><br><span class="line"><span class="comment"># sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span></span><br><span class="line">sentinel auth-pass mymaster MySUPER--secret-0123passw0rd</span><br><span class="line"><span class="comment"># 哨兵连接主节点多长时间没有响应就代表主节点挂了，单位毫秒。默认30000毫秒，30秒。</span></span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line"><span class="comment"># 在故障转移时，最多有多少从节点对新的主节点进行同步。这个值越小完成故障转移的时间就越长，这个值越大就意味着越多的从节点因为同步数据而暂时阻塞不可用</span></span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"><span class="comment"># 故障转移的超时时间，默认3分钟</span></span><br><span class="line"><span class="comment"># sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;</span></span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br><span class="line"><span class="comment">#禁止使用SENTINEL SET设置notification-script和client-reconfig-script</span></span><br><span class="line">sentinel deny-scripts-reconfig yes</span><br><span class="line"><span class="comment"># 配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。</span></span><br><span class="line"><span class="comment"># 通知脚本</span></span><br><span class="line"><span class="comment"># sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;</span></span><br><span class="line">sentinel notification-script mymaster /var/redis/notify.sh</span><br><span class="line"><span class="comment"># 客户端重新配置主节点参数脚本</span></span><br><span class="line"><span class="comment"># 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。</span></span><br><span class="line"><span class="comment"># sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;</span></span><br><span class="line">sentinel client-reconfig-script mymaster /var/redis/reconfig.sh</span><br></pre></td></tr></table></figure>
<h3 id="3、Redis集群">3、Redis集群</h3>
<blockquote>
<p>Redis集群由多个节点(Node)组成，Redis 的数据分布在这些节点中。集群中的节点分为主节点和从节点，只有主节点负责读写请求和集群信息的维护，从节点只进行主节点数据和状态信息的复制。Redis集群采用哈希分区的方式对数据进行分区，哈希分区就是对数据的特征值进行哈希，然后根据哈希值决定数据放在哪个节点。其中redis cluster集群是去中心化的，每个节点都是平等的，连接哪个节点都可以获取和设置数据。</p>
</blockquote>
<p>Redis集群的作用有下面几点：</p>
<ul>
<li><strong>数据分区</strong>：突破单机的存储限制，将数据分散到多个不同的节点存储；</li>
<li><strong>负载均衡</strong>：每个主节点都可以处理读写请求，提高了并发能力；</li>
<li><strong>高可用</strong>：集群有着和哨兵模式类似的故障转移能力，提升集群的稳定性；</li>
</ul>
<p><strong>普通端口</strong>：即客户端访问端口，如默认的6379；</p>
<p><strong>集群端口</strong>：普通端口号加10000，如6379的集群端口为16379，用于集群节点之间的通讯</p>
<p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/image-20210608101514039.png" alt="image-20210607155751506"></p>
<p><strong>配置</strong></p>
<p>分配6个配置文件</p>
<table>
<thead>
<tr>
<th style="text-align:left">ID</th>
<th style="text-align:left">IP</th>
<th style="text-align:left">Host</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">从节点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">A</td>
<td style="text-align:left">127.0.0.1</td>
<td style="text-align:left">6381</td>
<td style="text-align:left">主</td>
<td style="text-align:left">AA</td>
</tr>
<tr>
<td style="text-align:left">B</td>
<td style="text-align:left">127.0.0.1</td>
<td style="text-align:left">6382</td>
<td style="text-align:left">主</td>
<td style="text-align:left">BB</td>
</tr>
<tr>
<td style="text-align:left">C</td>
<td style="text-align:left">127.0.0.1</td>
<td style="text-align:left">6383</td>
<td style="text-align:left">主</td>
<td style="text-align:left">CC</td>
</tr>
<tr>
<td style="text-align:left">AA</td>
<td style="text-align:left">127.0.0.1</td>
<td style="text-align:left">6391</td>
<td style="text-align:left">从</td>
<td style="text-align:left">/</td>
</tr>
<tr>
<td style="text-align:left">BB</td>
<td style="text-align:left">127.0.0.1</td>
<td style="text-align:left">6392</td>
<td style="text-align:left">从</td>
<td style="text-align:left">/</td>
</tr>
<tr>
<td style="text-align:left">CC</td>
<td style="text-align:left">127.0.0.1</td>
<td style="text-align:left">6393</td>
<td style="text-align:left">从</td>
<td style="text-align:left">/</td>
</tr>
</tbody>
</table>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#分别修改6个目录中的redis.conf文件，主要开启集群以及修改端口和文件路径</span></span><br><span class="line"><span class="comment">#举例其中一个</span></span><br><span class="line">port 6381</span><br><span class="line">port 26381</span><br><span class="line">daemonize yes</span><br><span class="line">pidfile <span class="string">"/var/run/redis-sentinel26381.pid"</span></span><br><span class="line">logfile <span class="string">"26381.log"</span></span><br><span class="line">cluster-enabled yes                            <span class="comment"># 启用集群模式</span></span><br><span class="line">cluster-node-timeout 15000                     <span class="comment"># 设置当前节点连接超时毫秒数</span></span><br><span class="line"><span class="comment">#设置当前节点集群配置文件路径，该文件由集群自动维护，如果有则使用文件中的配置启动；如果没有，则初始化配置并将配置保存到文件中。</span></span><br><span class="line">cluster-config-file node_6381.conf             </span><br><span class="line"><span class="comment">#=========================================</span></span><br><span class="line"><span class="comment">#启动，前三个表示主机，后三个表示从机</span></span><br><span class="line"><span class="comment">#这里的--cluster-replicas表示每个主节点有几个副本节点</span></span><br><span class="line">redis-cli --cluster create 127.0.0.1:6381 127.0.0.1:6382 127.0.0.1:6383 127.0.0.1:6391 127.0.0.1:6392 127.0.0.1:6393 --cluster-replicas 1</span><br><span class="line"><span class="comment"># -c，使用集群方式登录</span></span><br><span class="line">redis-cli -c [-h 192.168.30.128] -p 7001 [-a 123456]    </span><br><span class="line"><span class="comment">#集群状态</span></span><br><span class="line">CLUSTER INFO     </span><br><span class="line"><span class="comment">#列出节点信息</span></span><br><span class="line">CLUSTER NODES</span><br></pre></td></tr></table></figure>
<h2 id="十、Redis缓存">十、Redis缓存</h2>
<h3 id="1、缓存穿透">1、缓存穿透</h3>
<blockquote>
<p>缓存穿透是指查询一个根本不存在的数据，缓存层和持久层都不会命中。在日常工作中出于容错的考虑，如果从持久层查不到数据则不写入缓存层，缓存穿透将导致不存在的数据每次请求都要到持久层去查询，失去了缓存保护后端持久的意义</p>
</blockquote>
<p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/image-20210607170538553.png" alt="image-20210608101514039"></p>
<h3 id="2、缓存击穿">2、缓存击穿</h3>
<blockquote>
<p>系统中存在以下两个问题时需要引起注意：当前key是一个热点key（例如一个秒杀活动），并发量非常大；重建缓存不能在短时间完成，可能是一个复杂计算，例如复杂的SQL、多次IO、多个依赖等。在缓存失效的瞬间，有大量线程来重建缓存，造成后端负载加大，甚至可能会让应用崩溃。</p>
</blockquote>
<p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/image-20210607170758835.png" alt="image-20210607170758835"></p>
<h3 id="3、缓存雪崩">3、缓存雪崩</h3>
<blockquote>
<p>由于缓存层承载着大量请求，有效地保护了存储层，但是如果缓存层由于某些原因不可用（宕机）或者大量缓存由于超时时间相同在同一时间段失效（大批key失效/热点数据失效），大量请求直接到达存储层，存储层压力过大导致系统雪崩。</p>
</blockquote>
<p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/image-20210607170901524.png" alt="image-20210607170538553"></p>
<hr>
<hr>
<p>参考文章：<br>
<a href="https://blog.csdn.net/wsdc0521/article/details/106316972" target="_blank" rel="noopener">https://blog.csdn.net/wsdc0521/article/details/106316972</a><br>
<a href="https://blog.csdn.net/weixin_43445935/article/details/115393205" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43445935/article/details/115393205</a><br>
<a href="https://www.bilibili.com/video/BV1S54y1R7SB?p=12&amp;spm_id_from=pageDriver" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1S54y1R7SB?p=12&amp;spm_id_from=pageDriver</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>mmdetection2 config详解</title>
    <url>/posts/2f275aa8.html</url>
    <content><![CDATA[<blockquote>
<p>官方文档config详情：<a href="https://mmdetection.readthedocs.io/en/latest/tutorials/config.html" target="_blank" rel="noopener">https://mmdetection.readthedocs.io/en/latest/tutorials/config.html</a></p>
</blockquote>
<h3 id="1、配置文件结构">1、配置文件结构</h3>
<p>在<code>config/_base_</code>文件夹下面总共有4个基础的组件，它们分别是：dataset、model、schedule、default_runtime。</p>
<a id="more"></a>
<h3 id="2、配置文件命名风格">2、配置文件命名风格</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;model&#125;_[model setting]_&#123;backbone&#125;_&#123;neck&#125;_[norm setting]_[misc]_[gpu x batch_per_gpu]_&#123;schedule&#125;_&#123;dataset&#125;</span><br></pre></td></tr></table></figure>
<p><code>{xxx}</code>是必选项，<code>[yyy]</code>是可选项</p>
<ul>
<li><code>{model}</code>:模型的类型 ，例如<code>faster_rcnn</code>、<code>mask_rcnn</code> 等等.</li>
<li><code>[model setting]</code>: 给模型一些指定设置, 例如<code>without_semantic for htc</code>、<code>moment for reppoints</code>等等.</li>
<li><code>{backbone}</code>: backbone 的类型 <code>r50</code> (ResNet-50), <code>x101</code> (ResNeXt-101)。（相当于特征提取网络）</li>
<li><code>{neck}</code>: neck 的类型选择，例如<code>fpn</code>,<code> pafpn</code>, <code>nasfpn</code>,<code> c4</code>.</li>
<li><code>[norm_setting]</code>: 如果没有指定，那就默认为<code>bn</code> (Batch Normalization) , 还有其他可选的norm layer类型，比如 <code>gn</code> (Group Normalization)、<code>syncbn</code> (Synchronized Batch Normalization). <code>gn-head</code>/<code>gn-neck </code>表示 GN 仅仅被用在head/neck模块上, gn-all 表示 GN 被用在整个模型上, 例如：backbone, neck, head这些模块。</li>
<li><code>[misc]</code>: 一些比较杂的模型设置或者插件，例如 <code>dconv</code>, <code>gcb</code>, <code>attention</code>, <code>albu</code>, <code>mstrain</code>.</li>
<li><code>[gpu x batch_per_gpu]</code>: GPU的个数以及每块GPU上的batch size大小，默认为<code>8*2</code>(8块GPU，每块GPU上2个batch size，相当于batch size为16)。</li>
<li><code>{schedule}</code>: 训练的 schedule, 可选择的有<code>1x</code>, <code>2x</code>, <code>20e</code>等等. <code>1x</code> 和 <code>2x</code> 分别表示 12 个epochs 和 24个epochs。 20e 被用在 cascade models中,它表示20个epochs. 对于1x/2x而言, 初始的学习率分别在第8/16个epeochs和第11/22个epochs以10的倍率递减。对于<code>20e</code>而言,初始的学习率在第16个epeochs和第19个epochs以10的倍率。</li>
<li><code>{dataset}</code>: 数据集有<code> coco</code>, <code>cityscapes</code>, <code>voc_0712</code>, <code>wider_face</code>这些选项。</li>
</ul>
<h3 id="3、faster-rcnn-r50-fpn-2x-py">3、faster_rcnn_r50_fpn_2x.py</h3>
<p>首先介绍一下这个配置文件所描述的框架，它是基于resnet50的backbone，有着5个fpn特征层的faster-RCNN目标检测网络，训练迭代次数为标准的24次epoch。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 模型配置</span></span><br><span class="line">model = dict(</span><br><span class="line">    <span class="comment"># model类型</span></span><br><span class="line">    type=<span class="string">'FasterRCNN'</span>,</span><br><span class="line">    <span class="comment"># 预训练模型：resnet50</span></span><br><span class="line">    pretrained=<span class="string">'torchvision://resnet50'</span>,</span><br><span class="line">    backbone=dict(</span><br><span class="line">        <span class="comment"># backbone类型</span></span><br><span class="line">        type=<span class="string">'ResNet'</span>, </span><br><span class="line">        <span class="comment"># 网络层数</span></span><br><span class="line">        depth=<span class="number">50</span>,</span><br><span class="line">        <span class="comment"># resnet的stage数量</span></span><br><span class="line">        num_stages=<span class="number">4</span>,</span><br><span class="line">        <span class="comment"># 输出的stage的序号</span></span><br><span class="line">        out_indices=(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>),</span><br><span class="line">        <span class="comment"># 冻结的stage数量，即该stage不更新参数，-1表示所有的stage都更新参数</span></span><br><span class="line">        frozen_stages=<span class="number">1</span>,</span><br><span class="line">        <span class="comment"># normalization layers的配置,type 为norm layer的类型, 通常是 BN or GN，requires_grad参数是否训练BN中的gamma和beta参数</span></span><br><span class="line">        norm_cfg=dict(type=<span class="string">'BN'</span>, requires_grad=<span class="literal">True</span>),</span><br><span class="line">        <span class="comment"># 是否冻结BN中的统计信息（相当于模型eval的过程，不进行统计数据）</span></span><br><span class="line">        norm_eval=<span class="literal">True</span>,</span><br><span class="line">        <span class="comment"># 网络风格：如果设置pytorch，则stride为2的层是conv3x3的卷积层；如果设置caffe，则stride为2的层是第一个conv1x1的卷积层</span></span><br><span class="line">        style=<span class="string">'pytorch'</span>),</span><br><span class="line">    neck=dict(</span><br><span class="line">        <span class="comment"># neck类型</span></span><br><span class="line">        type=<span class="string">'FPN'</span>,</span><br><span class="line">        <span class="comment"># 输入的各个stage的通道数</span></span><br><span class="line">        in_channels=[<span class="number">256</span>, <span class="number">512</span>, <span class="number">1024</span>, <span class="number">2048</span>],</span><br><span class="line">        <span class="comment"># 输出的特征层的通道数</span></span><br><span class="line">        out_channels=<span class="number">256</span>,</span><br><span class="line">        <span class="comment"># 输出的特征层的数量</span></span><br><span class="line">        num_outs=<span class="number">5</span>),</span><br><span class="line">    rpn_head=dict(</span><br><span class="line">        <span class="comment"># RPN网络类型</span></span><br><span class="line">        type=<span class="string">'RPNHead'</span>,</span><br><span class="line">        <span class="comment"># RPN网络的输入通道数</span></span><br><span class="line">        in_channels=<span class="number">256</span>,</span><br><span class="line">        <span class="comment"># 特征层的通道数</span></span><br><span class="line">        feat_channels=<span class="number">256</span>,</span><br><span class="line">        <span class="comment"># 生成anchor的配置</span></span><br><span class="line">        anchor_generator=dict(</span><br><span class="line">            <span class="comment"># 绝大多数都是用AnchorGenerator, SSD 检测器(单阶段的目标检测算法)使用的是SSDAnchorGenerator</span></span><br><span class="line">            type=<span class="string">'AnchorGenerator'</span>,</span><br><span class="line">             <span class="comment"># anchor的生成个数, 特征图上每一个位置所生成的anchor个数为scale * base_sizes</span></span><br><span class="line">            scales=[<span class="number">8</span>],</span><br><span class="line">            <span class="comment"># anchor的宽高比率.</span></span><br><span class="line">            ratios=[<span class="number">0.5</span>, <span class="number">1.0</span>, <span class="number">2.0</span>],</span><br><span class="line">           <span class="comment"># 在每个特征层上的anchor的步长（对应于原图）</span></span><br><span class="line">            strides=[<span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>]),</span><br><span class="line">        bbox_coder=dict(</span><br><span class="line">            type=<span class="string">'DeltaXYWHBBoxCoder'</span>,</span><br><span class="line">            <span class="comment"># 均值</span></span><br><span class="line">            target_means=[<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>],</span><br><span class="line">            <span class="comment"># 方差</span></span><br><span class="line">            target_stds=[<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>]),</span><br><span class="line">            <span class="comment"># 分类损失函数配置</span></span><br><span class="line">        loss_cls=dict(</span><br><span class="line">            <span class="comment"># 也提供FocalLoss等损失函数</span></span><br><span class="line">            type=<span class="string">'CrossEntropyLoss'</span>, </span><br><span class="line">            <span class="comment"># 是否使用sigmoid来进行分类，如果False则使用softmax来分类</span></span><br><span class="line">            use_sigmoid=<span class="literal">True</span>, </span><br><span class="line">            <span class="comment"># 分类分支所占权重</span></span><br><span class="line">            loss_weight=<span class="number">1.0</span>),</span><br><span class="line">            <span class="comment"># box回归分支的损失函数配置.</span></span><br><span class="line">        loss_bbox=dict(</span><br><span class="line">            type=<span class="string">'L1Loss'</span>, loss_weight=<span class="number">1.0</span>)),</span><br><span class="line">    <span class="comment"># RoIHead 封装了二阶段检测器的第二阶段的模块</span></span><br><span class="line">    roi_head=dict(</span><br><span class="line">        <span class="comment"># RoI head的类型</span></span><br><span class="line">        type=<span class="string">'StandardRoIHead'</span>,</span><br><span class="line">        <span class="comment"># RoI feature extractor 用于 bbox regression.</span></span><br><span class="line">        bbox_roi_extractor=dict(</span><br><span class="line">            <span class="comment"># 类型，大部分默认</span></span><br><span class="line">            type=<span class="string">'SingleRoIExtractor'</span>,</span><br><span class="line">            roi_layer=dict(</span><br><span class="line">                <span class="comment"># 同时还支持DeformRoIPoolingPack 和 ModulatedDeformRoIPoolingPack这两种类型.</span></span><br><span class="line">                type=<span class="string">'RoIAlign'</span>, </span><br><span class="line">                <span class="comment"># feature maps的输出尺度，相当于输出7*7.</span></span><br><span class="line">                output_size=<span class="number">7</span>, </span><br><span class="line">                <span class="comment"># 提取ROI特征层时的样本比例，0表示自适应</span></span><br><span class="line">                sampling_ratio=<span class="number">0</span>),</span><br><span class="line">            <span class="comment"># 提取特征的输出通道数</span></span><br><span class="line">            out_channels=<span class="number">256</span>,</span><br><span class="line">            <span class="comment"># 多尺度特征图的步幅</span></span><br><span class="line">            featmap_strides=[<span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>]),</span><br><span class="line">        bbox_head=dict(</span><br><span class="line">            <span class="comment"># 全连接层类型</span></span><br><span class="line">            type=<span class="string">'Shared2FCBBoxHead'</span>,</span><br><span class="line">            <span class="comment"># 输入通道数</span></span><br><span class="line">            in_channels=<span class="number">256</span>,</span><br><span class="line">            <span class="comment"># 全连接层输出通道数</span></span><br><span class="line">            fc_out_channels=<span class="number">1024</span>,</span><br><span class="line">            <span class="comment"># ROI特征层尺寸</span></span><br><span class="line">            roi_feat_size=<span class="number">7</span>,</span><br><span class="line">            <span class="comment"># 分类器数量，改自己数据集时修改</span></span><br><span class="line">            num_classes=<span class="number">1</span>,</span><br><span class="line">            <span class="comment"># 同上</span></span><br><span class="line">            bbox_coder=dict(</span><br><span class="line">                type=<span class="string">'DeltaXYWHBBoxCoder'</span>,</span><br><span class="line">                target_means=[<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>],</span><br><span class="line">                target_stds=[<span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.2</span>]),</span><br><span class="line">            <span class="comment"># 是否采用class_agnostic的方式来预测，class_agnostic表示输出bbox时只考虑其是否为前景，后续分类的时候再根据该bbox在网络中的类别得分来分类，也就是说一个框可以对应多个类别</span></span><br><span class="line">            reg_class_agnostic=<span class="literal">False</span>,</span><br><span class="line">            <span class="comment"># 同上</span></span><br><span class="line">            loss_cls=dict(</span><br><span class="line">                type=<span class="string">'CrossEntropyLoss'</span>, use_sigmoid=<span class="literal">False</span>, loss_weight=<span class="number">1.0</span>),</span><br><span class="line">            loss_bbox=dict(type=<span class="string">'L1Loss'</span>, loss_weight=<span class="number">1.0</span>))))</span><br><span class="line">train_cfg = dict(</span><br><span class="line">    rpn=dict(</span><br><span class="line">        assigner=dict(</span><br><span class="line">            <span class="comment"># RPN网络的正负样本划分</span></span><br><span class="line">            type=<span class="string">'MaxIoUAssigner'</span>,</span><br><span class="line">            <span class="comment"># 正样本的iou阈值</span></span><br><span class="line">            pos_iou_thr=<span class="number">0.7</span>,</span><br><span class="line">            <span class="comment"># 负样本的iou阈值</span></span><br><span class="line">            neg_iou_thr=<span class="number">0.3</span>,</span><br><span class="line">            <span class="comment"># 正样本的iou最小值。如果assign给ground truth的anchors中最大的IOU低于0.3，则忽略所有的anchors，否则保留最大IOU的anchor</span></span><br><span class="line">            min_pos_iou=<span class="number">0.3</span>,</span><br><span class="line">            <span class="comment"># 是否匹配低质量anchor</span></span><br><span class="line">            match_low_quality=<span class="literal">True</span>,</span><br><span class="line">            <span class="comment"># 忽略bbox的阈值，当ground truth中包含需要忽略的bbox时使用，-1表示不忽略</span></span><br><span class="line">            ignore_iof_thr=<span class="number">-1</span>),</span><br><span class="line">        sampler=dict(</span><br><span class="line">            <span class="comment"># 正负样本提取器类型</span></span><br><span class="line">            type=<span class="string">'RandomSampler'</span>,</span><br><span class="line">            <span class="comment"># 需提取的正负样本数量</span></span><br><span class="line">            num=<span class="number">256</span>,</span><br><span class="line">            <span class="comment"># 正样本比例</span></span><br><span class="line">            pos_fraction=<span class="number">0.5</span>,</span><br><span class="line">            <span class="comment"># 最大负样本比例，大于该比例的负样本忽略，-1表示不忽略</span></span><br><span class="line">            neg_pos_ub=<span class="number">-1</span>,</span><br><span class="line">            <span class="comment"># 把ground truth加入proposal作为正样本</span></span><br><span class="line">            add_gt_as_proposals=<span class="literal">False</span>),</span><br><span class="line">        <span class="comment"># 不允许允许在bbox周围外扩一定的像素，0表示允许</span></span><br><span class="line">        allowed_border=<span class="number">-1</span>,</span><br><span class="line">        <span class="comment"># 正样本权重，-1表示不改变原始的权重</span></span><br><span class="line">        pos_weight=<span class="number">-1</span>,</span><br><span class="line">        <span class="comment"># debug模式</span></span><br><span class="line">        debug=<span class="literal">False</span>),</span><br><span class="line">    <span class="comment"># 在训练过程中生成proposals的配置</span></span><br><span class="line">    rpn_proposal=dict(</span><br><span class="line">        <span class="comment"># 在所有的fpn层内做nms</span></span><br><span class="line">        nms_across_levels=<span class="literal">False</span>,</span><br><span class="line">        <span class="comment"># 在NMS之前的box个数</span></span><br><span class="line">        nms_pre=<span class="number">2000</span>,</span><br><span class="line">        <span class="comment"># NMS处理后保留的box个数</span></span><br><span class="line">        nms_post=<span class="number">1000</span>,</span><br><span class="line">        <span class="comment"># NMS处理之后所使用的box个数</span></span><br><span class="line">        max_num=<span class="number">1000</span>,</span><br><span class="line">        <span class="comment"># NMS过程所使用的阈值</span></span><br><span class="line">        nms_thr=<span class="number">0.7</span>,</span><br><span class="line">        <span class="comment"># 允许的最小的box尺寸</span></span><br><span class="line">        min_bbox_size=<span class="number">0</span>),</span><br><span class="line">    rcnn=dict(</span><br><span class="line">        assigner=dict(</span><br><span class="line">            <span class="comment"># RCNN网络正负样本划分</span></span><br><span class="line">            type=<span class="string">'MaxIoUAssigner'</span>,</span><br><span class="line">            <span class="comment"># 正样本的iou阈值</span></span><br><span class="line">            pos_iou_thr=<span class="number">0.5</span>,</span><br><span class="line">            <span class="comment"># 负样本的iou阈值</span></span><br><span class="line">            neg_iou_thr=<span class="number">0.5</span>,</span><br><span class="line">            <span class="comment"># 正样本的iou最小值。如果assign给ground truth的anchors中最大的IOU低于0.3，则忽略所有的anchors，否则保留最大IOU的anchor</span></span><br><span class="line">            min_pos_iou=<span class="number">0.5</span>,</span><br><span class="line">            match_low_quality=<span class="literal">False</span>,</span><br><span class="line">            <span class="comment"># 忽略bbox的阈值，当ground truth中包含需要忽略的bbox时使用，-1表示不忽略</span></span><br><span class="line">            ignore_iof_thr=<span class="number">-1</span>),</span><br><span class="line">        sampler=dict(</span><br><span class="line">            <span class="comment"># 正负样本提取器类型</span></span><br><span class="line">            type=<span class="string">'RandomSampler'</span>,</span><br><span class="line">            <span class="comment"># 需提取的正负样本数量</span></span><br><span class="line">            num=<span class="number">512</span>,</span><br><span class="line">            <span class="comment"># 正样本比例</span></span><br><span class="line">            pos_fraction=<span class="number">0.25</span>,</span><br><span class="line">            <span class="comment"># 最大负样本比例，大于该比例的负样本忽略，-1表示不忽略</span></span><br><span class="line">            neg_pos_ub=<span class="number">-1</span>,</span><br><span class="line">            <span class="comment"># 把ground truth加入proposal作为正样本</span></span><br><span class="line">            add_gt_as_proposals=<span class="literal">True</span>),</span><br><span class="line">        <span class="comment"># 正样本权重，-1表示不改变原始的权重</span></span><br><span class="line">        pos_weight=<span class="number">-1</span>,</span><br><span class="line">        <span class="comment"># debug模式</span></span><br><span class="line">        debug=<span class="literal">False</span>))</span><br><span class="line">test_cfg = dict(</span><br><span class="line">    <span class="comment"># 推断时的RPN参数</span></span><br><span class="line">    rpn=dict(</span><br><span class="line">        nms_across_levels=<span class="literal">False</span>,</span><br><span class="line">        <span class="comment"># 在nms之前保留的的得分最高的proposal数量</span></span><br><span class="line">        nms_pre=<span class="number">1000</span>,</span><br><span class="line">        <span class="comment"># 在nms之后保留的的得分最高的proposal数量</span></span><br><span class="line">        nms_post=<span class="number">1000</span>,</span><br><span class="line">        <span class="comment"># 在后处理完成之后保留的proposal数量</span></span><br><span class="line">        max_num=<span class="number">1000</span>,</span><br><span class="line">        <span class="comment"># nms阈值</span></span><br><span class="line">        nms_thr=<span class="number">0.7</span>,</span><br><span class="line">        <span class="comment"># 最小bbox尺寸</span></span><br><span class="line">        min_bbox_size=<span class="number">0</span>),</span><br><span class="line">    rcnn=dict(</span><br><span class="line">        score_thr=<span class="number">0.05</span>,</span><br><span class="line">        <span class="comment"># soft-nms is also supported for rcnn testing</span></span><br><span class="line">        nms=dict(type=<span class="string">'nms'</span>, iou_threshold=<span class="number">0.5</span>),</span><br><span class="line">        max_per_img=<span class="number">100</span>))</span><br><span class="line"><span class="comment"># 数据集类型</span></span><br><span class="line">dataset_type = <span class="string">'CocoDataset'</span>                </span><br><span class="line"><span class="comment"># 数据集根目录</span></span><br><span class="line">data_root = <span class="string">'/home/shawn/MyDataset/'</span>                   </span><br><span class="line"><span class="comment"># 输入图像初始化，减去均值mean并处以方差std，to_rgb表示将bgr转为rgb</span></span><br><span class="line">img_norm_cfg = dict(</span><br><span class="line">    mean=[<span class="number">123.675</span>, <span class="number">116.28</span>, <span class="number">103.53</span>], std=[<span class="number">58.395</span>, <span class="number">57.12</span>, <span class="number">57.375</span>], to_rgb=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Datasets配置</span></span><br><span class="line"><span class="comment"># 训练的pipeline，数据增强</span></span><br><span class="line">train_pipeline = [</span><br><span class="line">    <span class="comment"># 从文件读取图像</span></span><br><span class="line">    dict(type=<span class="string">'LoadImageFromFile'</span>),</span><br><span class="line">    <span class="comment"># 用于给图像导入对于的标签，并使用bounding box标签数据</span></span><br><span class="line">    dict(type=<span class="string">'LoadAnnotations'</span>, with_bbox=<span class="literal">True</span>),</span><br><span class="line">    <span class="comment"># Resize图片并保持比例</span></span><br><span class="line">    dict(type=<span class="string">'Resize'</span>, img_scale=(<span class="number">1333</span>, <span class="number">800</span>), keep_ratio=<span class="literal">True</span>),</span><br><span class="line">    <span class="comment"># 图像反转以及比率</span></span><br><span class="line">    dict(type=<span class="string">'RandomFlip'</span>, flip_ratio=<span class="number">0.5</span>),</span><br><span class="line">    <span class="comment"># 标准化</span></span><br><span class="line">    dict(</span><br><span class="line">        type=<span class="string">'Normalize'</span>,</span><br><span class="line">        mean=[<span class="number">123.675</span>, <span class="number">116.28</span>, <span class="number">103.53</span>],</span><br><span class="line">        std=[<span class="number">58.395</span>, <span class="number">57.12</span>, <span class="number">57.375</span>],</span><br><span class="line">        to_rgb=<span class="literal">True</span>),</span><br><span class="line">    <span class="comment"># 图像Padding 的配置，填充数目应该可以被整除</span></span><br><span class="line">    dict(type=<span class="string">'Pad'</span>, size_divisor=<span class="number">32</span>),</span><br><span class="line">    dict(type=<span class="string">'DefaultFormatBundle'</span>),</span><br><span class="line">    <span class="comment"># 决定数据中哪些key可以被传入pipeline中</span></span><br><span class="line">    dict(type=<span class="string">'Collect'</span>, keys=[<span class="string">'img'</span>, <span class="string">'gt_bboxes'</span>, <span class="string">'gt_labels'</span>])</span><br><span class="line">]</span><br><span class="line">test_pipeline = [</span><br><span class="line">    dict(type=<span class="string">'LoadImageFromFile'</span>),</span><br><span class="line">    dict(</span><br><span class="line">        type=<span class="string">'MultiScaleFlipAug'</span>,</span><br><span class="line">        img_scale=(<span class="number">1333</span>, <span class="number">800</span>),</span><br><span class="line">        <span class="comment"># 是否在test过程flip images</span></span><br><span class="line">        flip=<span class="literal">False</span>,</span><br><span class="line">        transforms=[</span><br><span class="line">            dict(type=<span class="string">'Resize'</span>, keep_ratio=<span class="literal">True</span>),</span><br><span class="line">            <span class="comment"># 由于flip=False这个RandomFlio将不会被使用。</span></span><br><span class="line">            dict(type=<span class="string">'RandomFlip'</span>),</span><br><span class="line">            dict(</span><br><span class="line">                type=<span class="string">'Normalize'</span>,</span><br><span class="line">                mean=[<span class="number">123.675</span>, <span class="number">116.28</span>, <span class="number">103.53</span>],</span><br><span class="line">                std=[<span class="number">58.395</span>, <span class="number">57.12</span>, <span class="number">57.375</span>],</span><br><span class="line">                to_rgb=<span class="literal">True</span>),</span><br><span class="line">            dict(type=<span class="string">'Pad'</span>, size_divisor=<span class="number">32</span>),</span><br><span class="line">            <span class="comment"># 将图片转化为tensor</span></span><br><span class="line">            dict(type=<span class="string">'ImageToTensor'</span>, keys=[<span class="string">'img'</span>]),</span><br><span class="line">            <span class="comment"># 收集在test过程中必要的key</span></span><br><span class="line">            dict(type=<span class="string">'Collect'</span>, keys=[<span class="string">'img'</span>])</span><br><span class="line">        ])</span><br><span class="line">]</span><br><span class="line">data = dict(</span><br><span class="line">    <span class="comment"># 每个gpu计算的图像数量</span></span><br><span class="line">    samples_per_gpu=<span class="number">2</span>,</span><br><span class="line">    <span class="comment"># 每个gpu分配的线程数</span></span><br><span class="line">    workers_per_gpu=<span class="number">2</span>,</span><br><span class="line">    train=dict(</span><br><span class="line">        type=<span class="string">'CocoDataset'</span>,</span><br><span class="line">        ann_file= data_root + <span class="string">'annotations/train.json'</span>,</span><br><span class="line">        img_prefix= data_root + <span class="string">'images/train/'</span>,</span><br><span class="line">        <span class="comment"># 类型，如果就一个类型需要加逗号</span></span><br><span class="line">        classes=(<span class="string">'polyp'</span>, ),</span><br><span class="line">        pipeline=train_pipeline),</span><br><span class="line">    val=dict(</span><br><span class="line">        type=<span class="string">'CocoDataset'</span>,</span><br><span class="line">        ann_file=data_root + <span class="string">'annotations/test.json'</span>,</span><br><span class="line">        img_prefix=data_root + <span class="string">'images/test/'</span>,</span><br><span class="line">        classes=(<span class="string">'polyp'</span>, ),</span><br><span class="line">        pipeline=test_pipeline),</span><br><span class="line">    test=dict(</span><br><span class="line">        type=<span class="string">'CocoDataset'</span>,</span><br><span class="line">        ann_file=data_root + <span class="string">'annotations/test.json'</span>,</span><br><span class="line">        img_prefix=data_root + <span class="string">'images/test/'</span>,</span><br><span class="line">        classes=(<span class="string">'polyp'</span>, ),</span><br><span class="line">        pipeline=test_pipeline))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">evaluation = dict(interval=<span class="number">1</span>, metric=<span class="string">'bbox'</span>)</span><br><span class="line">optimizer = dict(type=<span class="string">'SGD'</span>, lr=<span class="number">0.02</span>, momentum=<span class="number">0.9</span>, weight_decay=<span class="number">0.0001</span>)</span><br><span class="line">optimizer_config = dict(grad_clip=<span class="literal">None</span>)</span><br><span class="line">lr_config = dict(</span><br><span class="line">    <span class="comment"># 优化策略</span></span><br><span class="line">    policy=<span class="string">'step'</span>,</span><br><span class="line">    <span class="comment"># 初始的学习率增加的策略，linear为线性增加，# warmup的策略, 还支持 `exp` 和 `constant`.</span></span><br><span class="line">    warmup=<span class="string">'linear'</span>,</span><br><span class="line">    <span class="comment"># 在初始的500次迭代中学习率逐渐增加</span></span><br><span class="line">    warmup_iters=<span class="number">500</span>,</span><br><span class="line">    <span class="comment"># 起始的学习率</span></span><br><span class="line">    warmup_ratio=<span class="number">0.001</span>,</span><br><span class="line">    <span class="comment"># 在第16和22个epoch时降低学习率</span></span><br><span class="line">    step=[<span class="number">16</span>,<span class="number">22</span>])</span><br><span class="line"><span class="comment"># 最大epoch数</span></span><br><span class="line">total_epochs = <span class="number">24</span></span><br><span class="line"><span class="comment"># 每隔几个epoch保存一下checkpoint</span></span><br><span class="line">checkpoint_config = dict(interval=<span class="number">12</span>)</span><br><span class="line"><span class="comment">#log_config = dict(interval=5, hooks=[dict(type='TextLoggerHook')])</span></span><br><span class="line">log_config = dict(</span><br><span class="line">    <span class="comment"># 每隔多少个epoch输出一个log文件</span></span><br><span class="line">    interval=<span class="number">6</span>,</span><br><span class="line">    hooks=[</span><br><span class="line">        dict(type=<span class="string">'TextLoggerHook'</span>),</span><br><span class="line">        <span class="comment"># Tensorboard logger</span></span><br><span class="line">        dict(type=<span class="string">'TensorboardLoggerHook'</span>)</span><br><span class="line">    ])</span><br><span class="line"><span class="comment"># 设置分布式训练的参数，也可以设置端口</span></span><br><span class="line">dist_params = dict(backend=<span class="string">'nccl'</span>)</span><br><span class="line"><span class="comment"># 日志等级</span></span><br><span class="line">log_level = <span class="string">'INFO'</span></span><br><span class="line"><span class="comment"># 加载模型的路径，None表示从预训练模型加载</span></span><br><span class="line">load_from = <span class="literal">None</span></span><br><span class="line"><span class="comment"># 恢复训练模型的路径</span></span><br><span class="line">resume_from = <span class="literal">None</span></span><br><span class="line">workflow = [(<span class="string">'train'</span>, <span class="number">1</span>)]</span><br><span class="line"><span class="comment"># 保存模型的文件夹路径（checkpoints和log文件都会保存在其中）。</span></span><br><span class="line">work_dir = <span class="string">'work_dir/faster_rcnn_r50_2x/'</span></span><br></pre></td></tr></table></figure>
<h3 id="4、cascade-rcnn-r50-fpn-2x-py">4、cascade_rcnn_r50_fpn_2x.py</h3>
<p>cascade-RCNN是cvpr2018的文章，相比于faster-RCNN的改进主要在于其RCNN有三个stage，这三个stage逐级refine检测的结果，使得结果达到更高的精度。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model = dict(</span><br><span class="line">    type=<span class="string">'CascadeRCNN'</span>,</span><br><span class="line">    pretrained=<span class="string">'torchvision://resnet50'</span>,</span><br><span class="line">    backbone=dict(</span><br><span class="line">        type=<span class="string">'ResNet'</span>,</span><br><span class="line">        depth=<span class="number">50</span>,</span><br><span class="line">        num_stages=<span class="number">4</span>,</span><br><span class="line">        out_indices=(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>),</span><br><span class="line">        frozen_stages=<span class="number">1</span>,</span><br><span class="line">        norm_cfg=dict(type=<span class="string">'BN'</span>, requires_grad=<span class="literal">True</span>),</span><br><span class="line">        norm_eval=<span class="literal">True</span>,</span><br><span class="line">        style=<span class="string">'pytorch'</span>),</span><br><span class="line">    neck=dict(</span><br><span class="line">        type=<span class="string">'FPN'</span>,</span><br><span class="line">        in_channels=[<span class="number">256</span>, <span class="number">512</span>, <span class="number">1024</span>, <span class="number">2048</span>],</span><br><span class="line">        out_channels=<span class="number">256</span>,</span><br><span class="line">        num_outs=<span class="number">5</span>),</span><br><span class="line">    rpn_head=dict(</span><br><span class="line">        type=<span class="string">'RPNHead'</span>,</span><br><span class="line">        in_channels=<span class="number">256</span>,</span><br><span class="line">        feat_channels=<span class="number">256</span>,</span><br><span class="line">        anchor_generator=dict(</span><br><span class="line">            type=<span class="string">'AnchorGenerator'</span>,</span><br><span class="line">            scales=[<span class="number">8</span>],</span><br><span class="line">            ratios=[<span class="number">0.5</span>, <span class="number">1.0</span>, <span class="number">2.0</span>],</span><br><span class="line">            strides=[<span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>]),</span><br><span class="line">        bbox_coder=dict(</span><br><span class="line">            type=<span class="string">'DeltaXYWHBBoxCoder'</span>,</span><br><span class="line">            target_means=[<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>],</span><br><span class="line">            target_stds=[<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>]),</span><br><span class="line">        loss_cls=dict(</span><br><span class="line">            type=<span class="string">'CrossEntropyLoss'</span>, use_sigmoid=<span class="literal">True</span>, loss_weight=<span class="number">1.0</span>),</span><br><span class="line">        loss_bbox=dict(</span><br><span class="line">            type=<span class="string">'SmoothL1Loss'</span>, beta=<span class="number">0.1111111111111111</span>, loss_weight=<span class="number">1.0</span>)),</span><br><span class="line">    roi_head=dict(</span><br><span class="line">        type=<span class="string">'CascadeRoIHead'</span>,</span><br><span class="line">        <span class="comment"># RCNN网络的stage数量，在faster-RCNN中为1</span></span><br><span class="line">        num_stages=<span class="number">3</span>,</span><br><span class="line">        <span class="comment"># 3个RCNN的stage的loss权重</span></span><br><span class="line">        stage_loss_weights=[<span class="number">1</span>, <span class="number">0.5</span>, <span class="number">0.25</span>],</span><br><span class="line">        bbox_roi_extractor=dict(</span><br><span class="line">            type=<span class="string">'SingleRoIExtractor'</span>,</span><br><span class="line">            roi_layer=dict(type=<span class="string">'RoIAlign'</span>, output_size=<span class="number">7</span>, sampling_ratio=<span class="number">0</span>),</span><br><span class="line">            out_channels=<span class="number">256</span>,</span><br><span class="line">            featmap_strides=[<span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>]),</span><br><span class="line">        bbox_head=[</span><br><span class="line">            dict(</span><br><span class="line">                type=<span class="string">'Shared2FCBBoxHead'</span>,</span><br><span class="line">                in_channels=<span class="number">256</span>,</span><br><span class="line">                fc_out_channels=<span class="number">1024</span>,</span><br><span class="line">                roi_feat_size=<span class="number">7</span>,</span><br><span class="line">                num_classes=<span class="number">1</span>,</span><br><span class="line">                bbox_coder=dict(</span><br><span class="line">                    type=<span class="string">'DeltaXYWHBBoxCoder'</span>,</span><br><span class="line">                    target_means=[<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>],</span><br><span class="line">                    target_stds=[<span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.2</span>]),</span><br><span class="line">                reg_class_agnostic=<span class="literal">True</span>,</span><br><span class="line">                loss_cls=dict(</span><br><span class="line">                    type=<span class="string">'CrossEntropyLoss'</span>,</span><br><span class="line">                    use_sigmoid=<span class="literal">False</span>,</span><br><span class="line">                    loss_weight=<span class="number">1.0</span>),</span><br><span class="line">                loss_bbox=dict(type=<span class="string">'SmoothL1Loss'</span>, beta=<span class="number">1.0</span>,</span><br><span class="line">                               loss_weight=<span class="number">1.0</span>)),</span><br><span class="line">            dict(</span><br><span class="line">                type=<span class="string">'Shared2FCBBoxHead'</span>,</span><br><span class="line">                in_channels=<span class="number">256</span>,</span><br><span class="line">                fc_out_channels=<span class="number">1024</span>,</span><br><span class="line">                roi_feat_size=<span class="number">7</span>,</span><br><span class="line">                num_classes=<span class="number">1</span>,</span><br><span class="line">                bbox_coder=dict(</span><br><span class="line">                    type=<span class="string">'DeltaXYWHBBoxCoder'</span>,</span><br><span class="line">                    target_means=[<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>],</span><br><span class="line">                    target_stds=[<span class="number">0.05</span>, <span class="number">0.05</span>, <span class="number">0.1</span>, <span class="number">0.1</span>]),</span><br><span class="line">                reg_class_agnostic=<span class="literal">True</span>,</span><br><span class="line">                loss_cls=dict(</span><br><span class="line">                    type=<span class="string">'CrossEntropyLoss'</span>,</span><br><span class="line">                    use_sigmoid=<span class="literal">False</span>,</span><br><span class="line">                    loss_weight=<span class="number">1.0</span>),</span><br><span class="line">                loss_bbox=dict(type=<span class="string">'SmoothL1Loss'</span>, beta=<span class="number">1.0</span>,</span><br><span class="line">                               loss_weight=<span class="number">1.0</span>)),</span><br><span class="line">            dict(</span><br><span class="line">                type=<span class="string">'Shared2FCBBoxHead'</span>,</span><br><span class="line">                in_channels=<span class="number">256</span>,</span><br><span class="line">                fc_out_channels=<span class="number">1024</span>,</span><br><span class="line">                roi_feat_size=<span class="number">7</span>,</span><br><span class="line">                num_classes=<span class="number">1</span>,</span><br><span class="line">                bbox_coder=dict(</span><br><span class="line">                    type=<span class="string">'DeltaXYWHBBoxCoder'</span>,</span><br><span class="line">                    target_means=[<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>],</span><br><span class="line">                    target_stds=[<span class="number">0.033</span>, <span class="number">0.033</span>, <span class="number">0.067</span>, <span class="number">0.067</span>]),</span><br><span class="line">                reg_class_agnostic=<span class="literal">True</span>,</span><br><span class="line">                loss_cls=dict(</span><br><span class="line">                    type=<span class="string">'CrossEntropyLoss'</span>,</span><br><span class="line">                    use_sigmoid=<span class="literal">False</span>,</span><br><span class="line">                    loss_weight=<span class="number">1.0</span>),</span><br><span class="line">                loss_bbox=dict(type=<span class="string">'SmoothL1Loss'</span>, beta=<span class="number">1.0</span>, loss_weight=<span class="number">1.0</span>))</span><br><span class="line">        ]))</span><br><span class="line">train_cfg = dict(</span><br><span class="line">    rpn=dict(</span><br><span class="line">        assigner=dict(</span><br><span class="line">            type=<span class="string">'MaxIoUAssigner'</span>,</span><br><span class="line">            pos_iou_thr=<span class="number">0.7</span>,</span><br><span class="line">            neg_iou_thr=<span class="number">0.3</span>,</span><br><span class="line">            min_pos_iou=<span class="number">0.3</span>,</span><br><span class="line">            match_low_quality=<span class="literal">True</span>,</span><br><span class="line">            ignore_iof_thr=<span class="number">-1</span>),</span><br><span class="line">        sampler=dict(</span><br><span class="line">            type=<span class="string">'RandomSampler'</span>,</span><br><span class="line">            num=<span class="number">256</span>,</span><br><span class="line">            pos_fraction=<span class="number">0.5</span>,</span><br><span class="line">            neg_pos_ub=<span class="number">-1</span>,</span><br><span class="line">            add_gt_as_proposals=<span class="literal">False</span>),</span><br><span class="line">        allowed_border=<span class="number">0</span>,</span><br><span class="line">        pos_weight=<span class="number">-1</span>,</span><br><span class="line">        debug=<span class="literal">False</span>),</span><br><span class="line">    rpn_proposal=dict(</span><br><span class="line">        nms_across_levels=<span class="literal">False</span>,</span><br><span class="line">        nms_pre=<span class="number">2000</span>,</span><br><span class="line">        nms_post=<span class="number">2000</span>,</span><br><span class="line">        max_num=<span class="number">2000</span>,</span><br><span class="line">        nms_thr=<span class="number">0.7</span>,</span><br><span class="line">        min_bbox_size=<span class="number">0</span>),</span><br><span class="line">    <span class="comment"># 注意，这里有3个RCNN的模块,对应开头的那个RCNN的stage数量</span></span><br><span class="line">    rcnn=[</span><br><span class="line">        dict(</span><br><span class="line">            assigner=dict(</span><br><span class="line">                type=<span class="string">'MaxIoUAssigner'</span>,</span><br><span class="line">                pos_iou_thr=<span class="number">0.5</span>,</span><br><span class="line">                neg_iou_thr=<span class="number">0.5</span>,</span><br><span class="line">                min_pos_iou=<span class="number">0.5</span>,</span><br><span class="line">                match_low_quality=<span class="literal">False</span>,</span><br><span class="line">                ignore_iof_thr=<span class="number">-1</span>),</span><br><span class="line">            sampler=dict(</span><br><span class="line">                type=<span class="string">'RandomSampler'</span>,</span><br><span class="line">                num=<span class="number">512</span>,</span><br><span class="line">                pos_fraction=<span class="number">0.25</span>,</span><br><span class="line">                neg_pos_ub=<span class="number">-1</span>,</span><br><span class="line">                add_gt_as_proposals=<span class="literal">True</span>),</span><br><span class="line">            pos_weight=<span class="number">-1</span>,</span><br><span class="line">            debug=<span class="literal">False</span>),</span><br><span class="line">        dict(</span><br><span class="line">            assigner=dict(</span><br><span class="line">                type=<span class="string">'MaxIoUAssigner'</span>,</span><br><span class="line">                pos_iou_thr=<span class="number">0.6</span>,</span><br><span class="line">                neg_iou_thr=<span class="number">0.6</span>,</span><br><span class="line">                min_pos_iou=<span class="number">0.6</span>,</span><br><span class="line">                match_low_quality=<span class="literal">False</span>,</span><br><span class="line">                ignore_iof_thr=<span class="number">-1</span>),</span><br><span class="line">            sampler=dict(</span><br><span class="line">                type=<span class="string">'RandomSampler'</span>,</span><br><span class="line">                num=<span class="number">512</span>,</span><br><span class="line">                pos_fraction=<span class="number">0.25</span>,</span><br><span class="line">                neg_pos_ub=<span class="number">-1</span>,</span><br><span class="line">                add_gt_as_proposals=<span class="literal">True</span>),</span><br><span class="line">            pos_weight=<span class="number">-1</span>,</span><br><span class="line">            debug=<span class="literal">False</span>),</span><br><span class="line">        dict(</span><br><span class="line">            assigner=dict(</span><br><span class="line">                type=<span class="string">'MaxIoUAssigner'</span>,</span><br><span class="line">                pos_iou_thr=<span class="number">0.7</span>,</span><br><span class="line">                neg_iou_thr=<span class="number">0.7</span>,</span><br><span class="line">                min_pos_iou=<span class="number">0.7</span>,</span><br><span class="line">                match_low_quality=<span class="literal">False</span>,</span><br><span class="line">                ignore_iof_thr=<span class="number">-1</span>),</span><br><span class="line">            sampler=dict(</span><br><span class="line">                type=<span class="string">'RandomSampler'</span>,</span><br><span class="line">                num=<span class="number">512</span>,</span><br><span class="line">                pos_fraction=<span class="number">0.25</span>,</span><br><span class="line">                neg_pos_ub=<span class="number">-1</span>,</span><br><span class="line">                add_gt_as_proposals=<span class="literal">True</span>),</span><br><span class="line">            pos_weight=<span class="number">-1</span>,</span><br><span class="line">            debug=<span class="literal">False</span>)</span><br><span class="line">    ])</span><br><span class="line">test_cfg = dict(</span><br><span class="line">    rpn=dict(</span><br><span class="line">        nms_across_levels=<span class="literal">False</span>,</span><br><span class="line">        nms_pre=<span class="number">1000</span>,</span><br><span class="line">        nms_post=<span class="number">1000</span>,</span><br><span class="line">        max_num=<span class="number">1000</span>,</span><br><span class="line">        nms_thr=<span class="number">0.7</span>,</span><br><span class="line">        min_bbox_size=<span class="number">0</span>),</span><br><span class="line">    rcnn=dict(</span><br><span class="line">        score_thr=<span class="number">0.05</span>,</span><br><span class="line">        nms=dict(type=<span class="string">'nms'</span>, iou_threshold=<span class="number">0.5</span>),</span><br><span class="line">        max_per_img=<span class="number">100</span>))</span><br><span class="line">img_norm_cfg = dict(</span><br><span class="line">    mean=[<span class="number">123.675</span>, <span class="number">116.28</span>, <span class="number">103.53</span>], std=[<span class="number">58.395</span>, <span class="number">57.12</span>, <span class="number">57.375</span>], to_rgb=<span class="literal">True</span>)</span><br><span class="line">dataset_type = <span class="string">'CocoDataset'</span>                </span><br><span class="line"><span class="comment"># 数据集根目录</span></span><br><span class="line">data_root = <span class="string">'/home/shawn/MyDataset/'</span>    </span><br><span class="line"></span><br><span class="line">train_pipeline = [</span><br><span class="line">    dict(type=<span class="string">'LoadImageFromFile'</span>),</span><br><span class="line">    dict(type=<span class="string">'LoadAnnotations'</span>, with_bbox=<span class="literal">True</span>),</span><br><span class="line">    dict(type=<span class="string">'Resize'</span>, img_scale=(<span class="number">1333</span>, <span class="number">800</span>), keep_ratio=<span class="literal">True</span>),</span><br><span class="line">    dict(type=<span class="string">'RandomFlip'</span>, flip_ratio=<span class="number">0.5</span>),</span><br><span class="line">    dict(</span><br><span class="line">        type=<span class="string">'Normalize'</span>,</span><br><span class="line">        mean=[<span class="number">123.675</span>, <span class="number">116.28</span>, <span class="number">103.53</span>],</span><br><span class="line">        std=[<span class="number">58.395</span>, <span class="number">57.12</span>, <span class="number">57.375</span>],</span><br><span class="line">        to_rgb=<span class="literal">True</span>),</span><br><span class="line">    dict(type=<span class="string">'Pad'</span>, size_divisor=<span class="number">32</span>),</span><br><span class="line">    dict(type=<span class="string">'DefaultFormatBundle'</span>),</span><br><span class="line">    dict(type=<span class="string">'Collect'</span>, keys=[<span class="string">'img'</span>, <span class="string">'gt_bboxes'</span>, <span class="string">'gt_labels'</span>])</span><br><span class="line">]</span><br><span class="line">test_pipeline = [</span><br><span class="line">    dict(type=<span class="string">'LoadImageFromFile'</span>),</span><br><span class="line">    dict(</span><br><span class="line">        type=<span class="string">'MultiScaleFlipAug'</span>,</span><br><span class="line">        img_scale=(<span class="number">1333</span>, <span class="number">800</span>),</span><br><span class="line">        flip=<span class="literal">False</span>,</span><br><span class="line">        transforms=[</span><br><span class="line">            dict(type=<span class="string">'Resize'</span>, keep_ratio=<span class="literal">True</span>),</span><br><span class="line">            dict(type=<span class="string">'RandomFlip'</span>),</span><br><span class="line">            dict(</span><br><span class="line">                type=<span class="string">'Normalize'</span>,</span><br><span class="line">                mean=[<span class="number">123.675</span>, <span class="number">116.28</span>, <span class="number">103.53</span>],</span><br><span class="line">                std=[<span class="number">58.395</span>, <span class="number">57.12</span>, <span class="number">57.375</span>],</span><br><span class="line">                to_rgb=<span class="literal">True</span>),</span><br><span class="line">            dict(type=<span class="string">'Pad'</span>, size_divisor=<span class="number">32</span>),</span><br><span class="line">            dict(type=<span class="string">'ImageToTensor'</span>, keys=[<span class="string">'img'</span>]),</span><br><span class="line">            dict(type=<span class="string">'Collect'</span>, keys=[<span class="string">'img'</span>])</span><br><span class="line">        ])</span><br><span class="line">]</span><br><span class="line">data = dict(</span><br><span class="line">    samples_per_gpu=<span class="number">2</span>,</span><br><span class="line">    workers_per_gpu=<span class="number">2</span>,</span><br><span class="line">    train=dict(</span><br><span class="line">        type=<span class="string">'CocoDataset'</span>,</span><br><span class="line">        ann_file=data_root + <span class="string">'annotations/train.json'</span>,</span><br><span class="line">        img_prefix=data_root + <span class="string">'images/train/'</span>,</span><br><span class="line">        classes=(<span class="string">'polyp'</span>, ),</span><br><span class="line">        pipeline=train_pipeline),</span><br><span class="line">    val=dict(</span><br><span class="line">        type=<span class="string">'CocoDataset'</span>,</span><br><span class="line">        ann_file=data_root + <span class="string">'annotations/train.json'</span>,</span><br><span class="line">        img_prefix=data_root + <span class="string">'images/train/'</span>,</span><br><span class="line">        classes=(<span class="string">'polyp'</span>, ),</span><br><span class="line">        pipeline=test_pipeline),</span><br><span class="line">    test=dict(</span><br><span class="line">        type=<span class="string">'CocoDataset'</span>,</span><br><span class="line">        ann_file=data_root + <span class="string">'annotations/train.json'</span>,</span><br><span class="line">        img_prefix=data_root + <span class="string">'images/train/'</span>,</span><br><span class="line">        classes=(<span class="string">'polyp'</span>, ),</span><br><span class="line">        pipeline=test_pipeline))</span><br><span class="line">evaluation = dict(interval=<span class="number">1</span>, metric=<span class="string">'bbox'</span>)</span><br><span class="line">optimizer = dict(type=<span class="string">'SGD'</span>, lr=<span class="number">0.02</span>, momentum=<span class="number">0.9</span>, weight_decay=<span class="number">0.0001</span>)</span><br><span class="line">optimizer_config = dict(grad_clip=<span class="literal">None</span>)</span><br><span class="line">lr_config = dict(</span><br><span class="line">    policy=<span class="string">'step'</span>,</span><br><span class="line">    warmup=<span class="string">'linear'</span>,</span><br><span class="line">    warmup_iters=<span class="number">500</span>,</span><br><span class="line">    warmup_ratio=<span class="number">0.001</span>,</span><br><span class="line">    step=[<span class="number">16</span>, <span class="number">22</span>])</span><br><span class="line">total_epochs = <span class="number">24</span></span><br><span class="line">checkpoint_config = dict(interval=<span class="number">12</span>)</span><br><span class="line">log_config = dict(</span><br><span class="line">    interval=<span class="number">5</span>,</span><br><span class="line">    hooks=[</span><br><span class="line">        dict(type=<span class="string">'TextLoggerHook'</span>),</span><br><span class="line">        dict(type=<span class="string">'TensorboardLoggerHook'</span>)</span><br><span class="line">    ])</span><br><span class="line">dist_params = dict(backend=<span class="string">'nccl'</span>)</span><br><span class="line">log_level = <span class="string">'INFO'</span></span><br><span class="line">load_from = <span class="literal">None</span></span><br><span class="line">resume_from = <span class="literal">None</span></span><br><span class="line">workflow = [(<span class="string">'train'</span>, <span class="number">1</span>)]</span><br><span class="line">work_dir = <span class="string">'work_dir/cascade_rcnn_r50_fpn_2x.py'</span></span><br></pre></td></tr></table></figure>
<h3 id="5、服务器运行以及可视化">5、服务器运行以及可视化</h3>
<p><strong>参数修改</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#训练自己的COCO数据集，需要自己修改的地方有num_classes、data_root、classes（全部都要）</span></span><br><span class="line"><span class="comment">#若显存较小可修改img_scale=(1333, 800)为img_scale=(800, 500)</span></span><br><span class="line"><span class="comment">#如果要设置不同epoch,修改lr_config下的step以及total_epochs</span></span><br><span class="line"><span class="comment">#特征提取层model下的pretrained以及depth</span></span><br></pre></td></tr></table></figure>
<p><strong>服务器运行</strong>（举例）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#服务器运行命令，--gpu-ids哪块GPU运行，运行前nvidia-smi查看哪块gpu空闲</span></span><br><span class="line">python tools/train.py configs/cascade_rcnn_r50_fpn_2x.py --gpu-ids <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#后台运行cascade_r101.txt是日志输出文件</span></span><br><span class="line">nohup python tools/train.py configs/cascade_rcnn_r101_fpn_2x.py --gpu-ids <span class="number">1</span> &gt; cascade_r101.txt <span class="number">2</span>&gt;&amp;<span class="number">1</span> &amp;</span><br></pre></td></tr></table></figure>
<p><strong>tensorboard可视化</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#服务器在根目录运行</span></span><br><span class="line">tensorboard --logdir=work_dir</span><br><span class="line"><span class="comment">#windows cmd运行</span></span><br><span class="line">ssh -L <span class="number">16006</span>:<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6006</span> &#123;xx@ip地址&#125;</span><br><span class="line"><span class="comment">#本地运行</span></span><br><span class="line">http://localhost:<span class="number">16006</span>/</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>PyTorch</tag>
      </tags>
  </entry>
  <entry>
    <title>Pytorch神经网络简单入门</title>
    <url>/posts/561aebde.html</url>
    <content><![CDATA[<h2 id="一、框架说明">一、框架说明</h2>
<p>Pytorch具体的APi操作详见<a href="https://pytorch.org/docs/stable/torch.html" target="_blank" rel="noopener">Pytorch官方Api文档</a>，torchvision具体Api操作详见<a href="https://pytorch.org/vision/stable/index.html" target="_blank" rel="noopener">torchvision官方Api</a>，下面介绍一下常用的包</p>
<ul>
<li><code>torch</code>：张量的常见运算。如创建、索引、连接、转置、加减乘除、切片等</li>
<li><code>torch.nn</code>: 包含搭建神经网络层的模块（Modules）和一系列loss函数。如全连接、卷积、BN批处理、dropout、CrossEntryLoss、MSELoss等</li>
<li><code>torch.nn.functional</code>:常用的激活函数relu、leaky_relu、sigmoid等</li>
<li><code>torch.autograd</code>:提供Tensor所有操作的自动求导方法</li>
<li><code>torch.cuda</code>：提供对CUDA张量类型的支持，可以让模型使用gpu运行</li>
<li><code>torch.optim</code>:各种参数优化方法，例如SGD、AdaGrad、Adam、RMSProp等</li>
<li><code>torch.utils.data</code>:用于加载数据</li>
<li><code>torch.nn.init</code>:可以用它更改nn.Module的默认参数初始化方式</li>
<li><code>torchvision.datasets</code>:常用数据集。MNIST、COCO、CIFAR10、Imagenet等</li>
<li><code>torchvision.modules</code>:常用模型。AlexNet、VGG、ResNet、DenseNet等</li>
<li><code>torchvision.transforms</code>:图片相关处理。裁剪、尺寸缩放、归一化等</li>
<li><code>torchvision.utils</code>:将给定的Tensor保存成image文件</li>
</ul>
<a id="more"></a>
<h2 id="二、GPU相关">二、GPU相关</h2>
<p>运行需要成功安装CUDA和CUDNN，同时要保证显卡驱动以及CUDA、CUDNN版本相匹配。对于CUDA的安装网上有很多教程</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#True表示可以进行gpu加速</span></span><br><span class="line">torch.cuda.is_available()</span><br><span class="line"><span class="comment">#打印gpu数量</span></span><br><span class="line">torch.cuda.device_count()</span><br><span class="line"><span class="comment">#显示gpu名字，序号从0开始，例如我的是GeForce GTX 1050</span></span><br><span class="line">torch.cuda.get_device_name(<span class="number">0</span>) </span><br><span class="line"><span class="comment">#输出当前GPU序号，从0开始</span></span><br><span class="line">torch.cuda.current_device()</span><br></pre></td></tr></table></figure>
<p>在程序中可以如以下操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#如果机器不存在gpu就使用cpu，存在就使用0号gpu，序号可以按自己需求修改</span></span><br><span class="line">device = torch.device(<span class="string">'cuda:0'</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">'cpu'</span>)</span><br><span class="line"><span class="comment">#还需要将模型（神经网络）与数据转移到相应的设备上，model代表模型，data代表张量</span></span><br><span class="line">model = model.to(device)</span><br><span class="line"><span class="comment">#model = model.cuda()</span></span><br><span class="line">data = data.to(device)</span><br><span class="line"><span class="comment">#data = data.cuda()</span></span><br></pre></td></tr></table></figure>
<h2 id="三、前置知识学习">三、前置知识学习</h2>
<p>Pytorch的一些入门常用操作，以及Numpy的入门常用操作。Numpy可以看<a href="https://www.runoob.com/numpy/numpy-tutorial.html" target="_blank" rel="noopener">菜鸟教程</a></p>
<blockquote>
<p>深度学习入门可以浏览：</p>
<p><a href="https://apachecn.gitee.io/ailearning/#/README" target="_blank" rel="noopener">https://apachecn.gitee.io/ailearning/#/README</a></p>
<p><a href="https://tangshusen.me/Dive-into-DL-PyTorch/#/" target="_blank" rel="noopener">https://tangshusen.me/Dive-into-DL-PyTorch/#/</a></p>
</blockquote>
<p>对于网络模型的优化，可以加入<code>Dropout和BN批量归一化</code></p>
<h2 id="四、搭建第一个神经网络-回归">四、搭建第一个神经网络(回归)</h2>
<p><strong>第一步生成数据</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#导包</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># reproducible</span></span><br><span class="line">torch.manual_seed(<span class="number">1</span>)   </span><br><span class="line"><span class="comment">#这里linspace函数是从-1到1均分成100份，unsqueeze表示在第1轴增加一个维度，原本是一维，现在变成(100,1)维度,即100个数据1个特征。同理squeeze表示减少一个维度</span></span><br><span class="line">x = torch.unsqueeze(torch.linspace(<span class="number">-1</span>,<span class="number">1</span>,<span class="number">100</span>),dim=<span class="number">1</span>)</span><br><span class="line"><span class="comment">#增加随机噪声</span></span><br><span class="line">y = pow(x,<span class="number">2</span>) + torch.randn(x.size())*<span class="number">0.1</span></span><br><span class="line">plt.scatter(x,y)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/image-20210507205531917.png" alt></p>
<p><strong>第二步，建立神经网络，这里定义了一个隐藏层，并使用ReLu激活函数。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 继承 torch 的 Module</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span><span class="params">(torch.nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,n_feature,n_hidden,n_outpit)</span>:</span></span><br><span class="line">        <span class="comment"># 继承 __init__ 功能，必须要有，定义网络的时候进行初始化</span></span><br><span class="line">        super(Net,self).__init__()</span><br><span class="line">        self.hidden=torch.nn.Linear(n_feature,n_hidden)</span><br><span class="line">        self.output=torch.nn.Linear(n_hidden,n_outpit)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这同时也是 Module 中的 forward 功能，会自动进行前向计算</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self,x)</span>:</span></span><br><span class="line">        x=F.relu(self.hidden(x))</span><br><span class="line">        x=self.output(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"><span class="comment"># to(device)选择在'cpu'或'cuda'上运行</span></span><br><span class="line">net = Net(<span class="number">1</span>,<span class="number">10</span>,<span class="number">1</span>)</span><br><span class="line"><span class="comment">#net = Net(1,10,1).to(device)</span></span><br><span class="line"><span class="comment">#打印一下网络信息</span></span><br><span class="line">print(net)</span><br></pre></td></tr></table></figure>
<p><strong>第三步选择损失函数和优化器</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#回归常用MSE，而分类常用Cross Entropy</span></span><br><span class="line">loss = torch.nn.MSELoss()</span><br><span class="line"><span class="comment">#pytorch根据当前当属更新参数值，学习率在这里取0.5</span></span><br><span class="line">optimizer = torch.optim.SGD(net.parameters,lr=<span class="number">0.5</span>)</span><br><span class="line"><span class="comment">#查看参数值</span></span><br><span class="line"><span class="comment">#list(net.parameters())[0]</span></span><br><span class="line"><span class="comment">#list(net.parameters())[0]</span></span><br></pre></td></tr></table></figure>
<p><strong>第四步模型的训练及其结果</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">epochs = <span class="number">100</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(epochs):</span><br><span class="line">    <span class="comment">#训练给模型的数据，net(x)即net.forward(x)</span></span><br><span class="line">    prediction = net(x)</span><br><span class="line">    <span class="comment">#计算损失函数</span></span><br><span class="line">    loss = loss_fn(prediction,y)</span><br><span class="line">    <span class="comment">#优化器梯度清理，方便下一次梯度下降</span></span><br><span class="line">    optimizer.zero_grad()</span><br><span class="line">    <span class="comment">#反向传播求导</span></span><br><span class="line">    loss.backward()</span><br><span class="line">    <span class="comment">#优化器更新神经网络参数加到 net 的 parameters 上</span></span><br><span class="line">    optimizer.step()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> i%<span class="number">10</span>==<span class="number">0</span>:</span><br><span class="line">        plt.cla()</span><br><span class="line">        plt.scatter(x.data.numpy(),y.data.numpy())</span><br><span class="line">        plt.plot(x.data.numpy(),prediction.data.numpy())</span><br><span class="line">        plt.text(<span class="number">0.5</span>, <span class="number">0</span>, <span class="string">'Loss=%.4f'</span> % loss, fontdict=&#123;<span class="string">'size'</span>: <span class="number">16</span>, <span class="string">'color'</span>:  <span class="string">'red'</span>&#125;)</span><br><span class="line">        plt.pause(<span class="number">0.1</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/image-20210507223610151.png" alt></p>
<p><strong>第五步模型的保存和加载</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#保存整个模型</span></span><br><span class="line">torch.save(net,<span class="string">"mynet.pkl"</span>)</span><br><span class="line">net=torch.load(<span class="string">"mynet.pkl"</span>)</span><br><span class="line"><span class="comment">#保存模型参数，占用内存小，速度快</span></span><br><span class="line">torch.save(net.state_dict(),<span class="string">"mynet.pkl"</span>)</span><br><span class="line">net.load_state_dict(<span class="string">"mynet.pkl"</span>)</span><br></pre></td></tr></table></figure>
<h2 id="五、CNN卷积神经网络实现MNIST数据集">五、CNN卷积神经网络实现MNIST数据集</h2>
<blockquote>
<p>手写数字集识别的可视化网站：</p>
<p><a href="https://www.cs.ryerson.ca/~aharley/vis/conv/" target="_blank" rel="noopener">https://www.cs.ryerson.ca/~aharley/vis/conv/</a></p>
</blockquote>
<p><strong>首先导入第三方库</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">import</span> torch.utils.data <span class="keyword">as</span> Data</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="comment">#设置随机种子以便复现</span></span><br><span class="line">torch.manual_seed(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p><strong>训练集和测试集的获取，若本机有cuda环境，也可以运行cuda注释代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">EPOCH=<span class="number">1</span></span><br><span class="line">BATCH_SIZE=<span class="number">32</span></span><br><span class="line">LR=<span class="number">0.001</span></span><br><span class="line"><span class="comment">#如果已经下载好改为False</span></span><br><span class="line">DOWNLOAD_MINIST= <span class="literal">False</span></span><br><span class="line"><span class="comment">#获取手写数字训练集</span></span><br><span class="line">train_data = torchvision.datasets.MNIST(</span><br><span class="line">    <span class="comment"># 保存地点</span></span><br><span class="line">    root=<span class="string">"./minist/"</span>,</span><br><span class="line">    <span class="comment"># 是否是训练集</span></span><br><span class="line">    train=<span class="literal">True</span>,</span><br><span class="line">    <span class="comment"># 转换 PIL.Image or numpy.ndarray 成torch.FloatTensor (C,H,W), 训练的时候 normalize 成 [0.0, 1.0]区间</span></span><br><span class="line">    transform=torchvision.transforms.ToTensor(),</span><br><span class="line">    <span class="comment"># 是否下载</span></span><br><span class="line">    download=DOWNLOAD_MINIST)</span><br><span class="line"><span class="comment"># 可视化查看一下数据图片</span></span><br><span class="line">train,label = train_data[<span class="number">0</span>]</span><br><span class="line">plt.imshow(train.squeeze())</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">test_data = torchvision.datasets.MNIST(</span><br><span class="line">    <span class="comment"># 保存地点</span></span><br><span class="line">    root=<span class="string">"./minist/"</span>,</span><br><span class="line">    <span class="comment"># 是否是训练集</span></span><br><span class="line">    train=<span class="literal">False</span></span><br><span class="line">)</span><br><span class="line"><span class="comment"># 批训练(32,1,28,28)</span></span><br><span class="line">train_loader = Data.DataLoader(dataset=train_data,batch_size=BATCH_SIZE,shuffle=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 由原来的(60000,28,28)变为(60000,1,28,28)</span></span><br><span class="line">test_x = torch.unsqueeze(test_data.data, dim=<span class="number">1</span>).type(torch.FloatTensor)[:<span class="number">2000</span>]/<span class="number">255.</span></span><br><span class="line">test_y = test_data.targets[:<span class="number">2000</span>]</span><br><span class="line"><span class="comment"># 若存在cuda环境，即可使用注释代码</span></span><br><span class="line"><span class="comment"># test_x = test_x.cuda()</span></span><br><span class="line"><span class="comment"># test_y = test_y.cuda()</span></span><br></pre></td></tr></table></figure>
<p><strong>CNN网络配置</strong>，输出大小为<code>[(n - k + 2p) / s] + 1</code>，n代表输入大小，k为核大小，p为填充，s为步幅</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CNN</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(CNN,self).__init__()</span><br><span class="line">        <span class="comment">#输入形状为(1,28,28)，输出形状为(16,14,14)</span></span><br><span class="line">        self.conv1 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(in_channels=<span class="number">1</span>,   <span class="comment"># 输入通道</span></span><br><span class="line">                      out_channels=<span class="number">16</span>, <span class="comment"># 输出通道</span></span><br><span class="line">                      kernel_size=<span class="number">5</span>,   <span class="comment"># 卷积核大小</span></span><br><span class="line">                      stride=<span class="number">1</span>,        <span class="comment"># 步幅</span></span><br><span class="line">                      padding=<span class="number">2</span>),      <span class="comment"># 填充</span></span><br><span class="line">            <span class="comment"># 此时输出形状为(16,28,28)</span></span><br><span class="line">            nn.ReLU(),                 <span class="comment"># 激活函数</span></span><br><span class="line">            <span class="comment"># 最大池化，核大小为2，此时输出形状(16,14,14)</span></span><br><span class="line">            nn.MaxPool2d(kernel_size=<span class="number">2</span>)</span><br><span class="line">        )</span><br><span class="line">        self.conv2 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">16</span>,<span class="number">32</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>), <span class="comment"># 输出形状(32,14,14)</span></span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>)         <span class="comment">#输出形状(32,7,7)</span></span><br><span class="line">        )</span><br><span class="line">        <span class="comment">#全连接网络，输出10个类别</span></span><br><span class="line">        self.out = nn.Linear(<span class="number">32</span>*<span class="number">7</span>*<span class="number">7</span>,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self,x)</span>:</span></span><br><span class="line">        x = self.conv1(x)</span><br><span class="line">        x = self.conv2(x)</span><br><span class="line">        <span class="comment"># 将卷积层展平，才能输入全连接网络</span></span><br><span class="line">        x = x.view(x.size(<span class="number">0</span>),<span class="number">-1</span>)</span><br><span class="line">        output = self.out(x)</span><br><span class="line">        <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure>
<p><strong>训练与测试</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cnn = CNN()</span><br><span class="line"><span class="comment"># 若存在cuda环境，即可使用注释代码</span></span><br><span class="line"><span class="comment"># cnn = cnn.cuda()</span></span><br><span class="line"><span class="comment"># 优化器</span></span><br><span class="line">optimizer = torch.optim.Adam(cnn.parameters(),lr=LR)</span><br><span class="line"><span class="comment"># 损失函数，分类问题</span></span><br><span class="line">loss_fn = nn.CrossEntropyLoss()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(EPOCH):</span><br><span class="line">    <span class="comment"># 迭代运行</span></span><br><span class="line">    <span class="keyword">for</span> step, (x, y) <span class="keyword">in</span> enumerate(train_loader):</span><br><span class="line">        <span class="comment"># x = x.cuda()</span></span><br><span class="line">        <span class="comment"># y = y.cuda()</span></span><br><span class="line">        output = cnn(x)</span><br><span class="line">        loss = loss_fn(output, y)</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">        <span class="keyword">if</span>(step % <span class="number">50</span> == <span class="number">0</span>):</span><br><span class="line">            <span class="comment"># 可以单独进行模型的测试</span></span><br><span class="line">            test_output = cnn(test_x)</span><br><span class="line">            <span class="comment"># 1代表索引列，因为刚好匹配到0-9，获取概率高的</span></span><br><span class="line">            pre_y = torch.max(test_output, <span class="number">1</span>)[<span class="number">1</span>].data.squeeze()</span><br><span class="line">            <span class="comment"># pre_y = torch.max(test_output, 1)[1].cuda().data.squeeze()</span></span><br><span class="line">            <span class="comment"># 获取准确率</span></span><br><span class="line">            accurary = float((pre_y == test_y).sum()) / float(test_y.size(<span class="number">0</span>))</span><br><span class="line">            print(<span class="string">'Epoch: '</span>,epoch, <span class="string">'| train loss: %.4f'</span> % loss.data, <span class="string">'| test accurary: %.2f'</span> % accurary)</span><br><span class="line"><span class="comment"># 最后可以模型保存</span></span><br></pre></td></tr></table></figure>
<h2 id="六、RNN循环神经网络实现MNIST数据集">六、RNN循环神经网络实现MNIST数据集</h2>
<p>之前的操作与CNN类似，RNN循环神经网络部分如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LSTM</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, input_size=<span class="number">28</span>, hidden_size=<span class="number">64</span>, num_layers=<span class="number">1</span>, output_size=<span class="number">10</span>)</span>:</span></span><br><span class="line">       super(LSTM, self).__init__()</span><br><span class="line">       <span class="comment"># 使用LSTM比RNN效果好</span></span><br><span class="line">       self.rnn = nn.LSTM(</span><br><span class="line">           <span class="comment"># 输入数据特征数，这里28个28维度的数据输入</span></span><br><span class="line">           input_size = input_size,</span><br><span class="line">           <span class="comment"># 隐藏层特征数    </span></span><br><span class="line">           hidden_size = hidden_size,</span><br><span class="line">           <span class="comment"># LSTM层数</span></span><br><span class="line">           num_layers = num_layers,</span><br><span class="line">           <span class="comment"># 如果是第一次输入，需要将batch_size与seq_length这两个维度调换</span></span><br><span class="line">           batch_first = <span class="literal">True</span></span><br><span class="line">       )</span><br><span class="line">       <span class="comment"># 输出10个类别</span></span><br><span class="line">       self.output = nn.Linear(hidden_size,output_size)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self,x)</span>:</span></span><br><span class="line">        <span class="comment"># x shape (batch, time_step, input_size)</span></span><br><span class="line">        <span class="comment"># r_out shape (batch, time_step, output_size)</span></span><br><span class="line">        <span class="comment"># h_n shape (n_layers, batch, hidden_size)   LSTM 有两个 hidden states, h_n 是分线, h_c 是主线</span></span><br><span class="line">        <span class="comment"># h_c shape (n_layers, batch, hidden_size)</span></span><br><span class="line">        r_out,(h_n, h_c) = self.rnn(x,<span class="literal">None</span>)</span><br><span class="line">        <span class="comment"># 选取最后一个时间点的 r_out 输出</span></span><br><span class="line">        output = self.output(r_out[:,<span class="number">-1</span>,:])</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line">lstm = LSTM()</span><br><span class="line"><span class="comment"># 优化器</span></span><br><span class="line">optimizer = torch.optim.Adam(lstm.parameters(),lr=LR)</span><br><span class="line"><span class="comment"># 损失函数，分类问题</span></span><br><span class="line">loss_fn = nn.CrossEntropyLoss()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(EPOCH):</span><br><span class="line">    <span class="comment"># 迭代运行</span></span><br><span class="line">    <span class="keyword">for</span> step, (x, y) <span class="keyword">in</span> enumerate(train_loader):</span><br><span class="line">         <span class="comment"># 输入输入需要变换形状</span></span><br><span class="line">        output = lstm(x.view(<span class="number">-1</span>,<span class="number">28</span>,<span class="number">28</span>))</span><br><span class="line">        loss = loss_fn(output, y)</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">        <span class="keyword">if</span>(step % <span class="number">50</span> == <span class="number">0</span>):</span><br><span class="line">            <span class="comment"># 可以单独进行模型的测试</span></span><br><span class="line">            test_output = lstm(test_x.view(<span class="number">-1</span>,<span class="number">28</span>,<span class="number">28</span>))</span><br><span class="line">            <span class="comment"># 1代表索引列，因为刚好匹配到0-9，获取概率高的</span></span><br><span class="line">            pre_y = torch.max(test_output, <span class="number">1</span>)[<span class="number">1</span>].data.squeeze()</span><br><span class="line">            <span class="comment"># 获取准确率</span></span><br><span class="line">            accurary = float((pre_y == test_y).sum()) / float(test_y.size(<span class="number">0</span>))</span><br><span class="line">            print(<span class="string">'Epoch: '</span>,epoch, <span class="string">'| train loss: %.4f'</span> % loss.data, <span class="string">'| test accurary: %.2f'</span> % accurary)</span><br><span class="line"><span class="comment"># 最后可以模型保存</span></span><br></pre></td></tr></table></figure>
<h2 id="七、AutoEncoder自编码">七、AutoEncoder自编码</h2>
<p><strong>首先获取数据集</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">import</span> torch.utils.data <span class="keyword">as</span> Data</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="comment">#设置随机种子以便复现</span></span><br><span class="line">torch.manual_seed(<span class="number">1</span>)</span><br><span class="line">EPOCH=<span class="number">1</span></span><br><span class="line">BATCH_SIZE=<span class="number">32</span></span><br><span class="line">LR=<span class="number">0.001</span></span><br><span class="line"><span class="comment">#如果已经下载好改为False</span></span><br><span class="line">DOWNLOAD_MINIST= <span class="literal">False</span></span><br><span class="line"><span class="comment">#获取手写数字训练集</span></span><br><span class="line">train_data = torchvision.datasets.MNIST(</span><br><span class="line">    <span class="comment"># 保存地点</span></span><br><span class="line">    root=<span class="string">"./minist/"</span>,</span><br><span class="line">    <span class="comment"># 是否是训练集</span></span><br><span class="line">    train=<span class="literal">True</span>,</span><br><span class="line">    <span class="comment"># 转换 PIL.Image or numpy.ndarray 成torch.FloatTensor (C,H,W), 训练的时候 normalize 成 [0.0, 1.0]区间</span></span><br><span class="line">    transform=torchvision.transforms.ToTensor(),</span><br><span class="line">    <span class="comment"># 是否下载</span></span><br><span class="line">    download=DOWNLOAD_MINIST)</span><br><span class="line"><span class="comment"># 批训练(32,1,28,28)</span></span><br><span class="line">train_loader = Data.DataLoader(dataset=train_data,batch_size=BATCH_SIZE,shuffle=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p><strong>网络的设置与训练，AutoEncoder是先将图片压缩后还原，用还原后的图片与原图片进行评估并梯度下降</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># AutoEncoder 形式很简单, 分别是 encoder  和 decoder , 压缩和解压, 压缩后得到压缩的特征值, 再从压缩的特征值解压成原图片</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoEncoder</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(AutoEncoder, self).__init__()</span><br><span class="line">        <span class="comment"># 压缩</span></span><br><span class="line">        self.encoder = nn.Sequential(</span><br><span class="line">            nn.Linear(<span class="number">28</span>*<span class="number">28</span>, <span class="number">128</span>),</span><br><span class="line">            nn.Tanh(),</span><br><span class="line">            nn.Linear(<span class="number">128</span>, <span class="number">64</span>),</span><br><span class="line">            nn.Tanh(),</span><br><span class="line">            nn.Linear(<span class="number">64</span>, <span class="number">12</span>),</span><br><span class="line">            nn.Tanh(),</span><br><span class="line">            nn.Linear(<span class="number">12</span>, <span class="number">3</span>),   <span class="comment"># 压缩成3个特征, 进行 3D 图像可视化</span></span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># 解压</span></span><br><span class="line">        self.decoder = nn.Sequential(</span><br><span class="line">            nn.Linear(<span class="number">3</span>, <span class="number">12</span>),</span><br><span class="line">            nn.Tanh(),</span><br><span class="line">            nn.Linear(<span class="number">12</span>, <span class="number">64</span>),</span><br><span class="line">            nn.Tanh(),</span><br><span class="line">            nn.Linear(<span class="number">64</span>, <span class="number">128</span>),</span><br><span class="line">            nn.Tanh(),</span><br><span class="line">            nn.Linear(<span class="number">128</span>, <span class="number">28</span>*<span class="number">28</span>),</span><br><span class="line">            nn.Sigmoid(),       <span class="comment"># 激励函数让输出值在 (0, 1)</span></span><br><span class="line">        )</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        encoded = self.encoder(x)</span><br><span class="line">        decoded = self.decoder(encoded)</span><br><span class="line">        <span class="keyword">return</span> encoded, decoded</span><br><span class="line"></span><br><span class="line">autoencoder = AutoEncoder()</span><br><span class="line">optimizer = torch.optim.Adam(autoencoder.parameters(),lr=LR)</span><br><span class="line">loss_fn = nn.MSELoss()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(EPOCH):</span><br><span class="line">    <span class="keyword">for</span> step, (x, y) <span class="keyword">in</span> enumerate(train_loader):</span><br><span class="line">        train_x = x.view(<span class="number">-1</span>,<span class="number">28</span>*<span class="number">28</span>)</span><br><span class="line">        train_y = x.view(<span class="number">-1</span>,<span class="number">28</span>*<span class="number">28</span>)</span><br><span class="line">        encoded, decoded = autoencoder(train_x)</span><br><span class="line">        loss = loss_fn(decoded, train_y)</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">        <span class="keyword">if</span>(step % <span class="number">50</span> == <span class="number">0</span>):</span><br><span class="line">            print(<span class="string">'Epoch: '</span>,epoch, <span class="string">'| train loss: %.4f'</span> % loss.data)</span><br></pre></td></tr></table></figure>
<p><strong>3D展示图，可以进行旋转观看</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> cm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要观看的数据</span></span><br><span class="line">view_data = train_data.data[:<span class="number">200</span>].view(<span class="number">-1</span>, <span class="number">28</span>*<span class="number">28</span>).type(torch.FloatTensor)/<span class="number">255.</span></span><br><span class="line">encoded_data, _ = autoencoder(view_data)    <span class="comment"># 提取压缩的特征值</span></span><br><span class="line">fig = plt.figure(<span class="number">2</span>)</span><br><span class="line">ax = Axes3D(fig)    <span class="comment"># 3D 图</span></span><br><span class="line"><span class="comment"># x, y, z 的数据值</span></span><br><span class="line">X = encoded_data.data[:, <span class="number">0</span>].numpy()</span><br><span class="line">Y = encoded_data.data[:, <span class="number">1</span>].numpy()</span><br><span class="line">Z = encoded_data.data[:, <span class="number">2</span>].numpy()</span><br><span class="line">values = train_data.targets[:<span class="number">200</span>].numpy()  <span class="comment"># 标签值</span></span><br><span class="line"><span class="keyword">for</span> x, y, z, s <span class="keyword">in</span> zip(X, Y, Z, values):</span><br><span class="line">    c = cm.rainbow(int(<span class="number">255</span>*s/<span class="number">9</span>))    <span class="comment"># 上色</span></span><br><span class="line">    ax.text(x, y, z, s, backgroundcolor=c)  <span class="comment"># 标位子</span></span><br><span class="line">ax.set_xlim(X.min(), X.max())</span><br><span class="line">ax.set_ylim(Y.min(), Y.max())</span><br><span class="line">ax.set_zlim(Z.min(), Z.max())</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/image-20210515213727565.png" alt></p>
<h2 id="八、GAN生成对抗网络">八、GAN生成对抗网络</h2>
<p>Generator 作为生成器努力生成以假乱真的图片, Discriminator作为判别器，努力判别生成图片为假数据，两者在训练中一起成长，最终训练出可以以假乱真的生成器。这里使用了MNIST作为数据集，生成器是生成数字，判别器验证输入是否为数字，使用了GPU加速训练，这里网络用了简单模型，可以自行修改为卷积网络</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">import</span> torch.utils.data <span class="keyword">as</span> Data</span><br><span class="line"><span class="comment"># 随机种子方便再现</span></span><br><span class="line">torch.manual_seed(<span class="number">1</span>)</span><br><span class="line">np.random.seed(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置超参数</span></span><br><span class="line">EPOCH = <span class="number">1</span></span><br><span class="line">BATCH_SIZE = <span class="number">32</span></span><br><span class="line">LR_G = <span class="number">0.0001</span>           <span class="comment"># 生成器学习率</span></span><br><span class="line">LR_D = <span class="number">0.0001</span>           <span class="comment"># 判别器学习率</span></span><br><span class="line"><span class="comment">#如果已经下载好改为False</span></span><br><span class="line">DOWNLOAD_MINIST= <span class="literal">False</span></span><br><span class="line"><span class="comment"># GPU加速</span></span><br><span class="line">device = torch.device(<span class="string">'cuda:0'</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">'cpu'</span>)</span><br><span class="line"><span class="comment">#获取手写数字训练集</span></span><br><span class="line">train_data = torchvision.datasets.MNIST(</span><br><span class="line">    <span class="comment"># 保存地点</span></span><br><span class="line">    root=<span class="string">"./minist/"</span>,</span><br><span class="line">    <span class="comment"># 是否是训练集</span></span><br><span class="line">    train=<span class="literal">True</span>,</span><br><span class="line">    <span class="comment"># 转换 PIL.Image or numpy.ndarray 成torch.FloatTensor (C,H,W), 训练的时候 normalize 成 [0.0, 1.0]区间</span></span><br><span class="line">    transform=torchvision.transforms.ToTensor(),</span><br><span class="line">    <span class="comment"># 是否下载</span></span><br><span class="line">    download=DOWNLOAD_MINIST)</span><br><span class="line"><span class="comment"># 批训练(32,1,28,28)</span></span><br><span class="line">train_loader = Data.DataLoader(dataset=train_data,batch_size=BATCH_SIZE,shuffle=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">generator</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, input_size)</span>:</span></span><br><span class="line">        super(generator,self).__init__()</span><br><span class="line">        self.gen = nn.Sequential(</span><br><span class="line">            nn.Linear(input_size,<span class="number">256</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Linear(<span class="number">256</span>,<span class="number">512</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Linear(<span class="number">512</span>,<span class="number">784</span>),</span><br><span class="line">            nn.Tanh()</span><br><span class="line">        )</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        output = self.gen(x)</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"><span class="comment"># 判别器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">discriminator</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(discriminator,self).__init__()</span><br><span class="line">        self.dis = nn.Sequential(</span><br><span class="line">            nn.Linear(<span class="number">784</span>,<span class="number">512</span>),</span><br><span class="line">            nn.LeakyReLU(<span class="number">0.2</span>),</span><br><span class="line">            nn.Linear(<span class="number">512</span>,<span class="number">256</span>),</span><br><span class="line">            nn.LeakyReLU(<span class="number">0.2</span>),</span><br><span class="line">            nn.Linear(<span class="number">256</span>,<span class="number">1</span>),</span><br><span class="line">            nn.Sigmoid()</span><br><span class="line">        )</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        output = self.dis(x)</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line">G = generator(<span class="number">28</span>*<span class="number">28</span>).to(device)</span><br><span class="line">D = discriminator().to(device)</span><br><span class="line"></span><br><span class="line">criterion = nn.BCELoss()</span><br><span class="line">g_optimizer = torch.optim.Adam(G.parameters(), lr=LR_G)</span><br><span class="line">d_optimizer = torch.optim.Adam(D.parameters(), lr=LR_D)</span><br><span class="line"><span class="comment"># 训练</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(EPOCH):</span><br><span class="line">    <span class="keyword">for</span> step, (x, _) <span class="keyword">in</span> enumerate(train_loader):</span><br><span class="line">        <span class="comment"># 获取每一次迭代数据的批量值</span></span><br><span class="line">        x_num = x.size(<span class="number">0</span>)</span><br><span class="line">        <span class="comment"># 训练判别器</span></span><br><span class="line">        train_x = x.view(x_num, <span class="number">-1</span>).to(device)</span><br><span class="line">        <span class="comment"># 真实标签值</span></span><br><span class="line">        real_label = torch.ones(x_num).to(device)</span><br><span class="line">        <span class="comment"># 噪声标签值</span></span><br><span class="line">        fake_label = torch.zeros(x_num).to(device)</span><br><span class="line">        real_out = D(train_x)</span><br><span class="line">        d_loss_real = criterion(real_out, real_label)</span><br><span class="line">        <span class="comment"># 噪声数值</span></span><br><span class="line">        z = torch.randn(x_num,<span class="number">28</span>*<span class="number">28</span>).to(device)</span><br><span class="line">        fake_x = G(z)</span><br><span class="line">        fake_out = D(fake_x)</span><br><span class="line">        d_loss_fake = criterion(fake_out, fake_label)</span><br><span class="line">        d_loss = d_loss_real + d_loss_fake</span><br><span class="line">        d_optimizer.zero_grad()</span><br><span class="line">        d_loss.backward()</span><br><span class="line">        d_optimizer.step()</span><br><span class="line">        <span class="comment"># 训练生成器</span></span><br><span class="line">        z = torch.randn(x_num,<span class="number">28</span>*<span class="number">28</span>).to(device)</span><br><span class="line">        fake_x = G(z)</span><br><span class="line">        fake_out = D(fake_x)</span><br><span class="line">        g_loss = criterion(fake_out, real_label)</span><br><span class="line">        g_optimizer.zero_grad()</span><br><span class="line">        g_loss.backward()</span><br><span class="line">        g_optimizer.step()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(step % <span class="number">50</span> == <span class="number">0</span>):</span><br><span class="line">            print(<span class="string">'Epoch: '</span>,epoch, <span class="string">'| train d_loss: %.4f'</span> % d_loss.data,<span class="string">'| train g_loss: %.4f'</span> % g_loss.data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘图展示</span></span><br><span class="line">z = torch.randn(x_num,<span class="number">28</span>*<span class="number">28</span>).to(device)</span><br><span class="line">x = z</span><br><span class="line">img = x.view(<span class="number">-1</span>,<span class="number">28</span>,<span class="number">28</span>)[<span class="number">3</span>].squeeze()</span><br><span class="line">plt.subplot(<span class="number">121</span>)</span><br><span class="line">plt.imshow(img.data.cpu().numpy())</span><br><span class="line">plt.show()</span><br><span class="line">x = G(z)</span><br><span class="line">img = x.view(<span class="number">-1</span>,<span class="number">28</span>,<span class="number">28</span>)[<span class="number">3</span>].squeeze()</span><br><span class="line">plt.subplot(<span class="number">122</span>)</span><br><span class="line">plt.imshow(img.data.cpu().numpy())</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>一下左图是生成的随机噪声，右图是随机噪声经过生成器后的图片</p>
<p><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/image-20210519210954854.png" alt><img src="https://gitee.com/LXT2017/Picbed/raw/blogimg/noteimg/image-20210519211005641.png" alt></p>
<h2 id="九、DQN强化学习">九、DQN强化学习</h2>
<p>通过Q-Learning和神经网络结合，通过反馈可以使机器学得的效果越来越好，下面是简单的demo(有点小难，我还没理解)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> gym</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义超参数</span></span><br><span class="line">BATCH_SIZE = <span class="number">32</span></span><br><span class="line">LR = <span class="number">0.01</span></span><br><span class="line">EPSILON = <span class="number">0.9</span>  <span class="comment"># 最优选择动作百分比</span></span><br><span class="line">GAMMA = <span class="number">0.9</span>  <span class="comment"># 奖励递减参数</span></span><br><span class="line">TARGET_REPLACE_ITER = <span class="number">100</span>  <span class="comment"># Q 现实网络的更新频率</span></span><br><span class="line">MEMORY_CAPACITY = <span class="number">2000</span>  <span class="comment"># 记忆库大小</span></span><br><span class="line">env = gym.make(<span class="string">"CartPole-v0"</span>)  <span class="comment"># 立杆子游戏</span></span><br><span class="line">env = env.unwrapped</span><br><span class="line">N_ACTIONS = env.action_space.n  <span class="comment"># 杆子能做的动作</span></span><br><span class="line">N_STATES = env.observation_space.shape[<span class="number">0</span>]  <span class="comment"># 杆子能获取的环境信息数</span></span><br><span class="line">ENV_A_SHAPE = <span class="number">0</span> <span class="keyword">if</span> isinstance(env.action_space.sample(),</span><br><span class="line">                              int) <span class="keyword">else</span> env.action_space.sample().shape  <span class="comment"># to confirm the shape</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造DON（Deep Q Network)强化学习神经网络 现实网络 (Target Net) 估计网络 (Eval Net)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(Net, self).__init__()</span><br><span class="line">        self.fc1 = nn.Linear(N_STATES, <span class="number">10</span>)</span><br><span class="line">        self.fc1.weight.data.normal_(<span class="number">0</span>, <span class="number">0.1</span>)  <span class="comment"># initialization(初始化）</span></span><br><span class="line">        self.out = nn.Linear(<span class="number">10</span>, N_ACTIONS)</span><br><span class="line">        self.out.weight.data.normal_(<span class="number">0</span>, <span class="number">0.1</span>)  <span class="comment"># initialization(初始化）</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        x = self.fc1(x)</span><br><span class="line">        x = F.relu(x)</span><br><span class="line">        action_value = self.out(x)</span><br><span class="line">        <span class="keyword">return</span> action_value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造DQN体系</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DQN</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 建立 target net 和 eval net 还有 memory</span></span><br><span class="line">        self.eval_net, self.target_net = Net(), Net()</span><br><span class="line">        self.learn_step_counter = <span class="number">0</span>  <span class="comment"># 用于 target 更新计时</span></span><br><span class="line">        self.memory_counter = <span class="number">0</span>  <span class="comment"># 记忆库记数</span></span><br><span class="line">        self.memory = np.zeros((MEMORY_CAPACITY, N_STATES * <span class="number">2</span> + <span class="number">2</span>))  <span class="comment"># 初始化记忆库</span></span><br><span class="line">        self.optimizer = torch.optim.Adam(self.eval_net.parameters(), lr=LR)</span><br><span class="line">        self.lose_func = nn.MSELoss()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">choose_action</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="comment"># 根据环境观测值选择动作的机制</span></span><br><span class="line">        x = torch.unsqueeze(torch.FloatTensor(x), <span class="number">0</span>)</span><br><span class="line">        <span class="comment"># 这里只输入一个 sample</span></span><br><span class="line">        <span class="keyword">if</span> np.random.uniform() &lt; EPSILON:  <span class="comment"># 选最优动作</span></span><br><span class="line">            actions_value = self.eval_net.forward(x)</span><br><span class="line">            action = torch.max(actions_value, <span class="number">1</span>)[<span class="number">1</span>].data.numpy()</span><br><span class="line">            action = action[<span class="number">0</span>] <span class="keyword">if</span> ENV_A_SHAPE == <span class="number">0</span> <span class="keyword">else</span> action.reshape(ENV_A_SHAPE)  <span class="comment"># return the argmax index</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            action = np.random.randint(<span class="number">0</span>, N_ACTIONS)</span><br><span class="line">            action = action <span class="keyword">if</span> ENV_A_SHAPE == <span class="number">0</span> <span class="keyword">else</span> action.reshape(ENV_A_SHAPE)</span><br><span class="line">        <span class="keyword">return</span> action</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">store_transition</span><span class="params">(self, s, a, r, s_)</span>:</span></span><br><span class="line">        <span class="comment"># 存储记忆</span></span><br><span class="line">        transition = np.hstack((s, [a, r], s_))</span><br><span class="line">        <span class="comment"># 如果记忆库满了, 就覆盖老数据</span></span><br><span class="line">        index = self.memory_counter % MEMORY_CAPACITY</span><br><span class="line">        self.memory[index, :] = transition</span><br><span class="line">        self.memory_counter += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">learn</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># target 网络更新 学习记忆库中的记忆</span></span><br><span class="line">        <span class="keyword">if</span> self.learn_step_counter % TARGET_REPLACE_ITER == <span class="number">0</span>:</span><br><span class="line">            self.target_net.load_state_dict(self.eval_net.state_dict())</span><br><span class="line">        self.learn_step_counter += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 抽取记忆库中的批数据</span></span><br><span class="line">        sample_index = np.random.choice(MEMORY_CAPACITY, BATCH_SIZE)</span><br><span class="line">        b_memory = self.memory[sample_index, :]</span><br><span class="line">        b_s = torch.FloatTensor(b_memory[:, :N_STATES])</span><br><span class="line">        b_a = torch.LongTensor(b_memory[:, N_STATES:N_STATES + <span class="number">1</span>].astype(int))</span><br><span class="line">        b_r = torch.FloatTensor(b_memory[:, N_STATES + <span class="number">1</span>:N_STATES + <span class="number">2</span>])</span><br><span class="line">        b_s_ = torch.FloatTensor(b_memory[:, -N_STATES:])</span><br><span class="line">        <span class="comment"># 针对做过的动作b_a, 来选 q_eval 的值, (q_eval 原本有所有动作的值)</span></span><br><span class="line">        q_eval = self.eval_net(b_s).gather(<span class="number">1</span>, b_a)  <span class="comment"># shape (batch, 1)</span></span><br><span class="line">        q_next = self.target_net(b_s_).detach()  <span class="comment"># q_next 不进行反向传递误差, 所以 detach</span></span><br><span class="line">        q_target = b_r + GAMMA * q_next.max(<span class="number">1</span>)[<span class="number">0</span>]  <span class="comment"># shape (batch, 1)</span></span><br><span class="line">        loss = self.lose_func(q_eval, q_target)</span><br><span class="line">        <span class="comment"># 计算, 更新 eval net</span></span><br><span class="line">        self.optimizer.zero_grad()</span><br><span class="line">        loss.backward()</span><br><span class="line">        self.optimizer.step()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练 按照 Qlearning 的形式进行 off-policy 的更新. 我们进行回合制更新, 一个回合完了, 进入下一回合. 一直到他们将杆子立起来很久.</span></span><br><span class="line">dqn = DQN()</span><br><span class="line"><span class="keyword">for</span> i_episode <span class="keyword">in</span> range(<span class="number">400</span>):</span><br><span class="line">    s = env.reset()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        env.render()  <span class="comment"># 显示实验动画</span></span><br><span class="line">        a = dqn.choose_action(s)</span><br><span class="line">        <span class="comment"># 选动作, 得到环境反馈</span></span><br><span class="line">        s_, r, done, info = env.step(a)</span><br><span class="line">        <span class="comment"># 修改 reward, 使 DQN 快速学习</span></span><br><span class="line">        x, x_dot, theta, theta_dot = s_</span><br><span class="line">        r1 = (env.x_threshold - abs(x)) / env.x_threshold - <span class="number">0.8</span></span><br><span class="line">        r2 = (env.theta_threshold_radians - abs(theta)) / env.theta_threshold_radians - <span class="number">0.5</span></span><br><span class="line">        r = r1 + r2</span><br><span class="line">        <span class="comment"># 存记忆</span></span><br><span class="line">        dqn.store_transition(s, a, r, s_)</span><br><span class="line">        <span class="keyword">if</span> dqn.memory_counter &gt; MEMORY_CAPACITY:</span><br><span class="line">            dqn.learn()</span><br><span class="line">        <span class="keyword">if</span> done:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        s = s_</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>PyTorch</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql基础</title>
    <url>/posts/8a2dddd9.html</url>
    <content><![CDATA[<h3 id="一、数据库基本知识">一、数据库基本知识</h3>
<h4 id="1、数据库基本介绍">1、数据库基本介绍</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 本地进入可不输入-h命令,-u和-p后面没有空格！</span></span><br><span class="line">mysql [-h 服务器主机地址] -u用户名 -p密码</span><br><span class="line"><span class="comment"># 修改数据库密码</span></span><br><span class="line">mysqladmin -u用户名 -p密码 password 新密码;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有数据库</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">databases</span>; </span><br><span class="line"><span class="comment"># 打开某个数据库</span></span><br><span class="line"><span class="keyword">use</span> dbname； </span><br><span class="line"><span class="comment"># 显示表mysql数据库中user表的列信息</span></span><br><span class="line"><span class="keyword">describe</span> <span class="keyword">user</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建数据库</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> [<span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span>] 数据库名;</span><br><span class="line"><span class="comment"># 删除数据库</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">database</span> [<span class="keyword">if</span> <span class="keyword">exists</span>] 数据库名;</span><br><span class="line"><span class="comment"># 显示数据库中所有的表</span></span><br><span class="line"><span class="keyword">show</span> 数据库名;</span><br><span class="line"><span class="comment"># 选择数据库</span></span><br><span class="line"><span class="keyword">use</span> 数据库名; </span><br><span class="line"></span><br><span class="line">exit; 退出Mysql</span><br><span class="line">? 命令关键词 : 寻求帮助</span><br><span class="line"><span class="comment">-- 表示注释</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="2、结构化查询语句分类">2、结构化查询语句分类</h4>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">解释</th>
<th style="text-align:center">命令</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">DDL(数据定义语言)</td>
<td style="text-align:center">定义和管理数据对象，如数据库，数据表等</td>
<td style="text-align:center">CREATE、DROP、ALTER</td>
</tr>
<tr>
<td style="text-align:center">DML(数据操作语言)</td>
<td style="text-align:center">用于操作数据库对象中所包含的数据</td>
<td style="text-align:center">INSERT、UPDATE、DELETE</td>
</tr>
<tr>
<td style="text-align:center">DQL(数据查询语言)</td>
<td style="text-align:center">用于查询数据库数据</td>
<td style="text-align:center">SELECT</td>
</tr>
<tr>
<td style="text-align:center">DCL(数据控制语言)</td>
<td style="text-align:center">用于管理数据库的语言，包括管理权限及数据更改</td>
<td style="text-align:center">GRANT、commit、rollback</td>
</tr>
</tbody>
</table>
<h4 id="3、数据类型和范围大小">3、数据类型和范围大小</h4>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">说明</th>
<th style="text-align:center">长度(取值范围)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">tinyint</td>
<td style="text-align:center">十分小的数据</td>
<td style="text-align:center">1字节</td>
</tr>
<tr>
<td style="text-align:center">smallint</td>
<td style="text-align:center">较小的数据</td>
<td style="text-align:center">2字节</td>
</tr>
<tr>
<td style="text-align:center">mediumint</td>
<td style="text-align:center">中等大小的数据</td>
<td style="text-align:center">3字节</td>
</tr>
<tr>
<td style="text-align:center">==int==</td>
<td style="text-align:center">标准整数(常用)</td>
<td style="text-align:center">4字节</td>
</tr>
<tr>
<td style="text-align:center">bigint</td>
<td style="text-align:center">较大的的整数</td>
<td style="text-align:center">8字节</td>
</tr>
<tr>
<td style="text-align:center">float</td>
<td style="text-align:center">单精度浮点数</td>
<td style="text-align:center">4字节</td>
</tr>
<tr>
<td style="text-align:center">double</td>
<td style="text-align:center">双精度浮点数</td>
<td style="text-align:center">8字节</td>
</tr>
<tr>
<td style="text-align:center">==decimal(m,d)==</td>
<td style="text-align:center">字符串形式的浮点数，涉及钱时使用</td>
<td style="text-align:center">m字节</td>
</tr>
<tr>
<td style="text-align:center">char(m)</td>
<td style="text-align:center">固定长度字符串，检索快但浪费空间，0&lt;=m&lt;=255</td>
<td style="text-align:center">m字符</td>
</tr>
<tr>
<td style="text-align:center">==varchar(m)==</td>
<td style="text-align:center">可变字符串，0&lt;=m&lt;=65535(常用)</td>
<td style="text-align:center">变长数</td>
</tr>
<tr>
<td style="text-align:center">tinytext</td>
<td style="text-align:center">微型文本串</td>
<td style="text-align:center">2^8-1</td>
</tr>
<tr>
<td style="text-align:center">==text==</td>
<td style="text-align:center">文本串</td>
<td style="text-align:center">2^16-1</td>
</tr>
<tr>
<td style="text-align:center">==DATETIME==</td>
<td style="text-align:center">时间格式，YYYY-MM-DD HH:mm:ss</td>
<td style="text-align:center">1000-01-01 00:00:00~9999-12-31 23:59:59</td>
</tr>
<tr>
<td style="text-align:center">==TIMESTAMP==</td>
<td style="text-align:center">时间戳，从1970开始的毫秒数</td>
<td style="text-align:center">197010101000000~2037年</td>
</tr>
</tbody>
</table>
<h4 id="4、创建数据表">4、创建数据表</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> [<span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span>] <span class="string">`表名`</span>(</span><br><span class="line">   <span class="string">'字段名1'</span> 列类型 [属性][索引][注释],</span><br><span class="line">   <span class="string">'字段名2'</span> 列类型 [属性][索引][注释],</span><br><span class="line">  <span class="comment">#...</span></span><br><span class="line">   <span class="string">'字段名n'</span> 列类型 [属性][索引][注释]</span><br><span class="line">)[表类型][表字符集][注释];</span><br></pre></td></tr></table></figure>
<h4 id="5、数据表字段属性">5、数据表字段属性</h4>
<p><strong>UnSigned</strong></p>
<ul>
<li>
<p>无符号的</p>
</li>
<li>
<p>声明该数据列不允许负数</p>
</li>
</ul>
<p><strong>ZEROFILL</strong></p>
<ul>
<li>0填充的</li>
<li>不足位数的用0来填充 , 如int(3),5则为005</li>
</ul>
<p><strong>Auto_Increment</strong></p>
<ul>
<li>自动增长的 , 每添加一条数据 , 自动在上一个记录数上加 1(默认)</li>
<li>通常用于设置主键 , 且为整数类型</li>
<li>可定义起始值和步长
<ul>
<li>当前表设置步长(AUTO_INCREMENT=100) : 只影响当前表</li>
<li>SET @@auto_increment_increment=5 ; 影响所有使用自增的表(全局)</li>
</ul>
</li>
</ul>
<p><strong>NULL 和 NOT NULL</strong></p>
<ul>
<li>默认为NULL , 即没有插入该列的数值</li>
<li>如果设置为NOT NULL , 则该列必须有值</li>
</ul>
<p><strong>DEFAULT</strong></p>
<ul>
<li>默认的，用于设置默认值</li>
<li>例如,性别字段,默认为&quot;男&quot; , 否则为 “女” ; 若无指定该列的值 , 则默认值为&quot;男&quot;的值</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*用户表*/</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="string">`user`</span>(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'用户编号'</span>,</span><br><span class="line"><span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'匿名'</span> <span class="keyword">COMMENT</span> <span class="string">'姓名'</span>,</span><br><span class="line"><span class="string">`pwd`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'123456'</span> <span class="keyword">COMMENT</span> <span class="string">'密码'</span>,</span><br><span class="line"><span class="string">`sex`</span> <span class="built_in">varchar</span>(<span class="number">2</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'男'</span> <span class="keyword">COMMENT</span> <span class="string">'性别'</span>,</span><br><span class="line"><span class="string">`birthday`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'生日'</span>,</span><br><span class="line"><span class="string">`address`</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'地址'</span>,</span><br><span class="line"><span class="string">`email`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'邮箱'</span>,</span><br><span class="line">primary <span class="keyword">key</span>(<span class="string">`id`</span>)</span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看数据表的定义</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">user</span>;</span><br><span class="line"><span class="comment">-- 显示表结构</span></span><br><span class="line">DESC user;  <span class="comment">-- 设置严格检查模式(不能容错了)SET sql_mode='STRICT_TRANS_TABLES';</span></span><br></pre></td></tr></table></figure>
<p>对于Mysql的引擎，现在一般使用InnoDB，而MySql的一些默认设置都在<code>my.ini</code>文件中设置</p>
<ul>
<li>适用 MyISAM : 节约空间及相应速度</li>
<li>适用 InnoDB : 安全性 , 事务处理及多用户操作数据表</li>
</ul>
<h4 id="6、修改与删除数据库">6、修改与删除数据库</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改表名</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 旧表名 <span class="keyword">RENAME</span> <span class="keyword">AS</span> 新表名</span><br><span class="line"><span class="comment"># 添加字段</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span>字段名 列属性[属性]</span><br><span class="line"><span class="comment"># 修改字段</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">MODIFY</span> 字段名 列类型[属性]</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">CHANGE</span> 旧字段名 新字段名 列属性[属性]</span><br><span class="line"><span class="comment"># 删除字段</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">DROP</span> 字段名</span><br><span class="line"><span class="comment"># 删除数据表</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> [<span class="keyword">IF</span> <span class="keyword">EXISTS</span>] 表名</span><br></pre></td></tr></table></figure>
<p>==注：==Mysql仅在windows下大小写不敏感！</p>
<h3 id="二、MySql数据管理">二、MySql数据管理</h3>
<h4 id="1、外键">1、外键</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 主表已经在第一章写明</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`usertype`</span> (</span><br><span class="line"><span class="string">`type`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户类型'</span>,</span><br><span class="line"><span class="string">`userid`</span> <span class="built_in">int</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户id'</span>,</span><br><span class="line"><span class="keyword">CONSTRAINT</span> <span class="string">`FK_userid`</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (<span class="string">`userid`</span>) <span class="keyword">REFERENCES</span> <span class="string">`user`</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建外键方式二 : 创建子表完毕后,修改子表添加外键</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`usertype`</span> <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> <span class="string">`FK_userid`</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (<span class="string">`userid`</span>) <span class="keyword">REFERENCES</span> <span class="string">`user`</span> (<span class="string">`id`</span>);</span><br></pre></td></tr></table></figure>
<p>再删除表时，要先删除有外键的表，再删除主表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 删除外键</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> usertype <span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> FK_gradeid;</span><br><span class="line"><span class="comment">-- 发现执行完上面的,索引还在,所以还要删除索引</span></span><br><span class="line"><span class="comment">-- 注:这个索引是建立外键的时候默认生成的</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> usertype <span class="keyword">DROP</span> <span class="keyword">INDEX</span> FK_gradeid;</span><br></pre></td></tr></table></figure>
<h4 id="2、DML数据操作语言">2、DML数据操作语言</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名[(字段<span class="number">1</span>,字段<span class="number">2</span>,字段<span class="number">3</span>,...)] <span class="keyword">VALUES</span>(<span class="string">'值1'</span>,<span class="string">'值2'</span>,<span class="string">'值3'</span>)</span><br><span class="line"><span class="keyword">UPDATE</span> 表名 <span class="keyword">SET</span> column_name=<span class="keyword">value</span> [,column_name2=value2,...] [WHEREcondition];</span><br><span class="line"><span class="comment"># condition为筛选条件 , 如不指定则删除该表的所有列数据</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> 表名 [<span class="keyword">WHERE</span> condition];</span><br><span class="line"><span class="comment"># TRUNCATE用于完全清空表数据,但表结构,索引,约束等不变;</span></span><br><span class="line"><span class="keyword">TRUNCATE</span> [<span class="keyword">TABLE</span>] table_name;</span><br></pre></td></tr></table></figure>
<p><code>TRUNCATE</code>和<code>DELETE</code>异同：</p>
<p><strong>相同</strong> : 都能删除数据 , 不删除表结构 , 但TRUNCATE速度更快</p>
<p><strong>不同</strong> :</p>
<ul>
<li>使用TRUNCATE TABLE 重新设置AUTO_INCREMENT计数器</li>
</ul>
<ul>
<li>使用TRUNCATE TABLE不会对事务有影响</li>
</ul>
<h4 id="3、DQL数据查询语言">3、DQL数据查询语言</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 注意 : [ ] 括号代表可选的 , &#123; &#125;括号代表必选得，*指查询所有，不推荐</span></span><br><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">ALL</span> | <span class="keyword">DISTINCT</span>]</span><br><span class="line">&#123;* | table.* | [table.field1[<span class="keyword">as</span> alias1][,table.field2[<span class="keyword">as</span> alias2]][,...]]&#125;</span><br><span class="line"><span class="keyword">FROM</span> table_name [<span class="keyword">as</span> table_alias]</span><br><span class="line">  [<span class="keyword">left</span> | <span class="keyword">right</span> | <span class="keyword">inner</span> <span class="keyword">join</span> table_name2]  <span class="comment">-- 联合查询</span></span><br><span class="line">  [<span class="keyword">WHERE</span> ...]  <span class="comment">-- 指定结果需满足的条件</span></span><br><span class="line">  [<span class="keyword">GROUP</span> <span class="keyword">BY</span> ...]  <span class="comment">-- 指定结果按照哪几个字段来分组</span></span><br><span class="line">  [<span class="keyword">HAVING</span>]  <span class="comment">-- 过滤分组的记录必须满足的次要条件</span></span><br><span class="line">  [<span class="keyword">ORDER</span> <span class="keyword">BY</span> ...]  <span class="comment">-- 指定查询记录按一个或多个条件排序</span></span><br><span class="line">  [<span class="keyword">LIMIT</span> &#123;[<span class="keyword">offset</span>,]<span class="keyword">row_count</span> | row_countOFFSET <span class="keyword">offset</span>&#125;];</span><br><span class="line">   <span class="comment">-- 指定查询的记录从哪条至哪条</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>As</code>字句作为别名，查询指定字段，<code>DISTINCT</code>去掉SELECT查询返回的记录结果中重复的记录 ( 返回所有列的值都相同 ) , 只返回一条</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CONCAT</span>(<span class="string">'用户'</span>,<span class="keyword">id</span>) <span class="keyword">AS</span> 新用户名 <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> sex <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br><span class="line"><span class="keyword">SELECT</span> @@auto_increment_increment; <span class="comment">-- 查询自增步长</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">VERSION</span>(); <span class="comment">-- 查询版本号</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">100</span>*<span class="number">3</span><span class="number">-1</span> <span class="keyword">AS</span> 计算结果; <span class="comment">-- 表达式</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>where</code>条件语句：<code>AND、OR、NOT</code></li>
<li>模糊查询:比较操作符</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">操作符名称</th>
<th style="text-align:center">语法</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">IS NULL</td>
<td style="text-align:center">a IS NULL</td>
<td style="text-align:center">若操作符为NULL，则结果为真</td>
</tr>
<tr>
<td style="text-align:center">IS NOT NULL</td>
<td style="text-align:center">a IS NOT NULL</td>
<td style="text-align:center">若操作符不为NULL，则结果为真</td>
</tr>
<tr>
<td style="text-align:center">BETWEEN</td>
<td style="text-align:center">a BETWEEN b AND c</td>
<td style="text-align:center">若 a 范围在 b 与 c 之间，则结果为真</td>
</tr>
<tr>
<td style="text-align:center">LIKE</td>
<td style="text-align:center">a LIKE b</td>
<td style="text-align:center">SQL 模式匹配，若a匹配b，则结果为真</td>
</tr>
<tr>
<td style="text-align:center">IN</td>
<td style="text-align:center">a IN (a1，a2，a3，…)</td>
<td style="text-align:center">SQL 模式匹配，若a匹配b，则结果为真</td>
</tr>
</tbody>
</table>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 举例</span></span><br><span class="line"><span class="comment">-- like结合使用的通配符 : % (代表0到任意个字符) _ (一个字符)</span></span><br><span class="line"><span class="comment">-- 查询姓刘用户的姓名</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span> <span class="keyword">FROM</span> <span class="string">`user`</span> <span class="keyword">WHERE</span> <span class="keyword">name</span> <span class="keyword">LIKE</span> <span class="string">'刘%'</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>连接查询:<code>join</code>对比</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/7963c5409eeac83b1134262da55d7a38.png" alt="sql-join"></p>
<ul>
<li>排序和分页、子查询</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 举例</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> <span class="string">`user`</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> birthday <span class="keyword">DESC</span> <span class="keyword">LIMIT</span> <span class="number">0</span>,<span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<h3 id="三、MySql函数">三、MySql函数</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"> <span class="comment">-- ================ 内置函数 ================</span></span><br><span class="line"><span class="comment">-- 数值函数</span></span><br><span class="line">abs(x)            <span class="comment">-- 绝对值 abs(-10.9) = 10</span></span><br><span class="line">format(x, d)    <span class="comment">-- 格式化千分位数值 format(1234567.456, 2) = 1,234,567.46</span></span><br><span class="line">ceil(x)            <span class="comment">-- 向上取整 ceil(10.1) = 11</span></span><br><span class="line">floor(x)        <span class="comment">-- 向下取整 floor (10.1) = 10</span></span><br><span class="line">round(x)        <span class="comment">-- 四舍五入去整</span></span><br><span class="line">mod(m, n)        <span class="comment">-- m%n m mod n 求余 10%3=1</span></span><br><span class="line">pi()            <span class="comment">-- 获得圆周率</span></span><br><span class="line">pow(m, n)        <span class="comment">-- m^n</span></span><br><span class="line">sqrt(x)            <span class="comment">-- 算术平方根</span></span><br><span class="line">rand()            <span class="comment">-- 随机数</span></span><br><span class="line"><span class="keyword">truncate</span>(x, d)    <span class="comment">-- 截取d位小数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 时间日期函数</span></span><br><span class="line"><span class="keyword">now</span>(), <span class="keyword">current_timestamp</span>();     <span class="comment">-- 当前日期时间</span></span><br><span class="line">current_date();                    <span class="comment">-- 当前日期</span></span><br><span class="line">current_time();                    <span class="comment">-- 当前时间</span></span><br><span class="line">date('yyyy-mm-dd hh:ii:ss');    <span class="comment">-- 获取日期部分</span></span><br><span class="line">time('yyyy-mm-dd hh:ii:ss');    <span class="comment">-- 获取时间部分</span></span><br><span class="line">date_format('yyyy-mm-dd hh:ii:ss', '%d %y %a %d %m %b %j');    <span class="comment">-- 格式化时间</span></span><br><span class="line">unix_timestamp();                <span class="comment">-- 获得unix时间戳</span></span><br><span class="line">from_unixtime();                <span class="comment">-- 从时间戳获得时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 字符串函数</span></span><br><span class="line">length(string)            <span class="comment">-- string长度，字节</span></span><br><span class="line">char_length(string)        <span class="comment">-- string的字符个数</span></span><br><span class="line">substring(str, position [,length])        <span class="comment">-- 从str的position开始,取length个字符</span></span><br><span class="line"><span class="keyword">replace</span>(<span class="keyword">str</span> ,search_str ,replace_str)    <span class="comment">-- 在str中用replace_str替换search_str</span></span><br><span class="line"><span class="keyword">instr</span>(<span class="keyword">string</span> ,<span class="keyword">substring</span>)    <span class="comment">-- 返回substring首次在string中出现的位置</span></span><br><span class="line"><span class="keyword">concat</span>(<span class="keyword">string</span> [,...])    <span class="comment">-- 连接字串</span></span><br><span class="line"><span class="keyword">charset</span>(<span class="keyword">str</span>)            <span class="comment">-- 返回字串字符集</span></span><br><span class="line"><span class="keyword">lcase</span>(<span class="keyword">string</span>)            <span class="comment">-- 转换成小写</span></span><br><span class="line"><span class="keyword">left</span>(<span class="keyword">string</span>, <span class="keyword">length</span>)    <span class="comment">-- 从string2中的左边起取length个字符</span></span><br><span class="line"><span class="keyword">load_file</span>(file_name)    <span class="comment">-- 从文件读取内容</span></span><br><span class="line"><span class="keyword">locate</span>(<span class="keyword">substring</span>, <span class="keyword">string</span> [,start_position])    <span class="comment">-- 同instr,但可指定开始位置</span></span><br><span class="line"><span class="keyword">lpad</span>(<span class="keyword">string</span>, <span class="keyword">length</span>, <span class="keyword">pad</span>)    <span class="comment">-- 重复用pad加在string开头,直到字串长度为length</span></span><br><span class="line"><span class="keyword">ltrim</span>(<span class="keyword">string</span>)            <span class="comment">-- 去除前端空格</span></span><br><span class="line"><span class="keyword">repeat</span>(<span class="keyword">string</span>, <span class="keyword">count</span>)    <span class="comment">-- 重复count次</span></span><br><span class="line">rpad(<span class="keyword">string</span>, <span class="keyword">length</span>, <span class="keyword">pad</span>)    <span class="comment">--在str后用pad补充,直到长度为length</span></span><br><span class="line"><span class="keyword">rtrim</span>(<span class="keyword">string</span>)            <span class="comment">-- 去除后端空格</span></span><br><span class="line"><span class="keyword">strcmp</span>(string1 ,string2)    <span class="comment">-- 逐字符比较两字串大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 聚合函数</span></span><br><span class="line"><span class="keyword">count</span>()</span><br><span class="line"><span class="keyword">sum</span>();</span><br><span class="line">max();</span><br><span class="line">min();</span><br><span class="line">avg();</span><br><span class="line">group_concat()</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 其他常用函数</span></span><br><span class="line">md5();</span><br><span class="line">default();</span><br></pre></td></tr></table></figure>
<p>针对<code>count()</code>函数来说，更推荐使用<code>count(1)</code>而不是<code>count(*)</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 从含义上讲，count(1) 与 count(*) 都表示对全部数据行的查询。</span></span><br><span class="line"><span class="comment">-- count(字段) 会统计该字段在表中出现的次数，忽略字段为null 的情况。即不统计字段为null 的记录。</span></span><br><span class="line"><span class="comment">-- count(*) 包括了所有的列，相当于行数，在统计结果的时候，包含字段为null 的记录；</span></span><br><span class="line"><span class="comment">-- count(1) 用1代表代码行，在统计结果的时候，包含字段为null 的记录 。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">很多人认为count(1)执行的效率会比count(*)高，原因是count(*)会存在全表扫描，而count(1)可以针对一个字段进行查询。其实不然，count(1)和count(*)都会对全表进行扫描，统计所有记录的条数，包括那些为null的记录，因此，它们的效率可以说是相差无几。而count(字段)则与前两者不同，它会统计该字段不为null的记录条数。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">下面它们之间的一些对比：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1）在表没有主键时，count(1)比count(*)快</span></span><br><span class="line"><span class="comment">2）有主键时，主键作为计算条件，count(主键)效率最高；</span></span><br><span class="line"><span class="comment">3）若表格只有一个字段，则count(*)效率较高。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="四、事务">四、事务</h3>
<p>事务四大特性：<strong>ACID</strong></p>
<p><strong>原子性(Atomic)</strong></p>
<ul>
<li>整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（ROLLBACK）到事务开始前的状态，就像这个事务从来没有执行过一样。</li>
</ul>
<p><strong>一致性(Consist)</strong></p>
<ul>
<li>一个事务可以封装状态改变（除非它是一个只读的）。事务必须始终保持系统处于一致的状态，不管在任何给定的时间并发事务有多少。也就是说：如果事务是并发多个，系统也必须如同串行事务一样操作。其主要特征是保护性和不变性(Preserving an Invariant)，以转账案例为例，假设有五个账户，每个账户余额是100元，那么五个账户总额是500元，如果在这个5个账户之间同时发生多个转账，无论并发多少个，比如在A与B账户之间转账5元，在C与D账户之间转账10元，在B与E之间转账15元，五个账户总额也应该还是500元，这就是保护性和不变性。</li>
</ul>
<p><strong>隔离性(Isolated)</strong></p>
<ul>
<li>隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，执行相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。这种属性有时称为串行化，为了防止事务操作间的混淆，必须串行化或序列化请求，使得在同一时间仅有一个请求用于同一数据。</li>
</ul>
<p><strong>持久性(Durable)</strong></p>
<ul>
<li>在事务完成以后，该事务对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 使用set语句来改变自动提交模式</span></span><br><span class="line"><span class="keyword">SET</span> autocommit = <span class="number">0</span>;   <span class="comment">/*关闭*/</span></span><br><span class="line"><span class="keyword">SET</span> autocommit = <span class="number">1</span>;   <span class="comment">/*开启*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 注意:</span></span><br><span class="line"><span class="comment">--- 1.MySQL中默认是自动提交</span></span><br><span class="line"><span class="comment">--- 2.使用事务时应先关闭自动提交</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 开始一个事务,标记事务的起始点</span></span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 提交一个事务给数据库</span></span><br><span class="line"><span class="keyword">COMMIT</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将事务回滚,数据回到本次事务的初始状态</span></span><br><span class="line"><span class="keyword">ROLLBACK</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 还原MySQL数据库的自动提交</span></span><br><span class="line"><span class="keyword">SET</span> autocommit =<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 保存点</span></span><br><span class="line"><span class="keyword">SAVEPOINT</span> 保存点名称 <span class="comment">-- 设置一个事务保存点</span></span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> <span class="keyword">SAVEPOINT</span> 保存点名称 <span class="comment">-- 回滚到保存点</span></span><br><span class="line"><span class="keyword">RELEASE</span> <span class="keyword">SAVEPOINT</span> 保存点名称 <span class="comment">-- 删除保存点</span></span><br></pre></td></tr></table></figure>
<h3 id="五、索引">五、索引</h3>
<h4 id="1、索引概述">1、索引概述</h4>
<p><strong>索引的作用</strong></p>
<ul>
<li>提高查询速度</li>
<li>确保数据的唯一性</li>
<li>可以加速表和表之间的连接 , 实现表与表之间的参照完整性</li>
<li>使用分组和排序子句进行数据</li>
</ul>
<p><strong>索引分类</strong></p>
<ul>
<li>主键索引 (Primary Key)</li>
<li>唯一索引 (Unique)</li>
<li>常规索引 (Index)</li>
<li>全文索引 (FullText)</li>
</ul>
<h4 id="2、主键索引">2、主键索引</h4>
<p>主键 : 某一个属性组能唯一标识一条记录</p>
<p>特点 :</p>
<ul>
<li>最常见的索引类型</li>
<li>确保数据记录的唯一性</li>
<li>确定特定数据记录在数据库中的位置</li>
</ul>
<h4 id="3、唯一索引">3、唯一索引</h4>
<p>作用 : 避免同一个表中某数据列中的值重复</p>
<p>与主键索引的区别</p>
<ul>
<li>主键索引只能有一个</li>
<li>唯一索引可能有多个</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 举例</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`Grade`</span>(</span><br><span class="line">  <span class="string">`GradeID`</span> <span class="built_in">INT</span>(<span class="number">11</span>) AUTO_INCREMENT PRIMARYKEY,</span><br><span class="line">  <span class="string">`GradeName`</span> <span class="built_in">VARCHAR</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">UNIQUE</span></span><br><span class="line">   <span class="comment">-- 或 UNIQUE KEY `GradeID` (`GradeID`)</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h4 id="4、常规索引">4、常规索引</h4>
<p>作用 : 快速定位特定数据</p>
<p>注意 :</p>
<ul>
<li>index 和 key 关键字都可以设置常规索引</li>
<li>应加在查询找条件的字段</li>
<li>不宜添加太多常规索引,影响数据的插入,删除和修改操作</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`result`</span>(</span><br><span class="line">   <span class="comment">-- 省略一些代码</span></span><br><span class="line">  <span class="keyword">INDEX</span>/<span class="keyword">KEY</span> <span class="string">`ind`</span> (<span class="string">`studentNo`</span>,<span class="string">`subjectNo`</span>) <span class="comment">-- 创建表时添加</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">-- 创建后添加</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`result`</span> <span class="keyword">ADD</span> <span class="keyword">INDEX</span> <span class="string">`ind`</span>(<span class="string">`studentNo`</span>,<span class="string">`subjectNo`</span>);</span><br></pre></td></tr></table></figure>
<h4 id="5、全文索引">5、全文索引</h4>
<p>作用 : 快速定位特定数据</p>
<p>注意 :</p>
<ul>
<li>只能用于MyISAM类型的数据表</li>
<li>只能用于CHAR , VARCHAR , TEXT数据列类型</li>
<li>适合大型数据集</li>
</ul>
<h4 id="6、索引测试">6、索引测试</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 新建表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`app_user`</span> (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line"><span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'用户昵称'</span>,</span><br><span class="line"><span class="string">`email`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户邮箱'</span>,</span><br><span class="line"><span class="string">`phone`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'手机号'</span>,</span><br><span class="line"><span class="string">`gender`</span> <span class="built_in">tinyint</span>(<span class="number">4</span>) <span class="keyword">unsigned</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'性别（0:男；1：女）'</span>,</span><br><span class="line"><span class="string">`password`</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'密码'</span>,</span><br><span class="line"><span class="string">`age`</span> <span class="built_in">tinyint</span>(<span class="number">4</span>) <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'年龄'</span>,</span><br><span class="line"><span class="string">`create_time`</span> datetime <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span>,</span><br><span class="line"><span class="string">`update_time`</span> <span class="built_in">timestamp</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4 <span class="keyword">COMMENT</span>=<span class="string">'app用户表'</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 插入100w数据</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">FUNCTION</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> mock_data;</span><br><span class="line">DELIMITER $$</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> mock_data()</span><br><span class="line"><span class="keyword">RETURNS</span> <span class="built_in">INT</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> <span class="keyword">num</span> <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">1000000</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">WHILE i &lt; num DO</span><br><span class="line">  <span class="keyword">INSERT</span> <span class="keyword">INTO</span> app_user(<span class="string">`name`</span>, <span class="string">`email`</span>, <span class="string">`phone`</span>, <span class="string">`gender`</span>, <span class="string">`password`</span>, <span class="string">`age`</span>)</span><br><span class="line">   <span class="keyword">VALUES</span>(<span class="keyword">CONCAT</span>(<span class="string">'用户'</span>, i), <span class="string">'24736743@qq.com'</span>, <span class="keyword">CONCAT</span>(<span class="string">'18'</span>, <span class="keyword">FLOOR</span>(<span class="keyword">RAND</span>()*(<span class="number">999999999</span><span class="number">-100000000</span>)+<span class="number">100000000</span>)),<span class="keyword">FLOOR</span>(<span class="keyword">RAND</span>()*<span class="number">2</span>),<span class="keyword">UUID</span>(), <span class="keyword">FLOOR</span>(<span class="keyword">RAND</span>()*<span class="number">100</span>));</span><br><span class="line">  <span class="keyword">SET</span> i = i + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">WHILE</span>;</span><br><span class="line">RETURN i;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"><span class="keyword">SELECT</span> mock_data();</span><br></pre></td></tr></table></figure>
<p><strong>索引效率测试</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- CMD命令行内的语句结束符可以为 ";", "\G", "\g"，仅影响显示结果。</span></span><br><span class="line"><span class="comment">-- 无索引</span></span><br><span class="line"><span class="comment">-- 查看耗时，本地我用了6+s</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> app_user <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'用户9999'</span>; </span><br><span class="line"><span class="comment">-- 查询信息，使用EXPLAIN关键字</span></span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> app_user <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'用户9999'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 有索引时</span></span><br><span class="line"><span class="comment">-- 先创建索引，需要花一段时间</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> idx_app_user_name <span class="keyword">ON</span> app_user(<span class="keyword">name</span>);</span><br><span class="line"><span class="comment">-- 测试发现，只查了一行，速度极快</span></span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> app_user <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'用户9999'</span>;</span><br></pre></td></tr></table></figure>
<p>==注==</p>
<ul>
<li>索引不是越多越好</li>
<li>不要对经常变动的数据加索引</li>
<li>小数据量的表建议不要加索引</li>
<li>索引一般应加在查找条件的字段</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 我们可以在创建上述索引的时候，为其指定索引类型，分两类</span></span><br><span class="line">hash类型的索引：查询单条快，范围查询慢</span><br><span class="line">btree类型的索引：b+树，层数越多，数据量指数级增长（我们就用它，因为innodb默认支持它）</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 不同的存储引擎支持的索引类型也不一样</span></span><br><span class="line">InnoDB 支持事务，支持行级别锁定，支持 B-tree、Full-text 等索引，不支持 Hash 索引；</span><br><span class="line">MyISAM 不支持事务，支持表级别锁定，支持 B-tree、Full-text 等索引，不支持 Hash 索引；</span><br><span class="line">Memory 不支持事务，支持表级别锁定，支持 B-tree、Hash 等索引，不支持 Full-text 索引；</span><br><span class="line">NDB 支持事务，支持行级别锁定，支持 Hash 索引，不支持 B-tree、Full-text 等索引；</span><br><span class="line">Archive 不支持事务，支持表级别锁定，不支持 B-tree、Hash、Full-text 等索引；</span><br></pre></td></tr></table></figure>
<h3 id="六、权限管理">六、权限管理</h3>
<h4 id="1、用户管理">1、用户管理</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 用户和权限管理 */</span></span><br><span class="line">用户信息表：mysql.user</span><br><span class="line"><span class="comment">-- 刷新权限</span></span><br><span class="line"><span class="keyword">FLUSH</span> <span class="keyword">PRIVILEGES</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 增加用户 CREATE USER shawn IDENTIFIED BY 'shawn'</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> 用户名 <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> [<span class="keyword">PASSWORD</span>] 密码(字符串)</span><br><span class="line">  - 必须拥有mysql数据库的全局<span class="keyword">CREATE</span> <span class="keyword">USER</span>权限，或拥有<span class="keyword">INSERT</span>权限。</span><br><span class="line">  - 只能创建用户，不能赋予权限。</span><br><span class="line">  - 用户名，注意引号：如 <span class="string">'user_name'</span>@<span class="string">'192.168.1.1'</span></span><br><span class="line">  - 密码也需引号，纯数字密码也要加引号</span><br><span class="line">  - 要在纯文本中指定密码，需忽略<span class="keyword">PASSWORD</span>关键词。要把密码指定为由<span class="keyword">PASSWORD</span>()函数返回的混编值，需包含关键字<span class="keyword">PASSWORD</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 重命名用户 RENAME USER shawn TO shawn1</span></span><br><span class="line"><span class="keyword">RENAME</span> <span class="keyword">USER</span> old_user <span class="keyword">TO</span> new_user</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置密码</span></span><br><span class="line"><span class="comment">-- alter user'shawn'@'%' IDENTIFIED BY 'shawn'; </span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">user</span><span class="string">'用户名'</span>@<span class="string">'%'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'新密码'</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除用户 DROP USER shawn</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> 用户名</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 分配权限/添加用户</span></span><br><span class="line"><span class="comment">-- 默认是没有GRANT权限的</span></span><br><span class="line"><span class="comment">-- GRANT all privileges ON *.* TO shawn</span></span><br><span class="line"><span class="keyword">GRANT</span> 权限列表 <span class="keyword">ON</span> 表名 <span class="keyword">TO</span> 用户名 [<span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> [<span class="keyword">PASSWORD</span>] <span class="string">'password'</span>]</span><br><span class="line">  - <span class="keyword">all</span> <span class="keyword">privileges</span> 表示所有权限</span><br><span class="line">  - *.* 表示所有库的所有表</span><br><span class="line">  - 库名.表名 表示某库下面的某表</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看权限   SHOW GRANTS FOR shawn;</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GRANTS</span> <span class="keyword">FOR</span> 用户名</span><br><span class="line">   <span class="comment">-- 查看当前用户权限</span></span><br><span class="line">  <span class="keyword">SHOW</span> <span class="keyword">GRANTS</span>; 或 <span class="keyword">SHOW</span> <span class="keyword">GRANTS</span> <span class="keyword">FOR</span> <span class="keyword">CURRENT_USER</span>; 或 <span class="keyword">SHOW</span> <span class="keyword">GRANTS</span> <span class="keyword">FOR</span> <span class="keyword">CURRENT_USER</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 撤消权限</span></span><br><span class="line"><span class="comment">-- REVOKE all privileges ON *.* FROM shawn;</span></span><br><span class="line"><span class="keyword">REVOKE</span> 权限列表 <span class="keyword">ON</span> 表名 <span class="keyword">FROM</span> 用户名</span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">ALL</span> <span class="keyword">PRIVILEGES</span>, <span class="keyword">GRANT</span> <span class="keyword">OPTION</span> <span class="keyword">FROM</span> 用户名    <span class="comment">-- 撤销所有权限</span></span><br></pre></td></tr></table></figure>
<p><strong>权限解释</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 权限列表</span></span><br><span class="line">ALL [PRIVILEGES]    <span class="comment">-- 设置除GRANT OPTION之外的所有简单权限</span></span><br><span class="line"><span class="keyword">ALTER</span>    <span class="comment">-- 允许使用ALTER TABLE</span></span><br><span class="line"><span class="keyword">ALTER</span> ROUTINE    <span class="comment">-- 更改或取消已存储的子程序</span></span><br><span class="line"><span class="keyword">CREATE</span>    <span class="comment">-- 允许使用CREATE TABLE</span></span><br><span class="line"><span class="keyword">CREATE</span> ROUTINE    <span class="comment">-- 创建已存储的子程序</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TEMPORARY</span> <span class="keyword">TABLES</span>        <span class="comment">-- 允许使用CREATE TEMPORARY TABLE</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span>        <span class="comment">-- 允许使用CREATE USER, DROP USER, RENAME USER和REVOKE ALL PRIVILEGES。</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span>        <span class="comment">-- 允许使用CREATE VIEW</span></span><br><span class="line"><span class="keyword">DELETE</span>    <span class="comment">-- 允许使用DELETE</span></span><br><span class="line"><span class="keyword">DROP</span>    <span class="comment">-- 允许使用DROP TABLE</span></span><br><span class="line"><span class="keyword">EXECUTE</span>        <span class="comment">-- 允许用户运行已存储的子程序</span></span><br><span class="line"><span class="keyword">FILE</span>    <span class="comment">-- 允许使用SELECT...INTO OUTFILE和LOAD DATA INFILE</span></span><br><span class="line"><span class="keyword">INDEX</span>     <span class="comment">-- 允许使用CREATE INDEX和DROP INDEX</span></span><br><span class="line"><span class="keyword">INSERT</span>    <span class="comment">-- 允许使用INSERT</span></span><br><span class="line"><span class="keyword">LOCK</span> <span class="keyword">TABLES</span>        <span class="comment">-- 允许对您拥有SELECT权限的表使用LOCK TABLES</span></span><br><span class="line">PROCESS     <span class="comment">-- 允许使用SHOW FULL PROCESSLIST</span></span><br><span class="line"><span class="keyword">REFERENCES</span>    <span class="comment">-- 未被实施</span></span><br><span class="line">RELOAD    <span class="comment">-- 允许使用FLUSH</span></span><br><span class="line"><span class="keyword">REPLICATION</span> <span class="keyword">CLIENT</span>    <span class="comment">-- 允许用户询问从属服务器或主服务器的地址</span></span><br><span class="line"><span class="keyword">REPLICATION</span> <span class="keyword">SLAVE</span>    <span class="comment">-- 用于复制型从属服务器（从主服务器中读取二进制日志事件）</span></span><br><span class="line"><span class="keyword">SELECT</span>    <span class="comment">-- 允许使用SELECT</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">DATABASES</span>    <span class="comment">-- 显示所有数据库</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VIEW</span>    <span class="comment">-- 允许使用SHOW CREATE VIEW</span></span><br><span class="line"><span class="keyword">SHUTDOWN</span>    <span class="comment">-- 允许使用mysqladmin shutdown</span></span><br><span class="line">SUPER    <span class="comment">-- 允许使用CHANGE MASTER, KILL, PURGE MASTER LOGS和SET GLOBAL语句，mysqladmin debug命令；允许您连接（一次），即使已达到max_connections。</span></span><br><span class="line"><span class="keyword">UPDATE</span>    <span class="comment">-- 允许使用UPDATE</span></span><br><span class="line"><span class="keyword">USAGE</span>    <span class="comment">-- “无权限”的同义词</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">OPTION</span>    <span class="comment">-- 允许授予权限</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 表维护 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 分析和存储表的关键字分布</span></span><br><span class="line"><span class="keyword">ANALYZE</span> [<span class="keyword">LOCAL</span> | <span class="keyword">NO_WRITE_TO_BINLOG</span>] <span class="keyword">TABLE</span> 表名 ...</span><br><span class="line"><span class="comment">-- 检查一个或多个表是否有错误</span></span><br><span class="line"><span class="keyword">CHECK</span> <span class="keyword">TABLE</span> tbl_name [, tbl_name] ... [<span class="keyword">option</span>] ...</span><br><span class="line"><span class="keyword">option</span> = &#123;<span class="keyword">QUICK</span> | <span class="keyword">FAST</span> | <span class="keyword">MEDIUM</span> | <span class="keyword">EXTENDED</span> | <span class="keyword">CHANGED</span>&#125;</span><br><span class="line"><span class="comment">-- 整理数据文件的碎片</span></span><br><span class="line"><span class="keyword">OPTIMIZE</span> [<span class="keyword">LOCAL</span> | <span class="keyword">NO_WRITE_TO_BINLOG</span>] <span class="keyword">TABLE</span> tbl_name [, tbl_name] ...</span><br></pre></td></tr></table></figure>
<h4 id="2、MySql备份">2、MySql备份</h4>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 导出</span></span><br><span class="line">1. 导出一张表 <span class="comment">-- mysqldump -uroot -p123456 school student &gt;D:/a.sql</span></span><br><span class="line">　　mysqldump -u用户名 -p密码 库名 表名 &gt; 文件名(D:/a.sql)</span><br><span class="line">2. 导出多张表 <span class="comment">-- mysqldump -uroot -p123456 school student result &gt;D:/a.sql</span></span><br><span class="line">　　mysqldump -u用户名 -p密码 库名 表1 表2 表3 &gt; 文件名(D:/a.sql)</span><br><span class="line">3. 导出所有表 <span class="comment">-- mysqldump -uroot -p123456 school &gt;D:/a.sql</span></span><br><span class="line">　　mysqldump -u用户名 -p密码 库名 &gt; 文件名(D:/a.sql)</span><br><span class="line">4. 导出一个库 <span class="comment">-- mysqldump -uroot -p123456 -B school &gt;D:/a.sql</span></span><br><span class="line">　　mysqldump -u用户名 -p密码 -B 库名 &gt; 文件名(D:/a.sql)</span><br><span class="line"></span><br><span class="line">可以-w携带备份条件</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导入</span></span><br><span class="line">1. 在登录mysql的情况下：<span class="comment">-- source D:/a.sql</span></span><br><span class="line">　　source 备份文件</span><br><span class="line">2. 在不登录的情况下</span><br><span class="line">　　mysql -u用户名 -p密码 库名 &lt; 备份文件</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>＜img＞标签src缓存问题</title>
    <url>/posts/d39ecf00.html</url>
    <content><![CDATA[<h4 id="问题描述：">问题描述：</h4>
<p>最近在使用vue做目标检测算法可视化的时候发现了一个问题，我在前端传入原始图片到后端，经过后端算法检测后生成检测图片，前端vue直接调用该图片路径。本来想着输入不同图片，后端会不断覆盖result.jpg，最终前端也会实时变化，但是最终结果出现了意外，如图后连输入图不管如何变化，结果图都是同一张图片。</p>
<a id="more"></a>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//html部分</span></span><br><span class="line">&lt;el-image <span class="class"><span class="keyword">class</span></span>=<span class="string">"originImg"</span> :src=<span class="string">"resulturl"</span>/&gt;</span><br><span class="line"><span class="comment">//js部分</span></span><br><span class="line"><span class="keyword">this</span>.resulturl=<span class="string">"http://localhost:5000/static/images/result.jpg"</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210430142255885.png" alt="在这里插入图片描述"></p>
<h4 id="问题原因">问题原因</h4>
<p>因为src后面的请求路径不变，所以浏览器就认为是同一个图片，就不会重新发送请求，导致获得的一直是第一张缓存图片。</p>
<blockquote>
<p>浏览器缓存知识：<a href="https://www.cnblogs.com/chengxs/p/10396066.html" target="_blank" rel="noopener">https://www.cnblogs.com/chengxs/p/10396066.html</a></p>
</blockquote>
<h4 id="解决方法">解决方法</h4>
<p>因为浏览器缓存的img是根据scr属性的，只要告诉浏览器这个图片和原来的缓存图片不一样浏览器就会重新进行请求了，即在请求图片后面添加<code>&quot;?tempid=&quot;+Math.random()</code>字符串。比如我的，成功解决。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.resulturl=<span class="string">"http://localhost:5000/static/images/result.jpg?tempid="</span>+<span class="built_in">Math</span>.random();</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>SSH原理与使用</title>
    <url>/posts/ec679095.html</url>
    <content><![CDATA[<h2 id="一、SSH介绍">一、SSH介绍</h2>
<p>SSH是Secure Shell Protocol的简写，用于加密两台计算机之间的通信，并且支持各种身份验证机制。SSH先对联机数据包通过加密技术进行加密处理，加密后在进行数据传输。确保了传递的数据安全。</p>
<a id="more"></a>
<ul>
<li>SSH是安全的加密协议，用于远程连接linux服务器。</li>
<li>SSH默认端口是22，安全协议版本SSHv2，除了2之外还有SSHv1（有漏洞）。</li>
<li>SSH服务端主要包含两个服务功能SSH远程连接和SFTP服务。</li>
<li>Linux SSH客户端包含ssh远程连接命令，以及远程拷贝scp命令等。</li>
</ul>
<p>而SSH 的软件架构是服务器-客户端模式（Server - Client）。在这个架构中，SSH 软件分成两个部分：向服务器发出请求的部分，称为客户端（client），OpenSSH 的实现为 ssh；接收客户端发出的请求的部分，称为服务器（server），OpenSSH 的实现为 sshd。</p>
<h2 id="二、SSH登录">二、SSH登录</h2>
<h3 id="1、基本用法">1、基本用法</h3>
<p>SSH主要用于远程登录。假定你要以用户名user，登录远程主机host，只要一条简单命令就可以了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># user指的是你远程主机的名字，host指的是ip或者局域网的主机名</span></span><br><span class="line">ssh user@host</span><br><span class="line"><span class="comment"># 如果本地用户名与远程用户名一致，登录时可以省略用户名。</span></span><br><span class="line">ssh host</span><br><span class="line"><span class="comment">#SSH的默认端口是22，你的登录请求会送进远程主机的22端口。使用p参数，可以修改这个端口，注意端口开放。</span></span><br><span class="line">ssh -p 2222 user@hostSSH</span><br></pre></td></tr></table></figure>
<h3 id="2、口令登录">2、口令登录</h3>
<p>SSH之所以能够保证安全，原因在于它采用了公钥加密。整个过程是这样的：</p>
<ol>
<li>远程主机收到用户的登录请求，把自己的公钥发给用户。</li>
<li>用户使用这个公钥，将登录密码加密后，发送回来。</li>
<li>远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。</li>
</ol>
<p>这个过程本身是安全的，但是实施的时候存在一个风险：如果有人截获了登录请求，然后冒充远程主机，将伪造的公钥发给用户，那么用户很难辨别真伪。因为不像https协议，SSH协议的公钥是没有证书中心（CA）公证的，也就是说，都是自己签发的。可以设想，如果攻击者插在用户与远程主机之间（比如在公共的wifi区域），用伪造的公钥，获取用户的登录密码。再用这个密码登录远程主机，那么SSH的安全机制就荡然无存了。这种风险就是著名的<a href="https://baike.baidu.com/item/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/1739730?fr=aladdin" target="_blank" rel="noopener">&quot;中间人攻击&quot;</a>（Man-in-the-middle attack）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh user@host</span><br></pre></td></tr></table></figure>
<p>第一次登录对方主机，系统会出现一个警告提示，意思是无法确认远程主机的真实性，只知道它的公钥指纹，问你还想继续连接吗？经过用户的考虑后接受，之后进行口令的输入，如果密码正确，就可以登录了。当远程主机的公钥被接受以后，它就会被保存在文件<code>$HOME/.ssh/known_hosts</code>之中。下次再连接这台主机，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码。</p>
<h3 id="3、公钥登录">3、公钥登录</h3>
<p>使用密码登录，每次都必须输入密码，非常麻烦。SSH还提供了公钥登录，可以省去输入密码的步骤。</p>
<p>所谓&quot;公钥登录&quot;，原理很简单，就是用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。</p>
<p>这种方法要求用户必须提供自己的公钥。如果没有现成的，可以直接用ssh-keygen生成一个：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#程序会询问一系列问题，然后生成密钥，默认rsa算法</span></span><br><span class="line">ssh-keygen</span><br><span class="line"><span class="comment">#通常做法是使用-t参数，指定密钥的加密算法</span></span><br><span class="line">ssh-keygen -t dsa</span><br></pre></td></tr></table></figure>
<p>执行<code>ssh-keygen</code>命令以后，会出现第一个问题，询问密钥保存的文件名，默认是<code>~/.ssh/id_rsa</code>文件，这个是私钥的文件名，对应的公钥文件<code>~/.ssh/id_rsa.pub</code>是自动生成的。用户的密钥一般都放在主目录的<code>.ssh</code>目录里面。</p>
<p>生成密钥以后，公钥必须上传到服务器，才能使用公钥登录。</p>
<p><strong>手动上传公钥</strong></p>
<p>OpenSSH 规定，用户公钥保存在服务器的<code>~/.ssh/authorized_keys</code>文件。你要以哪个用户的身份登录到服务器，密钥就必须保存在该用户主目录的<code>~/.ssh/authorized_keys</code>文件。只要把公钥添加到这个文件之中，就相当于公钥上传到服务器了。每个公钥占据一行。如果该文件不存在，可以手动创建。</p>
<p><strong><code>ssh-copy-id</code>命令：自动上传公钥</strong></p>
<p>OpenSSH 自带一个<code>ssh-copy-id</code>命令，可以自动将公钥拷贝到远程服务器的<code>~/.ssh/authorized_keys</code>文件。如果<code>~/.ssh/authorized_keys</code>文件不存在，<code>ssh-copy-id</code>命令会自动创建该文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#需要把工作目录切换到~/.ssh/下</span></span><br><span class="line">ssh-copy-id -i id_rsa user@host</span><br></pre></td></tr></table></figure>
<p>上面命令中，<code>-i</code>参数用来指定公钥文件，<code>user</code>是所要登录的账户名，<code>host</code>是服务器地址。如果省略用户名，默认为当前的本机用户名。执行完该命令，公钥就会拷贝到服务器。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#SSH 就会自动采用密钥登录，不再提示输入密码。</span></span><br><span class="line">ssh user@host</span><br></pre></td></tr></table></figure>
<p>从此ssh登录，为了安全性就不需要密码登录了，具体方法就是打开服务器 sshd 的配置文件<code>/etc/ssh/sshd_config</code>，将<code>PasswordAuthentication</code>这一项设为<code>no</code>，最后重启sshd。</p>
<h2 id="三、SSH端口转发">三、SSH端口转发</h2>
<h3 id="1、动态转发">1、动态转发</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -D <span class="built_in">local</span>-port tunnel-host [-N]</span><br><span class="line"><span class="comment">#举例</span></span><br><span class="line">ssh -D 8080 user@host</span><br></pre></td></tr></table></figure>
<p>上面命令中，<code>-D</code>表示动态转发，<code>local-port</code>是本地端口，<code>tunnel-host</code>是 SSH 服务器，<code>-N</code>表示这个 SSH 连接只进行端口转发，不登录远程 Shell，不能执行远程命令，只能充当隧道。</p>
<p>SSH会建立一个socket，去监听本地的端口。一旦有数据传向那个端口，就自动把它转移到SSH连接上面，发往远程主机。可以想象，如果某个本地端口原来是一个不加密端口，现在将变成一个加密端口。</p>
<h3 id="2、本地转发">2、本地转发</h3>
<p>本地转发（local forwarding）指的是，SSH 服务器作为中介的跳板机，建立本地计算机与特定目标网站之间的加密连接。本地转发是在本地计算机的 SSH 客户端建立的转发规则。</p>
<p>它会指定一个本地端口（local-port），所有发向那个端口的请求，都会转发到 SSH 跳板机（tunnel-host），然后 SSH 跳板机作为中介，将收到的请求发到目标服务器（target-host）的目标端口（target-port）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -L <span class="built_in">local</span>-port:target-host:target-port tunnel-host [-N] [-f]</span><br></pre></td></tr></table></figure>
<p>上面命令中，<code>-L</code>参数表示本地转发，<code>local-port</code>是本地端口，<code>target-host</code>是你想要访问的目标服务器，<code>target-port</code>是目标服务器的端口，<code>tunnel-host</code>是 SSH 跳板机。<code>-N</code>参数表示不在 SSH 跳板机执行远程命令，让 SSH 只充当隧道。另外还有一个<code>-f</code>参数表示 SSH 连接在后台运行。</p>
<p>举例来说，现在有一台 SSH 跳板机<code>root@10.16.22.123</code>，我们可以通过本地访问<code>http://localhost:16006</code>即可访问到跳板机的<code>127.0.0.1:6006</code>端口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#本机运行</span></span><br><span class="line">ssh -L 16006:127.0.0.1:6006 root@10.16.22.123</span><br></pre></td></tr></table></figure>
<h3 id="3、远程端口转发">3、远程端口转发</h3>
<p>远程端口指的是在远程 SSH 服务器建立的转发规则。</p>
<p>这种场景比较特殊，主要针对内网的情况。本地计算机在外网，SSH 跳板机和目标服务器都在内网，而且本地计算机无法访问内网之中的 SSH 跳板机，但是 SSH 跳板机可以访问本机计算机。</p>
<p>由于本机无法访问内网 SSH 跳板机，就无法从外网发起 SSH 隧道，建立端口转发。必须反过来，从 SSH 跳板机发起隧道，建立端口转发，这时就形成了远程端口转发。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -R <span class="built_in">local</span>-port:target-host:target-port <span class="built_in">local</span> [-N] [-f]</span><br></pre></td></tr></table></figure>
<p>上面的命令，首先需要注意，不是在本机执行的，而是在 SSH 跳板机执行的，从跳板机去连接本地计算机。<code>-R</code>参数表示远程端口转发，<code>local-port</code>是本地计算机的端口，<code>target-host</code>和<code>target-port</code>是目标服务器(内网机器)及其端口，<code>local</code>是本地计算机。</p>
<p>举例来说，目标服务器在内网但可以访问外网，而跳板机不能直接访问内网，这时候就需要用远程端口转发，即可以直接使用跳板机访问内网</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#内网机器运行，将内网服务器的22端口转发到跳板机的2222端口</span></span><br><span class="line">ssh -R 2222:localhost:22 root@114.215.200.71 -N -f</span><br><span class="line"><span class="comment">#在跳板机进行登录，即可访问内网目标服务器，注意端口开放，以及用户名的修改，localhost不变，其中若因为网络问题断线，可以下载autossh</span></span><br><span class="line">ssh shawn@localhost -p 2222</span><br></pre></td></tr></table></figure>
<h2 id="四、SSH其他命令">四、SSH其他命令</h2>
<h3 id="1、scp命令">1、scp命令</h3>
<p><code>scp</code>是 SSH 提供的一个客户端程序，用来在两台主机之间加密传送文件（即复制文件）。<code>scp</code>主要用于以下三种复制操作：</p>
<ul>
<li>本地复制到远程。</li>
<li>远程复制到本地。</li>
<li>两个远程系统之间的复制。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#上传文件</span></span><br><span class="line">scp <span class="built_in">source</span> destination</span><br><span class="line"><span class="comment">#上传design.tar.gz到服务器/shawn目录下,也可以反过来</span></span><br><span class="line">scp design.tar.gz root@114.215.200.70:/shawn</span><br><span class="line"><span class="comment">#上传目录</span></span><br><span class="line">scp -r 目录 用户名@ip:服务器绝对路径目录</span><br></pre></td></tr></table></figure>
<h3 id="2、sftp-命令">2、sftp 命令</h3>
<p><code>sftp</code>是 SSH 提供的一个客户端应用程序，主要用来安全地访问 FTP。因为 FTP 是不加密协议，很不安全，<code>sftp</code>就相当于将 FTP 放入了 SSH。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 连接</span></span><br><span class="line">sftp username@hostname</span><br><span class="line"><span class="comment"># 本地文件传输到远程主机。</span></span><br><span class="line">put localfile</span><br><span class="line"><span class="comment"># 远程文件传输到本地。</span></span><br><span class="line">get remotefile</span><br></pre></td></tr></table></figure>
<h3 id="3、rsync-命令">3、rsync 命令</h3>
<p>rsync 是一个常用的 Linux 应用程序，用于文件同步。</p>
<hr>
<p>参考文章:</p>
<p><a href="http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html</a></p>
<p><a href="https://wangdoc.com/ssh/port-forwarding.html" target="_blank" rel="noopener">https://wangdoc.com/ssh/port-forwarding.html</a></p>
<p><a href="https://abcdabcd987.com/ssh/" target="_blank" rel="noopener">https://abcdabcd987.com/ssh/</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java多线程几种实现方式</title>
    <url>/posts/d5b482ca.html</url>
    <content><![CDATA[<h4 id="1、继承Thread类">1、继承Thread类</h4>
<blockquote>
<p>继承类必须重写 run() 方法，该方法是新线程的入口点。它也必须调用 start() 方法才能执行。该方法尽管被列为一种多线程实现方式，但是本质上也是实现了 Runnable 接口的一个实例。</p>
</blockquote>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//4.创建Thread类的子类对象</span></span><br><span class="line">        MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line">        <span class="comment">//5.开启线程</span></span><br><span class="line">        mt.setName(<span class="string">"多线程"</span>);</span><br><span class="line">        mt.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()  + i);</span><br><span class="line">            <span class="comment">// 让线程睡眠一会</span></span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.继承Thread</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 2.重写run方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//3.将要执行的代码写在run方法中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过匿名类创建</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        <span class="comment">//重写run方法,将要执行的代码写在run方法中</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">"thread"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2、实现Runnable接口">2、实现Runnable接口</h4>
<blockquote>
<p>为了实现 Runnable，一个类只需要执行一个方法调用 run()，声明如下：</p>
<p><code>public void run()</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//4,创建Runnable的子类对象</span></span><br><span class="line">        MyRunnable mr = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">        <span class="comment">//5,将其当作参数传递给Thread的构造函数</span></span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(mr,<span class="string">"myrunnable"</span>);</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()  + i);</span><br><span class="line">            <span class="comment">// 让线程睡眠一会</span></span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1,定义一个类实现Runnable</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 2.重写run方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//3.将要执行的代码写在run方法中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 内部匿名类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        <span class="comment">//1,将Runnable的子类对象传递给Thread的构造方法</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="comment">//2,重写run方法</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//3,将要执行的代码写在run方法中</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="comment">//4,开启线程</span></span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3、通过-Callable-和-Future-创建线程">3、通过 Callable 和 Future 创建线程</h4>
<ol>
<li>创建 Callable 接口的实现类，并实现 call() 方法，该 call() 方法将作为线程执行体，并且有返回值。</li>
<li>创建 Callable 实现类的实例，使用 FutureTask 类来包装 Callable 对象，该 FutureTask 对象封装了该 Callable 对象的 call() 方法的返回值。</li>
<li>使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程。</li>
<li>调用 FutureTask 对象的 get() 方法来获得子线程执行结束后的返回值。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        MyCallable mc = <span class="keyword">new</span> MyCallable(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        FutureTask&lt;Integer&gt; f = <span class="keyword">new</span> FutureTask&lt;&gt;(mc);</span><br><span class="line">        <span class="keyword">new</span> Thread(f).start();</span><br><span class="line"></span><br><span class="line">        System.out.println(f.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">    <span class="comment">//实现从1加到100并返回结果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCallable</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= number; x++) &#123;</span><br><span class="line">            sum += x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4、创建线程的三种方法对比">4、创建线程的三种方法对比</h4>
<ol>
<li>采用实现 Runnable、Callable 接口的方式创建多线程时，线程类只是实现了 Runnable 接口或 Callable 接口，还可以继承其他类。</li>
<li>使用继承 Thread 类的方式创建多线程时，编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread() 方法，直接使用 this 即可获得当前线程。</li>
</ol>
<h4 id="5、线程池">5、线程池</h4>
<p>Java中创建和销毁一个线程是比较昂贵的操作，需要系统调用。频繁创建和销毁线程会影响系统性能。于是线程池应运而生。其好处是可以抛出异常和有返回值。</p>
<ul>
<li>创建线程池对象</li>
<li>创建Runnable实例</li>
<li>提交Runnable实例</li>
<li>关闭线程池</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 提交Runnable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService pool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可以执行Runnable对象或者Callable对象代表的线程</span></span><br><span class="line">        pool.submit(<span class="keyword">new</span> MyRunnable());</span><br><span class="line">        pool.submit(<span class="keyword">new</span> MyRunnable());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//结束线程池</span></span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1,定义一个类实现Runnable</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 2.重写run方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//3.将要执行的代码写在run方法中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//提交Callable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程池对象</span></span><br><span class="line">        ExecutorService pool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可以执行Runnable对象或者Callable对象代表的线程</span></span><br><span class="line">        Future&lt;Integer&gt; f1 = pool.submit(<span class="keyword">new</span> MyCallable(<span class="number">100</span>));</span><br><span class="line">        Future&lt;Integer&gt; f2 = pool.submit(<span class="keyword">new</span> MyCallable(<span class="number">200</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// V get()</span></span><br><span class="line">        Integer i1 = f1.get();</span><br><span class="line">        Integer i2 = f2.get();</span><br><span class="line"></span><br><span class="line">        System.out.println(i1);</span><br><span class="line">        System.out.println(i2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 结束</span></span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">    <span class="comment">//实现从1加到100并返回结果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCallable</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= number; x++) &#123;</span><br><span class="line">            sum += x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>参考文章：</p>
<p><a href="https://www.runoob.com/java/java-multithreading.html" target="_blank" rel="noopener">https://www.runoob.com/java/java-multithreading.html</a></p>
<p><a href="https://blog.csdn.net/qq_40298054/article/details/87870297" target="_blank" rel="noopener">https://blog.csdn.net/qq_40298054/article/details/87870297</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch7.x学习笔记</title>
    <url>/posts/803c8798.html</url>
    <content><![CDATA[<h2 id="一、简介和下载">一、简介和下载</h2>
<h4 id="1、windows-es下载安装">1、windows es下载安装</h4>
<blockquote>
<p>**Elasticsearch(ES)**是一个基于<a href="https://zh.wikipedia.org/wiki/Lucene" target="_blank" rel="noopener">Lucene</a>库的<a href="https://zh.wikipedia.org/wiki/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E" target="_blank" rel="noopener">搜索引擎</a>。它提供了一个分布式、支持多租户的<a href="https://zh.wikipedia.org/wiki/%E5%85%A8%E6%96%87%E6%AA%A2%E7%B4%A2" target="_blank" rel="noopener">全文搜索</a>引擎，具有<a href="https://zh.wikipedia.org/wiki/HTTP" target="_blank" rel="noopener">HTTP</a> Web接口和无模式<a href="https://zh.wikipedia.org/wiki/JSON" target="_blank" rel="noopener">JSON</a>文档。Elasticsearch是用<a href="https://zh.wikipedia.org/wiki/Java" target="_blank" rel="noopener">Java</a>开发的，并在<a href="https://zh.wikipedia.org/wiki/Apache%E8%AE%B8%E5%8F%AF%E8%AF%81" target="_blank" rel="noopener">Apache许可证</a>下作为开源软件发布。Elasticsearch可以用于搜索各种文档。它提供可扩展的搜索，具有接近实时的搜索，并支持多租户。</p>
</blockquote>
<p><a href="https://elasticsearch.cn/download/" target="_blank" rel="noopener">Elasticsearch下载地址</a></p>
<a id="more"></a>
<p>这里我选择了7.10.2，并使用迅雷下载，速度还可以</p>
<p>解压后目录结构</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">bin</span> <span class="comment">#启动文件</span></span><br><span class="line"><span class="attr">config:</span></span><br><span class="line">	<span class="string">log4j2</span> <span class="comment">#日志配置文件</span></span><br><span class="line">	<span class="string">jvm.options</span> <span class="comment">#java虚拟机相关配置</span></span><br><span class="line">	<span class="string">elasticsearch.yml</span> <span class="comment">#elasticsearch的配置文件 默认9200端口</span></span><br><span class="line"><span class="string">lib</span> <span class="comment">#相关jar包</span></span><br><span class="line"><span class="string">logs</span> <span class="comment">#日志</span></span><br><span class="line"><span class="string">modules</span> <span class="comment">#功能模块</span></span><br><span class="line"><span class="string">plugins</span> <span class="comment">#插件</span></span><br></pre></td></tr></table></figure>
<p>进入bin目录双击<code>elasticsearch.bat</code>，然后访问<code>http://127.0.0.1:9200/</code>,成功出现以下json信息</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"SHAWN"</span>,</span><br><span class="line">  <span class="attr">"cluster_name"</span>: <span class="string">"elasticsearch"</span>,</span><br><span class="line">  <span class="attr">"cluster_uuid"</span>: <span class="string">"jsUcSDzlQ_W7ikv3MOWrBw"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: &#123;</span><br><span class="line">    <span class="attr">"number"</span>: <span class="string">"7.10.2"</span>,</span><br><span class="line">    <span class="attr">"build_flavor"</span>: <span class="string">"default"</span>,</span><br><span class="line">    <span class="attr">"build_type"</span>: <span class="string">"zip"</span>,</span><br><span class="line">    <span class="attr">"build_hash"</span>: <span class="string">"747e1cc71def077253878a59143c1f785afa92b9"</span>,</span><br><span class="line">    <span class="attr">"build_date"</span>: <span class="string">"2021-01-13T00:42:12.435326Z"</span>,</span><br><span class="line">    <span class="attr">"build_snapshot"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"lucene_version"</span>: <span class="string">"8.7.0"</span>,</span><br><span class="line">    <span class="attr">"minimum_wire_compatibility_version"</span>: <span class="string">"6.8.0"</span>,</span><br><span class="line">    <span class="attr">"minimum_index_compatibility_version"</span>: <span class="string">"6.0.0-beta1"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"tagline"</span>: <span class="string">"You Know, for Search"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2、可视化插件">2、可视化插件</h4>
<ol>
<li>github地址：<a href="https://github.com/mobz/elasticsearch-head%EF%BC%8C%E6%8C%89%E6%93%8D%E4%BD%9C%E8%BF%90%E8%A1%8C%E9%A1%B9%E7%9B%AE%EF%BC%9B%E8%8B%A5%E5%87%BA%E7%8E%B0%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E8%BF%9B%E8%A1%8C%E9%85%8D%E7%BD%AE" target="_blank" rel="noopener">https://github.com/mobz/elasticsearch-head，按操作运行项目；若出现跨域问题进行配置</a></li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">http.cors.enabled: true</span><br><span class="line">http.cors.allow-origin: "*"</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>google商店搜索ElasticSearch Head，安装插件</li>
</ol>
<h4 id="3、Kibana-下载与安装">3、Kibana 下载与安装</h4>
<blockquote>
<p>ELK是三个开源软件的缩写，分别表示：Elasticsearch , Logstash, Kibana , 它们都是开源软件。新增了一个FileBeat，它是一个轻量级的日志收集处理工具(Agent)，Filebeat占用资源少，适合于在各个服务器上搜集日志后传输给Logstash，官方也推荐此工具。<br>
Elasticsearch是个开源分布式搜索引擎，提供搜集、分析、存储数据三大功能。它的特点有：分布式，零配置，自动发现，索引自动分片，索引副本机制，restful风格接口，多数据源，自动搜索负载等。<br>
Logstash 主要是用来日志的搜集、分析、过滤日志的工具，支持大量的数据获取方式。一般工作方式为c/s架构，client端安装在需要收集日志的主机上，server端负责将收到的各节点日志进行过滤、修改等操作在一并发往elasticsearch上去。<br>
Kibana 也是一个开源和免费的工具，Kibana可以为 Logstash 和 ElasticSearch 提供的日志分析友好Web 界面，可以帮助汇总、分析和搜索重要数据日志。</p>
</blockquote>
<p><a href="https://elasticsearch.cn/download/" target="_blank" rel="noopener">Kibana 下载地址</a></p>
<p>注意要和ES版本一致</p>
<p>解压打开<code>bin/kibana.bat</code>浏览器<code>http://localhost:5601/</code></p>
<p>汉化，在<code>config/kibana.yml</code>下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">i18n.locale: "zh-CN"</span><br></pre></td></tr></table></figure>
<h2 id="二、核心概念">二、核心概念</h2>
<ol>
<li>索引</li>
<li>字段类型(mapping)</li>
<li>文档(documents)（倒排索引）</li>
</ol>
<h2 id="三、IK分词器">三、IK分词器</h2>
<blockquote>
<p>分词：即把一段中文或者别的划分成一个个的关键字，我们在搜索时候会把自己的信息进行分词，会把数据库中或者索引库中的数据进行分词，然后进行一个匹配操作，默认的中文分词是将每个字看成一个词，比<br>
如果要使用中文，建议使用ik分词器！</p>
</blockquote>
<p><a href="https://github.com/medcl/elasticsearch-analysis-ik" target="_blank" rel="noopener">下载安装地址</a></p>
<p>下载完成后放入es plugins中（注意版本匹配），之后重启es</p>
<p><code>ik_smart</code>最少切分，<code>ik_max_word</code>最细粒度划分，穷尽词库可能</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在Kibana 控制台进行访问</span></span><br><span class="line">GET _analyze</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"analyzer"</span>: <span class="string">"ik_smart"</span>,</span><br><span class="line">  <span class="attr">"text"</span>: <span class="string">"中国共产党"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET _analyze</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"analyzer"</span>: <span class="string">"ik_max_word"</span>,</span><br><span class="line">  <span class="attr">"text"</span>: <span class="string">"中国共产党"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>ik分词器增加自己目录</p>
</blockquote>
<p>在插件目录下<code>config/IKAnalyzer.cfg.xml</code>进行配置</p>
<h2 id="四、ES基础测试">四、ES基础测试</h2>
<h4 id="1-创建一个索引">1.创建一个索引</h4>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"># put /索引名/~类型名~/文档id</span><br><span class="line">PUT /test1/type1/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"shawn"</span>,</span><br><span class="line">  <span class="attr">"age"</span>: <span class="string">"18"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>字符串类型<br>
text、keyword</li>
<li>数值类型<br>
long，integer，short，byte，double，float，half float，scaled float</li>
<li>日期类型<br>
date</li>
<li>te布尔值类型<br>
boolean</li>
<li>二进制类型<br>
binary</li>
</ul>
<h4 id="2-映射，默认是-doc">2.映射，默认是_doc</h4>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /test2</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">    <span class="attr">"properties"</span>:&#123;</span><br><span class="line">      <span class="attr">"name"</span>:&#123;</span><br><span class="line">        <span class="attr">"type"</span>:<span class="string">"text"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"address"</span>:&#123;</span><br><span class="line">        <span class="attr">"type"</span>:<span class="string">"text"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"age"</span>:&#123;</span><br><span class="line">        <span class="attr">"type"</span>:<span class="string">"integer"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-更新-有值就更新">3.更新(有值就更新)</h4>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /test1/type1/1/_update</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"shawn"</span>,</span><br><span class="line">  <span class="attr">"age"</span>: <span class="string">"20"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4、简单查询">4、简单查询</h4>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /test1/_search?q=name:shawn</span><br></pre></td></tr></table></figure>
<h4 id="5、复杂操作搜索">5、复杂操作搜索</h4>
<p>select（排序，分页，高亮，模糊查询，精准查询！）,里面可以有很多查询操作，和mysql类似</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET test1/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"bool"</span>:&#123;</span><br><span class="line">      <span class="attr">"must"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"match"</span>: &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"shawn"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"match"</span>: &#123;</span><br><span class="line">            <span class="attr">"age"</span>: <span class="string">"18"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"_source"</span>: [<span class="string">"name"</span>,<span class="string">"age"</span>],</span><br><span class="line">  <span class="attr">"from"</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">"size"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"highlight"</span>: &#123;</span><br><span class="line">    <span class="attr">"pre_tags"</span>:<span class="string">"&lt;p class='key' style='color:red'&gt;"</span>,</span><br><span class="line">	<span class="attr">"post_tags"</span>:<span class="string">"&lt;/p&gt;"</span>,</span><br><span class="line">    <span class="attr">"fields"</span>: &#123;</span><br><span class="line">      <span class="attr">"name"</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>text</code>类型可以被分词 <code>keyword</code>不能被分词</p>
<ul>
<li>匹配</li>
<li>按照条件匹配</li>
<li>精确匹配</li>
<li>区间范围匹配</li>
<li>匹配字段过滤</li>
<li>多条件查询</li>
<li>高亮查询</li>
</ul>
<h2 id="五、springboot整合es">五、springboot整合es</h2>
<h4 id="1、引入maven依赖">1、引入maven依赖</h4>
<p>我的springboot版本是<code>2.4.2</code>，es版本是7.10.2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.elasticsearch.client&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;elasticsearch-rest-high-level-client&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;7.10.2&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.elasticsearch&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;elasticsearch&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;7.10.2&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;fastjson&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.70&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>
<h4 id="2、创建配置文件">2、创建配置文件</h4>
<p>创建<code>config/ElasticSearchConfig.java</code>配置文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElasticSearchConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">final</span> RequestOptions COMMON_OPTIONS;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        RequestOptions.Builder builder = RequestOptions.DEFAULT.toBuilder();</span><br><span class="line">        COMMON_OPTIONS = builder.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestHighLevelClient <span class="title">client</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestHighLevelClient(</span><br><span class="line">                RestClient.builder(</span><br><span class="line">                        <span class="keyword">new</span> HttpHost(<span class="string">"127.0.0.1"</span>, <span class="number">9200</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3、创建实体类">3、创建实体类</h4>
<p>创建<code>pojo/User.java</code>类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4、测试文件">4、测试文件</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoApplicationTests</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestHighLevelClient client;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试索引的创建</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testCreateIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建索引请求</span></span><br><span class="line">        CreateIndexRequest request = <span class="keyword">new</span> CreateIndexRequest(<span class="string">"shawn_index"</span>);</span><br><span class="line">        <span class="comment">// 客户端执行请求</span></span><br><span class="line">        CreateIndexResponse createIndexResponse =</span><br><span class="line">                client.indices().create(request, RequestOptions.DEFAULT);</span><br><span class="line">        System.out.println(createIndexResponse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取索引</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testExistIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        GetIndexRequest getIndexRequest = <span class="keyword">new</span> GetIndexRequest(<span class="string">"shawn_index"</span>);</span><br><span class="line">        <span class="keyword">boolean</span> exists = client.indices().exists(getIndexRequest, RequestOptions.DEFAULT);</span><br><span class="line">        System.out.println(exists);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除索引</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testDeleteIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        DeleteIndexRequest request = <span class="keyword">new</span> DeleteIndexRequest(<span class="string">"shawn_index"</span>);</span><br><span class="line">        AcknowledgedResponse delete = client.indices().delete(request, RequestOptions.DEFAULT);</span><br><span class="line">        System.out.println(delete.isAcknowledged());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加文档</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testAddDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="string">"shawn"</span>,<span class="number">18</span>);</span><br><span class="line">        <span class="comment">// 创建请求</span></span><br><span class="line">        IndexRequest request = <span class="keyword">new</span> IndexRequest(<span class="string">"shawn_index"</span>);</span><br><span class="line">        <span class="comment">// 规则</span></span><br><span class="line">        request.id(<span class="string">"1"</span>);</span><br><span class="line">        request.timeout(TimeValue.timeValueSeconds(<span class="number">1</span>));</span><br><span class="line">        request.timeout(<span class="string">"1s"</span>);</span><br><span class="line">        <span class="comment">// 将微码数据放入请求 json</span></span><br><span class="line">        request.source(JSON.toJSONString(user), XContentType.JSON);</span><br><span class="line">        <span class="comment">// 客户端发送请求</span></span><br><span class="line">        IndexResponse index = client.index(request, RequestOptions.DEFAULT);</span><br><span class="line">        System.out.println(index.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取文档</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testIsExists</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        GetRequest getRequest = <span class="keyword">new</span> GetRequest(<span class="string">"shawn_index"</span>);</span><br><span class="line">        <span class="comment">// 不获取返回的source上下文</span></span><br><span class="line">        getRequest.fetchSourceContext(<span class="keyword">new</span> FetchSourceContext(<span class="keyword">false</span>));</span><br><span class="line">        <span class="keyword">boolean</span> exists = client.exists(getRequest, RequestOptions.DEFAULT);</span><br><span class="line">        System.out.println(exists);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取文档信息</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testGetDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        GetRequest getRequest = <span class="keyword">new</span> GetRequest(<span class="string">"shawn_index"</span>,<span class="string">"1"</span>);</span><br><span class="line">        GetResponse documentFields = client.get(getRequest, RequestOptions.DEFAULT);</span><br><span class="line">        <span class="comment">// 打印文档</span></span><br><span class="line">        System.out.println(documentFields.getSourceAsString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新文档信息</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testUpdateDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        UpdateRequest request = <span class="keyword">new</span> UpdateRequest(<span class="string">"shawn_index"</span>, <span class="string">"1"</span>);</span><br><span class="line">        request.timeout(<span class="string">"1s"</span>);</span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="string">"shawn22"</span>,<span class="number">22</span>);</span><br><span class="line">        request.doc(JSON.toJSONString(user),XContentType.JSON);</span><br><span class="line">        UpdateResponse update = client.update(request, RequestOptions.DEFAULT);</span><br><span class="line">        <span class="comment">// 打印文档</span></span><br><span class="line">        System.out.println(update.status());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除文档信息</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testDeleteDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        DeleteRequest request = <span class="keyword">new</span> DeleteRequest(<span class="string">"shawn_index"</span>,<span class="string">"1"</span>);</span><br><span class="line">        DeleteResponse delete = client.delete(request, RequestOptions.DEFAULT);</span><br><span class="line">        <span class="comment">// 打印文档</span></span><br><span class="line">        System.out.println(delete.status());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//特殊的，真的项目一般都会批量插入数据！</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testBulkRequest</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        BulkRequest bulkRequest=<span class="keyword">new</span> BulkRequest();</span><br><span class="line">        bulkRequest.timeout(<span class="string">"10s"</span>);</span><br><span class="line">        ArrayList&lt;User&gt; userlist=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        userlist.add(<span class="keyword">new</span> User(<span class="string">"shawn1"</span>,<span class="number">3</span>));</span><br><span class="line">        <span class="comment">//批处理请求</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt; userlist.size();i++)&#123;</span><br><span class="line">            bulkRequest.add(</span><br><span class="line">                <span class="keyword">new</span> IndexRequest(<span class="string">"shawn_index"</span>)</span><br><span class="line">                        .id(<span class="string">""</span>+(i+<span class="number">1</span>))</span><br><span class="line">                        .source(JSON.toJSONString(userlist.get(i)),XContentType.JSON));</span><br><span class="line">        &#125;</span><br><span class="line">        BulkResponse bulk = client.bulk(bulkRequest, RequestOptions.DEFAULT);</span><br><span class="line">        System.out.println(bulk.hasFailures());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testSearch</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 构建搜索条件</span></span><br><span class="line">        SearchRequest searchRequest = <span class="keyword">new</span> SearchRequest(<span class="string">"shawn_index"</span>);</span><br><span class="line">        <span class="comment">// 查询条件</span></span><br><span class="line">        SearchSourceBuilder searchSourceBuilder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">        <span class="comment">// 匹配所有</span></span><br><span class="line">        <span class="comment">// QueryBuilders.matchAllQuery();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// termquery精确匹配</span></span><br><span class="line">        TermQueryBuilder termQueryBuilder = QueryBuilders.termQuery(<span class="string">"name"</span>, <span class="string">"shawn1"</span>);</span><br><span class="line">        searchSourceBuilder.query(termQueryBuilder);</span><br><span class="line">        searchSourceBuilder.timeout(<span class="keyword">new</span> TimeValue(<span class="number">60</span>, TimeUnit.SECONDS));</span><br><span class="line">        <span class="comment">// 分页</span></span><br><span class="line">        searchSourceBuilder.from(<span class="number">1</span>);</span><br><span class="line">        searchSourceBuilder.size(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// // 高亮</span></span><br><span class="line">        <span class="comment">// HighlightBuilder highlightBuilder = new HighlightBuilder();</span></span><br><span class="line">        <span class="comment">// highlightBuilder.field("name");</span></span><br><span class="line">        <span class="comment">// // 关闭多个高亮匹配</span></span><br><span class="line">        <span class="comment">// highlightBuilder.requireFieldMatch(false);</span></span><br><span class="line">        <span class="comment">// highlightBuilder.preTags("&lt;span style='color:red'&gt;");</span></span><br><span class="line">        <span class="comment">// highlightBuilder.postTags("&lt;/span&gt;");</span></span><br><span class="line">        <span class="comment">// searchSourceBuilder.highlighter(highlightBuilder);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行搜索</span></span><br><span class="line">        searchRequest.source(searchSourceBuilder);</span><br><span class="line">        SearchResponse searchResponse = client.search(searchRequest, RequestOptions.DEFAULT);</span><br><span class="line">        <span class="comment">// 解析结果</span></span><br><span class="line">        System.out.println(JSON.toJSONString(searchResponse.getHits()));</span><br><span class="line">        System.out.println(<span class="string">"========================="</span>);</span><br><span class="line">        <span class="keyword">for</span> (SearchHit hit : searchResponse.getHits()) &#123;</span><br><span class="line">            System.out.println(hit.getSourceAsMap());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// // 如果高亮了需要解析高亮字段</span></span><br><span class="line">        <span class="comment">// ArrayList&lt;Map&lt;String, Object&gt;&gt; list = new ArrayList&lt;&gt;();</span></span><br><span class="line">        <span class="comment">// for (SearchHit hit : searchResponse.getHits()) &#123;</span></span><br><span class="line">        <span class="comment">//     // 解析高亮</span></span><br><span class="line">        <span class="comment">//     Map&lt;String, HighlightField&gt; highlightFieldMap = hit.getHighlightFields();</span></span><br><span class="line">        <span class="comment">//     HighlightField highlightField = highlightFieldMap.get("name");</span></span><br><span class="line">        <span class="comment">//     Map&lt;String, Object&gt; sourceAsMap = hit.getSourceAsMap();</span></span><br><span class="line">        <span class="comment">//     // 替换原来的</span></span><br><span class="line">        <span class="comment">//     if(highlightField!=null)&#123;</span></span><br><span class="line">        <span class="comment">//         Text[] fragments = highlightField.fragments();</span></span><br><span class="line">        <span class="comment">//         String n_highlightField = "";</span></span><br><span class="line">        <span class="comment">//         for (Text text : fragments) &#123;</span></span><br><span class="line">        <span class="comment">//             n_highlightField += text;</span></span><br><span class="line">        <span class="comment">//         &#125;</span></span><br><span class="line">        <span class="comment">//         sourceAsMap.put("name",n_highlightField);</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     list.add(sourceAsMap);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot日志总结</title>
    <url>/posts/ece49569.html</url>
    <content><![CDATA[<p>在开发中，我们经常使用 <code>System.out.println()</code> 来打印一些信息，但是这样不好，因为大量的使用 <code>System.out</code> 会增加资源的消耗，而且部署在Linux上时只能通过日志来查看输出。我们实际项目中使用的是 <code>slf4j</code> 的 <code>logback</code> 来输出日志,<code>slf4j+logback</code>也是springboot的默认日志框架，当然<code>logback</code>也可以换成性能更好的<code>log4j2</code>框架。</p>
<a id="more"></a>
<h2 id="1-slf4j-介绍">1. slf4j 介绍</h2>
<blockquote>
<p>SLF4J，即简单日志门面（Simple Logging Facade for Java），不是具体的日志解决方案，它只服务于各种各样的日志系统。按照官方的说法，SLF4J是一个用于日志系统的简单Facade，允许最终用户在部署其应用时使用其所希望的日志系统。</p>
</blockquote>
<p>slf4j要求我们只需要按统一的方式写记录日志的代码，而无需关心日志是通过哪个日志系统，以什么风格输出的。因为它们取决于部署项目时绑定的日志系统。</p>
<p>首先需要添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--&lt;dependency&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--	&lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;/dependency&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 下面的springboot依赖已经包含上面的依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>日志的使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(Test<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">//logger.info("test");</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有一种方法通过注解方式，需要安装好Lombok插件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// log.info("test");</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-application-yml-中对日志的配置">2. application.yml 中对日志的配置</h2>
<p><code>application.yml</code> 文件是 Spring Boot 中唯一一个需要配置的文件，一开始创建工程的时候是 <code>application.properties</code> 文件(*注：同一优先级位置同时有 <code>application.properties </code>和 <code>application.yml </code>，那么 <code>application.yml</code> 里的属性会覆盖 <code>application.properties </code>里的属性)</p>
<p>这里我们对 <code>application.yml </code>文件中对日志的配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">logging:</span><br><span class="line">  config: classpath:logback.xml </span><br><span class="line">  level:</span><br><span class="line">    com.test: trace</span><br></pre></td></tr></table></figure>
<p><code>logging.config</code> 是用来指定项目启动的时候，读取哪个配置文件，这里指定的是日志配置文件是根路径下的 <code>logback.xml</code> 文件，关于日志的相关配置信息，都放在 <code>logback.xml</code> 文件中了。<code>logging.level</code> 是用来指定具体的 mapper 中日志的输出级别，上面的配置表示 <code>com.test</code> 包下的所有日志输出级别为 trace，会打印出所以debug以上信息。在生产环境上，将这个日志级别再设置成 error 级别即可。当然在 application.yml 中还可以显示定义其他例如<code>logging.pattern.console</code>等配置信息。</p>
<p>常用的日志级别按照从高到低依次为：ERROR、WARN、INFO、DEBUG。</p>
<p><em>对于classpath路径，src 路径下的文件 在编译后都会放到 WEB-INF/classes 路径下。默认classpath 就是指这里。用maven构建 项目时，resources 目录就是默认的classpath</em></p>
<h2 id="3-logback-xml-配置文件解析">3. logback.xml 配置文件解析</h2>
<p>在上面 <code>application.yml</code> 文件中，我们指定了日志配置文件 <code>logback.xml</code>，<code>logback.xml</code> 文件中主要用来做日志的相关配置。在 <code>logback.xml</code> 中，我们可以定义日志输出的格式、路径、控制台输出格式、文件大小、保存时长等等。下面来分析一下：</p>
<h3 id="3-1-定义日志输出格式和存储路径">3.1 定义日志输出格式和存储路径</h3>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"LOG_PATTERN"</span> <span class="attr">value</span>=<span class="string">"%date&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"FILE_PATH"</span> <span class="attr">value</span>=<span class="string">"D:/logs/demo.%d&#123;yyyy-MM-dd&#125;.%i.log"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">日志输出格式:</span><br><span class="line">%d表示日期时间，</span><br><span class="line">%thread表示线程名，</span><br><span class="line">%-5level :级别从左显示5个字符宽度</span><br><span class="line">%logger&#123;50&#125;表示logger名字最长50个字符,否则按照句点分割。</span><br><span class="line">%msg:日志消息，</span><br><span class="line">%n是换行符</span><br><span class="line"></span><br><span class="line">%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n</span><br></pre></td></tr></table></figure>
<p>对于“FILE_PATH” 文件路径，日志都会存储在该路径下。<code>%i</code> 表示第 i 个文件，当日志文件达到指定大小时，会将日志生成到新的文件里，这里的 i 就是文件索引，日志文件允许的大小可以设置。这里需要注意的是，不管是 windows 系统还是 Linux 系统，日志存储的路径必须要是绝对路径。</p>
<p>如果想在控制台换成彩色打印输出，可以在<code>&lt;configuration&gt;</code>里添加如下配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 彩色日志配置 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 彩色日志依赖的渲染类 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">conversionRule</span> <span class="attr">conversionWord</span>=<span class="string">"clr"</span> <span class="attr">converterClass</span>=<span class="string">"org.springframework.boot.logging.logback.ColorConverter"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">conversionRule</span> <span class="attr">conversionWord</span>=<span class="string">"wex"</span> <span class="attr">converterClass</span>=<span class="string">"org.springframework.boot.logging.logback.WhitespaceThrowableProxyConverter"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">conversionRule</span> <span class="attr">conversionWord</span>=<span class="string">"wEx"</span> <span class="attr">converterClass</span>=<span class="string">"org.springframework.boot.logging.logback.ExtendedWhitespaceThrowableProxyConverter"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 彩色日志格式 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"CONSOLE_LOG_PATTERN"</span> <span class="attr">value</span>=<span class="string">"$&#123;CONSOLE_LOG_PATTERN:-%clr(%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;)&#123;green&#125; %clr($&#123;LOG_LEVEL_PATTERN:-%5p&#125;)&#123;red&#125; %clr($&#123;PID:-&#125;)&#123;magenta&#125; %clr(---)&#123;blue&#125; %clr([%30.30t])&#123;yellow&#125; %clr(%-40.40logger&#123;39&#125;)&#123;cyan&#125; %clr(:)&#123;blue&#125; %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:-%wEx&#125;&#125;"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="3-2-定义控制台输出">3.2 定义控制台输出</h3>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"CONSOLE"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 按照上面配置的LOG_PATTERN来打印日志，若彩色打印，将pattern中名字换成彩色日志格式即可--&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">pattern</span>&gt;</span>$&#123;LOG_PATTERN&#125;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>&lt;appender&gt;</code> 节点设置个控制台输出（<code>class=&quot;ch.qos.logback.core.ConsoleAppender&quot;</code>）的配置，定义为 “CONSOLE”。使用上面定义好的输出格式（LOG_PATTERN）来输出，使用 <code>${}</code> 引用进来即可。</p>
<h3 id="3-3-定义日志文件的相关参数">3.3 定义日志文件的相关参数</h3>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"FILE"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- 按照上面配置的FILE_PATH路径来保存日志 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;FILE_PATH&#125;<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- 日志保存30天 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>30<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">timeBasedFileNamingAndTriggeringPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP"</span>&gt;</span></span><br><span class="line">				<span class="comment">&lt;!-- 单个日志文件的最大，超过则新建日志文件存储 --&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>30MB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">timeBasedFileNamingAndTriggeringPolicy</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- 按照上面配置的LOG_PATTERN来打印日志 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">pattern</span>&gt;</span>$&#123;LOG_PATTERN&#125;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>&lt;appender&gt;</code> 定义一个名为 “FILE” 的文件配置，主要是配置日志文件保存的时间、单个日志文件存储的大小、以及文件保存的路径和日志的输出格式。</p>
<h3 id="3-4-定义日志输出级别">3.4 定义日志输出级别</h3>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"com.test"</span> <span class="attr">level</span>=<span class="string">"INFO"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"INFO"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"CONSOLE"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"FILE"</span> /&gt;</span></span><br><span class="line">         <span class="comment">&lt;!--在这里可以配置多种文件输出，只需要配置好相应的appender--&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>有了上面那些定义后，最后我们使用 <code>&lt;logger&gt;</code> 来定义一下项目中默认的日志输出级别，这里定义级别为 INFO，然后针对 INFO 级别的日志，使用 <code>&lt;root&gt;</code> 引用上面定义好的控制台日志输出和日志文件的参数。这样 logback.xml 文件中的配置就设置完了。</p>
<h2 id="4-Springboot默认日志logback切换为log4j2">4.Springboot默认日志logback切换为log4j2</h2>
<h3 id="1、引入log4j2依赖，去除固有依赖">1、引入log4j2依赖，去除固有依赖</h3>
<p>首先 ，引入log4j2的starter，将logback.xml改为log4j2的配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-log4j2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后需要排除spring自带的日志框架logback依赖，如果项目中只引入了web的starter，则可以在web starter中排除掉logging</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果项目中引入的不止web starter，此时我们需要在spring-boot-starter中排除logging的依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2、配置log4j2-xml文件">2、配置<code>log4j2.xml</code>文件</h3>
<p>若自定义文件名，则需要在<code>application.yml</code>进行修改，配置文件也logback也有区别</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">logging:</span><br><span class="line">  config: classpath:log4j2_dev.xml</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="comment">&lt;!--日志级别以及优先级排序: OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt; ALL --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Configuration后面的status，这个用于设置log4j2自身内部的信息输出，可以不设置，当设置成trace时，你会看到log4j2内部各种详细输出--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--monitorInterval：Log4j能够自动检测修改配置 文件和重新配置本身，设置间隔秒数--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">monitorInterval</span>=<span class="string">"30"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--这里相当于配置变量，后面在 &lt;Appenders&gt;  标签引入 用$&#123;&#125;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Properties</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 控制台彩色日志 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"LOG_CONSOLE"</span> <span class="attr">value</span>=<span class="string">"%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; %highlight&#123;%-5level&#125; [%t] %highlight&#123;%c&#123;1.&#125;.%M(%L)&#125;: %msg%n"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">"LOG_HOME"</span> <span class="attr">value</span>=<span class="string">"logs"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--日志输出模式--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"LOG_FILE"</span> <span class="attr">value</span>=<span class="string">"%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; &#123;%-5level&#125; [%t] &#123;%c&#123;1.&#125;.%M(%L)&#125;: %msg%n"</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--日志输出文件名--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"FILE_PATH"</span> <span class="attr">value</span>=<span class="string">"lamp.%d&#123;yyyy-MM-dd&#125;.%i.log"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Appenders</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">console</span> <span class="attr">name</span>=<span class="string">"CONSOLE"</span> <span class="attr">target</span>=<span class="string">"SYSTEM_OUT"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"$&#123;LOG_CONSOLE&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">console</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--生成文件的文件名，当天生成日志 log.log ，保存其他天日志为log-%d&#123;yyyy-MM-dd&#125;.log--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">RollingFile</span> <span class="attr">name</span>=<span class="string">"FILE"</span> <span class="attr">fileName</span>=<span class="string">"$&#123;LOG_HOME&#125;/log.log"</span> <span class="attr">filePattern</span>=<span class="string">"$&#123;LOG_HOME&#125;/$&#123;FILE_PATH&#125;"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--$&#123;FILE&#125; 引入&lt;Property&gt; 标签的文件格式--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"$&#123;LOG_FILE&#125;"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Policies</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--基于时间的触发策略。该策略主要是完成周期性的log文件封存工作。有两个参数：</span></span><br><span class="line"><span class="comment">               interval，integer型，指定两次封存动作之间的时间间隔,modulate，boolean型，说明是否对封存时间进行调制。--&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--设置每天打包日志一次--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">TimeBasedTriggeringPolicy</span> <span class="attr">modulate</span>=<span class="string">"true"</span> <span class="attr">interval</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">"20 MB"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Policies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">DefaultRolloverStrategy</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--要访问的目录的最大级别数。值为0表示仅访问起始文件,2表示能访问一下两级目录--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Delete</span> <span class="attr">basePath</span>=<span class="string">"$&#123;LOG_HOME&#125;"</span> <span class="attr">maxDepth</span>=<span class="string">"2"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">IfFileName</span> <span class="attr">glob</span>=<span class="string">"$&#123;LOG_HOME&#125;/*.log"</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--删除超过十天文件--&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">IfLastModified</span> <span class="attr">age</span>=<span class="string">"30d"</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">IfFileName</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">Delete</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">DefaultRolloverStrategy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">RollingFile</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Appenders</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Loggers</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 生产环境下，将此级别配置为适合的级别，以免日志文件太多或影响程序性能 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--这里指代生效的日志级别和 输出的内容，这里代表生效的是 debug ，</span></span><br><span class="line"><span class="comment">        文件和控制台都会输出，如果是在环境留下file就可以了，file和CONSOLE 来自于 &lt;Appenders&gt; 配置的标签 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"info"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"CONSOLE"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"FILE"</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--在这里可以配置多种文件输出，只需要配置好相应的appender--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Loggers</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="3、控制台显示颜色">3、控制台显示颜色</h3>
<p>在Log4j 2.10以前的版本，pattern中配置%highlight属性是可以正常打印彩色日志的。<br>
但是是更新到2.10版本以后，控制台中就无法显示彩色日志了，各种级别的日志混杂在一起，难以阅读。Log4j2默认关闭了Jansi（一个支持输出ANSI颜色的类库）。</p>
<p><strong>操作</strong></p>
<p>IDEA中，点击右上角-&gt;Edit Configurations，在VM options中添加<code>-Dlog4j.skipJansi=false</code></p>
<hr>
<p>参考：</p>
<p><a href="https://blog.csdn.net/java821643/article/details/88753898" target="_blank" rel="noopener">https://blog.csdn.net/java821643/article/details/88753898</a></p>
<p><a href="http://logback.qos.ch/manual/index.html" target="_blank" rel="noopener">http://logback.qos.ch/manual/index.html</a></p>
<p><a href="https://blog.csdn.net/weixin_39370859/article/details/105039787" target="_blank" rel="noopener">https://blog.csdn.net/weixin_39370859/article/details/105039787</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot异步、邮件、定时任务</title>
    <url>/posts/87f335be.html</url>
    <content><![CDATA[<h2 id="一、异步任务">一、异步任务</h2>
<p>首先在service服务类上添加注解<code>@Async</code>，然后在Application启动类上添加<code>@EnableAsync</code>注解即可</p>
<a id="more"></a>
<h2 id="二、邮件任务">二、邮件任务</h2>
<h3 id="1、引入maven依赖">1、引入maven依赖</h3>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h3 id="2、配置yml文件">2、配置yml文件</h3>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mail:</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">your</span> <span class="string">username</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">your</span> <span class="string">password</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">smtp.qq.com</span></span><br><span class="line">    <span class="comment">#开启加密验证</span></span><br><span class="line">    <span class="attr">properties:</span></span><br><span class="line">      <span class="attr">mail.smtl.ssl.enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>这里需要注意开通<code>POP3/SMTP服务</code>，以QQ邮箱为例，<code>首页-&gt;设置-&gt;账户</code>找到<code>POP3/SMTP服务</code>并开启，开启后会获得一个password，而username就填你的邮箱地址</p>
<p><img src="https://img-blog.csdnimg.cn/20210315192806333.png" alt="在这里插入图片描述"></p>
<h3 id="3、编写发送邮件服务类">3、编写发送邮件服务类</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LearnApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    JavaMailSenderImpl javaMailSender;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//简单邮件</span></span><br><span class="line">        SimpleMailMessage mailMessage = <span class="keyword">new</span> SimpleMailMessage();</span><br><span class="line">        <span class="comment">//邮件主题</span></span><br><span class="line">        mailMessage.setSubject(<span class="string">"hello shawn"</span>);</span><br><span class="line">        <span class="comment">//正文</span></span><br><span class="line">        mailMessage.setText(<span class="string">"很高兴认识你"</span>);</span><br><span class="line">        <span class="comment">//接受者的邮箱地址</span></span><br><span class="line">        mailMessage.setTo(<span class="string">"xxx@qq.com"</span>);</span><br><span class="line">        <span class="comment">//发送者的邮箱地址</span></span><br><span class="line">        mailMessage.setFrom(<span class="string">"xxx@qq.com"</span>);</span><br><span class="line"></span><br><span class="line">        javaMailSender.send(mailMessage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads2</span><span class="params">()</span> <span class="keyword">throws</span> MessagingException, ParseException </span>&#123;</span><br><span class="line">        <span class="comment">//复杂邮件</span></span><br><span class="line">        MimeMessage mailMessage = javaMailSender.createMimeMessage();</span><br><span class="line">        <span class="comment">//组装</span></span><br><span class="line">        MimeMessageHelper helper = <span class="keyword">new</span> MimeMessageHelper(mailMessage,<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//邮件主题</span></span><br><span class="line">        helper.setSubject(<span class="string">"hello shawn"</span>);</span><br><span class="line">        <span class="comment">//正文，可以支持html解析</span></span><br><span class="line">        helper.setText(<span class="string">"&lt;p style='color:red'&gt;很高兴认识你&lt;p&gt;"</span>,<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//附件</span></span><br><span class="line">        helper.addAttachment(<span class="string">"1.jpg"</span>,<span class="keyword">new</span> File(<span class="string">"C:\\Users\\Shawn\\Desktop\\1.jpg"</span>));</span><br><span class="line">		 <span class="comment">//接受者的邮箱地址</span></span><br><span class="line">        helper.setTo(<span class="string">"xxx@qq.com"</span>);</span><br><span class="line">         <span class="comment">//发送者的邮箱地址</span></span><br><span class="line">        helper.setFrom(<span class="string">"xxx@qq.com"</span>);</span><br><span class="line"></span><br><span class="line">        javaMailSender.send(mailMessage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三、定时任务">三、定时任务</h2>
<p>首先在主启动类上添加<code>@EnableScheduling</code>，之后在服务类上添加<code>@Scheduled(cron=&quot;xxx&quot;)</code>，例如<code>@Scheduled(cron=&quot;0 * * * * 0-7&quot;)</code>，cron顺序分别为<code>秒，分，时，日，月，周几</code></p>
<p><a href="https://crontab.guru/" target="_blank" rel="noopener">cron在线生成网站</a></p>
<p><strong>常用表达式例子</strong></p>
<p><strong>0 0 2 1 * ? *</strong>  表示在每月的1日的凌晨2点调整任务</p>
<p><strong>0 15 10 ? * MON-FRI</strong>  表示周一到周五每天上午10:15执行作业</p>
<p><strong>0 15 10 ? 6L 2002-2006</strong>  表示2002-2006年的每个月的最后一个星期五上午10:15执行作</p>
<p><strong>0 0 10,14,16 * * ?</strong>  每天上午10点，下午2点，4点</p>
<p><strong>0 0/30 9-17 * * ?</strong>  朝九晚五工作时间内每半小时</p>
<p><strong>0 0 12 ? * WED</strong>   表示每个星期三中午12点</p>
<p><strong>0 0 12 * * ?</strong>  每天中午12点触发</p>
<p><strong>0 15 10 ? * *</strong>   每天上午10:15触发</p>
<p><strong>0 15 10 * * ?</strong>   每天上午10:15触发</p>
<p><strong>0 15 10 * * ? *</strong>   每天上午10:15触发<br>
<strong>0 15 10 * * ? 2005</strong>   2005年的每天上午10:15触发<br>
<strong>0 * 14 * * ?</strong>   在每天下午2点到下午2:59期间的每1分钟触发<br>
<strong>0 0/5 14 * * ?</strong>   在每天下午2点到下午2:55期间的每5分钟触发<br>
<strong>0 0/5 14,18 * * ?</strong>   在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发<br>
<strong>0 0-5 14 * * ?</strong>   在每天下午2点到下午2:05期间的每1分钟触发<br>
<strong>0 10,44 14 ? 3 WED</strong>   每年三月的星期三的下午2:10和2:44触发<br>
<strong>0 15 10 ? * MON-FRI</strong>   周一至周五的上午10:15触发<br>
<strong>0 15 10 15 * ?</strong>   每月15日上午10:15触发<br>
<strong>0 15 10 L * ?</strong>   每月最后一日的上午10:15触发<br>
<strong>0 15 10 ? * 6L</strong>   每月的最后一个星期五上午10:15触发<br>
<strong>0 15 10 ? * 6L 2002-2005</strong>  2002年至2005年的每月的最后一个星期五上午10:15触发<br>
<strong>0 15 10 ? * 6#3</strong>  每月的第三个星期五上午10:15触发</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>spring整合POI及EasyExcel</title>
    <url>/posts/d48f4301.html</url>
    <content><![CDATA[<h3 id="1、POI与EasyExcel介绍">1、POI与EasyExcel介绍</h3>
<p>Apache POI官网: <a href="https://poi.apache.org/" target="_blank" rel="noopener">https://poi.apache.org/</a></p>
<blockquote>
<p>Apache POI 简介是用Java编写的免费开源的跨平台的 Java API，Apache POI提供API给Java程式对Microsoft Office（Excel、WORD、PowerPoint、Visio等）格式档案读和写的功能。</p>
</blockquote>
<a id="more"></a>
<p>基本功能**(原生)</p>
<ol>
<li>HSSF – 提供读写Microsoft Excel各式档案的功能。(03版本)</li>
<li>XSSF – 提供读写Microsoft Excel OOXML各式档案的功能。(07版本)</li>
<li>HWPF – 提供读写Microsoft Word各式档案的功能。</li>
<li>HSLF – 提供读写Microsof PowerPoint格式档案的功能。</li>
<li>HDGF – 提供读写Microsoft Visio格式档案的功能。</li>
</ol>
<p>Easy Excel官方文档：<a href="https://www.yuque.com/easyexcel/doc/easyexcel" target="_blank" rel="noopener">https://www.yuque.com/easyexcel/doc/easyexcel</a></p>
<blockquote>
<p>Java解析、生成Excel比较有名的框架有Apache poi、jxl。但他们都存在一个严重的问题就是非常的耗内存，poi有一套SAX模式的API可以一定程度的解决一些内存溢出的问题，但POI还是有一些缺陷，比如07版Excel解压缩以及解压后存储都是在内存中完成的，内存消耗依然很大。easyexcel重写了poi对07版Excel的解析，能够原本一个3M的excel用POI sax依然需要100M左右内存降低到几M，并且再大的excel不会出现内存溢出，03版依赖POI的sax模式。在上层做了模型转换的封装，让使用者更加简单方便</p>
</blockquote>
<h3 id="2、POI-Excel操作">2、POI-Excel操作</h3>
<p><strong>导入maven依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--xls(03)--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.poi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>poi<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--xlsx(07)--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.poi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>poi-ooxml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--日期格式化工具--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>joda-time<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>joda-time<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.10.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.70<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>==注:== 03版本和07版本存在兼容性问题，03版本最多支持65535行</p>
<p><strong>POI-Excel写</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExcelWriteTest</span> </span>&#123;</span><br><span class="line">    String path = <span class="string">"./"</span>;</span><br><span class="line">    <span class="comment">// 基本写</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testWrite</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1、创建一个工作簿(03版本）</span></span><br><span class="line">        Workbook workbook = <span class="keyword">new</span> HSSFWorkbook();</span><br><span class="line">        <span class="comment">//07版本</span></span><br><span class="line">        <span class="comment">// Workbook workbook = new XSSFWorkbook();</span></span><br><span class="line">        <span class="comment">// 2、创建一个工作表</span></span><br><span class="line">        Sheet sheet = workbook.createSheet(<span class="string">"shawn科技"</span>);</span><br><span class="line">        <span class="comment">// 3、创建一行</span></span><br><span class="line">        Row row1 = sheet.createRow(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 4、创建一个单元格（1,1）</span></span><br><span class="line">        Cell cell11 = row1.createCell(<span class="number">0</span>);</span><br><span class="line">        cell11.setCellValue(<span class="string">"今日新增访客"</span>);</span><br><span class="line">        <span class="comment">// （1,2）</span></span><br><span class="line">        Cell cell12 = row1.createCell(<span class="number">1</span>);</span><br><span class="line">        cell12.setCellValue(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">// 第二行</span></span><br><span class="line">        Row row2 = sheet.createRow(<span class="number">1</span>);</span><br><span class="line">        Cell cell21 = row2.createCell(<span class="number">0</span>);</span><br><span class="line">        cell21.setCellValue(<span class="string">"统计时间"</span>);</span><br><span class="line">        <span class="comment">// (2,2)</span></span><br><span class="line">        Cell cell22 = row2.createCell(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 注意是joda的DateTime</span></span><br><span class="line">        String s = <span class="keyword">new</span> DateTime().toString(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">        cell22.setCellValue(s);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成一张表（IO流，03版本）</span></span><br><span class="line">        FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(path+<span class="string">"shanw科技.xls"</span>);</span><br><span class="line">        <span class="comment">// 07版本</span></span><br><span class="line">        <span class="comment">// FileOutputStream fileOutputStream = new FileOutputStream(path+"shanw科技.xlsx");</span></span><br><span class="line">        workbook.write(fileOutputStream);</span><br><span class="line">        <span class="comment">// 关闭流</span></span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">        System.out.println(<span class="string">"版本生成完毕"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//大数据写</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testWriteBigData</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 时间</span></span><br><span class="line">        <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、创建一个工作簿(03版本）</span></span><br><span class="line">        Workbook workbook = <span class="keyword">new</span> HSSFWorkbook();</span><br><span class="line">        <span class="comment">// 07版本</span></span><br><span class="line">        <span class="comment">// Workbook workbook = new XSSFWorkbook();</span></span><br><span class="line">        <span class="comment">// 07版本加速，会产生临时文件</span></span><br><span class="line">        <span class="comment">// Workbook workbook = new SXSSFWorkbook();</span></span><br><span class="line">        <span class="comment">// 2、创建一个工作表</span></span><br><span class="line">        Sheet sheet = workbook.createSheet(<span class="string">"shawn科技"</span>);</span><br><span class="line">        <span class="comment">// 写入数据，07版本没有限制，但是会比较慢</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> rowNum = <span class="number">0</span>; rowNum &lt; <span class="number">65536</span>; rowNum++)&#123;</span><br><span class="line">            Row row = sheet.createRow(rowNum);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> cellNum = <span class="number">0</span>; cellNum &lt; <span class="number">10</span>; cellNum++)&#123;</span><br><span class="line">                Cell cell = row.createCell(cellNum);</span><br><span class="line">                cell.setCellValue(cellNum);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 生成一张表（IO流，03版本）</span></span><br><span class="line">        FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(path+<span class="string">"shawn科技.xls"</span>);</span><br><span class="line">        <span class="comment">// 07版本</span></span><br><span class="line">        <span class="comment">// FileOutputStream fileOutputStream = new FileOutputStream(path+"shanw科技.xlsx");</span></span><br><span class="line">        workbook.write(fileOutputStream);</span><br><span class="line">        <span class="comment">// 关闭流</span></span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">        <span class="comment">// 如果开启了SXSSFWorkbook，清除临时文件</span></span><br><span class="line">        <span class="comment">// ((SXSSFWorkbook)workbook).dispose();</span></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"时间为"</span>+(<span class="keyword">double</span>)(end-begin)/<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>POI-Excel读</strong></p>
<p>其中表格<code>会员消费商品明细表.xls</code>内容如下</p>
<table>
<thead>
<tr>
<th>卡号</th>
<th>持卡人</th>
<th>手机号</th>
<th>消费日期</th>
<th>小票号</th>
<th>商品编号</th>
</tr>
</thead>
<tbody>
<tr>
<td>100088</td>
<td>shawn</td>
<td>12333333333</td>
<td>2021/2/22</td>
<td>0000201510200146</td>
<td>PV700012</td>
</tr>
<tr>
<td>100089</td>
<td>shawn22</td>
<td>12333333333</td>
<td>2021/2/22</td>
<td>0000201510200146</td>
<td>PV700006</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExcelReadTest</span> </span>&#123;</span><br><span class="line">    String path = <span class="string">"./"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//基本读操作</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRead</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取文件流</span></span><br><span class="line">        FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(path + <span class="string">"shawn科技.xls"</span>);</span><br><span class="line">        <span class="comment">// 创建工作簿03版本，07版本相对应变化</span></span><br><span class="line">        Workbook workbook = <span class="keyword">new</span> HSSFWorkbook(fileInputStream);</span><br><span class="line">        Sheet sheetAt = workbook.getSheetAt(<span class="number">0</span>);</span><br><span class="line">        Row row = sheetAt.getRow(<span class="number">0</span>);</span><br><span class="line">        Cell cell = row.getCell(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//类型注意</span></span><br><span class="line">        <span class="comment">// cell.getNumericCellValue();</span></span><br><span class="line">        System.out.println(cell.getStringCellValue());</span><br><span class="line">        fileInputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取内容</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCellType</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取文件流</span></span><br><span class="line">        FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(path + <span class="string">"会员消费商品明细表.xls"</span>);</span><br><span class="line">        <span class="comment">// 创建工作簿03版本，07版本相对应变化</span></span><br><span class="line">        Workbook workbook = <span class="keyword">new</span> HSSFWorkbook(fileInputStream);</span><br><span class="line">        <span class="comment">//获取标题，假设这个文件标题都在第一行</span></span><br><span class="line">        Sheet sheet = workbook.getSheetAt(<span class="number">0</span>);</span><br><span class="line">        Row rowTitle = sheet.getRow(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (rowTitle != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 重要</span></span><br><span class="line">            <span class="keyword">int</span> physicalNumberOfCells = rowTitle.getPhysicalNumberOfCells();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> cellNum = <span class="number">0</span>; cellNum &lt; physicalNumberOfCells; cellNum++) &#123;</span><br><span class="line">                Cell cell = rowTitle.getCell(cellNum);</span><br><span class="line">                <span class="keyword">if</span> (cell != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    String stringCellValue = cell.getStringCellValue();</span><br><span class="line">                    System.out.print(stringCellValue + <span class="string">"|"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取表中内容，可以封装成工具类使用，03版本和07有区别</span></span><br><span class="line">        <span class="keyword">int</span> physicalNumberOfRows = sheet.getPhysicalNumberOfRows();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> rowNum = <span class="number">1</span>; rowNum &lt; physicalNumberOfRows; rowNum++) &#123;</span><br><span class="line">            Row rowData = sheet.getRow(rowNum);</span><br><span class="line">            <span class="keyword">if</span> (rowData != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//读取列</span></span><br><span class="line">                <span class="keyword">int</span> cellCount = rowTitle.getPhysicalNumberOfCells();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> cellNum = <span class="number">0</span>; cellNum &lt; cellCount; cellNum++) &#123;</span><br><span class="line">                    System.out.print(<span class="string">"【"</span> + (rowNum + <span class="number">1</span>) + <span class="string">"-"</span> + (cellNum + <span class="number">1</span>) + <span class="string">"】"</span>);</span><br><span class="line"></span><br><span class="line">                    Cell cell = rowData.getCell(cellNum);</span><br><span class="line">                    <span class="keyword">if</span> (cell != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        CellType cellType = cell.getCellType();</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//判断单元格数据类型</span></span><br><span class="line">                        String cellValue = <span class="string">""</span>;</span><br><span class="line">                        <span class="keyword">switch</span> (cellType) &#123;</span><br><span class="line">                            <span class="keyword">case</span> STRING:<span class="comment">//字符串</span></span><br><span class="line">                                System.out.print(<span class="string">"【STRING】"</span>);</span><br><span class="line">                                cellValue = cell.getStringCellValue();</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">case</span> BOOLEAN:<span class="comment">//布尔</span></span><br><span class="line">                                System.out.print(<span class="string">"【BOOLEAN】"</span>);</span><br><span class="line">                                cellValue = String.valueOf(cell.getBooleanCellValue());</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">case</span> BLANK:<span class="comment">//空</span></span><br><span class="line">                                System.out.print(<span class="string">"【BLANK】"</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">case</span> NUMERIC:</span><br><span class="line">                                System.out.print(<span class="string">"【NUMERIC】"</span>);</span><br><span class="line">                                <span class="comment">//cellValue = String.valueOf(cell.getNumericCellValue());</span></span><br><span class="line"></span><br><span class="line">                                <span class="keyword">if</span> (DateUtil.isCellDateFormatted(cell)) &#123;<span class="comment">//日期</span></span><br><span class="line">                                    System.out.print(<span class="string">"【日期】"</span>);</span><br><span class="line">                                    Date date = cell.getDateCellValue();</span><br><span class="line">                                    cellValue = <span class="keyword">new</span> DateTime(date).toString(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    <span class="comment">// 不是日期格式，则防止当数字过长时以科学计数法显示</span></span><br><span class="line">                                    System.out.print(<span class="string">"【转换成字符串】"</span>);</span><br><span class="line">                                    cell.setCellType(CellType.STRING);</span><br><span class="line">                                    cellValue = cell.toString();</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">case</span> ERROR:</span><br><span class="line">                                System.out.print(<span class="string">"【数据类型错误】"</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        System.out.println(cellValue);</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 公式，了解</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFormula</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        InputStream is = <span class="keyword">new</span> FileInputStream(path + <span class="string">"计算公式.xls"</span>);</span><br><span class="line">        Workbook workbook = <span class="keyword">new</span> HSSFWorkbook(is);</span><br><span class="line">        Sheet sheet = workbook.getSheetAt(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 读取第五行第一列</span></span><br><span class="line">        Row row = sheet.getRow(<span class="number">4</span>);</span><br><span class="line">        Cell cell = row.getCell(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//公式计算器</span></span><br><span class="line">        FormulaEvaluator formulaEvaluator = <span class="keyword">new</span> HSSFFormulaEvaluator((HSSFWorkbook) workbook);</span><br><span class="line">        <span class="comment">// 输出单元内容</span></span><br><span class="line">        CellType cellType = cell.getCellType();</span><br><span class="line">        <span class="keyword">switch</span> (cellType) &#123;</span><br><span class="line">            <span class="keyword">case</span> FORMULA:<span class="comment">//公式</span></span><br><span class="line">                <span class="comment">//得到公式</span></span><br><span class="line">                String formula = cell.getCellFormula();</span><br><span class="line">                System.out.println(formula);</span><br><span class="line">                CellValue evaluate = formulaEvaluator.evaluate(cell);</span><br><span class="line">                <span class="comment">//String cellValue = String.valueOf(evaluate.getNumberValue());</span></span><br><span class="line">                String cellValue = evaluate.formatAsString();</span><br><span class="line">                System.out.println(cellValue);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3、EasyExcel操作">3、EasyExcel操作</h3>
<p>Easy Excel官方文档：<a href="https://www.yuque.com/easyexcel/doc/easyexcel" target="_blank" rel="noopener">https://www.yuque.com/easyexcel/doc/easyexcel</a></p>
<p>导入maven依赖，注意里面已经存在<code>poi</code>和<code>poi-ooxml</code>依赖，需要注释刚才我们自己加上去的</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>easyexcel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>读写都在文档中已详细写明</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis学习笔记</title>
    <url>/posts/5177b49d.html</url>
    <content><![CDATA[<h2 id="一、简介">一、简介</h2>
<h3 id="MyBatis是什么">MyBatis是什么</h3>
<ul>
<li>MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的<strong>持久层框架</strong>。</li>
<li>MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。</li>
<li>MyBatis 可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO（ Plain Old Java Objects，普通的Java对象）映射成数据库中的记录</li>
</ul>
<blockquote>
<p><a href="https://mybatis.org/mybatis-3/index.html" target="_blank" rel="noopener">Mabits官方文档</a></p>
</blockquote>
<a id="more"></a>
<h2 id="二、Mybatis配置">二、Mybatis配置</h2>
<h3 id="1-数据准备">1.数据准备</h3>
<p>在MySQL数据库创建一数据库实例<code>learnmybatis</code>，在其创建一张表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employee(</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">INT</span>(<span class="number">11</span>) PRIMARY <span class="keyword">KEY</span> AUTO_INCREMENT,</span><br><span class="line">	last_name <span class="built_in">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">	gender <span class="built_in">CHAR</span>(<span class="number">1</span>),</span><br><span class="line">	email <span class="built_in">VARCHAR</span>(<span class="number">255</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>创建对应的JavaBean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> Integer id;</span><br><span class="line">	<span class="keyword">private</span> String lastName;</span><br><span class="line">	<span class="keyword">private</span> String email;</span><br><span class="line">	<span class="keyword">private</span> String gender;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//getter and setter and toString()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>pom.xml中引入依赖，注意引入最新版</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>MyBatis 的配置文件包含了影响 MyBatis 行为甚深的设置（ settings）和属性（ properties）信息。文档的顶层结构如下：</p>
<ul>
<li>configuration 配置
<ul>
<li>properties 属性</li>
<li>settings 设置</li>
<li>typeAliases 类型命名</li>
<li>typeHandlers 类型处理器</li>
<li>objectFactory 对象工厂</li>
<li>plugins 插件</li>
<li>environments 环境
<ul>
<li>environment 环境变量
<ul>
<li>transactionManager 事务管理器</li>
<li>dataSource 数据源</li>
</ul>
</li>
</ul>
</li>
<li>databaseIdProvider 数据库厂商标识</li>
<li>mappers 映射器</li>
</ul>
</li>
</ul>
<p><a href="https://mybatis.org/mybatis-3/zh/configuration.html" target="_blank" rel="noopener">官方文档</a></p>
<h3 id="2-Mybatis全局配置">2.Mybatis全局配置</h3>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta"> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span></span><br><span class="line"><span class="meta"> <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"com.mysql.cj.jdbc.Driver"</span> /&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/learnmybatis?useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=UTF-8<span class="symbol">&amp;amp;</span>serverTimezone=Asia/Shanghai"</span> /&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span> /&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"root"</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 将我们写好的sql映射文件（EmployeeMapper.xml）一定要注册到全局配置文件（mybatis-config.xml）中 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--这里填写resource下的路径--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"c01/EmployeeMapper.xml"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="3-全局配置文件-properties外部引入">3.全局配置文件-properties外部引入</h3>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">		1、mybatis可以使用properties来引入外部properties配置文件的内容；</span></span><br><span class="line"><span class="comment">		resource：引入类路径下的资源</span></span><br><span class="line"><span class="comment">		url：引入网络路径或者磁盘路径下的资源</span></span><br><span class="line"><span class="comment">	  --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span> =<span class="string">"dbconfig.properties"</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在resource下中创建dbconfig.properties文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jdbc.driver&#x3D;com.mysql.cj.jdbc.Driver</span><br><span class="line">jdbc.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;learnmybatis?useUnicode&#x3D;true&amp;characterEncoding&#x3D;UTF-8&amp;serverTimezone&#x3D;Asia&#x2F;Shanghai</span><br><span class="line">jdbc.username&#x3D;root</span><br><span class="line">jdbc.password&#x3D;root</span><br></pre></td></tr></table></figure>
<h3 id="4-配置文件常用配置">4.配置文件常用配置</h3>
<ul>
<li><strong>settings-运行时行为设置</strong></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">		2、settings包含很多重要的设置项</span></span><br><span class="line"><span class="comment">		setting:用来设置每一个设置项</span></span><br><span class="line"><span class="comment">			name：设置项名</span></span><br><span class="line"><span class="comment">			value：设置项取值</span></span><br><span class="line"><span class="comment">		这里设置驼峰命名法</span></span><br><span class="line"><span class="comment">	 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"mapUnderscoreToCamelCase"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><a href="https://mybatis.org/mybatis-3/zh/configuration.html#settings" target="_blank" rel="noopener">更多设置</a></p>
<p><a href="https://mybatis.org/mybatis-3/zh/configuration.html#typeHandlers" target="_blank" rel="noopener">类型处理器</a></p>
<ul>
<li><strong>typeAliases-别名</strong></li>
</ul>
<p>类型别名可为 Java 类型设置一个缩写名字。 它仅用于 XML 配置，意在降低冗余的全限定类名书写。可以在xml配置<code>&lt;typeAliases&gt;</code>，也可以在类上加注解<code>@Alias</code>不过为了好排查，一般都写全类名。</p>
<ul>
<li><strong>enviroments-运行环境</strong>
<ul>
<li>id：指定当前环境的唯一标识</li>
<li>transactionManager、和dataSource都必须有</li>
</ul>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"dev_mysql"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"dev_mysql"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>&gt;</span><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.driver&#125;"</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<h2 id="三、Mybatis-常用操作">三、Mybatis 常用操作</h2>
<h3 id="1-基础操作">1.基础操作</h3>
<ul>
<li>cache –命名空间的二级缓存配置</li>
<li>cache-ref – 其他命名空间缓存配置的引用。</li>
<li>resultMap – 自定义结果集映射</li>
<li>parameterMap – <strong>已废弃</strong>！老式风格的参数映射</li>
<li>sql –抽取可重用语句块。</li>
<li>insert – 映射插入语句</li>
<li>update – 映射更新语句</li>
<li>delete – 映射删除语句</li>
<li>select – 映射查询语句</li>
</ul>
<p><code>EmployeeMapper.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EmployeeMapper</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">    <span class="comment">//也可以通过注解方式</span></span><br><span class="line">    <span class="comment">//@Select("select * from employee where id = #&#123;id&#125;")</span></span><br><span class="line">    <span class="comment">// @Results(&#123;</span></span><br><span class="line">    <span class="comment">//         @Result(id=true,column="id",property="id")</span></span><br><span class="line">    <span class="comment">// )&#125;</span></span><br><span class="line">    <span class="comment">// public Employee getEmpById(Integer id);</span></span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> Employee <span class="title">getEmpById</span><span class="params">(Integer id)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Long <span class="title">addEmp</span><span class="params">(Employee employee)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">updateEmp</span><span class="params">(Employee employee)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteEmpById</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>EmployeeMapper.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这里修改自己的mapper --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.lun.c03.mapper.dao.EmployeeMapper"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getEmpById"</span> <span class="attr">resultType</span>=<span class="string">"com.lun.c01.helloworld.bean.Employee"</span>&gt;</span></span><br><span class="line">		select * from employee where id = #&#123;id&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- public void addEmp(Employee employee); </span></span><br><span class="line"><span class="comment">    插入自增返回主键 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"addEmp"</span> <span class="attr">parameterType</span>=<span class="string">"com.lun.c01.helloworld.bean.Employee"</span></span></span><br><span class="line"><span class="tag">		<span class="attr">useGeneratedKeys</span>=<span class="string">"true"</span> <span class="attr">keyProperty</span>=<span class="string">"id"</span> &gt;</span></span><br><span class="line">		insert into employee(last_name,email,gender) </span><br><span class="line">		values(#&#123;lastName&#125;,#&#123;email&#125;,#&#123;gender&#125;)</span><br><span class="line">	<span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">&lt;!-- public void updateEmp(Employee employee);  --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateEmp"</span>&gt;</span></span><br><span class="line">		update employee </span><br><span class="line">		set last_name=#&#123;lastName&#125;,email=#&#123;email&#125;,gender=#&#123;gender&#125;</span><br><span class="line">		where id=#&#123;id&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">&lt;!-- public void deleteEmpById(Integer id); --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">"deleteEmpById"</span>&gt;</span></span><br><span class="line">		delete from employee where id=#&#123;id&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line">	</span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>parameterType：参数类型，可以省略，</li>
<li>获取自增主键的值：
<ul>
<li>mysql支持自增主键，自增主键值的获取，mybatis也是利用statement.getGenreatedKeys()；</li>
<li>useGeneratedKeys=“true”；使用自增主键获取主键值策略</li>
<li>keyProperty；指定对应的主键属性，也就是mybatis获取到主键值以后，将这个值封装给javaBean的哪个属性</li>
</ul>
</li>
</ul>
<h3 id="2-映射文件-参数处理">2.映射文件-参数处理</h3>
<p>4种映射文件，多个参数会被封装成 一个map</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.lun.c03.mapper.dao.EmployeeMapper"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 多个参数，不能直写id或lastName，否则抛出 org.apache.ibatis.binding.BindingException: Parameter 'id' not found. Available parameters are [1, 0, param1, param2]--&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getEmpByIdAndLastName"</span> <span class="attr">resultType</span>=<span class="string">"com.lun.c01.helloworld.bean.Employee"</span>&gt;</span></span><br><span class="line"> 		select * from tbl_employee where id = #&#123;id&#125; and last_name=#&#123;lastName&#125;</span><br><span class="line"> 	<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getEmpByIdAndLastName2"</span> <span class="attr">resultType</span>=<span class="string">"com.lun.c01.helloworld.bean.Employee"</span>&gt;</span></span><br><span class="line"> 		select * from employee where id = #&#123;0&#125; and last_name=#&#123;1&#125;</span><br><span class="line"> 	<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getEmpByIdAndLastName3"</span> <span class="attr">resultType</span>=<span class="string">"com.lun.c01.helloworld.bean.Employee"</span>&gt;</span></span><br><span class="line"> 		select * from employee where id = #&#123;param1&#125; and last_name=#&#123;param2&#125;</span><br><span class="line"> 	<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getEmpByIdAndLastName4"</span> <span class="attr">resultType</span>=<span class="string">"com.lun.c01.helloworld.bean.Employee"</span>&gt;</span></span><br><span class="line"> 		select * from employee where id = #&#123;id&#125; and last_name=#&#123;lastName&#125;</span><br><span class="line"> 	<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EmployeeMapper</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Employee <span class="title">getEmpByIdAndLastName</span><span class="params">(Integer id, String name)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Employee <span class="title">getEmpByIdAndLastName2</span><span class="params">(Integer id, String name)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Employee <span class="title">getEmpByIdAndLastName3</span><span class="params">(Integer id, String name)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Employee <span class="title">getEmpByIdAndLastName4</span><span class="params">(@Param(<span class="string">"id"</span>)</span>Integer id,@<span class="title">Param</span><span class="params">(<span class="string">"lastName"</span>)</span>String name)</span>;</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<p><strong>参数处理#{}与${}取值区别</strong></p>
<ul>
<li><code>#{}</code> : 是以预编译的形式，将参数设置到sql语句中；PreparedStatement；防止sql注入</li>
<li><code>${}</code> : 取出的值<strong>直接拼装</strong>在sql语句中；会有安全问题；</li>
</ul>
<h3 id="3-Mybatis-高级操作-一对多、多对一">3.Mybatis 高级操作(一对多、多对一)</h3>
<p><strong>select-记录封装map</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EmployeeMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//多条记录封装一个map：Map&lt;Integer,Employee&gt;:键是这条记录的主键，值是记录封装后的javaBean</span></span><br><span class="line">	<span class="comment">//@MapKey:告诉mybatis封装这个map的时候使用哪个属性作为map的key</span></span><br><span class="line">	<span class="meta">@MapKey</span>(<span class="string">"lastName"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Map&lt;String, Employee&gt; <span class="title">getEmpByLastNameLikeReturnMap</span><span class="params">(String lastName)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//返回一条记录的map；key就是列名，值就是对应的值</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getEmpByIdReturnMap</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<p><strong>select-resultMap-自定义结果映射规则</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.lun.c03.mapper.dao.EmployeeMapper"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!--自定义某个javaBean的封装规则</span></span><br><span class="line"><span class="comment">	type：自定义规则的Java类型</span></span><br><span class="line"><span class="comment">	id:唯一id方便引用</span></span><br><span class="line"><span class="comment">	  --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"com.lun.c01.helloworld.bean.Employee"</span> <span class="attr">id</span>=<span class="string">"MySimpleEmp"</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!--指定主键列的封装规则</span></span><br><span class="line"><span class="comment">		id定义主键会底层有优化；</span></span><br><span class="line"><span class="comment">		column：指定哪一列</span></span><br><span class="line"><span class="comment">		property：指定对应的javaBean属性</span></span><br><span class="line"><span class="comment">		  --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 定义普通列封装规则 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"last_name"</span> <span class="attr">property</span>=<span class="string">"lastName"</span>/&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 其他不指定的列会自动封装：我们只要写resultMap就把全部的映射规则都写上。 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"email"</span> <span class="attr">property</span>=<span class="string">"email"</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"gender"</span> <span class="attr">property</span>=<span class="string">"gender"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">&lt;!-- resultMap:自定义结果集映射规则；  --&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- public Employee getEmpById(Integer id); --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getEmpByIdWithResultMap"</span>  <span class="attr">resultMap</span>=<span class="string">"MySimpleEmp"</span>&gt;</span></span><br><span class="line">		select * from employee where id=#&#123;id&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>select-resultMap-关联查询</strong></p>
<p>新建2个实体类，并创建好数据库</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Department</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> Integer id;</span><br><span class="line">	<span class="keyword">private</span> String departmentName;</span><br><span class="line">	<span class="keyword">private</span> List&lt;Employee&gt; emps;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//getter and setter and toString()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">private</span> Department department;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="comment">//add department's getter and setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mapper.xml文件（多对一）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.lun.c03.mapper.dao.EmployeeMapper"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 联合查询：级联属性封装结果集--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"com.lun.c01.helloworld.bean.Employee"</span> <span class="attr">id</span>=<span class="string">"MyDifEmp"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"last_name"</span> <span class="attr">property</span>=<span class="string">"lastName"</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"gender"</span> <span class="attr">property</span>=<span class="string">"gender"</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"department_id"</span> <span class="attr">property</span>=<span class="string">"department.id"</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"department_name"</span> <span class="attr">property</span>=<span class="string">"department.departmentName"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!--  association可以指定联合的javaBean对象 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"com.lun.c01.helloworld.bean.Employee"</span> <span class="attr">id</span>=<span class="string">"MyDifEmp2"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"last_name"</span> <span class="attr">property</span>=<span class="string">"lastName"</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"gender"</span> <span class="attr">property</span>=<span class="string">"gender"</span>/&gt;</span></span><br><span class="line">		<span class="comment">&lt;!--  association可以指定联合的javaBean对象</span></span><br><span class="line"><span class="comment">		property="dept"：指定哪个属性是联合的对象</span></span><br><span class="line"><span class="comment">		javaType:指定这个属性对象的类型[不能省略]</span></span><br><span class="line"><span class="comment">		--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"department"</span> <span class="attr">javaType</span>=<span class="string">"com.lun.c01.helloworld.bean.Department"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"department_id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"department_name"</span> <span class="attr">property</span>=<span class="string">"departmentName"</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">	<span class="comment">&lt;!--  public Employee getEmpAndDept(Integer id);--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getEmpAndDept"</span> <span class="attr">resultMap</span>=<span class="string">"MyDifEmp"</span>&gt;</span></span><br><span class="line">		SELECT</span><br><span class="line">			e.id id,e.last_name last_name,e.gender gender,</span><br><span class="line">			e.department_id department_id, d.department_name department_name </span><br><span class="line">		FROM employee e, department d</span><br><span class="line">		WHERE e.department_id=d.id AND e.id=#&#123;id&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<p><strong>select-resultMap-关联查询-association分步查询</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.lun.c03.mapper.dao.EmployeeMapper"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- association分步查询  --&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 使用association进行分步查询：</span></span><br><span class="line"><span class="comment">		1、先按照员工id查询员工信息</span></span><br><span class="line"><span class="comment">		2、根据查询员工信息中的department_id值去部门表查出部门信息</span></span><br><span class="line"><span class="comment">		3、部门设置到员工中；</span></span><br><span class="line"><span class="comment">	 --&gt;</span></span><br><span class="line">	 <span class="comment">&lt;!--  id  last_name  email   gender    d_id   --&gt;</span></span><br><span class="line">	 <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"com.lun.c01.helloworld.bean.Employee"</span> <span class="attr">id</span>=<span class="string">"MyEmpByStep"</span>&gt;</span></span><br><span class="line">	 	<span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">	 	<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"last_name"</span> <span class="attr">property</span>=<span class="string">"lastName"</span>/&gt;</span></span><br><span class="line">	 	<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"email"</span> <span class="attr">property</span>=<span class="string">"email"</span>/&gt;</span></span><br><span class="line">	 	<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"gender"</span> <span class="attr">property</span>=<span class="string">"gender"</span>/&gt;</span></span><br><span class="line">	 	<span class="comment">&lt;!-- association定义关联对象的封装规则</span></span><br><span class="line"><span class="comment">	 		select:表明当前属性是调用select指定的方法查出的结果</span></span><br><span class="line"><span class="comment">	 		column:指定将哪一列的值传给这个方法</span></span><br><span class="line"><span class="comment">	 		</span></span><br><span class="line"><span class="comment">	 		流程：使用select指定的方法（传入column指定的这列参数的值）查出对象，并封装给property指定的属性</span></span><br><span class="line"><span class="comment">	 	 --&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"department"</span> </span></span><br><span class="line"><span class="tag">	 		<span class="attr">select</span>=<span class="string">"com.lun.c03.mapper.dao.DepartmentMapper.getDeptById"</span></span></span><br><span class="line"><span class="tag">	 		<span class="attr">column</span>=<span class="string">"department_id"</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">	 <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">	 <span class="comment">&lt;!--  public Employee getEmpByIdStep(Integer id);--&gt;</span></span><br><span class="line">	 <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getEmpByIdStep"</span> <span class="attr">resultMap</span>=<span class="string">"MyEmpByStep"</span>&gt;</span></span><br><span class="line">	 	select * from employee where id=#&#123;id&#125;</span><br><span class="line">	 <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>延迟加载</strong></p>
<p>我们每次查询Employee对象的时候，都将一起查询出来。部门信息在我们使用的时候再去查询；分段查询的基础之上加上两个配置：</p>
<p>在全局配置文件中配置，实现<strong>懒加载</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">	...</span><br><span class="line">	<span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">		...</span><br><span class="line">		<span class="comment">&lt;!--显示的指定每个我们需要更改的配置的值，即使他是默认的。防止版本更新带来的问题  --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"lazyLoadingEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"aggressiveLazyLoading"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>select-resultMap-关联查询-collection定义关联集合封装规则</strong></p>
<p>一对多</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.lun.c03.mapper.dao.DepartmentMapper"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">	public class Department &#123;</span></span><br><span class="line"><span class="comment">			private Integer id;</span></span><br><span class="line"><span class="comment">			private String departmentName;</span></span><br><span class="line"><span class="comment">			private List&lt;Employee&gt; emps;</span></span><br><span class="line"><span class="comment">	  did  dept_name  ||  eid  last_name  email   gender  </span></span><br><span class="line"><span class="comment">	 --&gt;</span></span><br><span class="line">	 </span><br><span class="line">	<span class="comment">&lt;!--嵌套结果集的方式，使用collection标签定义关联的集合类型的属性封装规则  --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"com.lun.c01.helloworld.bean.Department"</span> <span class="attr">id</span>=<span class="string">"MyDept"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"did"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"department_name"</span> <span class="attr">property</span>=<span class="string">"departmentName"</span>/&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">			collection定义关联集合类型的属性的封装规则 </span></span><br><span class="line"><span class="comment">			ofType:指定集合里面元素的类型</span></span><br><span class="line"><span class="comment">		--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"emps"</span> <span class="attr">ofType</span>=<span class="string">"com.lun.c01.helloworld.bean.Employee"</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- 定义这个集合中元素的封装规则 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"eid"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"last_name"</span> <span class="attr">property</span>=<span class="string">"lastName"</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"email"</span> <span class="attr">property</span>=<span class="string">"email"</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"gender"</span> <span class="attr">property</span>=<span class="string">"gender"</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- collection：分段查询 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"com.lun.c01.helloworld.bean.Department"</span> <span class="attr">id</span>=<span class="string">"MyDeptStep"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"department_name"</span> <span class="attr">property</span>=<span class="string">"departmentName"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--多列传值column="&#123;key1=column1,key2=column2&#125;"--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"emps"</span> </span></span><br><span class="line"><span class="tag">			<span class="attr">select</span>=<span class="string">"com.lun.c03.mapper.dao.EmployeeMapper.getEmpsByDeptId"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">column</span>=<span class="string">"id"</span>&gt;</span><span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">	<span class="comment">&lt;!-- public Department getDeptByIdPlus(Integer id); --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getDeptByIdPlus"</span> <span class="attr">resultMap</span>=<span class="string">"MyDept"</span>&gt;</span></span><br><span class="line">		SELECT d.id did,d.department_name department_name,</span><br><span class="line">				e.id eid,e.last_name last_name,</span><br><span class="line">				e.email email,e.gender gender</span><br><span class="line">		FROM department d LEFT JOIN employee e ON d.id=e.department_id</span><br><span class="line">		WHERE d.id=#&#123;id&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<p>select-resultMap-discriminator鉴别器**</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.lun.c03.mapper.dao.EmployeeMapper"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- =======================鉴别器============================ --&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- &lt;discriminator javaType=""&gt;&lt;/discriminator&gt;</span></span><br><span class="line"><span class="comment">		鉴别器：mybatis可以使用discriminator判断某列的值，然后根据某列的值改变封装行为</span></span><br><span class="line"><span class="comment">		封装Employee：</span></span><br><span class="line"><span class="comment">			如果查出的是女生：就把部门信息查询出来，否则不查询；</span></span><br><span class="line"><span class="comment">			如果是男生，把last_name这一列的值赋值给email;</span></span><br><span class="line"><span class="comment">	 --&gt;</span></span><br><span class="line">	 <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"com.lun.c01.helloworld.bean.Employee"</span> <span class="attr">id</span>=<span class="string">"MyEmpDis"</span>&gt;</span></span><br><span class="line">	 	<span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">	 	<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"last_name"</span> <span class="attr">property</span>=<span class="string">"lastName"</span>/&gt;</span></span><br><span class="line">	 	<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"email"</span> <span class="attr">property</span>=<span class="string">"email"</span>/&gt;</span></span><br><span class="line">	 	<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"gender"</span> <span class="attr">property</span>=<span class="string">"gender"</span>/&gt;</span></span><br><span class="line">	 	<span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">	 		column：指定判定的列名</span></span><br><span class="line"><span class="comment">	 		javaType：列值对应的java类型  --&gt;</span></span><br><span class="line">	 	<span class="tag">&lt;<span class="name">discriminator</span> <span class="attr">javaType</span>=<span class="string">"string"</span> <span class="attr">column</span>=<span class="string">"gender"</span>&gt;</span></span><br><span class="line">	 		<span class="comment">&lt;!--女生  resultType:指定封装的结果类型；不能缺少。/resultMap--&gt;</span></span><br><span class="line">	 		<span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">"0"</span> <span class="attr">resultType</span>=<span class="string">"com.lun.c01.helloworld.bean.Employee"</span>&gt;</span></span><br><span class="line">	 			<span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"department"</span> </span></span><br><span class="line"><span class="tag">			 		<span class="attr">select</span>=<span class="string">"com.lun.c03.mapper.dao.DepartmentMapper.getDeptById"</span></span></span><br><span class="line"><span class="tag">			 		<span class="attr">column</span>=<span class="string">"department_id"</span> <span class="attr">fetchType</span>=<span class="string">"eager"</span> &gt;</span></span><br><span class="line">		 		<span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">	 		<span class="tag">&lt;/<span class="name">case</span>&gt;</span></span><br><span class="line">	 		<span class="comment">&lt;!--男生 ;如果是男生，把last_name这一列的值赋值给email; --&gt;</span></span><br><span class="line">	 		<span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">"1"</span> <span class="attr">resultType</span>=<span class="string">"com.lun.c01.helloworld.bean.Employee"</span>&gt;</span></span><br><span class="line">		 		<span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">			 	<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"last_name"</span> <span class="attr">property</span>=<span class="string">"lastName"</span>/&gt;</span></span><br><span class="line">			 	<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"last_name"</span> <span class="attr">property</span>=<span class="string">"email"</span>/&gt;</span></span><br><span class="line">			 	<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"gender"</span> <span class="attr">property</span>=<span class="string">"gender"</span>/&gt;</span></span><br><span class="line">	 		<span class="tag">&lt;/<span class="name">case</span>&gt;</span></span><br><span class="line">	 	<span class="tag">&lt;/<span class="name">discriminator</span>&gt;</span></span><br><span class="line">	 <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	 <span class="comment">&lt;!--  public Employee getEmpByIdStep(Integer id);--&gt;</span></span><br><span class="line">	 <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getEmpsWithDiscriminator"</span> <span class="attr">resultMap</span>=<span class="string">"MyEmpDis"</span>&gt;</span></span><br><span class="line">	 	select * from employee limit 10</span><br><span class="line">	 <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="4-动态sql">4.动态sql</h3>
<p>MyBatis采用功能强大的基于 OGNL 的表达式来简化操作。</p>
<ul>
<li>if</li>
<li>choose (when, otherwise)</li>
<li>trim (where, set)</li>
<li>foreach</li>
</ul>
<p>严格来说，在XML中只有”&lt;”和”&amp;”是非法的，需要转义，其中转义字符</p>
<table>
<thead>
<tr>
<th style="text-align:center"><code>&amp;lt;</code></th>
<th style="text-align:center">&lt;</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>&amp;gt;</code></td>
<td style="text-align:center">&gt;</td>
</tr>
<tr>
<td style="text-align:center"><code>&amp;amp;</code></td>
<td style="text-align:center">&amp;</td>
</tr>
<tr>
<td style="text-align:center"><code>&amp;apos;</code></td>
<td style="text-align:center">’</td>
</tr>
<tr>
<td style="text-align:center"><code>&amp;quot;</code></td>
<td style="text-align:center">&quot;</td>
</tr>
</tbody>
</table>
<p><strong>if判断</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.lun.c04.dynamicsql.DynamicSQLMapper"</span>&gt;</span></span><br><span class="line">	 <span class="comment">&lt;!-- 查询员工，要求，携带了哪个字段查询条件就带上这个字段的值 --&gt;</span></span><br><span class="line">	 <span class="comment">&lt;!-- public List&lt;Employee&gt; getEmpsByConditionIf(Employee employee); --&gt;</span></span><br><span class="line">	 <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getEmpsByConditionIf"</span> <span class="attr">resultType</span>=<span class="string">"com.lun.c01.helloworld.bean.Employee"</span>&gt;</span></span><br><span class="line">	 	select * from employee where</span><br><span class="line">	 	<span class="comment">&lt;!-- test：判断表达式（OGNL）</span></span><br><span class="line"><span class="comment">	 	OGNL参照PPT或者官方文档。</span></span><br><span class="line"><span class="comment">	 	  	 c:if  test</span></span><br><span class="line"><span class="comment">	 	从参数中取值进行判断</span></span><br><span class="line"><span class="comment">	 	遇见特殊符号应该去写转义字符：</span></span><br><span class="line"><span class="comment">	 	&amp;&amp;：</span></span><br><span class="line"><span class="comment">	 	--&gt;</span></span><br><span class="line">	 	<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"id!=null"</span>&gt;</span></span><br><span class="line">	 		id=#&#123;id&#125;</span><br><span class="line">	 	<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">	 	<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"lastName!=null <span class="symbol">&amp;amp;</span><span class="symbol">&amp;amp;</span> lastName!=<span class="symbol">&amp;quot;</span><span class="symbol">&amp;quot;</span>"</span>&gt;</span></span><br><span class="line">	 		and last_name like #&#123;lastName&#125;</span><br><span class="line">	 	<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">	 	<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"email!=null and email.trim()!=<span class="symbol">&amp;quot;</span><span class="symbol">&amp;quot;</span>"</span>&gt;</span></span><br><span class="line">	 		and email=#&#123;email&#125;</span><br><span class="line">	 	<span class="tag">&lt;/<span class="name">if</span>&gt;</span> </span><br><span class="line">	 	<span class="comment">&lt;!-- ognl会进行字符串与数字的转换判断  "0"==0 --&gt;</span></span><br><span class="line">	 	<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"gender==0 or gender==1"</span>&gt;</span></span><br><span class="line">	 	 	and gender=#&#123;gender&#125;</span><br><span class="line">	 	<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">	 <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">		查询的时候如果某些条件没带可能sql拼装会有问题</span></span><br><span class="line"><span class="comment">		1. 给where后面加上1=1，以后的条件都and xxx。</span></span><br><span class="line"><span class="comment">		2. mybatis使用where标签来将所有的查询条件包括在内。mybatis就会将where标签中拼		装的sql，多出来的and或者or去掉（where只会去掉第一个多出来的and或者or，但最后一个		 多出来的and或者or则**不会去掉**）。</span></span><br><span class="line"><span class="comment">			--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getEmpsByConditionIfWithWhere"</span> <span class="attr">resultType</span>=<span class="string">"com.lun.c01.helloworld.bean.Employee"</span>&gt;</span></span><br><span class="line">	 	select * from employee</span><br><span class="line">	 	<span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">		 	<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"id!=null"</span>&gt;</span></span><br><span class="line">		 		id=#&#123;id&#125;</span><br><span class="line">		 	<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">		 	<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"lastName!=null <span class="symbol">&amp;amp;</span><span class="symbol">&amp;amp;</span> lastName!=<span class="symbol">&amp;quot;</span><span class="symbol">&amp;quot;</span>"</span>&gt;</span></span><br><span class="line">		 		and last_name like #&#123;lastName&#125;</span><br><span class="line">		 	<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">		 	<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"email!=null and email.trim()!=<span class="symbol">&amp;quot;</span><span class="symbol">&amp;quot;</span>"</span>&gt;</span></span><br><span class="line">		 		and email=#&#123;email&#125;</span><br><span class="line">		 	<span class="tag">&lt;/<span class="name">if</span>&gt;</span> </span><br><span class="line">		 	<span class="comment">&lt;!-- ognl会进行字符串与数字的转换判断  "0"==0 --&gt;</span></span><br><span class="line">		 	<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"gender==0 or gender==1"</span>&gt;</span></span><br><span class="line">		 	 	and gender=#&#123;gender&#125;</span><br><span class="line">		 	<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">	 	<span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">	 <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--public void updateEmp(Employee employee);  --&gt;</span></span><br><span class="line">	 <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateEmp"</span>&gt;</span></span><br><span class="line">	 	<span class="comment">&lt;!-- Set标签的使用 --&gt;</span></span><br><span class="line">	 	update employee </span><br><span class="line">		<span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"lastName!=null"</span>&gt;</span></span><br><span class="line">				last_name=#&#123;lastName&#125;,</span><br><span class="line">			<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"email!=null"</span>&gt;</span></span><br><span class="line">				email=#&#123;email&#125;,</span><br><span class="line">			<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"gender!=null"</span>&gt;</span></span><br><span class="line">				gender=#&#123;gender&#125;</span><br><span class="line">			<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">		where id=#&#123;id&#125; </span><br><span class="line">	<span class="comment">&lt;!-- 		</span></span><br><span class="line"><span class="comment">		Trim：更新拼串</span></span><br><span class="line"><span class="comment">		update tbl_employee </span></span><br><span class="line"><span class="comment">		&lt;trim prefix="set" suffixOverrides=","&gt;</span></span><br><span class="line"><span class="comment">			&lt;if test="lastName!=null"&gt;</span></span><br><span class="line"><span class="comment">				last_name=#&#123;lastName&#125;,</span></span><br><span class="line"><span class="comment">			&lt;/if&gt;</span></span><br><span class="line"><span class="comment">			&lt;if test="email!=null"&gt;</span></span><br><span class="line"><span class="comment">				email=#&#123;email&#125;,</span></span><br><span class="line"><span class="comment">			&lt;/if&gt;</span></span><br><span class="line"><span class="comment">			&lt;if test="gender!=null"&gt;</span></span><br><span class="line"><span class="comment">				gender=#&#123;gender&#125;</span></span><br><span class="line"><span class="comment">			&lt;/if&gt;</span></span><br><span class="line"><span class="comment">		&lt;/trim&gt;</span></span><br><span class="line"><span class="comment">		where id=#&#123;id&#125;  --&gt;</span></span><br><span class="line">	 <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>trim-自定义字符串截取</strong></p>
<p>后面多出的and或者or where标签不能解决</p>
<ul>
<li>prefix=&quot;&quot;:前缀：trim标签体中是整个字符串拼串后的结果。
<ul>
<li>prefix给拼串后的整个字符串加一个前缀</li>
</ul>
</li>
<li>prefixOverrides=&quot;&quot;:
<ul>
<li>前缀覆盖： 去掉整个字符串前面多余的字符</li>
</ul>
</li>
<li>suffix=&quot;&quot;:后缀
<ul>
<li>suffix给拼串后的整个字符串加一个后缀</li>
</ul>
</li>
<li>suffixOverrides=&quot;&quot;
<ul>
<li>后缀覆盖：去掉整个字符串后面多余的字符</li>
</ul>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.lun.c04.dynamicsql.DynamicSQLMapper"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	 <span class="comment">&lt;!--public List&lt;Employee&gt; getEmpsByConditionTrim(Employee employee);  --&gt;</span></span><br><span class="line">	 <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getEmpsByConditionTrim"</span> <span class="attr">resultType</span>=<span class="string">"com.lun.c01.helloworld.bean.Employee"</span>&gt;</span></span><br><span class="line">	 	select * from employee</span><br><span class="line">	 	<span class="comment">&lt;!-- 自定义字符串的截取规则 --&gt;</span></span><br><span class="line">	 	<span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">"where"</span> <span class="attr">suffixOverrides</span>=<span class="string">"and"</span>&gt;</span></span><br><span class="line">	 		<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"id!=null"</span>&gt;</span></span><br><span class="line">		 		id=#&#123;id&#125; and</span><br><span class="line">		 	<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">		 	<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"lastName!=null <span class="symbol">&amp;amp;</span><span class="symbol">&amp;amp;</span> lastName!=<span class="symbol">&amp;quot;</span><span class="symbol">&amp;quot;</span>"</span>&gt;</span></span><br><span class="line">		 		last_name like #&#123;lastName&#125; and</span><br><span class="line">		 	<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">		 	<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"email!=null and email.trim()!=<span class="symbol">&amp;quot;</span><span class="symbol">&amp;quot;</span>"</span>&gt;</span></span><br><span class="line">		 		email=#&#123;email&#125; and</span><br><span class="line">		 	<span class="tag">&lt;/<span class="name">if</span>&gt;</span> </span><br><span class="line">		 	<span class="comment">&lt;!-- ognl会进行字符串与数字的转换判断  "0"==0 --&gt;</span></span><br><span class="line">		 	<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"gender==0 or gender==1"</span>&gt;</span></span><br><span class="line">		 	 	gender=#&#123;gender&#125;</span><br><span class="line">		 	<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">		 <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line">	 <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<p><strong>choose-分支选择</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.lun.c04.dynamicsql.DynamicSQLMapper"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	 <span class="comment">&lt;!-- public List&lt;Employee&gt; getEmpsByConditionChoose(Employee employee); --&gt;</span></span><br><span class="line">	 <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getEmpsByConditionChoose"</span> <span class="attr">resultType</span>=<span class="string">"com.lun.c01.helloworld.bean.Employee"</span>&gt;</span></span><br><span class="line">	 	select * from employee </span><br><span class="line">	 	<span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">	 		<span class="comment">&lt;!-- 如果带了id就用id查，如果带了lastName就用lastName查;只会进入其中一个 --&gt;</span></span><br><span class="line">	 		<span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">	 			<span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">"id!=null"</span>&gt;</span></span><br><span class="line">	 				id=#&#123;id&#125;</span><br><span class="line">	 			<span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">	 			<span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">"lastName!=null"</span>&gt;</span></span><br><span class="line">	 				last_name like #&#123;lastName&#125;</span><br><span class="line">	 			<span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">	 			<span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">"email!=null"</span>&gt;</span></span><br><span class="line">	 				email = #&#123;email&#125;</span><br><span class="line">	 			<span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">	 			<span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">	 				gender = 0</span><br><span class="line">	 			<span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">	 		<span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line">	 	<span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">	 <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>foreach-遍历集合</strong></p>
<ul>
<li>collection：指定要遍历的集合：
<ul>
<li>list类型的参数会特殊处理封装在map中，map的key就叫list</li>
</ul>
</li>
<li>item：将当前遍历出的元素赋值给指定的变量</li>
<li>separator:每个元素之间的分隔符</li>
<li>open：遍历出所有结果拼接一个开始的字符</li>
<li>close:遍历出所有结果拼接一个结束的字符</li>
<li>index:索引。遍历list的时候是index就是索引，item就是当前值
<ul>
<li>遍历map的时候index表示的就是map的key，item就是map的值</li>
</ul>
</li>
<li><code>#{变量名}</code>就能取出变量的值也就是当前遍历出的元素</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--public List&lt;Employee&gt; getEmpsByConditionForeach(List&lt;Integer&gt; ids);  --&gt;</span></span><br><span class="line">	 <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getEmpsByConditionForeach"</span> <span class="attr">resultType</span>=<span class="string">"com.lun.c01.helloworld.bean.Employee"</span>&gt;</span></span><br><span class="line">	 	select * from employee</span><br><span class="line">	 	<span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"ids"</span> <span class="attr">item</span>=<span class="string">"item_id"</span> <span class="attr">separator</span>=<span class="string">","</span></span></span><br><span class="line"><span class="tag">	 		<span class="attr">open</span>=<span class="string">"where id in("</span> <span class="attr">close</span>=<span class="string">")"</span>&gt;</span></span><br><span class="line">	 		#&#123;item_id&#125;</span><br><span class="line">	 	<span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">	 <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!-- 批量保存 --&gt;</span></span><br><span class="line">	 <span class="comment">&lt;!--public void addEmps(@Param("emps")List&lt;Employee&gt; emps);  --&gt;</span></span><br><span class="line">	 <span class="comment">&lt;!--MySQL下批量保存：可以foreach遍历   mysql支持values(),(),()语法--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"addEmps"</span>&gt;</span></span><br><span class="line">	 	insert into employee(last_name,email,gender,department_id) </span><br><span class="line">		values</span><br><span class="line">		<span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"emps"</span> <span class="attr">item</span>=<span class="string">"emp"</span> <span class="attr">separator</span>=<span class="string">","</span>&gt;</span></span><br><span class="line">			(#&#123;emp.lastName&#125;,#&#123;emp.email&#125;,#&#123;emp.gender&#125;,#&#123;emp.department.id&#125;)</span><br><span class="line">		<span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">	 <span class="tag">&lt;/<span class="name">insert</span>&gt;</span><span class="comment">&lt;!--   --&gt;</span></span><br><span class="line">	 </span><br><span class="line">	 <span class="comment">&lt;!-- 这种方式需要数据库连接属性allowMultiQueries=true；</span></span><br><span class="line"><span class="comment">	 	这种分号分隔多个sql可以用于其他的批量操作（删除，修改） --&gt;</span></span><br><span class="line">	 <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"addEmps2"</span>&gt;</span></span><br><span class="line">	 	<span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"emps"</span> <span class="attr">item</span>=<span class="string">"emp"</span> <span class="attr">separator</span>=<span class="string">";"</span>&gt;</span></span><br><span class="line">	 		insert into employee(last_name,email,gender,department_id)</span><br><span class="line">	 		values(#&#123;emp.lastName&#125;,#&#123;emp.email&#125;,#&#123;emp.gender&#125;,#&#123;emp.department.id&#125;)</span><br><span class="line">	 	<span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">	 <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>sql-抽取可重用的sql片段</strong></p>
<p>抽取可重用的sql片段。方便后面引用：</p>
<ol>
<li>sql抽取：经常将要查询的列名，或者插入用的列名抽取出来方便引用</li>
<li>include来引用已经抽取的sql：</li>
<li>include还可以自定义一些property，sql标签内部就能使用自定义的属性
<ul>
<li>include-property：取值的正确方式${prop},</li>
<li>不能使用<code>#{}</code>，而使用<code>${}</code></li>
</ul>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">"userColumns"</span>&gt;</span> $&#123;alias&#125;.id,$&#123;alias&#125;.username,$&#123;alias&#125;.password <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectUsers"</span> <span class="attr">resultType</span>=<span class="string">"map"</span>&gt;</span></span><br><span class="line">	select</span><br><span class="line">		<span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"userColumns"</span>&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"alias"</span> <span class="attr">value</span>=<span class="string">"t1"</span>/&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span>,</span><br><span class="line">		<span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"userColumns"</span>&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"alias"</span> <span class="attr">value</span>=<span class="string">"t2"</span>/&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">	from some_table t1</span><br><span class="line">		cross join some_table t2</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">"insertColumn"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"_databaseId=='oracle'"</span>&gt;</span></span><br><span class="line">		employee_id,last_name,email</span><br><span class="line">	<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"_databaseId=='mysql'"</span>&gt;</span></span><br><span class="line">		last_name,email,gender,d_id</span><br><span class="line">	<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"addEmps"</span>&gt;</span></span><br><span class="line">	insert into tbl_employee(</span><br><span class="line">		<span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"insertColumn"</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span><span class="comment">&lt;!-- 使用地方 --&gt;</span></span><br><span class="line">	) </span><br><span class="line">	values</span><br><span class="line">	<span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"emps"</span> <span class="attr">item</span>=<span class="string">"emp"</span> <span class="attr">separator</span>=<span class="string">","</span>&gt;</span></span><br><span class="line">		(#&#123;emp.lastName&#125;,#&#123;emp.email&#125;,#&#123;emp.gender&#125;,#&#123;emp.dept.id&#125;)</span><br><span class="line">	<span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="四、缓存">四、缓存</h2>
<p><a href="https://mybatis.org/mybatis-3/zh/sqlmap-xml.html#cache" target="_blank" rel="noopener">MyBatis官方文档</a></p>
<p>MyBatis 包含一个非常强大的查询缓存特性，它可以非常方便地配置和定制。缓存可以极大的提升查询效率。</p>
<p>MyBatis系统中默认定义了两级缓存，一级缓存和二级缓存。</p>
<ol>
<li>默认情况下，只有一级缓存（ SqlSession级别的缓存，也称为本地缓存）开启。</li>
<li>二级缓存需要手动开启和配置，他是基于namespace级别的缓存。</li>
<li>为了提高扩展性。 MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存</li>
<li>对于Mabtis查询，查询过程默认是二级缓存-&gt;一级缓存-&gt;数据库</li>
</ol>
<h2 id="五、其他">五、其他</h2>
<p><code>pagehelper插件</code></p>
<p><code>Mabatis逆向工程</code></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatisPlus学习笔记</title>
    <url>/posts/9b26b051.html</url>
    <content><![CDATA[<h1>一、简介</h1>
<blockquote>
<p>Mybatis-plus官网：<a href="https://mp.baomidou.com/" target="_blank" rel="noopener">https://mp.baomidou.com/</a></p>
</blockquote>
<p>MyBatis-Plus（简称 MP）是一个 <a href="http://www.mybatis.org/mybatis-3/" target="_blank" rel="noopener">MyBatis (opens new window)</a>的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生，它具有以下特性</p>
<a id="more"></a>
<ul>
<li><strong>无侵入</strong>：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑</li>
<li><strong>损耗小</strong>：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作</li>
<li><strong>强大的 CRUD 操作</strong>：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求</li>
<li><strong>支持 Lambda 形式调用</strong>：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错</li>
<li><strong>支持主键自动生成</strong>：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题</li>
<li><strong>支持 ActiveRecord 模式</strong>：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作</li>
<li><strong>支持自定义全局通用操作</strong>：支持全局通用方法注入（ Write once, use anywhere ）</li>
<li><strong>内置代码生成器</strong>：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用</li>
<li><strong>内置分页插件</strong>：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询</li>
<li><strong>分页插件支持多种数据库</strong>：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库</li>
<li><strong>内置性能分析插件</strong>：可输出 Sql 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询</li>
<li><strong>内置全局拦截插件</strong>：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作</li>
</ul>
<h1>二、快速入门</h1>
<p>首先在数据库创建ssmdemo数据库，运行sql语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="keyword">user</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">user</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'主键ID'</span>,</span><br><span class="line"><span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">30</span>) <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'姓名'</span>,</span><br><span class="line">age <span class="built_in">INT</span>(<span class="number">11</span>) <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'年龄'</span>,</span><br><span class="line">email <span class="built_in">VARCHAR</span>(<span class="number">50</span>) <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'邮箱'</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> (<span class="keyword">id</span>, <span class="keyword">name</span>, age, email) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">1</span>, <span class="string">'Jone'</span>, <span class="number">18</span>, <span class="string">'test1@baomidou.com'</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="string">'Jack'</span>, <span class="number">20</span>, <span class="string">'test2@baomidou.com'</span>),</span><br><span class="line">(<span class="number">3</span>, <span class="string">'Tom'</span>, <span class="number">28</span>, <span class="string">'test3@baomidou.com'</span>),</span><br><span class="line">(<span class="number">4</span>, <span class="string">'Sandy'</span>, <span class="number">21</span>, <span class="string">'test4@baomidou.com'</span>),</span><br><span class="line">(<span class="number">5</span>, <span class="string">'Billie'</span>, <span class="number">24</span>, <span class="string">'test5@baomidou.com'</span>);</span><br><span class="line"><span class="comment">-- 真实开发中，version（乐观锁）、deleted（逻辑删除）、gmt_create、gmt_modified</span></span><br></pre></td></tr></table></figure>
<p>创建springboot项目，引入依赖文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 数据库驱动 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- lombok --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- mybatis-plus --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- mybatis-plus 是自己开发，并非官方的！ --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在resource资源路径下<code>application.yml</code>中配置，其中配置日志为了显示具体mabatis日志输出</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mysql 5 驱动不同 com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="comment"># mysql 8 驱动不同com.mysql.cj.jdbc.Driver、需要增加时区的配置</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/ssmdemo?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=GMT%2B8</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置日志</span></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br></pre></td></tr></table></figure>
<p>创建po实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建mapper类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 所有的CRUD操作都已经编写完成了</span></span><br><span class="line">    <span class="comment">// 你不需要像以前的配置一大堆文件了！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>在主启动类上扫描我们的mapper包下的所有接口(十分重要)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MapperScan</span>(<span class="string">"com.mybatis.demo.mapper"</span>)</span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DemoApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后在测试类中测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MybatisPlusApplicationTests</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 继承了BaseMapper，所有的方法都来自己父类</span></span><br><span class="line">    <span class="comment">// 我们也可以编写自己的扩展方法！</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 参数是一个 Wrapper ，条件构造器，这里我们先不用 null</span></span><br><span class="line">    <span class="comment">// 查询全部用户</span></span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(<span class="keyword">null</span>);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 测试插入</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsert</span><span class="params">()</span></span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setName(<span class="string">"test"</span>);</span><br><span class="line">        user.setAge(<span class="number">3</span>);</span><br><span class="line">        user.setEmail(<span class="string">"24736743@qq.com"</span>);</span><br><span class="line">        <span class="keyword">int</span> result = userMapper.insert(user); <span class="comment">// 帮我们自动生成id</span></span><br><span class="line">        System.out.println(result); <span class="comment">// 受影响的行数</span></span><br><span class="line">        System.out.println(user); <span class="comment">// 发现，id会自动回填</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">// 测试更新</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        <span class="comment">// 通过条件自动拼接动态sql</span></span><br><span class="line">        user.setId(<span class="number">5L</span>);</span><br><span class="line">        user.setName(<span class="string">"123456"</span>);</span><br><span class="line">        user.setAge(<span class="number">18</span>);</span><br><span class="line">        <span class="comment">// 注意：updateById 但是参数是一个 对象！</span></span><br><span class="line">        <span class="keyword">int</span> i = userMapper.updateById(user);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>三、CRUD扩展</h1>
<h2 id="1、主键生成策略">1、主键生成策略</h2>
<p>实体类字段上 <code>@TableId(type = IdType.xxx)</code>，其中IdTyoe的枚举类型如下</p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>AUTO</td>
<td>数据库ID自增</td>
</tr>
<tr>
<td>NONE</td>
<td>无状态,该类型为未设置主键类型(注解里等于跟随全局,全局里约等于 INPUT)</td>
</tr>
<tr>
<td>INPUT</td>
<td>insert前自行set主键值</td>
</tr>
<tr>
<td>ASSIGN_ID</td>
<td>分配ID(主键类型为Number(Long和Integer)或String)(since 3.3.0),使用接口<code>IdentifierGenerator</code>的方法<code>nextId</code>(默认实现类为<code>DefaultIdentifierGenerator</code>雪花算法)</td>
</tr>
<tr>
<td>ASSIGN_UUID</td>
<td>分配UUID,主键类型为String(since 3.3.0),使用接口<code>IdentifierGenerator</code>的方法<code>nextUUID</code>(默认default方法)</td>
</tr>
</tbody>
</table>
<p><strong>雪花算法：</strong><br>
snowflake是Twitter开源的分布式ID生成算法，结果是一个long型的ID。其核心思想是：使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID），最后还有一个符号位，永远是0。可以保证几乎全球唯一！</p>
<p><strong>主键自增</strong></p>
<ol>
<li>实体类字段上 <code>@TableId(type = IdType.AUTO)</code></li>
<li>数据库字段一定要是自增！</li>
</ol>
<h2 id="2、自动填充">2、自动填充</h2>
<blockquote>
<p>创建时间、修改时间！这些个操作一遍都是自动化完成的，我们不希望手动更新！</p>
</blockquote>
<h3 id="2-1-数据库级别（工作中不允许修改数据库）">2.1 <strong>数据库级别</strong>（工作中不允许修改数据库）</h3>
<ul>
<li>首先在MySql数据库中添加两个字段<code>create_time</code>和<code>update_time</code>，同时设置默认值为<code>根据当前时间戳更新</code></li>
<li>在实体类User插入两个字段</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Date createTime;</span><br><span class="line"><span class="keyword">private</span> Date updateTime;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-代码级别">2.2 <strong>代码级别</strong></h3>
<ul>
<li>删除数据库datetime的默认值</li>
<li>实体类字段属性上增加注解</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字段添加填充内容</span></span><br><span class="line"><span class="meta">@TableField</span>(fill = FieldFill.INSERT)</span><br><span class="line"><span class="keyword">private</span> Date createTime;</span><br><span class="line"><span class="meta">@TableField</span>(fill = FieldFill.INSERT_UPDATE)</span><br><span class="line"><span class="keyword">private</span> Date updateTime;</span><br></pre></td></tr></table></figure>
<ul>
<li>编写处理器来处理这个注解</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMetaObjectHandler</span> <span class="keyword">implements</span> <span class="title">MetaObjectHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入时的填充策略</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertFill</span><span class="params">(MetaObject metaObject)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"start insert fill....."</span>);</span><br><span class="line">        <span class="comment">// setFieldValByName(String fieldName, Object fieldVal, MetaObject,metaObject</span></span><br><span class="line">        <span class="keyword">this</span>.setFieldValByName(<span class="string">"createTime"</span>,<span class="keyword">new</span> Date(),metaObject);</span><br><span class="line">        <span class="keyword">this</span>.setFieldValByName(<span class="string">"updateTime"</span>,<span class="keyword">new</span> Date(),metaObject);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新时的填充策略</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateFill</span><span class="params">(MetaObject metaObject)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"start update fill....."</span>);</span><br><span class="line">        <span class="keyword">this</span>.setFieldValByName(<span class="string">"updateTime"</span>,<span class="keyword">new</span> Date(),metaObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3、乐观锁">3、乐观锁</h2>
<h3 id="3-1-介绍">3.1 介绍</h3>
<blockquote>
<p>乐观锁 : 故名思意十分乐观，它总是认为不会出现问题，无论干什么不去上锁！如果出现了问题，再次更新值测试<br>
悲观锁：故名思意十分悲观，它总是认为总是出现问题，无论干什么都会上锁！再去操作！</p>
</blockquote>
<p>乐观锁实现方式</p>
<ul>
<li>取出记录时，获取当前version</li>
<li>更新时，带上这个version</li>
<li>执行更新时， set version = newVersion where version = oldVersion</li>
<li>如果version不对，就更新失败</li>
</ul>
<h3 id="3-2-操作步骤">3.2 操作步骤</h3>
<ul>
<li>给数据库增加version字段</li>
<li>在User实体类增加对应的字段</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Version</span> <span class="comment">//乐观锁Version注解</span></span><br><span class="line"><span class="keyword">private</span> Integer version;</span><br></pre></td></tr></table></figure>
<ul>
<li>注册组件，同时启用事务管理</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 扫描我们的 mapper 文件夹</span></span><br><span class="line"><span class="meta">@MapperScan</span>(<span class="string">"com.mybatis.demo.mapper"</span>)</span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">@Configuration</span> <span class="comment">// 配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisPlusConfig</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MybatisPlusInterceptor <span class="title">mybatisPlusInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MybatisPlusInterceptor interceptor = <span class="keyword">new</span> MybatisPlusInterceptor();</span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> OptimisticLockerInnerInterceptor());</span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>测试</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试乐观锁成功！</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testOptimisticLocker</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// 1、查询用户信息</span></span><br><span class="line">User user = userMapper.selectById(<span class="number">1L</span>);</span><br><span class="line"><span class="comment">// 2、修改用户信息</span></span><br><span class="line">user.setName(<span class="string">"test"</span>);</span><br><span class="line">user.setEmail(<span class="string">"zzzzz@163.com"</span>);</span><br><span class="line"><span class="comment">// 3、执行更新操作</span></span><br><span class="line">userMapper.updateById(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4、普通查询操作">4、普通查询操作</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSelectById</span><span class="params">()</span></span>&#123;</span><br><span class="line">    User user = userMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试批量查询！</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSelectByBatchId</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;User&gt; users = userMapper.selectBatchIds(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 按条件查询之一使用map操作</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSelectByBatchIds</span><span class="params">()</span></span>&#123;</span><br><span class="line">    HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 自定义要查询</span></span><br><span class="line">    map.put(<span class="string">"name"</span>,<span class="string">"1234567"</span>);</span><br><span class="line">    map.put(<span class="string">"age"</span>,<span class="number">3</span>);</span><br><span class="line">    List&lt;User&gt; users = userMapper.selectByMap(map);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5、分页查询">5、分页查询</h2>
<ul>
<li>配置拦截器</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 扫描我们的 mapper 文件夹</span></span><br><span class="line"><span class="meta">@MapperScan</span>(<span class="string">"com.mybatis.demo.mapper"</span>)</span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">@Configuration</span> <span class="comment">// 配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisPlusConfig</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新的分页插件,一缓和二缓遵循mybatis的规则,需要设置 MybatisConfiguration#useDeprecatedExecutor = false 避免缓存出现问题(该属性会在旧插件移除后一同移除)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MybatisPlusInterceptor <span class="title">mybatisPlusInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MybatisPlusInterceptor interceptor = <span class="keyword">new</span> MybatisPlusInterceptor();</span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> OptimisticLockerInnerInterceptor());</span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> PaginationInnerInterceptor(DbType.MYSQL));</span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConfigurationCustomizer <span class="title">configurationCustomizer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> configuration -&gt; configuration.setUseDeprecatedExecutor(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>测试类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试分页查询</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPage</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 参数一：当前页</span></span><br><span class="line">    <span class="comment">// 参数二：页面大小</span></span><br><span class="line">    <span class="comment">// 使用了分页插件之后，所有的分页操作也变得简单的！</span></span><br><span class="line">    Page&lt;User&gt; page = <span class="keyword">new</span> Page&lt;&gt;(<span class="number">2</span>,<span class="number">5</span>);</span><br><span class="line">    userMapper.selectPage(page,<span class="keyword">null</span>);</span><br><span class="line">    page.getRecords().forEach(System.out::println);</span><br><span class="line">    System.out.println(page.getTotal());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6、逻辑删除">6、逻辑删除</h2>
<ul>
<li>首先在数据库中插入字段<code>deleted</code>，代表逻辑删除字段，设置默认为0</li>
<li>在User实体类添加属性</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableLogic</span> <span class="comment">//逻辑删除</span></span><br><span class="line"><span class="keyword">private</span> Integer deleted;</span><br></pre></td></tr></table></figure>
<ul>
<li>配置<code>application.yml</code></li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置日志</span></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">logic-delete-value:</span> <span class="number">1</span> <span class="comment"># 逻辑已删除值(默认为 1)</span></span><br><span class="line">      <span class="attr">logic-not-delete-value:</span> <span class="number">0</span> <span class="comment"># 逻辑未删除值(默认为 0)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>测试</li>
</ul>
<p>配置好之后使用delete操作不会物理删除，而是进行逻辑删除，同时查询时自动过滤已被逻辑删除的数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试删除</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDeleteById</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        userMapper.deleteById(<span class="number">1L</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="7、条件生成器">7、条件生成器</h2>
<blockquote>
<p>详情请查看<a href="https://mp.baomidou.com/guide/wrapper.html" target="_blank" rel="noopener">https://mp.baomidou.com/guide/wrapper.html</a></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">contextLoads1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查询name不为空的用户，并且邮箱不为空的用户，年龄大于等于12</span></span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">    wrapper</span><br><span class="line">    .isNotNull(<span class="string">"name"</span>)</span><br><span class="line">    .isNotNull(<span class="string">"email"</span>)</span><br><span class="line">    .ge(<span class="string">"age"</span>,<span class="number">12</span>);</span><br><span class="line">    userMapper.selectList(wrapper).forEach(System.out::println); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8、逆向工程">8、逆向工程</h2>
<p>在<code>pom.xml</code>引入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-generator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.velocity<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>velocity-engine-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>编写代码生成器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CodeGenerator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** 模块名 */</span></span><br><span class="line">        String moduleName = <span class="string">"bean"</span>;</span><br><span class="line">        <span class="comment">/** 基本包名 */</span></span><br><span class="line">        String basePackage = <span class="string">"com.zstu"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** 作者 */</span></span><br><span class="line">        String authorName = <span class="string">"shawn"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** 要生成的表名 */</span></span><br><span class="line">        String[] tables = &#123;<span class="string">"tb_student"</span>,<span class="string">"tb_label"</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** table前缀 */</span></span><br><span class="line">        String prefix = <span class="string">"tb_"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** 代码生成路径 */</span></span><br><span class="line">        String codePath = System.getProperty(<span class="string">"user.dir"</span>) + <span class="string">"/bean/src/main/java"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1、获取代码生成器对象</span></span><br><span class="line">        AutoGenerator mpg = <span class="keyword">new</span> AutoGenerator();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、全局配置</span></span><br><span class="line">        GlobalConfig gc = <span class="keyword">new</span> GlobalConfig();</span><br><span class="line">        <span class="comment">//代码生成路径</span></span><br><span class="line">        gc.setOutputDir(codePath);</span><br><span class="line">        <span class="comment">//作者信息</span></span><br><span class="line">        gc.setAuthor(authorName);</span><br><span class="line">        gc.setOpen(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//生成ID类型</span></span><br><span class="line">        gc.setIdType(IdType.AUTO);</span><br><span class="line">        gc.setDateType(DateType.ONLY_DATE);</span><br><span class="line">        gc.setFileOverride(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//去掉Servce前缀</span></span><br><span class="line">        gc.setMapperName(<span class="string">"%sMapper"</span>);</span><br><span class="line">        <span class="comment">//对于IDEA系列编辑器，XML 文件是不能放在 java 文件夹中的，要移到resource文件</span></span><br><span class="line">        <span class="comment">//多模块在配置文件要设置mapper-locations，在启动类要加上扫描的路径mapper以及spring扫描包</span></span><br><span class="line">        gc.setXmlName(<span class="string">"%sMapper"</span>);</span><br><span class="line">        gc.setServiceName(<span class="string">"%sService"</span>);</span><br><span class="line">        gc.setServiceImplName(<span class="string">"%sServiceImpl"</span>);</span><br><span class="line">        gc.setEntityName(<span class="string">"%sEntity"</span>);</span><br><span class="line">        mpg.setGlobalConfig(gc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、数据源配置</span></span><br><span class="line">        DataSourceConfig dsc = <span class="keyword">new</span> DataSourceConfig();</span><br><span class="line">        dsc.setUrl(<span class="string">"jdbc:mysql://localhost:3306/intelligent_lamp?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=GMT%2B8"</span>);</span><br><span class="line">        dsc.setDriverName(<span class="string">"com.mysql.cj.jdbc.Driver"</span>);</span><br><span class="line">        dsc.setUsername(<span class="string">"root"</span>);</span><br><span class="line">        dsc.setPassword(<span class="string">"root"</span>);</span><br><span class="line">        dsc.setDbType(DbType.MYSQL);</span><br><span class="line">        mpg.setDataSource(dsc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4、包配置</span></span><br><span class="line">        PackageConfig pc = <span class="keyword">new</span> PackageConfig();</span><br><span class="line">        <span class="comment">//设置模块名</span></span><br><span class="line">        <span class="comment">//没有第0步时此代码必写</span></span><br><span class="line">        pc.setModuleName(moduleName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5、设置工程名</span></span><br><span class="line">        pc.setParent(basePackage);</span><br><span class="line">        <span class="comment">//设置包名</span></span><br><span class="line">        pc.setEntity(<span class="string">"entity"</span>);</span><br><span class="line">        pc.setMapper(<span class="string">"mapper"</span>);</span><br><span class="line">        pc.setService(<span class="string">"service"</span>);</span><br><span class="line">        pc.setController(<span class="string">"controller"</span>);</span><br><span class="line">        mpg.setPackageInfo(pc);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//6、策略配置</span></span><br><span class="line">        StrategyConfig strategy = <span class="keyword">new</span> StrategyConfig();</span><br><span class="line">        <span class="comment">//去除前缀</span></span><br><span class="line">        strategy.setTablePrefix(prefix);</span><br><span class="line">        <span class="comment">//数据库表名优先映射,配置</span></span><br><span class="line">        strategy.setInclude(tables);</span><br><span class="line">        <span class="comment">//下划线转驼峰命名的策略</span></span><br><span class="line">        strategy.setNaming(NamingStrategy.underline_to_camel);</span><br><span class="line">        <span class="comment">//数据库命名规则</span></span><br><span class="line">        strategy.setColumnNaming(NamingStrategy.underline_to_camel);</span><br><span class="line">        <span class="comment">//自动生成lombok注解</span></span><br><span class="line">        strategy.setEntityLombokModel(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//自动添加控制结构</span></span><br><span class="line">        strategy.setRestControllerStyle(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//自动添加逻辑删除策略</span></span><br><span class="line">        strategy.setLogicDeleteFieldName(<span class="string">"deleted"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7、设置自动填充策略</span></span><br><span class="line">        TableFill gmtCreatereate = <span class="keyword">new</span> TableFill(<span class="string">"create_time"</span>, FieldFill.INSERT);</span><br><span class="line">        <span class="comment">//设置自动更新时间策略</span></span><br><span class="line">        TableFill gmtModifiedodified = <span class="keyword">new</span> TableFill(<span class="string">"update_time"</span>, FieldFill.UPDATE);</span><br><span class="line">        <span class="comment">//获取自动填充对象</span></span><br><span class="line">        ArrayList&lt;TableFill&gt; tableFills = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//添加填充策略</span></span><br><span class="line">        tableFills.add(gmtCreatereate);</span><br><span class="line">        tableFills.add(gmtModifiedodified);</span><br><span class="line">        strategy.setTableFillList(tableFills);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//8、设置乐观锁策略</span></span><br><span class="line">        strategy.setVersionFieldName(<span class="string">"version"</span>);</span><br><span class="line">        <span class="comment">//设置Restful风格</span></span><br><span class="line">        strategy.setRestControllerStyle(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//设置连接请求 http://localhost:8080/hello_id_2</span></span><br><span class="line">        strategy.setControllerMappingHyphenStyle(<span class="keyword">true</span>);</span><br><span class="line">        mpg.setStrategy(strategy);</span><br><span class="line">        mpg.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="9、其他">9、其他</h2>
<p>Sql性能分析</p>
<h1>四、其他错误</h1>
<p>如果要用到xml文件的话,就必须再加两个配置，且IntelliJ Idea 出现 <code>Could not autowire. No beans of 'xxxx' type found</code> 的错误提示，并且发现编译生成的Classes没有xml文件夹，这时候需要进行简单配置<br>
<strong>解决方法</strong><br>
首先在<code>pom.xml</code>文件里添加,这个是全局的，一般写在父工程里就行</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其次在<code>application.yml</code>添加配置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span> <span class="comment">#sql日志</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:com/shawn/demo/mapper/xml/*.xml</span></span><br></pre></td></tr></table></figure>
<h1>五、时区处理</h1>
<h2 id="1、Mysql数据库">1、Mysql数据库</h2>
<h3 id="1-1-数据库与JDBC时区">1.1 数据库与JDBC时区</h3>
<p>数据库MySQL是存在时区的概念的，<code>show variables like &quot;%time_zone%&quot;;</code>命令可以查询当前时区</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#默认配置</span></span><br><span class="line">+<span class="comment">------------------+--------+</span></span><br><span class="line">| Variable_name  | Value |</span><br><span class="line">+<span class="comment">------------------+--------+</span></span><br><span class="line">| system_time_zone | CST  |</span><br><span class="line">| time_zone    | SYSTEM |</span><br><span class="line">+<span class="comment">------------------+--------+</span></span><br></pre></td></tr></table></figure>
<p><strong>问题描述</strong></p>
<p>默认CST指的是MySQL所在主机的系统时间，是中国标准时间的缩写(China Standard Time UT+8:00)。MySQL 中，如果 time_zone 为默认的 SYSTEM 值，则时区会继承为系统时区 CST，MySQL 内部将其认为是 UTC+08:00；而 jdbc 会将 CST 认为是美国中部时间，这会导致两者时间出现时区上的偏差（差8/13/14小时都可能是这个问题）</p>
<p><strong>解决方法</strong></p>
<p>明确指定 MySQL 数据库的时区，不使用引发误解的 CST，可以将** time_zone 改为’+8:00’**，同时 jdbc 连接串中也可以增加 <strong>serverTimezone=Asia/Shanghai</strong></p>
<p><strong>举例</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#第一种方法通过代码修改</span></span><br><span class="line"><span class="comment">##修改mysql全局时区为北京时间，即我们所在的东8区</span></span><br><span class="line"><span class="built_in">set</span> global time_zone = <span class="string">'+8:00'</span>; </span><br><span class="line"><span class="comment">##修改当前会话时区,并使其立即生效</span></span><br><span class="line"><span class="built_in">set</span> time_zone = <span class="string">'+8:00'</span>; </span><br><span class="line">flush privileges; </span><br><span class="line"><span class="comment">#-----------------#</span></span><br><span class="line"><span class="comment">#第二种方法通过配置文件修改</span></span><br><span class="line"><span class="comment"># vim /etc/my.cnf ##在[mysqld]区域中加上</span></span><br><span class="line">default-time_zone = <span class="string">'+8:00'</span></span><br><span class="line"><span class="comment"># /etc/init.d/mysqld restart ##重启mysql使新时区生效</span></span><br><span class="line"><span class="comment">#-----------------#</span></span><br><span class="line"><span class="comment">#这是我在用的jdbc连接</span></span><br><span class="line">jdbc:mysql://ip:port/sql_name?useSSL=<span class="literal">false</span>&amp;useUnicode=<span class="literal">true</span>&amp;characterEncoding=utf-8&amp;serverTimezone=GMT%2B8&amp;allowPublicKeyRetrieval=<span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h3 id="1-2-DateTime和TimeStamp异同">1.2 DateTime和TimeStamp异同</h3>
<ul>
<li>默认都精确到秒</li>
<li>时间范围不一样，TIMESTAMP 要小很多且最大范围为<code>2038-01-19 03:14:07.999999</code>，而datetime范围是<code>'1000-01-01 00:00:00'</code> to <code>'9999-12-31 23:59:59'</code></li>
<li><strong>TIMESTAMP</strong>把客户端插入的时间从当前时区转化为UTC（世界标准时间）进行存储；查询时，将其又转化为客户端当前时区进行返回。即存储的时候如果数据库换了时区，其存储的时间也会相应发生变化</li>
<li><strong>DATETIME</strong>存储时不做任何改变，基本上是原样输入和输出</li>
</ul>
<h2 id="2、Java框架">2、Java框架</h2>
<h3 id="2-1-LocalDateTime和Date">2.1 LocalDateTime和Date</h3>
<p>LocalDateTime本身不包含时区信息，它存储的是年、月、日、时分秒，纳秒这样的数字；Date存储的是一个毫秒数，准确说是从1970-01-01 00:00:00到现在经过的毫秒数，而这个毫秒数是有时区的，它存储的永远是现在针对UTC时区时的1970年零点，经过的毫秒数。</p>
<p>对于Date类来说，解析字符串成Date对象和格式化Date对象成字符串都会涉及时区</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date date = <span class="keyword">new</span> Date();</span><br><span class="line"><span class="comment">// 默认是系统时区</span></span><br><span class="line">System.out.println(date);</span><br><span class="line"><span class="comment">// 修改默认时区</span></span><br><span class="line">TimeZone.setDefault(TimeZone.getTimeZone(<span class="string">"GMT"</span>));</span><br><span class="line">System.out.println(date);</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">Fri Feb <span class="number">11</span> <span class="number">16</span>:<span class="number">51</span>:<span class="number">58</span> CST <span class="number">2022</span></span><br><span class="line">Fri Feb <span class="number">11</span> <span class="number">08</span>:<span class="number">51</span>:<span class="number">58</span> GMT <span class="number">2022</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*-------------------*/</span></span><br><span class="line">Date date1 = <span class="keyword">new</span> Date();</span><br><span class="line"><span class="comment">// 默认是系统时区</span></span><br><span class="line">SimpleDateFormat dateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">System.out.println(dateFormat.format(date1));</span><br><span class="line"><span class="comment">// 设置时区</span></span><br><span class="line">dateFormat.setTimeZone(TimeZone.getTimeZone(<span class="string">"GMT+8:00"</span>));</span><br><span class="line">System.out.println(dateFormat.format(date1));</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="number">2022</span>-<span class="number">02</span>-<span class="number">11</span> <span class="number">08</span>:<span class="number">51</span>:<span class="number">58</span></span><br><span class="line"><span class="number">2022</span>-<span class="number">02</span>-<span class="number">11</span> <span class="number">16</span>:<span class="number">51</span>:<span class="number">58</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*--------------------*/</span></span><br><span class="line">String dateStr = <span class="string">"2022-2-11 08:00:00"</span>;</span><br><span class="line"><span class="comment">// 默认是系统时区</span></span><br><span class="line">SimpleDateFormat dateFormat1 = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">Date date2 = dateFormat1.parse(dateStr);</span><br><span class="line">System.out.println(date2.getTime());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置时区</span></span><br><span class="line">dateFormat1.setTimeZone(TimeZone.getTimeZone(<span class="string">"GMT+8:00"</span>));</span><br><span class="line">Date date3 = dateFormat1.parse(dateStr);</span><br><span class="line">System.out.println(date3.getTime());</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="number">1644566400000</span></span><br><span class="line"><span class="number">1644537600000</span></span><br></pre></td></tr></table></figure>
<h3 id="2-2-Json传值给前端">2.2 Json传值给前端</h3>
<blockquote>
<p>参考：<a href="https://blog.csdn.net/lemon_TT/article/details/109145432" target="_blank" rel="noopener">Java8 日期时间类整理</a></p>
</blockquote>
<p>jackson也有自己的时区问题，默认情况下会将时区设置为UTC，这里仅需要在yml文件中设置全局配置即可</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#时间戳统一转换</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">jackson:</span></span><br><span class="line">    <span class="attr">date-format:</span> <span class="string">yyyy-MM-dd</span> <span class="string">HH:mm:ss</span></span><br><span class="line">    <span class="attr">time-zone:</span> <span class="string">GMT+8</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux基于OwnCloud搭建私有云盘</title>
    <url>/posts/11c723bd.html</url>
    <content><![CDATA[<h1>一、正常方式搭建OwnCloud</h1>
<p><a href="https://blog.csdn.net/Mr_Seng/article/details/105938578?biz_id=102&amp;utm_term=centos%E6%90%AD%E5%BB%BA%E7%BD%91%E7%9B%98&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-8-105938578&amp;spm=1018.2118.3001.4449" target="_blank" rel="noopener">centos 7搭建owncloud个人私有网盘</a><br>
<a href="https://blog.csdn.net/Huang6899587/article/details/84671034?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.add_param_isCf&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.add_param_isCf" target="_blank" rel="noopener">基于宝塔面板和nextcloud搭建自己的网盘</a></p>
<a id="more"></a>
<h1>二、基于Docker容器快速搭建</h1>
<p>这里默认已经下载安装好并成功启动了docker，并成功进行了配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#拉取docker镜像</span></span><br><span class="line">docker pull owncloud</span><br><span class="line">docker pull mysql</span><br><span class="line"><span class="comment">#创建文件存储路径，自定义但要记住该路径,下面是我个人路径</span></span><br><span class="line">mkdir /lxt/data/mysql</span><br><span class="line">mkdir /lxt/data/mysql/owncloud</span><br><span class="line">mkdir /lxt/data/owncloud</span><br><span class="line"><span class="comment">#设置权限</span></span><br><span class="line">chmod 770 /lxt/data</span><br></pre></td></tr></table></figure>
<p>分别运行以下两句代码，启动容器，注意要修改自己的个人路径，另外如果端口冲突可以自行设置端口号</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#启动数据库</span></span><br><span class="line">docker run --name mysql-owncloud  -v /lxt/data/mysql/owncloud:/var/lib/mysql  -e MYSQL_ROOT_PASSWORD=password  -e MYSQL_DATABASE=owncloud  -e MYSQL_USER=owncloud  -e MYSQL_PASSWORD=password  -d -p 3307:3306 --restart unless-stopped mysql</span><br><span class="line"><span class="comment">#启动owncloud</span></span><br><span class="line">docker run --name=owncloud --link=mysql-owncloud:mysql-owncloud -v /var/data/owncloud:/var/www/html/data -p 80:80 -d --restart unless-stopped owncloud</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20201114134654202.png#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看启动的docker容器</span></span><br><span class="line">docker ps</span><br></pre></td></tr></table></figure>
<p>最后注意开放相应的端口号，这里我开放了8000端口，最后访问<code>ip:端口</code>即可<br>
<img src="https://img-blog.csdnimg.cn/20201114135043686.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbW9uX1RU,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<hr>
<p>参考文章<br>
<a href="https://blog.csdn.net/lionwerson/article/details/81775650?utm_medium=distribute.pc_relevant.none-task-blog-utm_term-2&amp;spm=1001.2101.3001.4242" target="_blank" rel="noopener">https://blog.csdn.net/lionwerson/article/details/81775650?utm_medium=distribute.pc_relevant.none-task-blog-utm_term-2&amp;spm=1001.2101.3001.4242</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux基础</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-cli脚手架三种搭建方式</title>
    <url>/posts/1c69613d.html</url>
    <content><![CDATA[<h3 id="1、基于2-x的旧模板">1、基于2.x的旧模板</h3>
<p> 默认已经安装好了<code>Node</code>和<code>Webpack</code><br>
1、全局安装vue-cli</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install vue-cli -g</span><br></pre></td></tr></table></figure>
<p>查看版本输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vue -V</span><br></pre></td></tr></table></figure>
<p>2、vue-cli来创建一个基于 webpack 模板的新项目</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#my_project是项目名</span></span><br><span class="line">vue init webpack my_project</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>之后需要填写项目的一些基本配置，下面是我的配置<br>
<img src="https://img-blog.csdnimg.cn/20200430170320574.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbW9uX1RU,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
3、运行vue-cli项目<br>
 进入项目，输入<code>npm run dev</code>之后项目就跑起来了，可以进入<code>localhost:8080</code>查看效果</p>
<h3 id="2、基于交互式命令创建新版vue项目">2、基于交互式命令创建新版vue项目</h3>
<p>1、安装新版脚手架<br>
 首先需要更新vue-cli脚手架，需要重新卸载安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#卸载旧版</span></span><br><span class="line">npm uninstall vue-cli -g</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装新版脚手架</span></span><br><span class="line">npm install -g @vue/cli</span><br></pre></td></tr></table></figure>
<p><em>注：如何在安装新版的脚手架后要创建旧版项目，可以运行<code>npm install -g @vue/cli-init</code>后面操作就和安装旧版本一样了</em><br>
2、创建项目</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#注意这里不能用中文项目名</span></span><br><span class="line">vue create project1</span><br></pre></td></tr></table></figure>
<p>其中空格表示选中，回车确定，其配置项如下，这里我总的配置项，新建项目时会一个个选项进行询问。<br>
<img src="https://img-blog.csdnimg.cn/20200430171747210.png" alt="在这里插入图片描述"><br>
3、运行项目<br>
进入项目后<code>npm run serve</code>启动项目</p>
<h3 id="3、基于图形化界面创建新版vue项目">3、基于图形化界面创建新版vue项目</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在cmd窗口运行命令，进入图形化界面</span></span><br><span class="line">vue ui</span><br></pre></td></tr></table></figure>
<p>选择创建项目，后面的配置项和命令行类似，这里不多阐述了。<br>
<img src="https://img-blog.csdnimg.cn/20200430172209100.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbW9uX1RU,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
<img src="https://img-blog.csdnimg.cn/20200430172311886.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbW9uX1RU,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
3、运行项目<br>
 创建好项目后选择任务，在这里serve是我们开发期间打包和运行，build是成品发布运行，我们选择serve，点击运行即可成功启动项目<br>
<img src="https://img-blog.csdnimg.cn/20200430172608398.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbW9uX1RU,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常用命令操作</title>
    <url>/posts/2940781e.html</url>
    <content><![CDATA[<h3 id="1、文件目录操作">1、文件目录操作</h3>
<p><strong>ls命令</strong></p>
<p>所有ls可以进行组合使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls -a <span class="comment">#列出目录所有文件，包含以.开始的隐藏文件</span></span><br><span class="line">ls -A <span class="comment">#列出除.及..的其它文件</span></span><br><span class="line">ls -r <span class="comment">#反序排列</span></span><br><span class="line">ls -t <span class="comment">#以文件修改时间排序</span></span><br><span class="line">ls -S <span class="comment">#以文件大小排序</span></span><br><span class="line">ls -h <span class="comment">#以易读大小显示</span></span><br><span class="line">ls -l <span class="comment">#除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#列出当前目录中以“l"开头的目录的详细内容</span></span><br><span class="line">ls -l l*</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p><strong>cd命令</strong></p>
<p>切换目录，其中 ./指当前目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#进入根目录</span></span><br><span class="line"><span class="built_in">cd</span> /</span><br><span class="line"><span class="comment">#进去当前账户home目录</span></span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line"><span class="comment">#返回上次所在的目录</span></span><br><span class="line"><span class="built_in">cd</span> -</span><br></pre></td></tr></table></figure>
<p><strong>pwd命令</strong></p>
<p>查看当前工作目录路径</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#显示当前目录</span></span><br><span class="line"><span class="built_in">pwd</span></span><br><span class="line"><span class="comment">#显示当前软连接的实际目录</span></span><br><span class="line"><span class="built_in">pwd</span> -P</span><br></pre></td></tr></table></figure>
<p><strong>mkdir 命令</strong></p>
<p>创建文件夹</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在当前目录下创建目录</span></span><br><span class="line">mkdir <span class="built_in">test</span></span><br><span class="line"><span class="comment">#在/tmp下创建建目录(不存在就创建)</span></span><br><span class="line">mkdir -p /tmp/<span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<p><strong>rmdir命令</strong></p>
<p>删除文件夹，递归删除多个目录需要添加<code>-P</code>，另外只能删除空目录</p>
<p><strong>mv命令</strong></p>
<p>移动或修改文件名</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-f <span class="comment">#force强制的意思，如果目标文件已经存在，不会询问而直接覆盖</span></span><br><span class="line">-i <span class="comment">#若目标文件已经存在，就会询问是否覆盖</span></span><br><span class="line">-u <span class="comment">#若目标文件已经存在，且比目标文件新，才会更新</span></span><br><span class="line"><span class="comment">#重命名，不同路径代表移动文件</span></span><br><span class="line">mv test.txt test.json</span><br><span class="line"><span class="comment">#将文件 file1 改名为 file2，如果 file2 已经存在，则询问是否覆盖</span></span><br><span class="line">mv -i log1.txt log2.txt</span><br><span class="line"><span class="comment">#将本级所有文件移动到上一级</span></span><br><span class="line">mv * ../</span><br></pre></td></tr></table></figure>
<p><strong>cp命令</strong></p>
<p>复制文件或目录到新的路径，和mv操作类似</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-i <span class="comment">#提示</span></span><br><span class="line">-r <span class="comment">#复制目录及目录内所有项目</span></span><br><span class="line">-a <span class="comment">#复制的文件与原文件时间一样</span></span><br><span class="line">-p <span class="comment">#连同文件的属性一起复制过去，而非使用默认属性(备份常用)</span></span><br><span class="line">-u <span class="comment">#目标文件与源文件有差异时才会复制</span></span><br></pre></td></tr></table></figure>
<p><strong>rm命令</strong></p>
<p>删除文件或目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-f  <span class="comment">#忽略不存在的文件，不会出现警告，强制删除！</span></span><br><span class="line">-r  <span class="comment">#递归删除目录！</span></span><br><span class="line">-i  <span class="comment">#提示，删除询问是否删除</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#删除任何 .log 文件，删除前逐一询问确认</span></span><br><span class="line">rm -i *.<span class="built_in">log</span></span><br></pre></td></tr></table></figure>
<p><strong>ln命令</strong></p>
<blockquote>
<p>硬链接：A—B，假设B是A的硬链接，那么他们两个指向了同一个文件！允许一个文件拥有多个路径，用户可以通过这种机制建立硬链接到一些重要文件上，防止误删！<br>
软链接： 类似Window下的快捷方式，删除的源文件，快捷方式也访问不了！</p>
</blockquote>
<ul>
<li>-b 删除，覆盖以前建立的链接</li>
<li>-d 允许超级用户制作目录的硬链接</li>
<li>-f 强制执行</li>
<li>-i 交互模式，文件存在则提示用户是否覆盖</li>
<li>-n 把符号链接视为一般目录</li>
<li>-s 软链接(符号链接)</li>
<li>-v 显示详细的处理过程</li>
</ul>
<p><code> ln [参数][源文件或目录][目标文件或目录]</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建软连接</span></span><br><span class="line">ln -s test1.log link2013</span><br></pre></td></tr></table></figure>
<p><strong>tar命令</strong></p>
<p>文件打包与解压</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-c <span class="comment">#新建打包文件</span></span><br><span class="line">-t <span class="comment">#查看打包文件的内容含有哪些文件名</span></span><br><span class="line">-x <span class="comment">#解打包或解压缩的功能，可以搭配-C（大写）指定解压的目录，注意-c,-t,-x不能同时出现在同一条命令中</span></span><br><span class="line">-j <span class="comment">#通过bzip2的支持进行压缩/解压缩</span></span><br><span class="line">-z <span class="comment">#通过gzip的支持进行压缩/解压缩</span></span><br><span class="line">-v <span class="comment">#在压缩/解压缩过程中，将正在处理的文件名显示出来</span></span><br><span class="line">-f filename <span class="comment">#filename为要处理的文件</span></span><br><span class="line">-C dir <span class="comment">#指定压缩/解压缩的目录dir</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#文件打包</span></span><br><span class="line">tar -zcvf 打包名 文件</span><br><span class="line"><span class="comment">#举例</span></span><br><span class="line">tar -zcvf design.tar.gz design/</span><br><span class="line"><span class="comment">#文件解压</span></span><br><span class="line">tar -zxvf 文件名</span><br></pre></td></tr></table></figure>
<p><strong>scp命令</strong></p>
<p>Linux远程拷贝文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#上传文件</span></span><br><span class="line">scp 文件名 用户名@ip:服务器绝对路径目录</span><br><span class="line"><span class="comment">#上传design.tar.gz到服务器/shawn目录下</span></span><br><span class="line">scp design.tar.gz root@114.215.200.70:/shawn</span><br><span class="line"><span class="comment">#上传目录</span></span><br><span class="line">scp -r 目录 用户名@ip:服务器绝对路径目录</span><br></pre></td></tr></table></figure>
<p><strong>echo命令</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 若不存在就创建，存在就覆盖，使用&gt;&gt;为追加</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'hello world'</span> &gt; hw.text</span><br></pre></td></tr></table></figure>
<p><strong>find命令</strong></p>
<p><code>find 目录 参数</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find [目录] -name <span class="string">"*.c"</span></span><br><span class="line">find /usr/bin -<span class="built_in">type</span> f -atime +100 <span class="comment">#搜索在过去100天内未被使用过的执行文件</span></span><br><span class="line">find /usr/bin -<span class="built_in">type</span> f -mtime -10 <span class="comment">#搜索在10天内被创建或者修改过的文件</span></span><br><span class="line">whereis halt <span class="comment">#显示一个二进制文件、源码或man的位置</span></span><br><span class="line"><span class="built_in">which</span> halt <span class="comment">#显示一个二进制文件或可执行文件的完整路径</span></span><br></pre></td></tr></table></figure>
<p><strong>touch命令</strong></p>
<p>创建新文件，也可以使用vim/vi创建</p>
<h3 id="2、文本处理">2、文本处理</h3>
<p><strong>grep 命令</strong></p>
<p>分析一行的信息，若当中有我们所需要的信息，就将该行显示出来，该命令通常与管道命令一起使用，用于对一些命令的输出进行筛选加工等等</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep Aug /var/<span class="built_in">log</span>/messages  <span class="comment">#在文件 /var/log/messages中查找关键词"Aug"</span></span><br><span class="line">grep ^Aug /var/<span class="built_in">log</span>/messages <span class="comment">#在文件 /var/log/messages中查找以"Aug"开始的词汇</span></span><br><span class="line">grep [0-9] /var/<span class="built_in">log</span>/messages <span class="comment">#选择 /var/log/messages'文件中所有包含数字的行</span></span><br><span class="line">grep Aug -R /var/<span class="built_in">log</span>/* <span class="comment">#在目录 /var/log'及随后的目录中搜索字符串"Aug"</span></span><br><span class="line">sed <span class="string">'s/stringa1/stringa2/g'</span> example.txt <span class="comment">#将example.txt文件中的 "string1" 替换成 "string2"</span></span><br><span class="line">sed <span class="string">'/^$/d'</span> example.txt <span class="comment">#从example.txt文件中删除所有空白行</span></span><br></pre></td></tr></table></figure>
<p><strong>paste 命令</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">paste file1 file2 <span class="comment">#合并两个文件或两栏的内容</span></span><br><span class="line">paste -d <span class="string">'+'</span> file1 file2 <span class="comment">#合并两个文件或两栏的内容，中间用"+"区分</span></span><br></pre></td></tr></table></figure>
<p><strong>sort 命令</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sort file1 file2 <span class="comment">#排序两个文件的内容</span></span><br><span class="line">sort file1 file2 | uniq <span class="comment">#取出两个文件的并集(重复的行只保留一份)</span></span><br><span class="line">sort file1 file2 | uniq -u <span class="comment">#删除交集，留下其他的行</span></span><br><span class="line">sort file1 file2 | uniq -d <span class="comment">#取出两个文件的交集(只留下同时存在于两个文件中的文件)</span></span><br></pre></td></tr></table></figure>
<p><strong>comm 命令</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">comm -1 file1 file2 <span class="comment">#比较两个文件的内容只删除 'file1' 所包含的内容</span></span><br><span class="line">comm -2 file1 file2 <span class="comment">#比较两个文件的内容只删除 'file2' 所包含的内容</span></span><br><span class="line">comm -3 file1 file2 <span class="comment">#比较两个文件的内容只删除两个文件共有的部分</span></span><br></pre></td></tr></table></figure>
<h3 id="3、文件基本属性">3、文件基本属性</h3>
<p>Linux系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。在Linux中我们可以使用 <code>ll</code> 或者 <code>ls –l </code>命令来显示一个文件的属性以及文件所属的用户和组</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lrwxrwxrwx.   1 root root    7 5月  11 2019 bin -&gt; usr/bin</span><br><span class="line">dr-xr-xr-x.   5 root root 4096 11月 14 14:11 boot</span><br><span class="line">drwxr-xr-x    7 root root   73 1月   2 11:29 data</span><br></pre></td></tr></table></figure>
<p>在Linux中第一个字符代表这个文件是目录、文件或者链接文件等等。</p>
<ul>
<li>==当为【d】则是目录==</li>
<li>==当为【-】则是文件==</li>
<li>==若是【l】则标识为链接文档（link file）==</li>
<li>若是【b】则表示为装置文件里面的可供储存的接口设备（可随机存取装置）</li>
<li>若是【c】则表示为装置文件里面的串行端口设备，例如键盘、鼠标（一次性读取装置）。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/8a540c96301297649f2e01eb85b0a654.png" alt="363003_1227493859FdXT"></p>
<p>从左至右用0-9这些数字来表示。<br>
第0位确定文件类型，第1-3位确定属主（该文件的所有者）拥有该文件的权限。第4-6位确定属组（所有者的同组用户）拥有该文件的权限，第7-9位确定其他用户拥有该文件的权限。<br>
其中：</p>
<ul>
<li>第1、4、7位表示读权限，如果用&quot;r&quot;字符表示，则有读权限，如果用&quot;-&quot;字符表示，则没有读权限；</li>
<li>第2、5、8位表示写权限，如果用&quot;w&quot;字符表示，则有写权限，如果用&quot;-&quot;字符表示没有写权限；</li>
<li>第3、6、9位表示可执行权限，如果用&quot;x&quot;字符表示，则有执行权限，如果用&quot;-&quot;字符表示，则没有执行权限。</li>
</ul>
<p>对于文件来说，它都有一个特定的所有者，也就是对该文件具有所有权的用户。同时，在Linux系统中，用户是按组分类的，一个用户属于一个或多个组。文件所有者以外的用户又可以分为文件所有者的同组用户和其他用户。因此，Linux系统按文件所有者、文件所有者同组用户和其他用户来规定了不同的文件访问权限。</p>
<p><strong>chgrp命令</strong></p>
<p>更改文件属组</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#-R表示递归更改文件属组，就是在更改某个文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。</span></span><br><span class="line">chgrp [-R] 属组名 文件名</span><br></pre></td></tr></table></figure>
<p><strong>chown命令</strong></p>
<p>更改文件的属主，也可以同时更改文件的属组</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chown [-R] 属主名 文件名</span><br><span class="line">chown [-R] 属主名:属组名 文件名</span><br><span class="line"></span><br><span class="line"><span class="comment">#将install.log的拥有者与属组改回root</span></span><br><span class="line">chown root:root install.log</span><br></pre></td></tr></table></figure>
<p><strong>chmod命令(重要)</strong></p>
<p>更改文件9个属性</p>
<p>Linux文件属性由两种设置方法，一种是数字，一种是符号。Linux文件的基本权限就有9个，分别是owner、group、others三种分别各有自己的read、write、execute权限。其中</p>
<ul>
<li>r:4</li>
<li>w:2</li>
<li>x:1</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#将test目录下所有文件启动所有权限</span></span><br><span class="line">chmod -R 777 <span class="built_in">test</span></span><br><span class="line"><span class="comment">#给文件增加执行权限</span></span><br><span class="line">chown +x <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<h3 id="4、文件内容查看">4、文件内容查看</h3>
<p>Linux系统中使用以下命令来查看文件的内容：</p>
<ul>
<li>cat 由第一行开始显示文件内容</li>
<li>tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！</li>
<li>n  显示的时候，顺道输出行号</li>
<li>more 一页一页的显示文件内容</li>
<li>less 与 more 类似，但是比 more 更好的是，他可以往前翻页！</li>
<li>head 只看头几行</li>
<li>tail 只看尾巴几行</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">head -n 2 file <span class="comment">#查看一个文件的前两行</span></span><br><span class="line">tail -n 2 file <span class="comment">#查看一个文件的最后两行</span></span><br><span class="line">tail -n +1000 file  <span class="comment">#从1000行开始显示，显示1000行以后的</span></span><br><span class="line">cat filename | head -n 3000 | tail -n +1000  <span class="comment">#显示2000行到3000行</span></span><br><span class="line">cat filename | tail -n +3000 | head -n 1000  <span class="comment">#从第3000行开始，显示1000(即显示3000~3999行)</span></span><br></pre></td></tr></table></figure>
<p>可以使用<code>man [命令]</code>来查看各个命令的使用文档</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat 文件</span><br><span class="line">nl [-bnw] 文件</span><br><span class="line">head [-n number] 文件 </span><br><span class="line"><span class="comment">#对于文本处理工具还有sed和awk两个强大的工具</span></span><br></pre></td></tr></table></figure>
<p><strong>wc命令</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看文件里有多少行</span></span><br><span class="line">wc -l filename</span><br><span class="line"><span class="comment"># 看文件里有多少个word</span></span><br><span class="line">wc -w filename</span><br><span class="line"><span class="comment"># 文件里最长的那一行是多少个字</span></span><br><span class="line">wc -L filename</span><br><span class="line"><span class="comment"># 统计字节数</span></span><br><span class="line">wc -c</span><br></pre></td></tr></table></figure>
<h3 id="5、磁盘管理">5、磁盘管理</h3>
<p><strong>df命令</strong></p>
<p>检查文件系统的磁盘空间占用情况。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。</p>
<p><code>df [-ahikHTm] [目录或文件名]</code></p>
<p>选项与参数：</p>
<ul>
<li>-a ：列出所有的文件系统，包括系统特有的 /proc 等文件系统；</li>
<li>-k ：以 KBytes 的容量显示各文件系统；</li>
<li>-m ：以 MBytes 的容量显示各文件系统；</li>
<li>-h ：以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示；</li>
<li>-H ：以 M=1000K 取代 M=1024K 的进位方式；</li>
<li>-T ：显示文件系统类型, 连同该 partition 的 filesystem 名称 (例如 ext3) 也列出；</li>
<li>-i ：不用硬盘容量，而以 inode 的数量来显示</li>
</ul>
<p><strong>du命令</strong></p>
<p><code>du [-ahskm] 文件或目录名称</code></p>
<p>选项与参数：</p>
<ul>
<li>-a ：列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已。</li>
<li>-h ：以人们较易读的容量格式 (G/M) 显示；</li>
<li>-s ：列出总量而已，而不列出每个各别的目录占用容量；</li>
<li>-S ：不包括子目录下的总计，与 -s 有点差别。</li>
<li>-k ：以 KBytes 列出容量显示；</li>
<li>-m ：以 MBytes 列出容量显示；</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查询目录大小</span></span><br><span class="line">du -sh design/</span><br></pre></td></tr></table></figure>
<h3 id="6、账户管理">6、账户管理</h3>
<p><strong>useradd命令</strong></p>
<p>添加用户</p>
<ul>
<li>-m： 自动创建这个用户的主目录 /home/shawn</li>
<li>-G : 给用户分配组！</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建用户，主目录 /home/shawn，本质往/etc/passwd写入了信息</span></span><br><span class="line">useradd -m shawn</span><br></pre></td></tr></table></figure>
<p><strong>userdel命令</strong></p>
<p>删除用户</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#加上-r即删除时将目录空间一并删除</span></span><br><span class="line">userdel [-r] shawn</span><br></pre></td></tr></table></figure>
<p><strong>usermod命令</strong></p>
<p>修改账户信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#修改主目录</span></span><br><span class="line">usermod -d /home/shawn22 shawn</span><br></pre></td></tr></table></figure>
<p><strong>passwd命令</strong></p>
<p>用户口令的管理，用户管理的一项重要内容是用户口令的管理。用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令。</p>
<p><code>passwd 选项 用户名</code></p>
<p>可使用的选项：</p>
<ul>
<li>-l 锁定口令，即禁用账号。</li>
<li>-u 口令解锁。</li>
<li>-d 使账号无口令。</li>
<li>-f 强迫用户下次登录时修改口令。</li>
</ul>
<blockquote>
<p>普通用户修改自己的口令时，passwd命令会先询问原口令，验证后再要求用户输入两遍新口令，如果两次输入的口令一致，则将这个口令指定给用户；而超级用户为用户指定口令时，就不需要知道原口令。</p>
</blockquote>
<p>具体账户管理可以参考：<a href="https://blog.csdn.net/lemon_TT/article/details/121295416" target="_blank" rel="noopener">Linux账户管理</a></p>
<h3 id="7、进程管理">7、进程管理</h3>
<ul>
<li>在Linux中，每一个程序都是有自己的一个进程，每一个进程都有一个id号</li>
<li>每一个进程呢，都会有一个父进程！</li>
<li>进程可以有两种存在方式：前台/后台运行</li>
<li>一般的话服务都是后台运行的，基本的程序都是前台运行的！</li>
</ul>
<p><strong>ps命令</strong></p>
<p>查看系统当前正在执行的各种进程信息</p>
<p><code>ps -xx</code></p>
<p>命令参数：</p>
<ul>
<li>a  显示所有进程</li>
<li>-a 显示同一终端下的所有程序</li>
<li>-A 显示所有进程</li>
<li>c  显示进程的真实名称</li>
<li>-N 反向选择</li>
<li>-e 等于“-A”</li>
<li>e  显示环境变量</li>
<li>f  显示程序间的关系</li>
<li>-H 显示树状结构</li>
<li>r  显示当前终端的进程</li>
<li>T  显示当前终端的所有程序</li>
<li>u  指定用户的所有进程</li>
<li>-au 显示较详细的资讯</li>
<li>-aux 显示所有包含其他使用者的行程</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ps -aux 查看所有的进程</span></span><br><span class="line">ps -aux|grep mysql </span><br><span class="line"><span class="comment"># |  在Linux这个叫做管道符    A|B 相当于前面的操作结果通过管道当做后面命令的输入</span></span><br><span class="line"><span class="comment"># grep 查找文件中符合条件的字符串！</span></span><br><span class="line"><span class="comment"># 看父进程我们一般可以通过目录树结构来查看！</span></span><br><span class="line">ps -ef|grep mysql </span><br><span class="line"><span class="comment">#进程树，-p显示父id， -u显示用户组</span></span><br><span class="line">pstree -pu</span><br></pre></td></tr></table></figure>
<p><strong>top命令</strong></p>
<p>cpu状态显示：</p>
<ul>
<li>us, user： 运行(未调整优先级的) 用户进程的CPU时间</li>
<li>sy，system: 运行内核进程的CPU时间</li>
<li>ni，niced：运行已调整优先级的用户进程的CPU时间</li>
<li>wa，IO wait: 用于等待IO完成的CPU时间</li>
<li>hi：处理硬件中断的CPU时间</li>
<li>si: 处理软件中断的CPU时间</li>
<li>st：这个虚拟机被hypervisor偷去的CPU时间（译注：如果当前处于一个hypervisor下的vm，实际上hypervisor也是要消耗一部分CPU处理时间的）。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/c6a0c06991494f6c8fc6df2395c670ff.png" alt="请添加图片描述"><br>
各进程（任务）的状态监控:</p>
<p>PID：进程ID，进程的唯一标识符<br>
USER：进程所有者的实际用户名。<br>
PR：进程的调度优先级。这个字段的一些值是’rt’。这意味这这些进程运行在实时态。<br>
NI：进程的nice值（优先级）。越小的值意味着越高的优先级。负值表示高优先级，正值表示低优先级<br>
VIRT：进程使用的虚拟内存。进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES<br>
RES：驻留内存大小。驻留内存是任务使用的非交换物理内存大小。进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA<br>
SHR：SHR是进程使用的共享内存。共享内存大小，单位kb<br>
S：这个是进程的状态。它有以下不同的值:</p>
<ul>
<li>D - 不可中断的睡眠态。</li>
<li>R – 运行态</li>
<li>S – 睡眠态</li>
<li>T – 被跟踪或已停止</li>
<li>Z – 僵尸态</li>
</ul>
<p>%CPU：自从上一次更新时到现在任务所使用的CPU时间百分比。<br>
%MEM：进程使用的可用物理内存百分比。<br>
TIME+：任务启动后到现在所使用的全部CPU时间，精确到百分之一秒。<br>
COMMAND：运行进程所使用的命令。进程名称（命令名/命令行）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">c： 显示完整的命令</span><br><span class="line">d： 更改刷新频率</span><br><span class="line">f： 增加或减少要显示的列(选中的会变成大写并加*号)</span><br><span class="line">F： 选择排序的列</span><br><span class="line">h： 显示帮助画面</span><br><span class="line">H： 显示线程</span><br><span class="line">i： 忽略闲置和僵死进程</span><br><span class="line">k： 通过给予一个PID和一个signal来终止一个进程。（默认signal为15。在安全模式中此命令被屏蔽）</span><br><span class="line">l:  显示平均负载以及启动时间（即显示影藏第一行）</span><br><span class="line">m： 显示内存信息</span><br><span class="line">M： 根据内存资源使用大小进行排序</span><br><span class="line">N： 按PID由高到低排列</span><br><span class="line">o： 改变列显示的顺序</span><br><span class="line">O： 选择排序的列，与F完全相同</span><br><span class="line">P： 根据CPU资源使用大小进行排序</span><br><span class="line">q： 退出top命令</span><br><span class="line">r： 修改进程的nice值(优先级)。优先级默认为10，正值使优先级降低，反之则提高的优先级</span><br><span class="line">s： 设置刷新频率（默认单位为秒，如有小数则换算成ms）。默认值是5s，输入0值则系统将不断刷新</span><br><span class="line">S： 累计模式（把已完成或退出的子进程占用的CPU时间累计到父进程的MITE+ ）</span><br><span class="line">T： 根据进程使用CPU的累积时间排序</span><br><span class="line">t： 显示进程和CPU状态信息（即显示影藏CPU行）</span><br><span class="line">u： 指定用户进程</span><br><span class="line">W： 将当前设置写入~/.toprc文件，下次启动自动调用toprc文件的设置</span><br><span class="line">&lt;： 向前翻页</span><br><span class="line">&gt;： 向后翻页</span><br><span class="line">?： 显示帮助画面</span><br><span class="line">1(数字1)： 显示每个CPU的详细情况</span><br></pre></td></tr></table></figure>
<p><strong>kill命令</strong></p>
<p>杀死进程，结束任务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#表示强制结束该进程,进程id可通过ps查看</span></span><br><span class="line"><span class="built_in">kill</span> -9 进程的id</span><br><span class="line"><span class="comment">#正常停止一个进程</span></span><br><span class="line"><span class="built_in">kill</span> -15 进程的id</span><br><span class="line"><span class="comment">#杀死所有相关的进程</span></span><br><span class="line">killall 进程名字</span><br><span class="line"><span class="comment">#强制关闭进程名包含xxx的所有进程</span></span><br><span class="line">ps aux|grep xxx | grep -v grep | awk <span class="string">'&#123;print $2&#125;'</span> | xargs <span class="built_in">kill</span> -9</span><br></pre></td></tr></table></figure>
<p><strong>nohup命令(后台)</strong></p>
<p>后台执行程序(no hang up不挂起)</p>
<p><code>nohup command &gt; myout.file 2&gt;&amp;1 &amp;</code></p>
<ul>
<li>command&gt;out.file是将command的输出重定向到out.file文件，即输出内容不打印到屏幕上，而是输出到out.file文件中</li>
<li>2&gt;&amp;1 也就表示将错误重定向到标准输出上</li>
<li>&amp; 放在命令到结尾，表示后台运行</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#启动python程序并将输出输出到python.txt文件中，后台</span></span><br><span class="line">nohup python tools/train.py&gt; python.txt 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>
<ul>
<li>ctrl + z 可以将一个正在前台执行的命令放到后台，并且处于暂停状态。</li>
<li>Ctrl+c 终止前台命令。</li>
<li>jobs 查看当前有多少在后台运行的命令。jobs -l选项可显示所有任务的PID，jobs的状态可以是running, stopped, Terminated。但是如果任务被终止了（kill），shell 从当前的shell环境已知的列表中删除任务的进程标识。</li>
</ul>
<h3 id="8、系统命令">8、系统命令</h3>
<ul>
<li>shutdown -h now 关闭系统(1)</li>
<li>init 0 关闭系统(2)</li>
<li>telinit 0 关闭系统(3)</li>
<li>shutdown -h hours:minutes &amp; 按预定时间关闭系统</li>
<li>shutdown -c 取消按预定时间关闭系统</li>
<li>shutdown -r now 重启(1)</li>
<li>reboot 重启(2)</li>
<li>logout 注销</li>
<li>time 测算一个命令（即程序）的执行时间</li>
<li>uname -a # 查看系统内核信息</li>
<li>cat /proc/version # 查看系统内核版本</li>
</ul>
<h3 id="9、网络相关">9、网络相关</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#配置dns</span></span><br><span class="line">vim /etc/resolv.conf</span><br><span class="line"><span class="comment">#查看域名路由表</span></span><br><span class="line">nslookup google.com</span><br><span class="line"><span class="comment"># 最近登录的5个账号</span></span><br><span class="line"><span class="comment">#可以参考https://blog.csdn.net/lemon_TT/article/details/121140378</span></span><br><span class="line">last -n 5</span><br><span class="line"><span class="comment">#查看什么进程使用了该端口</span></span><br><span class="line">lsof -i:port</span><br><span class="line"><span class="comment">#另外还会有nc、tcpdump、traceroute、ss等tcp调试命令</span></span><br><span class="line"><span class="comment"># ssh相关可以参考https://blog.csdn.net/lemon_TT/article/details/115253490</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>加深版：<a href="https://mp.weixin.qq.com/s/iWST4cIIhf12rjYWAZqURQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/iWST4cIIhf12rjYWAZqURQ</a></p>
</blockquote>
<hr>
<p>对于shell的学习，可以参考：</p>
<p><a href="https://book.apeland.cn/details/274/" target="_blank" rel="noopener">https://book.apeland.cn/details/274/</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux基础</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot整合JWT实现前后端Token验证</title>
    <url>/posts/5cd97de5.html</url>
    <content><![CDATA[<h2 id="一、JWT介绍">一、JWT介绍</h2>
<h3 id="1、JWT简介">1、JWT简介</h3>
<blockquote>
<p>Json web token (JWT), 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（<a href="https://link.jianshu.com?t=https://tools.ietf.org/html/rfc7519" target="_blank" rel="noopener">(RFC 7519</a>).该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。</p>
<p>官网：<a href="https://jwt.io/introduction/" target="_blank" rel="noopener">https://jwt.io/introduction/</a></p>
</blockquote>
<a id="more"></a>
<h3 id="2、JWT认证和session认证的区别">2、JWT认证和session认证的区别</h3>
<h4 id="session认证">session认证</h4>
<p>http协议是一种无状态的协议，而这就意味着如果用户向我们的应用提供了用户名和密码来进行用户认证，那么下一次请求时，用户还要再一次进行用户认证才行，因为根据http协议，我们并不能知道是哪个用户发送的请求，所以为了让我们的应用能识别是哪个用户发出的，我们只能在服务器存储一份用户登陆的信息，这份登陆信息会在响应时传递给浏览器，告诉其保存为cookie，以便下次请求时发送给我们的应用，这样我们的应用个就能识别请求来自哪个用户了，这就是传统的基于sessino认证。</p>
<h4 id="JWT认证">JWT认证</h4>
<p>基于token的鉴权机制类似于http协议也是无状态的，它不需要在服务端去保留用户的认证信息或会话信息。这也就意味着JWT认证机制的应用不需要去考虑用户在哪一台服务器登录了，这就为应用的扩展提供了便利。</p>
<h3 id="3、JWT认证过程">3、JWT认证过程</h3>
<p><img src="https://img-blog.csdnimg.cn/20210127183348127.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbW9uX1RU,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ol>
<li>用户使用账号和密码发出post请求；</li>
<li>服务器使用私钥创建一个jwt；</li>
<li>服务器返回这个jwt给浏览器；</li>
<li>浏览器将该jwt串在请求头中像服务器发送请求；</li>
<li>服务器验证该jwt；</li>
<li>返回响应的资源给浏览器</li>
</ol>
<h3 id="4、JWT结构">4、JWT结构</h3>
<p>JWT是由三段信息构成的，将这三段信息文本用<code>.</code>连接一起就构成了JWT字符串。就像这样:<code>xxxxx.yyyyy.zzzzz</code>。JWT包含了三部分：<br>
<strong>Header</strong> 头部(标题包含了令牌的元数据，并且包含签名和/或加密算法的类型)<br>
<strong>Payload</strong> 负载 (类似于飞机上承载的物品)<br>
<strong>Signature</strong> 签名/签证</p>
<h2 id="二、springboot和JWT整合">二、springboot和JWT整合</h2>
<p><strong>在<code>pom.xml</code>中添加依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.auth0<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>java-jwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--注意版本--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>创建<code>annotation</code>自定义注解包，在包下创建<code>PassToken</code>和<code>UserLoginToken</code>两个注解</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法上有该注解就放行</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> PassToken &#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">required</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//表示需要token验证</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> UserLoginToken &#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">required</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>配置拦截器，实现一个拦截器就需要实现<code>HandlerInterceptor</code>接口</strong></p>
<p><code>HandlerInterceptor</code>接口主要定义了三个方法<br>
<strong>1.<code>boolean preHandle ()</code>：</strong><br>
预处理回调方法,实现处理器的预处理，第三个参数为响应的处理器,自定义<code>Controller</code>,返回值为<code>true</code>表示继续流程（如调用下一个拦截器或处理器）或者接着执行<br>
<code>postHandle()</code>和<code>afterCompletion()</code>；<code>false</code>表示流程中断，不会继续调用其他的拦截器或处理器，中断执行。</p>
<p><strong>2.<code>void postHandle()</code>：</strong><br>
后处理回调方法，实现处理器的后处理（<code>DispatcherServlet</code>进行视图返回渲染之前进行调用），此时我们可以通过<code>modelAndView</code>（模型和视图对象）对模型数据进行处理或对视图进行处理，<code>modelAndView</code>也可能为<code>null</code>。</p>
<p><strong>3.<code>void afterCompletion()</code>:</strong><br>
整个请求处理完毕回调方法,该方法也是需要当前对应的<code>Interceptor</code>的<code>preHandle()</code>的返回值为true时才会执行，也就是在<code>DispatcherServlet</code>渲染了对应的视图之后执行。用于进行资源清理。整个请求处理完毕回调方法。如性能监控中我们可以在此记录结束时间并输出消耗时间，还可以进行一些资源清理，类似于<code>try-catch-finally</code>中的<code>finally</code>，但仅调用处理器执行链中</p>
<p><strong>代码主要流程:</strong></p>
<p><strong>1.从 <code>http</code> 请求头中取出 <code>token</code>，<br>
2.判断是否映射到方法<br>
3.检查是否有<code>passtoken</code>注释，有则跳过认证<br>
4.检查有没有需要用户登录的注解，有则需要取出并验证<br>
5.认证通过则可以访问，不通过会报相关错误信息</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(MyInterceptor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    IUserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse,</span></span></span><br><span class="line"><span class="function"><span class="params">                             Object object)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 从 http 请求头中取出 token</span></span><br><span class="line">        String token = httpServletRequest.getHeader(<span class="string">"token"</span>);</span><br><span class="line">        <span class="comment">// 如果不是映射到方法直接通过</span></span><br><span class="line">        <span class="keyword">if</span>(!(object <span class="keyword">instanceof</span> HandlerMethod))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HandlerMethod handlerMethod=(HandlerMethod)object;</span><br><span class="line">        Method method=handlerMethod.getMethod();</span><br><span class="line">        <span class="comment">//检查是否有passtoken注释，有则跳过认证</span></span><br><span class="line">        <span class="keyword">if</span> (method.isAnnotationPresent(PassToken<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">            PassToken passToken = method.getAnnotation(PassToken<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (passToken.required()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//检查有没有需要用户权限的注解</span></span><br><span class="line">        <span class="keyword">if</span> (method.isAnnotationPresent(UserLoginToken<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">            UserLoginToken userLoginToken = method.getAnnotation(UserLoginToken<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (userLoginToken.required()) &#123;</span><br><span class="line">                <span class="comment">// 执行认证</span></span><br><span class="line">                <span class="keyword">if</span> (token == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"无token，请重新登录"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 获取 token 中的 user id</span></span><br><span class="line">                String userId;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    userId = JWT.decode(token).getAudience().get(<span class="number">0</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (JWTDecodeException j) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"401"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//这里根据userId从数据库查找user</span></span><br><span class="line">                User user = userService.findUserById(userId);</span><br><span class="line">                <span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"用户不存在，请重新登录"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 验证 token</span></span><br><span class="line">                JWTVerifier jwtVerifier = JWT.require(Algorithm.HMAC256(user.getPwd())).build();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    jwtVerifier.verify(token);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (JWTVerificationException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"401"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// logger.info("执行完方法之后进执行(Controller方法调用之后)，但是此时还没进行视图渲染");</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// logger.info("整个请求都处理完咯，DispatcherServlet也渲染了对应的视图咯，此时我可以做一些清理的工作了");</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中我的User类(已简化)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer userId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String pwd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后还要配置拦截器，顺便把跨域配置给解决了，这里的WebMvcConfigurer可以扩展其他自定义功能，详情可查看<a href="https://docs.spring.io/spring-boot/docs/2.5.0-SNAPSHOT/reference/html/spring-boot-features.html#boot-features-spring-mvc-auto-configuration" target="_blank" rel="noopener">spring官网</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptorConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String[] ORIGINS = <span class="keyword">new</span> String[] &#123; <span class="string">"GET"</span>, <span class="string">"POST"</span>, <span class="string">"PUT"</span>, <span class="string">"DELETE"</span> &#125;;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     解决跨域问题</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//新版springboot将.allowedOrigins替换成.allowedOriginPatterns即可</span></span><br><span class="line">      registry.addMapping(<span class="string">"/**"</span>).allowedOrigins(<span class="string">"*"</span>).allowCredentials(<span class="keyword">true</span>)</span><br><span class="line">      .allowedMethods(ORIGINS).maxAge(<span class="number">3600</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实现WebMvcConfigurer不会导致静态资源被拦截</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> MyInterceptor())</span><br><span class="line">                <span class="comment">// 拦截所有url</span></span><br><span class="line">                .addPathPatterns(<span class="string">"/**"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>创建<code>TokenService</code>类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  String <span class="title">getToken</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        Date start = <span class="keyword">new</span> Date();</span><br><span class="line">        <span class="comment">//一小时有效时间</span></span><br><span class="line">        <span class="keyword">long</span> currentTime = System.currentTimeMillis() + <span class="number">60</span>* <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line">        Date end = <span class="keyword">new</span> Date(currentTime);</span><br><span class="line">        String token = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        token = JWT.create().withAudience(String.valueOf(user.getUserId())).withIssuedAt(start).withExpiresAt(end).sign(Algorithm.HMAC256(user.getPwd()));</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>最终只需要在登录的时候调用<code>TokenService.getToken(user)</code>即可获得token，返回给前端，下次请求其他接口在header带上token即可</strong></p>
<hr>
<p>参考：</p>
<p><a href="https://github.com/jwtk/jjwt" target="_blank" rel="noopener">https://github.com/jwtk/jjwt</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/91420328" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/91420328</a></p>
<p><a href="https://www.jianshu.com/p/e88d3f8151db" target="_blank" rel="noopener">https://www.jianshu.com/p/e88d3f8151db</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot自定义starter</title>
    <url>/posts/dd4c9c1d.html</url>
    <content><![CDATA[<h2 id="一、starter简介">一、starter简介</h2>
<h4 id="1、SpringBoot-starter机制">1、SpringBoot starter机制</h4>
<p>SpringBoot中的starter是一种非常重要的机制，能够抛弃以前繁杂的配置，将其统一集成进starter，应用者只需要在maven中引入starter依赖，SpringBoot就能自动扫描到要加载的信息并启动相应的默认配置。starter让我们摆脱了各种依赖库的处理，需要配置各种信息的困扰。SpringBoot会自动通过classpath路径下的类发现需要的Bean，并注册进IOC容器。SpringBoot提供了针对日常企业应用研发各种场景的spring-boot-starter依赖模块。所有这些依赖模块都遵循着约定成俗的默认配置，并允许我们调整这些配置，即遵循“约定大于配置”的理念。</p>
<a id="more"></a>
<h4 id="2、为什么要自定义starter">2、为什么要自定义starter</h4>
<p>在我们的日常开发工作中，经常会有一些独立于业务之外的配置模块，我们经常将其放到一个特定的包下，然后如果另一个工程需要复用这块功能的时候，需要将代码硬拷贝到另一个工程，重新集成一遍，麻烦至极。如果我们将这些可独立于业务代码之外的功配置模块封装成一个个starter，复用的时候只需要将其在pom中引用依赖即可。</p>
<h4 id="3、自定义starter命名规范">3、自定义starter命名规范</h4>
<p>官方命名：</p>
<ul>
<li>
<p>前缀：spring-boot-starter-xxx</p>
</li>
<li>
<p>比如：spring-boot-starter-web…</p>
</li>
</ul>
<p>自定义命名：</p>
<ul>
<li>xxx-spring-boot-starter</li>
<li>比如：mybatis-spring-boot-starter</li>
</ul>
<h2 id="二、starter实现">二、starter实现</h2>
<h4 id="1、新建工程">1、新建工程</h4>
<p>这里我命名为<code>shawn-spring-boot-starter</code><br>
<img src="https://img-blog.csdnimg.cn/20210128160453197.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbW9uX1RU,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="2、添加pom-xml依赖">2、添加pom.xml依赖</h4>
<p>这里需要注意spring版本，太高可能会导致install失败</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;groupId&gt;com.shawn&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;shawn-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;name&gt;shawn-spring-boot-starter&lt;/name&gt;</span><br><span class="line">    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;</span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;</span><br><span class="line">            &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>
<h4 id="3、定义一个实体类映射配置信息">3、定义一个实体类映射配置信息</h4>
<p><code>@ConfigurationProperties(prefix = &quot;shawn.hello&quot;) </code>它可以把相同前缀的配置信息通过配置项名称映射成实体类，可以直接在yml文件进行配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前缀 shawn.hello</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"shawn.hello"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShawnProperties</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前缀</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String prefix;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后缀</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String suffix;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPrefix</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> prefix;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrefix</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.prefix = prefix;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSuffix</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> suffix;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSuffix</span><span class="params">(String suffix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.suffix = suffix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4、编写自己的服务">4、编写自己的服务</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShawnService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ShawnProperties ShawnProperties;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ShawnProperties <span class="title">getShawnProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ShawnProperties;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setShawnProperties</span><span class="params">(ShawnProperties ShawnProperties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ShawnProperties = ShawnProperties;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ShawnProperties.getPrefix() + name + ShawnProperties.getSuffix();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5、定义配置类">5、定义配置类</h4>
<p>这里，我们将ShawnService类定义为一个Bean，交给Ioc容器。<br>
<code>@Configuration</code> 配置注解<br>
<code>@EnableConfigurationProperties </code>。该注解是用来开启对<code>@ConfigurationProperties</code> 注解配置Bean的支持。当然了，也可以在 <code>@ConfigurationProperties</code> 注解的类上添加 <code>@Configuration</code> 或者  <code>@Component </code>注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication</span> <span class="comment">//web应用生效</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(ShawnProperties<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">ShawnServiceAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ShawnProperties shawnProperties;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ShawnService <span class="title">shawnService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ShawnService service = <span class="keyword">new</span> ShawnService();</span><br><span class="line">        service.setShawnProperties(shawnProperties);</span><br><span class="line">        <span class="keyword">return</span> service;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6、在resources编写一个自己的-META-INF-spring-factories">6、在<code>resources</code>编写一个自己的 <code>META-INF\spring.factories</code></h4>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">com.shawn.ShawnServiceAutoConfiguration</span><br></pre></td></tr></table></figure>
<h4 id="7、打包到Maven仓库">7、打包到Maven仓库</h4>
<p><img src="https://img-blog.csdnimg.cn/20210128183428374.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbW9uX1RU,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="三、测试starter">三、测试starter</h2>
<h4 id="1、新建项目，引入依赖">1、新建项目，引入依赖</h4>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.shawn<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shawn-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="2、编写测试类">2、编写测试类</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShawnCOntroller</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ShawnService shawnService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> shawnService.sayHello(<span class="string">"shawn"</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3、配置">3、配置</h4>
<p>在<code>application.yml</code>中进行配置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">shawn:</span></span><br><span class="line">  <span class="attr">hello:</span></span><br><span class="line">    <span class="attr">prefix:</span> <span class="string">prefix</span></span><br><span class="line">    <span class="attr">suffix:</span> <span class="string">suffix</span></span><br></pre></td></tr></table></figure>
<h4 id="4、测试">4、测试</h4>
<p>成功打印<br>
<img src="https://img-blog.csdnimg.cn/20210128185155637.png" alt="在这里插入图片描述"></p>
<hr>
<p>参考:<br>
<a href="https://www.cnblogs.com/hellokuangshen/p/12486631.html" target="_blank" rel="noopener">https://www.cnblogs.com/hellokuangshen/p/12486631.html</a><br>
<a href="https://www.cnblogs.com/hello-shf/p/10864977.html" target="_blank" rel="noopener">https://www.cnblogs.com/hello-shf/p/10864977.html</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>github实用的几款chrome插件</title>
    <url>/posts/d7585d3e.html</url>
    <content><![CDATA[<h2 id="谷歌上网助手">谷歌上网助手</h2>
<p>在chrome浏览器上安装插件，最方便的是在chrome网上应用商店进行搜索下载，这里强烈推荐<strong>谷歌上网助手</strong>，可以进行学术性的科学上网。</p>
<a id="more"></a>
<p><a href="http://googlehelper.net/" target="_blank" rel="noopener">谷歌上网助手下载地址</a><br>
打开浏览器的扩展程序，直接将下载的crx拖进去就行了，打开插件之后就可以进行<a href="https://chrome.google.com/webstore/category/extensions" target="_blank" rel="noopener">应用商店</a>的访问了。<br>
<img src="https://img-blog.csdnimg.cn/20201128211605953.gif" alt="在这里插入图片描述"></p>
<h2 id="1、Octotree-GitHub-code-tree">1、Octotree - GitHub code tree</h2>
<p><img src="https://img-blog.csdnimg.cn/20201128212348459.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbW9uX1RU,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
😃它会在github左边会生成一个 <code>Octotree</code> 按钮，登录后鼠标滑动代码文件树，这样就可以快速定位文件和查看文件了。类似的还有<code>Sourcegraph</code>插件<br>
<img src="https://img-blog.csdnimg.cn/20201128212757505.gif" alt="在这里插入图片描述"></p>
<h2 id="2、Enhanced-GitHub">2、Enhanced GitHub</h2>
<p>😊之前从github上下载文件都需要整个工程clone，下载了该插件后可以进行单个文件的下载<br>
<img src="https://img-blog.csdnimg.cn/20201128214504261.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbW9uX1RU,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
<img src="https://img-blog.csdnimg.cn/20201128214653377.gif" alt="在这里插入图片描述"></p>
<h2 id="3、GitZip">3、GitZip</h2>
<p>😆多个文件一起下载，或者单独下载一个文件夹<br>
<img src="https://img-blog.csdnimg.cn/20201128215001164.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbW9uX1RU,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
<img src="https://img-blog.csdnimg.cn/20201128214949675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbW9uX1RU,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="4、GitHub加速">4、GitHub加速</h2>
<p>😁<code>GitHub加速</code>插件能提高中国开发者访问 <code>GitHub</code> 的速度，提升<code>clone Git </code>仓库的速度，提升下载<code>release</code>包的下载速度。<br>
<img src="https://img-blog.csdnimg.cn/20201128215348199.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbW9uX1RU,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="5、Isometric-Contributions">5、Isometric Contributions</h2>
<p>😄更炫酷的3D立体方式渲染 GitHub 贡献图。<br>
<img src="https://img-blog.csdnimg.cn/2020112821563210.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbW9uX1RU,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
<img src="https://img-blog.csdnimg.cn/20201128215705248.gif" alt="在这里插入图片描述"></p>
<h2 id="6、Awesome-Autocomplete-for-GitHub">6、Awesome Autocomplete for GitHub</h2>
<p>😍更快地、准确的github搜索插件<br>
<img src="https://img-blog.csdnimg.cn/20201128220119232.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbW9uX1RU,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
<img src="https://img-blog.csdnimg.cn/2020112822333144.gif" alt="在这里插入图片描述"></p>
<h2 id="7、File-Icons-for-GitHub-and-GitLab">7、File Icons for GitHub and GitLab</h2>
<p>😚一个Chrome扩展，为GitHub、GitLab、gitea和gogs提供不同的文件类型图标。<br>
<img src="https://img-blog.csdnimg.cn/20201128220746676.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbW9uX1RU,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
<img src="https://img-blog.csdnimg.cn/20201128220928252.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbW9uX1RU,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
最后github相关的插件都可以去尝试<br>
<img src="https://img-blog.csdnimg.cn/20201128222017952.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbW9uX1RU,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<hr>
<p>参考文章：<br>
<a href="https://blog.csdn.net/xinzhifu1/article/details/109309805" target="_blank" rel="noopener">https://blog.csdn.net/xinzhifu1/article/details/109309805</a><br>
<a href="https://blog.csdn.net/Mrs_chens/article/details/104500188" target="_blank" rel="noopener">https://blog.csdn.net/Mrs_chens/article/details/104500188</a></p>
]]></content>
      <categories>
        <category>Github</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>VMware15安装MacOS10.15</title>
    <url>/posts/cb79a5e7.html</url>
    <content><![CDATA[<h3 id="1、MAC-OS安装">1、MAC OS安装</h3>
<p>具体安装流程下面这篇博客已经十分详细的描述了<br>
<a href="https://blog.csdn.net/SuperAE86/article/details/104653595?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control" target="_blank" rel="noopener">VM15pro安装MacOS10.15.1系统(超详细，可用)</a></p>
<blockquote>
<p>MacOS和unlocker云盘资料，防止失联<br>
链接：<a href="https://pan.baidu.com/s/1XXAIM8HtvtgYN-r5E4MzIQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1XXAIM8HtvtgYN-r5E4MzIQ</a><br>
提取码：l1dd</p>
</blockquote>
<a id="more"></a>
<h3 id="2、修改虚拟机的Mac分辨率">2、修改虚拟机的Mac分辨率?</h3>
<p>使用VM安装好Mac后你会发现界面很小，就算全屏也不能真正的全屏，这就是因为分辨率的关系<br>
解决方法如下：<br>
<strong>安装VMware Tools</strong><br>
<img src="https://img-blog.csdnimg.cn/20201124210742361.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbW9uX1RU,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>
如果点击后发现正在使用CD/DVD，则需要推出你正在使用的CD/DVD（操作方法右键选择推出xxx）<br>
<img src="https://img-blog.csdnimg.cn/20201124210711300.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbW9uX1RU,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>
安装好之后需要给软件安装权限，否则后面的命令会显示<code>Unable to find the service</code>，如果出现，根据<strong>系统偏好设置——&gt;安全性与隐私——&gt;通用</strong>，解锁，点击允许<img src="https://img-blog.csdnimg.cn/20201124211105852.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbW9uX1RU,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>
重启之后VMware Tools则安装完毕<br>
打开Mac终端并输入<br>
<code>sudo /Library/Application\ Support/VMware\ Tools/vmware-resolutionSet 1920 1080 </code><br>
后面的两个数字可以根据需求修改，最后重启即可</p>
]]></content>
      <categories>
        <category>虚拟化与云计算</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>IntelliJ IDEA好用的几款插件</title>
    <url>/posts/5f51afa8.html</url>
    <content><![CDATA[<h4 id="1、CodeGlance">1、CodeGlance</h4>
<p>代码迷你缩放图插件，可以快速拖动代码，和VScode一样<br>
<img src="https://img-blog.csdnimg.cn/20201106233342873.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbW9uX1RU,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="2、Codota">2、Codota</h4>
<p>代码提示工具，扫描你的代码后，根据你的敲击完美提示。<br>
Codota基于数百万个开源Java程序和您的上下文来完成代码行，从而帮助您以更少的错误更快地进行编码。</p>
<p><img src="https://img-blog.csdnimg.cn/20201106234011347.png#pic_center" alt="在这里插入图片描述"></p>
<a id="more"></a>
<h4 id="3、Alibaba-Java-Coding-Guidelines">3、Alibaba Java Coding Guidelines</h4>
<p>阿里巴巴的编码规约检查插件，检查你的编码习惯，让你更规范</p>
<h4 id="4、Alibaba-Cloud-Toolkit">4、Alibaba Cloud Toolkit</h4>
<p>快速部署到服务器<br>
<img src="https://img-blog.csdnimg.cn/20201106233606633.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbW9uX1RU,size_16,color_FFFFFF,t_70#pic_center" alt="请添加图片描述"></p>
<h4 id="5、GenerateAllSetter">5、GenerateAllSetter</h4>
<p>快速生成get set</p>
<h4 id="6、Lombok">6、Lombok</h4>
<p>简化long冗余的javabean代码，提高执行效率。只需加上注解 什么get set 什么toString 等等方法都不需要写。<br>
简单使用详见<a href="https://blog.csdn.net/lemon_TT/article/details/109249154" target="_blank" rel="noopener">Lombok常用注解</a></p>
<h4 id="7、JUnitGenerator">7、JUnitGenerator</h4>
<p>自动生成测试代码。<br>
<img src="https://img-blog.csdnimg.cn/20201106233606469.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbW9uX1RU,size_16,color_FFFFFF,t_70#pic_center" alt="请添加图片描述"></p>
<h4 id="8、EasyCode">8、EasyCode</h4>
<p>Easycode是idea的一个插件，可以直接对数据的表生成entity，controller，service，dao，mapper，无需任何编码，简单而强大。<br>
<img src="https://img-blog.csdnimg.cn/20201106233606598.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbW9uX1RU,size_16,color_FFFFFF,t_70#pic_center" alt="请添加图片描述"></p>
<h4 id="9、Chinese-Simplified">9、Chinese (Simplified)</h4>
<p>汉化插件，看不懂英文必备</p>
<h4 id="10、Free-MyBatis-plugin">10、Free MyBatis plugin</h4>
<p>free-idea-mybatis是一款增强idea对mybatis支持的插件（和EasyCode功能有重复），主要功能如下：</p>
<ul>
<li>生成mapper xml文件</li>
<li>快速从代码跳转到mapper及从mapper返回代码</li>
<li>mybatis自动补全及语法错误提示</li>
<li>集成mybatis generator gui界面<br>
<img src="https://img-blog.csdnimg.cn/20201106233606676.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbW9uX1RU,size_16,color_FFFFFF,t_70#pic_center" alt="请添加图片描述"></li>
</ul>
<h4 id="11、MyBatis-Log-Plugin">11、MyBatis Log Plugin</h4>
<p>这款插件是直接将Mybatis执行的sql脚本显示出来，把 mybatis 输出的sql日志还原成完整的sql语句。即将日志输出的sql语句中的问号 ? 替换成真正的参数值（收费）。</p>
<p><a href="https://github.com/Link-Kou/intellij-mybaitslog" target="_blank" rel="noopener">github官网</a></p>
<h4 id="12、MyBatisCodeHelperPro">12、MyBatisCodeHelperPro</h4>
<p>支持mapper互跳，方法自动生成，代码自动生成。(和Free MyBatis plugin功能有些重复,，但是收费)</p>
<blockquote>
<p>链接：<a href="https://pan.baidu.com/s/1vrxBM8ujm79jabo2D2w8mQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1vrxBM8ujm79jabo2D2w8mQ</a><br>
提取码：jxo8</p>
<p>收费两项可以使用本地安装，注意版本对应，具体可查询百度</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20201106233606606.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbW9uX1RU,size_16,color_FFFFFF,t_70#pic_center" alt="请添加图片描述"></p>
<h4 id="13、RestfulTool">13、RestfulTool</h4>
<ul>
<li>提供了一个 Services tree 的显示窗口</li>
<li>双击 URL 直接跳转到对应的方法定义</li>
<li>一个简单的 http 请求工具</li>
<li>支持 Spring 体系 (Spring MVC / Spring Boot)</li>
<li>支持 JAX-RS</li>
<li>支持 <code>Navigate -&gt; Request Service</code> 搜索 Mapping (Ctrl + Alt + /)<br>
<img src="https://img-blog.csdnimg.cn/20201106233606636.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbW9uX1RU,size_16,color_FFFFFF,t_70#pic_center" alt="请添加图片描述"></li>
</ul>
<h4 id="14、Translation">14、Translation</h4>
<p>翻译插件<br>
<img src="https://img-blog.csdnimg.cn/20201106233606515.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbW9uX1RU,size_16,color_FFFFFF,t_70#pic_center" alt="请添加图片描述"></p>
<h4 id="15、WakaTime">15、WakaTime</h4>
<p>这是一款 IDE 插件，支持市场上大部分IDE，可以统计你使用 IDE 每个项目的时长以及代码数，一周一统计，它会将你每周的每个项目的工作时长统计好之后发到你的邮箱。<br>
<a href="https://wakatime.com/" target="_blank" rel="noopener">后台地址</a></p>
<h4 id="16、Easy-Javadoc">16、Easy Javadoc</h4>
<p>Easy Javadoc是IntelliJ IDEA的插件，能帮助java开发者自动生成javadoc文档注释<br>
使用：将光标放置到想要生成注释的类、方法或者属性上，然后按下快捷键ctrl \或者command \，即可生成注释，你的方法名起的越贴切，注释越得体。</p>
<hr>
<p>参考文章:<br>
<a href="https://mp.weixin.qq.com/s/KXEPNl1Peu4n-XkdC4vFwA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/KXEPNl1Peu4n-XkdC4vFwA</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>IDETools</tag>
      </tags>
  </entry>
  <entry>
    <title>Android组件点击事件三种实现方法</title>
    <url>/posts/49a72762.html</url>
    <content><![CDATA[<h2 id="一、准备工作">一、准备工作</h2>
<h3 id="1、工作目录">1、工作目录</h3>
<p>首先创建空项目<br>
<img src="https://img-blog.csdnimg.cn/20201028225647376.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbW9uX1RU,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<a id="more"></a>
<h3 id="2、布局文件（activity-main-xml）">2、布局文件（activity_main.xml）</h3>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">".MainActivity"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/btn_click"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"点击我"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="二、三种实现方式">二、三种实现方式</h2>
<h3 id="1、在与事件绑定时定义事件监听器">1、在与事件绑定时定义事件监听器</h3>
<p>该方法是当通过调用组件的setXXXListener()方法设置监听器时，定义只能当前的组件使用的事件监听器，代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.listener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.widget.Button;</span><br><span class="line"><span class="keyword">import</span> android.widget.Toast;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        Button btnClick = findViewById(R.id.btn_click);</span><br><span class="line">        <span class="comment">//使用findViewById方法对控件进行获取</span></span><br><span class="line">        <span class="comment">//R.id.btn_click对应布局中添加的id属性</span></span><br><span class="line">        btnClick.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//里面写点击后想要实现的效果</span></span><br><span class="line">                Toast.makeText(MainActivity.<span class="keyword">this</span>,</span><br><span class="line">                        <span class="string">"按钮被点击"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">                <span class="comment">//这里是弹出一个消息---"按钮被点击"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、当前Activity类实现监听器接口">2、当前Activity类实现监听器接口</h3>
<p>该方法使当前Activity类实现相应的监听器接口，完成监听器中的抽象方法，组件绑定监听器时，监听器对象为Activity对象（常用）。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.listener;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">import</span> android.os.Bundle;</span><br><span class="line">        <span class="keyword">import</span> android.view.View;</span><br><span class="line">        <span class="keyword">import</span> android.widget.Button;</span><br><span class="line">        <span class="keyword">import</span> android.widget.Toast;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        Button btnClick = findViewById(R.id.btn_click);<span class="comment">//控件的获取</span></span><br><span class="line">        btnClick.setOnClickListener(MainActivity.<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//需要传入接口实现类的实例。</span></span><br><span class="line">        <span class="comment">//此时接口实现类的实例为MainActivity</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (view.getId())&#123;</span><br><span class="line">            <span class="keyword">case</span> R.id.btn_click:</span><br><span class="line">                <span class="comment">//里面写点击后想要实现的效果</span></span><br><span class="line">                Toast.makeText(MainActivity.<span class="keyword">this</span>,</span><br><span class="line">                        <span class="string">"按钮被点击"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">                <span class="comment">//这里是弹出一个消息---"按钮被点击"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3、XML布局文件中设置回调方法">3、XML布局文件中设置回调方法</h3>
<p>该方法是在XML布局文件中设置回调方法，在Java代码中实现该方法即可。但此方法不是一个通用的方法，但对按钮等常用组件的点击事件处理确实很方便。具体步骤如下：<br>
1、<code>activity_main.xml </code>布局文件中添加<code>onclick </code>属性，设定回调方法</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">".MainActivity"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/btn_click"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"点击我"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:onClick</span>=<span class="string">"Click"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>2、在<code>MainActivity</code>中添加<code>Click</code>方法即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.listener;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.widget.Button;</span><br><span class="line"><span class="keyword">import</span> android.widget.Toast;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        Button btnClick = findViewById(R.id.btn_click);<span class="comment">//控件的获取</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">Click</span><span class="params">(View view)</span></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (view.getId())&#123;</span><br><span class="line">            <span class="keyword">case</span> R.id.btn_click:<span class="comment">//此处是对布局中设置的id直接进行判断，</span></span><br><span class="line">                <span class="comment">// 不需要对控件进行获取（findviewByID）</span></span><br><span class="line">                Toast.makeText(<span class="keyword">this</span>, <span class="string">"按钮被点击"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>参考文章：<br>
<a href="https://www.cnblogs.com/xqz0618/p/click3.html" target="_blank" rel="noopener">https://www.cnblogs.com/xqz0618/p/click3.html</a></p>
]]></content>
      <tags>
        <tag>安卓</tag>
      </tags>
  </entry>
  <entry>
    <title>Lombok常用注解</title>
    <url>/posts/a283ce74.html</url>
    <content><![CDATA[<h2 id="1、Lombok简介">1、Lombok简介</h2>
<p>Lombok是一个可以通过简单的注解形式来帮助我们简化消除一些必须有但显得很臃肿的Java代码的工具，通过使用对应的注解，可以在编译源码的时候生成对应的方法。</p>
<blockquote>
<p>官方地址：<a href="https://projectlombok.org/" target="_blank" rel="noopener">https://projectlombok.org/</a><br>
github地址：<a href="https://github.com/rzwitserloot/lombok" target="_blank" rel="noopener">https://github.com/rzwitserloot/lombok</a></p>
</blockquote>
<a id="more"></a>
<h2 id="2、Maven引入">2、Maven引入</h2>
<p>除了引入maven，还需要安装Lombok插件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="3、注解介绍">3、注解介绍</h2>
<p><img src="https://img-blog.csdnimg.cn/20201023202423444.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbW9uX1RU,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li>
<p><code>@Getter /@Setter</code><br>
作用在字段上，会自动生成字段的Getter；作用在类上，会自动生成该类所有非静态字段的Getter，还能控制Getter的访问级别</p>
</li>
<li>
<p><code>@ToString</code><br>
类注解，自动生成类的toString方法，可以做一些定制，比如不使用某个字段，不调用Getters等</p>
</li>
<li>
<p><code>@EqualsAndHashCode</code><br>
自动生成 equals(Object other) 和 hashcode() 方法，包括所有非静态变量和非 transient 的变量，如果某些变量不想要加进判断，可以透过 exclude 排除，也可以使用 of 指定某些字段</p>
</li>
<li>
<p><code>@NoArgsConstructor, @AllArgsConstructor, @RequiredArgsConstructor</code><br>
@NoArgsConstructor 类注解，自动生成一个无参构造函数。<br>
@AllArgsConstructor 类注解，生成一个初始化所有字段的构造函数(在加上 @AllArgsConstructor 时，一定要补上 @NoArgsConstrcutor)<br>
@RequiredArgsConstructor : 生成一个包含 “特定参数” 的构造器，特定参数指的是那些有加上 final 修饰词的变量们.</p>
</li>
<li>
<p><code>@Data</code><br>
相当于同时应用了@Getter、@Setter、@ToString、@EqualsAndHashCode、@RequiredArgsConstructor。如果已经定义了一个构造方法，就不会再自动生成构造方法了。</p>
</li>
<li>
<p><code>@Value</code><br>
和@Data类似，但是用于不可变类型。生成的类和所有字段都设置为final，所有字段都为private，自动生成Getter但是没有Setter，会生成初始化所有字段的构造函数。相当于同时应用了final @ToString、 @EqualsAndHashCode、 @AllArgsConstructor 、@FieldDefaults(makeFinal = true, level = AccessLevel.PRIVATE)和 @Getter</p>
</li>
<li>
<p><code>@Builder</code><br>
自动生成流式 set 值写法，从此之后再也不用写一堆 setter 了。注意，虽然只要加上 @Builder 注解，我们就能够用流式写法快速设定对象的值，但是 setter 还是必须要写不能省略的，因为 Spring 或是其他框架有很多地方都会用到对象的 getter/setter 对他们取值/赋值。<br>
所以通常是 @Data 和 @Builder 会一起用在同个类上，既方便我们流式写代码，也方便框架做事</p>
</li>
<li>
<p><code>@NotNull</code><br>
作用在方法参数上的注解，用于自动生成空值参数检查。</p>
</li>
<li>
<p><code>@Slf4j</code><br>
自动生成该类的 log 静态常量，要打日志就可以直接打，不用再手动 new log 静态常量了</p>
</li>
</ul>
<hr>
<p>实际开发中一般常用到的:<br>
@Data<br>
@NoArgsConstructor<br>
@AllArgsConstructor</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span>         <span class="comment">// 生成 getter/setter/equals/canEqual/hashCode/toString        </span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span>     <span class="comment">// 为类提供一个无参的构造方法 </span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span>    <span class="comment">// 为类提供一个全参的构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stu</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> weigh;</span><br><span class="line">    <span class="keyword">int</span> high;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要链式调用，增加注解<code>@Accessor(chain = true)</code>后即可链式。同时注意Lombok可能会产生一定问题</p>
<hr>
<p>参考文章：<br>
<a href="https://www.cnblogs.com/ooo0/p/12448096.html" target="_blank" rel="noopener">https://www.cnblogs.com/ooo0/p/12448096.html</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java实现生成和解析二维码</title>
    <url>/posts/d5aff0bc.html</url>
    <content><![CDATA[<h2 id="1、建立项目">1、建立项目</h2>
<p>首先需要创建一个普通的 Maven 项目，在这里我用的是 google 提供的 jar包，pom.xml 文件配置如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.javaboy<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>QRCode<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 添加 google 提供的二维码依赖 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.zxing<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果maven没有反应，建议刷新一下或者更换maven源（我用的就是阿里云源）</p>
</blockquote>
<a id="more"></a>
<h2 id="2、创建工具类">2、创建工具类</h2>
<p>这里需要创建两个工具类<code>BufferedImageLuminanceSource</code>和<code>QRCodeUtil</code>类。项目结构如下，我创建的是springboot的jar包，当然其他的也都可以的。<br>
<img src="https://img-blog.csdnimg.cn/2020101822193848.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbW9uX1RU,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li>工具类1 (BufferedImageLuminanceSource)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.csdn.qrcode.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.zxing.LuminanceSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.geom.AffineTransform;</span><br><span class="line"><span class="keyword">import</span> java.awt.image.BufferedImage;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedImageLuminanceSource</span> <span class="keyword">extends</span> <span class="title">LuminanceSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BufferedImage image;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> left;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> top;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BufferedImageLuminanceSource</span><span class="params">(BufferedImage image)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(image, <span class="number">0</span>, <span class="number">0</span>, image.getWidth(), image.getHeight());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BufferedImageLuminanceSource</span><span class="params">(BufferedImage image, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(width, height);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sourceWidth = image.getWidth();</span><br><span class="line">        <span class="keyword">int</span> sourceHeight = image.getHeight();</span><br><span class="line">        <span class="keyword">if</span> (left + width &gt; sourceWidth || top + height &gt; sourceHeight) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Crop rectangle does not fit within image data."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> y = top; y &lt; top + height; y++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x = left; x &lt; left + width; x++) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((image.getRGB(x, y) &amp; <span class="number">0xFF000000</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                    image.setRGB(x, y, <span class="number">0xFFFFFFFF</span>); <span class="comment">// = white</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.image = <span class="keyword">new</span> BufferedImage(sourceWidth, sourceHeight, BufferedImage.TYPE_BYTE_GRAY);</span><br><span class="line">        <span class="keyword">this</span>.image.getGraphics().drawImage(image, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.top = top;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] getRow(<span class="keyword">int</span> y, <span class="keyword">byte</span>[] row) &#123;</span><br><span class="line">        <span class="keyword">if</span> (y &lt; <span class="number">0</span> || y &gt;= getHeight()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Requested row is outside the image: "</span> + y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> width = getWidth();</span><br><span class="line">        <span class="keyword">if</span> (row == <span class="keyword">null</span> || row.length &lt; width) &#123;</span><br><span class="line">            row = <span class="keyword">new</span> <span class="keyword">byte</span>[width];</span><br><span class="line">        &#125;</span><br><span class="line">        image.getRaster().getDataElements(left, top + y, width, <span class="number">1</span>, row);</span><br><span class="line">        <span class="keyword">return</span> row;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] getMatrix() &#123;</span><br><span class="line">        <span class="keyword">int</span> width = getWidth();</span><br><span class="line">        <span class="keyword">int</span> height = getHeight();</span><br><span class="line">        <span class="keyword">int</span> area = width * height;</span><br><span class="line">        <span class="keyword">byte</span>[] matrix = <span class="keyword">new</span> <span class="keyword">byte</span>[area];</span><br><span class="line">        image.getRaster().getDataElements(left, top, width, height, matrix);</span><br><span class="line">        <span class="keyword">return</span> matrix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCropSupported</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LuminanceSource <span class="title">crop</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BufferedImageLuminanceSource(image, <span class="keyword">this</span>.left + left, <span class="keyword">this</span>.top + top, width, height);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRotateSupported</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LuminanceSource <span class="title">rotateCounterClockwise</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sourceWidth = image.getWidth();</span><br><span class="line">        <span class="keyword">int</span> sourceHeight = image.getHeight();</span><br><span class="line">        AffineTransform transform = <span class="keyword">new</span> AffineTransform(<span class="number">0.0</span>, -<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, sourceWidth);</span><br><span class="line">        BufferedImage rotatedImage = <span class="keyword">new</span> BufferedImage(sourceHeight, sourceWidth, BufferedImage.TYPE_BYTE_GRAY);</span><br><span class="line">        Graphics2D g = rotatedImage.createGraphics();</span><br><span class="line">        g.drawImage(image, transform, <span class="keyword">null</span>);</span><br><span class="line">        g.dispose();</span><br><span class="line">        <span class="keyword">int</span> width = getWidth();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BufferedImageLuminanceSource(rotatedImage, top, sourceWidth - (left + width), getHeight(), width);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>工具类2 (QRCodeUtil)<br>
这里面可以修改一些参数，例如二维码的尺寸，宽高等等。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.csdn.qrcode.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.zxing.*;</span><br><span class="line"><span class="keyword">import</span> com.google.zxing.common.BitMatrix;</span><br><span class="line"><span class="keyword">import</span> com.google.zxing.common.HybridBinarizer;</span><br><span class="line"><span class="keyword">import</span> com.google.zxing.qrcode.decoder.ErrorCorrectionLevel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.imageio.ImageIO;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.geom.RoundRectangle2D;</span><br><span class="line"><span class="keyword">import</span> java.awt.image.BufferedImage;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QRCodeUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CHARSET = <span class="string">"utf-8"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String FORMAT_NAME = <span class="string">"JPG"</span>;</span><br><span class="line">    <span class="comment">// 二维码尺寸</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> QRCODE_SIZE = <span class="number">300</span>;</span><br><span class="line">    <span class="comment">// LOGO宽度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WIDTH = <span class="number">60</span>;</span><br><span class="line">    <span class="comment">// LOGO高度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HEIGHT = <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> BufferedImage <span class="title">createImage</span><span class="params">(String content, String imgPath, <span class="keyword">boolean</span> needCompress)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Hashtable hints = <span class="keyword">new</span> Hashtable();</span><br><span class="line">        hints.put(EncodeHintType.ERROR_CORRECTION, ErrorCorrectionLevel.H);</span><br><span class="line">        hints.put(EncodeHintType.CHARACTER_SET, CHARSET);</span><br><span class="line">        hints.put(EncodeHintType.MARGIN, <span class="number">1</span>);</span><br><span class="line">        BitMatrix bitMatrix = <span class="keyword">new</span> MultiFormatWriter().encode(content, BarcodeFormat.QR_CODE, QRCODE_SIZE, QRCODE_SIZE,</span><br><span class="line">                hints);</span><br><span class="line">        <span class="keyword">int</span> width = bitMatrix.getWidth();</span><br><span class="line">        <span class="keyword">int</span> height = bitMatrix.getHeight();</span><br><span class="line">        BufferedImage image = <span class="keyword">new</span> BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; width; x++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; height; y++) &#123;</span><br><span class="line">                image.setRGB(x, y, bitMatrix.get(x, y) ? <span class="number">0xFF000000</span> : <span class="number">0xFFFFFFFF</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (imgPath == <span class="keyword">null</span> || <span class="string">""</span>.equals(imgPath)) &#123;</span><br><span class="line">            <span class="keyword">return</span> image;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 插入图片</span></span><br><span class="line">        QRCodeUtil.insertImage(image, imgPath, needCompress);</span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertImage</span><span class="params">(BufferedImage source, String imgPath, <span class="keyword">boolean</span> needCompress)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(imgPath);</span><br><span class="line">        <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">            System.err.println(<span class="string">""</span> + imgPath + <span class="string">" 该文件不存在！"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Image src = ImageIO.read(<span class="keyword">new</span> File(imgPath));</span><br><span class="line">        <span class="keyword">int</span> width = src.getWidth(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">int</span> height = src.getHeight(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (needCompress) &#123; <span class="comment">// 压缩LOGO</span></span><br><span class="line">            <span class="keyword">if</span> (width &gt; WIDTH) &#123;</span><br><span class="line">                width = WIDTH;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (height &gt; HEIGHT) &#123;</span><br><span class="line">                height = HEIGHT;</span><br><span class="line">            &#125;</span><br><span class="line">            Image image = src.getScaledInstance(width, height, Image.SCALE_SMOOTH);</span><br><span class="line">            BufferedImage tag = <span class="keyword">new</span> BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);</span><br><span class="line">            Graphics g = tag.getGraphics();</span><br><span class="line">            g.drawImage(image, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">null</span>); <span class="comment">// 绘制缩小后的图</span></span><br><span class="line">            g.dispose();</span><br><span class="line">            src = image;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 插入LOGO</span></span><br><span class="line">        Graphics2D graph = source.createGraphics();</span><br><span class="line">        <span class="keyword">int</span> x = (QRCODE_SIZE - width) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> y = (QRCODE_SIZE - height) / <span class="number">2</span>;</span><br><span class="line">        graph.drawImage(src, x, y, width, height, <span class="keyword">null</span>);</span><br><span class="line">        Shape shape = <span class="keyword">new</span> RoundRectangle2D.Float(x, y, width, width, <span class="number">6</span>, <span class="number">6</span>);</span><br><span class="line">        graph.setStroke(<span class="keyword">new</span> BasicStroke(<span class="number">3f</span>));</span><br><span class="line">        graph.draw(shape);</span><br><span class="line">        graph.dispose();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(String content, String imgPath, String destPath, <span class="keyword">boolean</span> needCompress)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        BufferedImage image = QRCodeUtil.createImage(content, imgPath, needCompress);</span><br><span class="line">        mkdirs(destPath);</span><br><span class="line">        <span class="comment">// String file = new Random().nextInt(99999999)+".jpg";</span></span><br><span class="line">        <span class="comment">// ImageIO.write(image, FORMAT_NAME, new File(destPath+"/"+file));</span></span><br><span class="line">        ImageIO.write(image, FORMAT_NAME, <span class="keyword">new</span> File(destPath));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BufferedImage <span class="title">encode</span><span class="params">(String content, String imgPath, <span class="keyword">boolean</span> needCompress)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        BufferedImage image = QRCodeUtil.createImage(content, imgPath, needCompress);</span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mkdirs</span><span class="params">(String destPath)</span> </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(destPath);</span><br><span class="line">        <span class="comment">// 当文件夹不存在时，mkdirs会自动创建多层目录，区别于mkdir．(mkdir如果父目录不存在则会抛出异常)</span></span><br><span class="line">        <span class="keyword">if</span> (!file.exists() &amp;&amp; !file.isDirectory()) &#123;</span><br><span class="line">            file.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(String content, String imgPath, String destPath)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        QRCodeUtil.encode(content, imgPath, destPath, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 被注释的方法</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * public static void encode(String content, String destPath, boolean</span></span><br><span class="line"><span class="comment">     * needCompress) throws Exception &#123; QRCodeUtil.encode(content, null, destPath,</span></span><br><span class="line"><span class="comment">     * needCompress); &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(String content, String destPath)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        QRCodeUtil.encode(content, <span class="keyword">null</span>, destPath, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(String content, String imgPath, OutputStream output, <span class="keyword">boolean</span> needCompress)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        BufferedImage image = QRCodeUtil.createImage(content, imgPath, needCompress);</span><br><span class="line">        ImageIO.write(image, FORMAT_NAME, output);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(String content, OutputStream output)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        QRCodeUtil.encode(content, <span class="keyword">null</span>, output, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">decode</span><span class="params">(File file)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        BufferedImage image;</span><br><span class="line">        image = ImageIO.read(file);</span><br><span class="line">        <span class="keyword">if</span> (image == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        BufferedImageLuminanceSource source = <span class="keyword">new</span> BufferedImageLuminanceSource(image);</span><br><span class="line">        BinaryBitmap bitmap = <span class="keyword">new</span> BinaryBitmap(<span class="keyword">new</span> HybridBinarizer(source));</span><br><span class="line">        Result result;</span><br><span class="line">        Hashtable hints = <span class="keyword">new</span> Hashtable();</span><br><span class="line">        hints.put(DecodeHintType.CHARACTER_SET, CHARSET);</span><br><span class="line">        result = <span class="keyword">new</span> MultiFormatReader().decode(bitmap, hints);</span><br><span class="line">        String resultStr = result.getText();</span><br><span class="line">        <span class="keyword">return</span> resultStr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">decode</span><span class="params">(String path)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QRCodeUtil.decode(<span class="keyword">new</span> File(path));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3、创建启动类">3、创建启动类</h2>
<p>这一步就是调用方法，一般大家使用这种功能都是为了实现业务，例如常见的扫描二维码跳转链接（页面），扫描二维码出现文字等等。有些二维码中间还带有 Logo 这种图片，将需要嵌入二维码的图片路径准备好就没有问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.csdn.qrcode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.csdn.qrcode.util.QRCodeUtil;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QrcodeApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 存放在二维码中的内容</span></span><br><span class="line">        <span class="comment">// 二维码中的内容可以是文字，可以是链接等</span></span><br><span class="line">        String text = <span class="string">"http://www.baidu.com"</span>;</span><br><span class="line">        <span class="comment">// 嵌入二维码的图片路径</span></span><br><span class="line">        <span class="comment">// String imgPath = "C:\\Users\\Administrator\\Pictures\\img\\dog.jpg";</span></span><br><span class="line">        String imgPath = <span class="string">"picture/lemon.jpg"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成的二维码的路径及名称</span></span><br><span class="line">        String destPath = <span class="string">"picture/"</span> + System.currentTimeMillis() + <span class="string">".jpg"</span>;</span><br><span class="line">        <span class="comment">//生成不带logo的二维码</span></span><br><span class="line">        <span class="comment">// QRCodeUtil.encode(text, null, destPath, true);</span></span><br><span class="line">        <span class="comment">//生成带logo的二维码</span></span><br><span class="line">        QRCodeUtil.encode(text, imgPath, destPath, <span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 解析二维码</span></span><br><span class="line">        String str = QRCodeUtil.decode(destPath);</span><br><span class="line">        <span class="comment">// 打印出解析出的内容</span></span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果:<br>
<img src="https://img-blog.csdnimg.cn/20201018222534856.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbW9uX1RU,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<hr>
<p>参考文章：<br>
<a href="https://gitee.com/jian_bo_bai/QRCode" target="_blank" rel="noopener">https://gitee.com/jian_bo_bai/QRCode</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java8 日期时间类整理</title>
    <url>/posts/1af375c2.html</url>
    <content><![CDATA[<blockquote>
<p>当我们开始使⽤Java操作⽇期和时间的时候，会有⼀些棘⼿。你也许会通过 System.currentTimeMillis() 来返回1970年1⽉1⽇到今天的毫秒数。或者使⽤ Date类来操作⽇期；当遇到加减⽉份、天数的时候 你⼜需要⽤到Calendar类； 当需要格式化⽇期的时候需要使⽤java.text.DateFormat类。</p>
</blockquote>
<a id="more"></a>
<h1>一、Date类型存在的问题</h1>
<ul>
<li>
<p>结构定义混乱</p>
<ul>
<li>java.util Date包含日期时间</li>
<li>java.sql Date包含日期</li>
<li>java.text 时间格式化</li>
</ul>
</li>
<li>
<p>API不易用</p>
</li>
<li>
<p>非线程安全</p>
<ul>
<li>可变，SimpleDateFormate</li>
</ul>
</li>
<li>
<p>国际化</p>
<ul>
<li>Calendar TimeZone</li>
</ul>
<p><code>Date</code>如果不格式化，打印出的日期可读性差</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Tue Sep <span class="number">10</span> <span class="number">09</span>:<span class="number">34</span>:<span class="number">04</span> CST <span class="number">2020</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1>二、Java8新的日期时间类</h1>
<h2 id="1、LocalDate">1、LocalDate</h2>
<p>只会获取年月日</p>
<ul>
<li>创建<code>LocalDate</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取当前年月日  </span></span><br><span class="line">LocalDate localDate = LocalDate.now();  </span><br><span class="line"><span class="comment">//构造指定的年月日  </span></span><br><span class="line">LocalDate localDate1 = LocalDate.of(<span class="number">2020</span>, <span class="number">10</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>获取年、月、日、星期几</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取年</span></span><br><span class="line"><span class="keyword">int</span> year = localDate.getYear();  </span><br><span class="line"><span class="keyword">int</span> year1 = localDate.get(ChronoField.YEAR);  </span><br><span class="line"><span class="comment">//获取月份</span></span><br><span class="line">Month month = localDate.getMonth();  </span><br><span class="line"><span class="keyword">int</span> month1 = localDate.get(ChronoField.MONTH_OF_YEAR);  </span><br><span class="line"><span class="comment">//获取天</span></span><br><span class="line"><span class="keyword">int</span> day = localDate.getDayOfMonth();  </span><br><span class="line"><span class="keyword">int</span> day1 = localDate.get(ChronoField.DAY_OF_MONTH);  </span><br><span class="line"><span class="comment">//获取星期几</span></span><br><span class="line">DayOfWeek dayOfWeek = localDate.getDayOfWeek();  </span><br><span class="line"><span class="keyword">int</span> dayOfWeek1 = localDate.get(ChronoField.DAY_OF_WEEK);</span><br></pre></td></tr></table></figure>
<h2 id="2、LocalTime">2、LocalTime</h2>
<p>只会获取几点几分几秒</p>
<ul>
<li>创建<code>LocalTime</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalTime localTime = LocalTime.of(<span class="number">13</span>, <span class="number">51</span>, <span class="number">10</span>);  </span><br><span class="line">LocalTime localTime1 = LocalTime.now();</span><br></pre></td></tr></table></figure>
<ul>
<li>获取时分秒</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取小时  </span></span><br><span class="line"><span class="keyword">int</span> hour = localTime.getHour();  </span><br><span class="line"><span class="keyword">int</span> hour1 = localTime.get(ChronoField.HOUR_OF_DAY);  </span><br><span class="line"><span class="comment">//获取分  </span></span><br><span class="line"><span class="keyword">int</span> minute = localTime.getMinute();  </span><br><span class="line"><span class="keyword">int</span> minute1 = localTime.get(ChronoField.MINUTE_OF_HOUR);  </span><br><span class="line"><span class="comment">//获取秒  </span></span><br><span class="line"><span class="keyword">int</span> second = localTime.getSecond();  </span><br><span class="line"><span class="keyword">int</span> second1 = localTime.get(ChronoField.SECOND_OF_MINUTE);</span><br></pre></td></tr></table></figure>
<h2 id="3、LocalDateTime">3、LocalDateTime</h2>
<p>获取年月日时分秒，等于LocalDate+LocalTime</p>
<ul>
<li>创建<code>LocalDateTime</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDateTime localDateTime = LocalDateTime.now();  </span><br><span class="line">LocalDateTime localDateTime1 = LocalDateTime.of(<span class="number">2020</span>, Month.SEPTEMBER, <span class="number">10</span>, <span class="number">14</span>, <span class="number">46</span>, <span class="number">56</span>);  </span><br><span class="line">LocalDateTime localDateTime2 = LocalDateTime.of(localDate, localTime);  </span><br><span class="line">LocalDateTime localDateTime3 = localDate.atTime(localTime);  </span><br><span class="line">LocalDateTime localDateTime4 = localTime.atDate(localDate);</span><br></pre></td></tr></table></figure>
<ul>
<li>获取<code>LocalDate</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDate localDate2 = localDateTime.toLocalDate();</span><br></pre></td></tr></table></figure>
<ul>
<li>获取<code>LocalTime</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalTime localTime2 = localDateTime.toLocalTime();</span><br></pre></td></tr></table></figure>
<h2 id="4、Instant">4、Instant</h2>
<p>获取秒数</p>
<ul>
<li>创建<code>Instant</code>对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Instant instant = Instant.now();</span><br></pre></td></tr></table></figure>
<ul>
<li>获取秒数</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> currentSecond = instant.getEpochSecond();</span><br></pre></td></tr></table></figure>
<ul>
<li>获取毫秒数</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> currentMilli = instant.toEpochMilli();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果只是为了获取秒数或者毫秒数，使用<code>System.currentTimeMillis()</code>来得更为方便</p>
</blockquote>
<h1>三、日期时间的修改与计算</h1>
<p><strong><code>LocalDate</code>、<code>LocalTime</code>、<code>LocalDateTime</code>、<code>Instant</code>为</strong>不可变对象**，修改这些对象对象会**返回一个副本****</p>
<h2 id="1、时间修改">1、时间修改</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDateTime localDateTime = LocalDateTime.of(<span class="number">2020</span>, Month.SEPTEMBER, <span class="number">10</span>,  </span><br><span class="line">              <span class="number">14</span>, <span class="number">46</span>, <span class="number">56</span>);  </span><br><span class="line"><span class="comment">//增加一年  </span></span><br><span class="line">localDateTime = localDateTime.plusYears(<span class="number">1</span>);  </span><br><span class="line">localDateTime = localDateTime.plus(<span class="number">1</span>, ChronoUnit.YEARS);  </span><br><span class="line"><span class="comment">//减少一个月  </span></span><br><span class="line">localDateTime = localDateTime.minusMonths(<span class="number">1</span>);  </span><br><span class="line">localDateTime = localDateTime.minus(<span class="number">1</span>, ChronoUnit.MONTHS);  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用with进行修改</span></span><br><span class="line"><span class="comment">//修改年为2020</span></span><br><span class="line">localDateTime = localDateTime.withYear(<span class="number">2020</span>);  </span><br><span class="line"><span class="comment">//修改为2022  </span></span><br><span class="line">localDateTime = localDateTime.with(ChronoField.YEAR, <span class="number">2022</span>);</span><br></pre></td></tr></table></figure>
<p>另外比如有些时候想知道这个月的最后一天是几号、下个周末是几号，通过提供的时间和日期API可以很快得到答案，比如通过<code>firstDayOfYear()</code>返回了当前日期的第一天日期</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDate localDate = LocalDate.now();  </span><br><span class="line">LocalDate localDate1 = localDate.with(firstDayOfYear());</span><br></pre></td></tr></table></figure>
<h2 id="2、格式化日期-常用">2、格式化日期(常用)</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDate localDate = LocalDate.of(<span class="number">2020</span>, <span class="number">10</span>, <span class="number">10</span>);  </span><br><span class="line">String s1 = localDate.format(DateTimeFormatter.BASIC_ISO_DATE);  </span><br><span class="line">String s2 = localDate.format(DateTimeFormatter.ISO_LOCAL_DATE);  </span><br><span class="line"><span class="comment">//自定义格式化  </span></span><br><span class="line">DateTimeFormatter dateTimeFormatter =   DateTimeFormatter.ofPattern(<span class="string">"dd/MM/yyyy"</span>);  </span><br><span class="line">String s3 = localDate.format(dateTimeFormatter);</span><br></pre></td></tr></table></figure>
<p><code>DateTimeFormatter</code>默认提供了多种格式化方式，如果默认提供的不能满足要求，可以通过<code>DateTimeFormatter</code>的<code>ofPattern</code>方法创建自定义格式化方式</p>
<h4 id="解析时间">解析时间</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDate localDate1 = LocalDate.parse(<span class="string">"20201010"</span>, DateTimeFormatter.BASIC_ISO_DATE);  </span><br><span class="line">LocalDate localDate2 = LocalDate.parse(<span class="string">"2020-10-10"</span>, DateTimeFormatter.ISO_LOCAL_DATE);</span><br></pre></td></tr></table></figure>
<p>和<code>SimpleDateFormat</code>相比，<code>DateTimeFormatter</code>是线程安全的</p>
<h1>四、LocalDateTime在SpringBoot中的应用</h1>
<h2 id="1、将LocalDateTime字段以时间戳的方式返回给前端-添加日期转化类">1、将LocalDateTime字段以时间戳的方式返回给前端 添加日期转化类</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalDateTimeConverter</span> <span class="keyword">extends</span> <span class="title">JsonSerializer</span>&lt;<span class="title">LocalDateTime</span>&gt; </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serialize</span><span class="params">(LocalDateTime value, JsonGenerator gen, SerializerProvider serializers)</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line">    gen.writeNumber(value.toInstant(ZoneOffset.of(<span class="string">"+8"</span>)).toEpochMilli());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并在<code>LocalDateTime </code> 字段上添加<code>@JsonSerialize(using = LocalDateTimeConverter.class) </code> 注解，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JsonSerialize</span>(using = LocalDateTimeConverter<span class="class">.<span class="keyword">class</span>)  </span></span><br><span class="line"><span class="class"><span class="title">protected</span> <span class="title">LocalDateTime</span> <span class="title">gmtModified</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="2、将LocalDateTime字段以指定格式化日期的方式返回给前端">2、将LocalDateTime字段以指定格式化日期的方式返回给前端</h2>
<p>在<code>LocalDateTime </code>字段上添加<code>@JsonFormat(shape=JsonFormat.Shape.STRING, pattern=&quot;yyyy-MM-dd HH:mm:ss&quot;) </code>注解即可，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JsonFormat</span>(shape=JsonFormat.Shape.STRING, pattern=<span class="string">"yyyy-MM-dd HH:mm:ss"</span>)  </span><br><span class="line"><span class="keyword">protected</span> LocalDateTime gmtModified;</span><br></pre></td></tr></table></figure>
<h2 id="3、对前端传入的日期进行格式化">3、对前端传入的日期进行格式化</h2>
<p>在<code>LocalDateTime</code>字段上添加<code>@DateTimeFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;) </code>注解即可，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@DateTimeFormat</span>(pattern = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>)  </span><br><span class="line"><span class="keyword">protected</span> LocalDateTime gmtModified;</span><br></pre></td></tr></table></figure>
<h2 id="4、前后端日期时间转化问题">4、前后端日期时间转化问题</h2>
<ul>
<li><strong>方式一</strong></li>
</ul>
<p>在实体类上加<code>@DatetimeFormat</code>与<code>@JsonFormat</code>注解</p>
<p><code>@DatetimeFormat</code>将前台日期字符串转换成Date格式 <code>@DateTimeFormat(pattern=&quot;yyyy-MM-dd&quot;)</code></p>
<p><code>@JsonFormat</code>将服务器端Date日期转换成指定字符串格式<code> @JsonFormat(pattern=&quot;yyyy-MM-dd&quot;,timezone=&quot;GMT+8&quot;)</code></p>
<p><strong>两个需要同时加，否则会有时区的问题</strong></p>
<ul>
<li><strong>方式二</strong></li>
</ul>
<p>在applicition.properties中添加如下配置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#时间戳统一转换</span></span><br><span class="line"><span class="string">spring.jackson.date-format=yyyy-MM-dd</span> <span class="string">HH:mm:ss</span></span><br><span class="line"><span class="string">spring.jackson.time-zone=GMT+8</span></span><br></pre></td></tr></table></figure>
<p>或者在application.yml中添加如下配置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#时间戳统一转换</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">jackson:</span></span><br><span class="line">    <span class="attr">date-format:</span> <span class="string">yyyy-MM-dd</span> <span class="string">HH:mm:ss</span></span><br><span class="line">    <span class="attr">time-zone:</span> <span class="string">GMT+8</span></span><br></pre></td></tr></table></figure>
<hr>
<p>参考文章：</p>
<p><a href="https://www.cnblogs.com/w-essay/p/11453943.html" target="_blank" rel="noopener">https://www.cnblogs.com/w-essay/p/11453943.html</a></p>
<p><a href="https://mp.weixin.qq.com/s/7LzRjG_uGjXq5yIwiSnV2w" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/7LzRjG_uGjXq5yIwiSnV2w</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>git命令清单</title>
    <url>/posts/2163f62e.html</url>
    <content><![CDATA[<p>一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。<br>
<img src="https://img-blog.csdnimg.cn/20201016212956605.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbW9uX1RU,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li>Workspace：工作区</li>
<li>Index / Stage：暂存区</li>
<li>Repository：仓库区（或本地仓库）</li>
<li>Remote：远程仓库</li>
</ul>
<hr>
<a id="more"></a>
<h2 id="一、新建代码库">一、新建代码库</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在当前目录新建一个Git代码库</span><br><span class="line">$ git init</span><br><span class="line"></span><br><span class="line"># 新建一个目录，将其初始化为Git代码库</span><br><span class="line">$ git init [project-name]</span><br><span class="line"></span><br><span class="line"># 下载一个项目和它的整个代码历史</span><br><span class="line">$ git clone [url]</span><br></pre></td></tr></table></figure>
<h2 id="二、配置">二、配置</h2>
<p>Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在当前目录新建一个Git代码库</span><br><span class="line">$ git init</span><br><span class="line"></span><br><span class="line"># 新建一个目录，将其初始化为Git代码库</span><br><span class="line">$ git init [project-name]</span><br><span class="line"></span><br><span class="line"># 下载一个项目和它的整个代码历史</span><br><span class="line">$ git clone [url]</span><br></pre></td></tr></table></figure>
<h2 id="三、增加-删除文件">三、增加/删除文件</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 添加指定文件到暂存区</span><br><span class="line">$ git add [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"># 添加指定目录到暂存区，包括子目录</span><br><span class="line">$ git add [dir]</span><br><span class="line"></span><br><span class="line"># 添加当前目录的所有文件到暂存区</span><br><span class="line">$ git add .</span><br><span class="line"></span><br><span class="line"># 添加每个变化前，都会要求确认</span><br><span class="line"># 对于同一个文件的多处变化，可以实现分次提交</span><br><span class="line">$ git add -p</span><br><span class="line"></span><br><span class="line"># 删除工作区文件，并且将这次删除放入暂存区</span><br><span class="line">$ git rm [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"># 停止追踪指定文件，但该文件会保留在工作区</span><br><span class="line">$ git rm --cached [file]</span><br><span class="line"></span><br><span class="line"># 改名文件，并且将这个改名放入暂存区</span><br><span class="line">$ git mv [file-original] [file-renamed]</span><br></pre></td></tr></table></figure>
<h2 id="四、代码提交">四、代码提交</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 提交暂存区到仓库区</span><br><span class="line">$ git commit -m [message]</span><br><span class="line"></span><br><span class="line"># 提交暂存区的指定文件到仓库区</span><br><span class="line">$ git commit [file1] [file2] ... -m [message]</span><br><span class="line"></span><br><span class="line"># 提交工作区自上次commit之后的变化，直接到仓库区</span><br><span class="line">$ git commit -a</span><br><span class="line"></span><br><span class="line"># 提交时显示所有diff信息</span><br><span class="line">$ git commit -v</span><br><span class="line"></span><br><span class="line"># 使用一次新的commit，替代上一次提交</span><br><span class="line"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span><br><span class="line">$ git commit --amend -m [message]</span><br><span class="line"></span><br><span class="line"># 重做上一次commit，并包括指定文件的新变化</span><br><span class="line">$ git commit --amend [file1] [file2] ...</span><br></pre></td></tr></table></figure>
<h2 id="五、分支">五、分支</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 列出所有本地分支</span><br><span class="line">$ git branch</span><br><span class="line"></span><br><span class="line"># 列出所有远程分支</span><br><span class="line">$ git branch -r</span><br><span class="line"></span><br><span class="line"># 列出所有本地分支和远程分支</span><br><span class="line">$ git branch -a</span><br><span class="line"></span><br><span class="line"># 新建一个分支，但依然停留在当前分支</span><br><span class="line">$ git branch [branch-name]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，并切换到该分支</span><br><span class="line">$ git checkout -b [branch]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，指向指定commit</span><br><span class="line">$ git branch [branch] [commit]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，与指定的远程分支建立追踪关系</span><br><span class="line">$ git branch --track [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"># 切换到指定分支，并更新工作区</span><br><span class="line">$ git checkout [branch-name]</span><br><span class="line"></span><br><span class="line"># 切换到上一个分支</span><br><span class="line">$ git checkout -</span><br><span class="line"></span><br><span class="line"># 建立追踪关系，在现有分支与指定的远程分支之间</span><br><span class="line">$ git branch --set-upstream [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"># 合并指定分支到当前分支</span><br><span class="line">$ git merge [branch]</span><br><span class="line"></span><br><span class="line"># 选择一个commit，合并进当前分支</span><br><span class="line">$ git cherry-pick [commit]</span><br><span class="line"></span><br><span class="line"># 删除分支</span><br><span class="line">$ git branch -d [branch-name]</span><br><span class="line"></span><br><span class="line"># 删除远程分支</span><br><span class="line">$ git push origin --delete [branch-name]</span><br><span class="line">$ git branch -dr [remote&#x2F;branch]</span><br></pre></td></tr></table></figure>
<h2 id="六、标签">六、标签</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 列出所有tag</span><br><span class="line">$ git tag</span><br><span class="line"></span><br><span class="line"># 新建一个tag在当前commit</span><br><span class="line">$ git tag [tag]</span><br><span class="line"></span><br><span class="line"># 新建一个tag在指定commit</span><br><span class="line">$ git tag [tag] [commit]</span><br><span class="line"></span><br><span class="line"># 删除本地tag</span><br><span class="line">$ git tag -d [tag]</span><br><span class="line"></span><br><span class="line"># 删除远程tag</span><br><span class="line">$ git push origin :refs&#x2F;tags&#x2F;[tagName]</span><br><span class="line"></span><br><span class="line"># 查看tag信息</span><br><span class="line">$ git show [tag]</span><br><span class="line"></span><br><span class="line"># 提交指定tag</span><br><span class="line">$ git push [remote] [tag]</span><br><span class="line"></span><br><span class="line"># 提交所有tag</span><br><span class="line">$ git push [remote] --tags</span><br><span class="line"></span><br><span class="line"># 新建一个分支，指向某个tag</span><br><span class="line">$ git checkout -b [branch] [tag]</span><br></pre></td></tr></table></figure>
<h2 id="七、查看信息">七、查看信息</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 显示有变更的文件</span><br><span class="line">$ git status</span><br><span class="line"></span><br><span class="line"># 显示当前分支的版本历史</span><br><span class="line">$ git log</span><br><span class="line"></span><br><span class="line"># 显示commit历史，以及每次commit发生变更的文件</span><br><span class="line">$ git log --stat</span><br><span class="line"></span><br><span class="line"># 搜索提交历史，根据关键词</span><br><span class="line">$ git log -S [keyword]</span><br><span class="line"></span><br><span class="line"># 显示某个commit之后的所有变动，每个commit占据一行</span><br><span class="line">$ git log [tag] HEAD --pretty&#x3D;format:%s</span><br><span class="line"></span><br><span class="line"># 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件</span><br><span class="line">$ git log [tag] HEAD --grep feature</span><br><span class="line"></span><br><span class="line"># 显示某个文件的版本历史，包括文件改名</span><br><span class="line">$ git log --follow [file]</span><br><span class="line">$ git whatchanged [file]</span><br><span class="line"></span><br><span class="line"># 显示指定文件相关的每一次diff</span><br><span class="line">$ git log -p [file]</span><br><span class="line"></span><br><span class="line"># 显示过去5次提交</span><br><span class="line">$ git log -5 --pretty --oneline</span><br><span class="line"></span><br><span class="line"># 显示所有提交过的用户，按提交次数排序</span><br><span class="line">$ git shortlog -sn</span><br><span class="line"></span><br><span class="line"># 显示指定文件是什么人在什么时间修改过</span><br><span class="line">$ git blame [file]</span><br><span class="line"></span><br><span class="line"># 显示暂存区和工作区的差异</span><br><span class="line">$ git diff</span><br><span class="line"></span><br><span class="line"># 显示暂存区和上一个commit的差异</span><br><span class="line">$ git diff --cached [file]</span><br><span class="line"></span><br><span class="line"># 显示工作区与当前分支最新commit之间的差异</span><br><span class="line">$ git diff HEAD</span><br><span class="line"></span><br><span class="line"># 显示两次提交之间的差异</span><br><span class="line">$ git diff [first-branch]...[second-branch]</span><br><span class="line"></span><br><span class="line"># 显示今天你写了多少行代码</span><br><span class="line">$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;</span><br><span class="line"></span><br><span class="line"># 显示某次提交的元数据和内容变化</span><br><span class="line">$ git show [commit]</span><br><span class="line"></span><br><span class="line"># 显示某次提交发生变化的文件</span><br><span class="line">$ git show --name-only [commit]</span><br><span class="line"></span><br><span class="line"># 显示某次提交时，某个文件的内容</span><br><span class="line">$ git show [commit]:[filename]</span><br><span class="line"></span><br><span class="line"># 显示当前分支的最近几次提交</span><br><span class="line">$ git reflog</span><br></pre></td></tr></table></figure>
<h2 id="八、远程同步">八、远程同步</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 下载远程仓库的所有变动</span><br><span class="line">$ git fetch [remote]</span><br><span class="line"></span><br><span class="line"># 显示所有远程仓库</span><br><span class="line">$ git remote -v</span><br><span class="line"></span><br><span class="line"># 显示某个远程仓库的信息</span><br><span class="line">$ git remote show [remote]</span><br><span class="line"></span><br><span class="line"># 增加一个新的远程仓库，并命名</span><br><span class="line">$ git remote add [shortname] [url]</span><br><span class="line"></span><br><span class="line"># 取回远程仓库的变化，并与本地分支合并</span><br><span class="line">$ git pull [remote] [branch]</span><br><span class="line"></span><br><span class="line"># 上传本地指定分支到远程仓库</span><br><span class="line">$ git push [remote] [branch]</span><br><span class="line"></span><br><span class="line"># 强行推送当前分支到远程仓库，即使有冲突</span><br><span class="line">$ git push [remote] --force</span><br><span class="line"></span><br><span class="line"># 推送所有分支到远程仓库</span><br><span class="line">$ git push [remote] --all</span><br></pre></td></tr></table></figure>
<h2 id="九、撤销">九、撤销</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 恢复暂存区的指定文件到工作区</span><br><span class="line">$ git checkout [file]</span><br><span class="line"></span><br><span class="line"># 恢复某个commit的指定文件到暂存区和工作区</span><br><span class="line">$ git checkout [commit] [file]</span><br><span class="line"></span><br><span class="line"># 恢复暂存区的所有文件到工作区</span><br><span class="line">$ git checkout .</span><br><span class="line"></span><br><span class="line"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span><br><span class="line">$ git reset [file]</span><br><span class="line"></span><br><span class="line"># 重置暂存区与工作区，与上一次commit保持一致</span><br><span class="line">$ git reset --hard</span><br><span class="line"></span><br><span class="line"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span><br><span class="line">$ git reset [commit]</span><br><span class="line"></span><br><span class="line"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span><br><span class="line">$ git reset --hard [commit]</span><br><span class="line"></span><br><span class="line"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span><br><span class="line">$ git reset --keep [commit]</span><br><span class="line"></span><br><span class="line"># 新建一个commit，用来撤销指定commit</span><br><span class="line"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span><br><span class="line">$ git revert [commit]</span><br><span class="line"></span><br><span class="line"># 暂时将未提交的变化移除，稍后再移入</span><br><span class="line">$ git stash</span><br><span class="line">$ git stash pop</span><br></pre></td></tr></table></figure>
<h2 id="十、其他">十、其他</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 生成一个可供发布的压缩包</span><br><span class="line">$ git archive</span><br></pre></td></tr></table></figure>
<hr>
<p>参考转载：<br>
<a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html</a><br>
<a href="https://gitee.com/all-about-git" target="_blank" rel="noopener">https://gitee.com/all-about-git</a></p>
]]></content>
      <categories>
        <category>Github</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Studio入门配置</title>
    <url>/posts/50ca3841.html</url>
    <content><![CDATA[<h1>一、JDK的下载与安装配置</h1>
<h2 id="1、下载合适版本并安装JDK-记住自己的安装路径">1、下载合适版本并安装JDK(记住自己的安装路径)</h2>
<p>下载路径：<br>
<a href="1%E3%80%81%09%E4%B8%8B%E8%BD%BD%E5%90%88%E9%80%82%E7%89%88%E6%9C%AC%E5%B9%B6%E5%AE%89%E8%A3%85JDK%28%E8%AE%B0%E4%BD%8F%E8%87%AA%E5%B7%B1%E7%9A%84%E5%AE%89%E8%A3%85%E8%B7%AF%E5%BE%84%29%20%E5%AE%89%E8%A3%85%E8%B7%AF%E5%BE%84%EF%BC%9A%20https://www.oracle.com/java/technologies/javase-jdk13-downloads.html">JDK13下载网址</a><br>
下载完成后进行解压安装，这里不提倡安装在c盘<br>
另外如果发现安装好后没有jre文件夹，则需要自己生成jre文件，在目标路径下（自己安装的JDK路径中运行cmd）运行命令行即可。<br>
<code>	bin\jlink.exe --module-path jmods --add-modules java.desktop --output jre</code></p>
<a id="more"></a>
<h2 id="2、系统环境配置">2、系统环境配置</h2>
<ul>
<li>
<p>在“系统变量”新建一个变量名为JAVA13_HOME的变量，变量值为你本地JDK的安装目录，当然这里的变量名可以根据自己需求修改。<br>
<img src="https://img-blog.csdnimg.cn/20201013201858433.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbW9uX1RU,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
<li>
<p>同样的再新建一个Path变量，Path大小写随意，变量的值为<code>%JAVA13_HOME%\bin</code>，当然直接用路径也可以。<br>
<img src="https://img-blog.csdnimg.cn/20201013202001642.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbW9uX1RU,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
<li>
<p>最后一步新建一个CLASSPATH变量，这里设置CLASSPATH的值是<code>.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar; </code>搞定。注意前面的.<br>
<img src="https://img-blog.csdnimg.cn/20201013202231575.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbW9uX1RU,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
<li>
<p>打开cmd命令行，运行<code>java -version</code>可以查看是否配置成功</p>
</li>
</ul>
<h1>二、Android Studio下载安装</h1>
<p><a href="https://www.androiddevtools.cn/" target="_blank" rel="noopener">Android Studio 4.0 下载地址</a><br>
下载完成后进行软件和SDK的安装（这里傻瓜式安装，不过注意安装路径不要出现中文，另外建议不要安装在系统盘）</p>
<ul>
<li>Android studio程序安装完毕，但是还需要继续对其进行配置；启动Android studio，出现下图,首次安装Android studio的情况下，选择不导入之前版本的配置即选择第二项，然后点击ok<br>
<img src="https://img-blog.csdnimg.cn/20201013203438389.jpg#pic_center" alt="在这里插入图片描述"></li>
<li>首次安装Android studio需要下载SDK，这里点击cancel，之后根据自己需求进行安装下载SDK.<br>
<img src="https://img-blog.csdnimg.cn/20201013203441592.jpg#pic_center" alt="在这里插入图片描述"></li>
</ul>
<h1>三、第一个Demo工程</h1>
<h2 id="1、工程创建">1、工程创建</h2>
<ul>
<li>打开软件，选择Empty Activity工程，选择next<br>
<img src="https://img-blog.csdnimg.cn/20201013203852237.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbW9uX1RU,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
<li>根据自己需求选择项目名、语言和安装路径等，选择完成后点击finish<br>
<img src="https://img-blog.csdnimg.cn/20201013203930157.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbW9uX1RU,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>
第一次建立工程有点慢，是因为从网上下载gradle构建工具，由于从国外站点下载，比较慢，一般情况需要挂梯子，最后等待左下角出现 Gradle bulid successfuly 就说明构建完成了</li>
</ul>
<hr>
<p>如果无法下载可以有两种方法，第一种进行换源，这里就不多介绍了，第二种就是进行手动下载，这里介绍第二种方法。<br>
1、找到对应的版本号，我这里是6.1.1版本，然后去<a href="https://services.gradle.org/distributions/" target="_blank" rel="noopener">Gradle下载地址</a>下载对于版本的压缩包，<br>
<img src="https://img-blog.csdnimg.cn/20201013204641699.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbW9uX1RU,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">2、打开电脑C盘，进入用户文件，找到<code>.gradle</code>文件夹，如图路径一层层打开，找到如图位置，删除下载失败的文件，将手动下载的压缩包放入，重启Android Studio即可。<br>
<img src="https://img-blog.csdnimg.cn/20201013205302816.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbW9uX1RU,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<hr>
<h2 id="2、虚拟机创建和启动">2、虚拟机创建和启动</h2>
<ul>
<li>选择合适的虚拟机进行创建，推荐使用默认的<br>
<img src="https://img-blog.csdnimg.cn/20201013205425981.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbW9uX1RU,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
<li>如果需要修改使用JDK的可以进行修改（android内置有jre），这里我使用了自己下载的JDK<br>
<img src="https://img-blog.csdnimg.cn/2020101321000439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbW9uX1RU,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>
<img src="https://img-blog.csdnimg.cn/20201013210141639.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbW9uX1RU,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
<li>启动项目，即可成功显示<br>
<img src="https://img-blog.csdnimg.cn/20201013205729125.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbW9uX1RU,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
</ul>
<h1>四、项目简单介绍</h1>
<h2 id="1、目录结构介绍">1、目录结构介绍</h2>
<p><img src="https://img-blog.csdnimg.cn/20201013210215919.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbW9uX1RU,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.idea <span class="comment">//系统自动生成的关于AS的配置目录（版权，jar包等）</span></span><br><span class="line">gradle <span class="comment">//Gradle目录（项目构建工具）</span></span><br><span class="line">app <span class="comment">//AS创建工程中的一个Module</span></span><br><span class="line">External Libraries <span class="comment">//依赖文件（版本号，SDK等）</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20201013210318735.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbW9uX1RU,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">build：<span class="comment">//构建目录，系统自动生成的编译目录</span></span><br><span class="line">libs：<span class="comment">//依赖包存放目录</span></span><br><span class="line">src：<span class="comment">//源码，资源目录</span></span><br><span class="line">androidTest: <span class="comment">//系统自动生成的用于测试的目录</span></span><br><span class="line">main：<span class="comment">//主目录 </span></span><br><span class="line">java：<span class="comment">//Java代码目录</span></span><br><span class="line">res：<span class="comment">//资源文件</span></span><br><span class="line">drawable： <span class="comment">//存放各种位图文件（png，jpg等）</span></span><br><span class="line">layout：<span class="comment">//App布局文件 </span></span><br><span class="line">values：<span class="comment">//储存一些引用文件（可以定义尺寸，字符串，样式，颜色等等）</span></span><br><span class="line">AndroidManifest.xml：<span class="comment">//App基本信息（Android配置文件） </span></span><br><span class="line">.gitgnore: <span class="comment">//项目空间的同步忽略文件</span></span><br><span class="line">build.gradle：<span class="comment">//Module的Gradle编译文件</span></span><br></pre></td></tr></table></figure>
<h2 id="2、安卓生命周期">2、安卓生命周期</h2>
<p><img src="https://img-blog.csdnimg.cn/20201013210519202.gif#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li>打开程序，执行顺序为onCreate、onStart、onResume</li>
<li>按下back键，执行顺序为onPause、onStop、onDestory；</li>
<li>再启动HelloWorld，执行顺序为onRestart、onStart、onResume；</li>
<li>按下home键，执行顺序为onPause、onStop；</li>
</ul>
<hr>
<p>参考文章<br>
<a href="https://blog.csdn.net/qq_43078852/article/details/104381548" target="_blank" rel="noopener">https://blog.csdn.net/qq_43078852/article/details/104381548</a><br>
<a href="https://www.jianshu.com/p/8d1d765a1a6c" target="_blank" rel="noopener">https://www.jianshu.com/p/8d1d765a1a6c</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>安卓</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot后端接口规范</title>
    <url>/posts/557d179e.html</url>
    <content><![CDATA[<h1>一、前言</h1>
<p> 一个后端接口大致分为四个部分组成：接口地址（url）、接口请求方式（get、post等）、请求数据（request）、响应数据（response）。虽然说后端接口的编写并没有统一规范要求，而且如何构建这几个部分每个公司要求都不同，没有什么“一定是最好的”标准，但其中最重要的关键点就是看是否规范。</p>
<a id="more"></a>
<h1>二、环境说明</h1>
<p> 因为讲解的重点是后端接口，所以需要导入一个spring-boot-starter-web包，而lombok作用是简化类，前端显示则使用了knife4j，具体使用在<a href="https://blog.csdn.net/lemon_TT/article/details/108158631" target="_blank" rel="noopener">Spring Boot整合knife4j实现Api文档</a>已写明。另外从<code>springboot-2.3</code>开始，校验包被独立成了一个<code>starter</code>组件，所以需要引入如下依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!--新版框架没有自动引入需要手动引入--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-validation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.xiaoymin<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>knife4j-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--在引用时请在maven中央仓库搜索最新版本号--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1>三、参数校验</h1>
<p> 一个接口一般对参数（请求数据）都会进行安全校验，参数校验的重要性自然不必多说，那么如何对参数进行校验就有讲究了。一般来说有三种常见的校验方式，我们使用了最简洁的第三种方法</p>
<ul>
<li>业务层校验</li>
<li>Validator + BindResult校验</li>
<li><strong>Validator + 自动抛出异常</strong></li>
</ul>
<p> 业务层校验无需多说，即手动在java的Service层进行数据校验判断。不过这样太繁琐了，光校验代码就会有很多。<br>
 而使用Validator+ BindingResult已经是非常方便实用的参数校验方式了，在实际开发中也有很多项目就是这么做的，不过这样还是不太方便，因为你每写一个接口都要添加一个BindingResult参数，然后再提取错误信息返回给前端（简单看一下）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/addUser"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addUser</span><span class="params">(@RequestBody @Validated User user, BindingResult bindingResult)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果有参数校验失败，会将错误信息封装成对象组装在BindingResult里</span></span><br><span class="line">    List&lt;ObjectError&gt; allErrors = bindingResult.getAllErrors();</span><br><span class="line">    <span class="keyword">if</span>(!allErrors.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">return</span> allErrors.stream()</span><br><span class="line">            .map(o-&gt;o.getDefaultMessage())</span><br><span class="line">            .collect(Collectors.toList()).toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回默认的错误信息</span></span><br><span class="line">    <span class="comment">// return allErrors.get(0).getDefaultMessage();</span></span><br><span class="line">    <span class="keyword">return</span> validationService.addUser(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Validator-自动抛出异常（使用）">Validator + 自动抛出异常（使用）</h2>
<p> 内置参数校验如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">注解</th>
<th style="text-align:left">校验功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">@AssertFalse</td>
<td style="text-align:left">必须是false</td>
</tr>
<tr>
<td style="text-align:left">@AssertTrue</td>
<td style="text-align:left">必须是true</td>
</tr>
<tr>
<td style="text-align:left">@DecimalMax</td>
<td style="text-align:left">小于等于给定的值</td>
</tr>
<tr>
<td style="text-align:left">@DecimalMin</td>
<td style="text-align:left">大于等于给定的值</td>
</tr>
<tr>
<td style="text-align:left">@Digits</td>
<td style="text-align:left">可设定最大整数位数和最大小数位数</td>
</tr>
<tr>
<td style="text-align:left">@Email</td>
<td style="text-align:left">校验是否符合Email格式</td>
</tr>
<tr>
<td style="text-align:left">@Future</td>
<td style="text-align:left">必须是将来的时间</td>
</tr>
<tr>
<td style="text-align:left">@FutureOrPresent</td>
<td style="text-align:left">当前或将来时间</td>
</tr>
<tr>
<td style="text-align:left">@Max</td>
<td style="text-align:left">最大值</td>
</tr>
<tr>
<td style="text-align:left">@Min</td>
<td style="text-align:left">最小值</td>
</tr>
<tr>
<td style="text-align:left">@Negative</td>
<td style="text-align:left">负数（不包括0）</td>
</tr>
<tr>
<td style="text-align:left">@NegativeOrZero</td>
<td style="text-align:left">负数或0</td>
</tr>
<tr>
<td style="text-align:left">@NotBlank</td>
<td style="text-align:left">不为null并且包含至少一个非空白字符</td>
</tr>
<tr>
<td style="text-align:left">@NotEmpty</td>
<td style="text-align:left">不为null并且不为空</td>
</tr>
<tr>
<td style="text-align:left">@NotNull</td>
<td style="text-align:left">不为null</td>
</tr>
<tr>
<td style="text-align:left">@Null</td>
<td style="text-align:left">为null</td>
</tr>
<tr>
<td style="text-align:left">@Past</td>
<td style="text-align:left">必须是过去的时间</td>
</tr>
<tr>
<td style="text-align:left">@PastOrPresent</td>
<td style="text-align:left">必须是过去的时间，包含现在</td>
</tr>
<tr>
<td style="text-align:left">@PositiveOrZero</td>
<td style="text-align:left">正数或0</td>
</tr>
<tr>
<td style="text-align:left">@Size</td>
<td style="text-align:left">校验容器的元素个数</td>
</tr>
</tbody>
</table>
<p> 首先Validator可以非常方便的制定校验规则，并自动帮你完成校验。首先在入参里需要校验的字段加上注解,每个注解对应不同的校验规则，并可制定校验失败后的信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NotNull</span>(message = <span class="string">"用户id不能为空"</span>)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span>(message = <span class="string">"用户账号不能为空"</span>)</span><br><span class="line">    <span class="meta">@Size</span>(min = <span class="number">6</span>, max = <span class="number">11</span>, message = <span class="string">"账号长度必须是6-11个字符"</span>)</span><br><span class="line">    <span class="keyword">private</span> String account;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span>(message = <span class="string">"用户密码不能为空"</span>)</span><br><span class="line">    <span class="meta">@Size</span>(min = <span class="number">6</span>, max = <span class="number">11</span>, message = <span class="string">"密码长度必须是6-16个字符"</span>)</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span>(message = <span class="string">"用户邮箱不能为空"</span>)</span><br><span class="line">    <span class="meta">@Email</span>(message = <span class="string">"邮箱格式不正确"</span>)</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 校验规则和错误提示信息配置完毕后，接下来只需要在接口仅需要在校验的参数上加上@Valid注解(去掉BindingResult后会自动引发异常，异常发生了自然而然就不会执行业务逻辑)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValidationController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ValidationService validationService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/addUser"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addUser</span><span class="params">(@RequestBody @Validated User user)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> validationService.addUser(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 现在我们进行测试，打开knife4j文档地址，当输入的请求数据为空时，Validator会将所有的报错信息全部进行返回，所以需要与全局异常处理一起使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用form data方式调用接口，校验异常抛出 BindException</span></span><br><span class="line"><span class="comment">// 使用 json 请求体调用接口，校验异常抛出 MethodArgumentNotValidException</span></span><br><span class="line"><span class="comment">// 单个参数校验异常抛出ConstraintViolationException</span></span><br><span class="line"><span class="comment">// 处理 json 请求体调用接口校验失败抛出的异常</span></span><br><span class="line"><span class="meta">@ExceptionHandler</span>(MethodArgumentNotValidException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">ResultVO</span>&lt;<span class="title">String</span>&gt; <span class="title">MethodArgumentNotValidException</span>(<span class="title">MethodArgumentNotValidException</span> <span class="title">e</span>) </span>&#123;</span><br><span class="line">    List&lt;FieldError&gt; fieldErrors = e.getBindingResult().getFieldErrors();</span><br><span class="line">    List&lt;String&gt; collect = fieldErrors.stream()</span><br><span class="line">        .map(DefaultMessageSourceResolvable::getDefaultMessage)</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ResultVO(ResultCode.VALIDATE_FAILED, collect);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用form data方式调用接口，校验异常抛出 BindException</span></span><br><span class="line"><span class="meta">@ExceptionHandler</span>(BindException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">ResultVO</span>&lt;<span class="title">String</span>&gt; <span class="title">BindException</span>(<span class="title">BindException</span> <span class="title">e</span>) </span>&#123;</span><br><span class="line">    List&lt;FieldError&gt; fieldErrors = e.getBindingResult().getFieldErrors();</span><br><span class="line">    List&lt;String&gt; collect = fieldErrors.stream()</span><br><span class="line">        .map(DefaultMessageSourceResolvable::getDefaultMessage)</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ResultVO(ResultCode.VALIDATE_FAILED, collect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/581af53947054b0197062c4cde1258bd.png" alt="请添加图片描述"></p>
<h2 id="分组校验和递归校验">分组校验和递归校验</h2>
<p> 分组校验有三个步骤：</p>
<ol>
<li>定义一个分组类（或接口）</li>
<li>在校验注解上添加<code>groups</code>属性指定分组</li>
<li><code>Controller</code>方法的<code>@Validated</code>注解添加分组类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Update</span> <span class="keyword">extends</span> <span class="title">Default</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NotNull</span>(message = <span class="string">"用户id不能为空"</span>,groups = Update<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">private</span> <span class="title">Long</span> <span class="title">id</span></span>;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"update"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">update</span><span class="params">(@Validated(&#123;Update.class&#125;)</span> User user) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 如果<code>Update</code>不继承<code>Default</code>，<code>@Validated({Update.class})</code>就只会校验属于<code>Update.class</code>分组的参数字段；如果继承了，会校验了其他默认属于<code>Default.class</code>分组的字段。</p>
<p> 对于递归校验（比如类中类），只要在相应属性类上增加<code>@Valid</code>注解即可实现（对于集合同样适用）</p>
<h2 id="自定义校验">自定义校验</h2>
<p>Spring Validation允许用户自定义校验，实现很简单，分两步：</p>
<ol>
<li>自定义校验注解</li>
<li>编写校验者类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123; METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE &#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Constraint</span>(validatedBy = &#123;HaveNoBlankValidator<span class="class">.<span class="keyword">class</span>&#125;)// 标明由哪个类执行校验逻辑</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">HaveNoBlank</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 校验出错时默认返回的消息</span></span><br><span class="line">    <span class="function">String <span class="title">message</span><span class="params">()</span> <span class="keyword">default</span> "字符串中不能含有空格"</span>;</span><br><span class="line">    Class&lt;?&gt;[] groups() <span class="keyword">default</span> &#123; &#125;;</span><br><span class="line">    Class&lt;? extends Payload&gt;[] payload() <span class="keyword">default</span> &#123; &#125;;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同一个元素上指定多个该注解时使用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Target</span>(&#123; METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE &#125;)</span><br><span class="line">    <span class="meta">@Retention</span>(RUNTIME)</span><br><span class="line">    <span class="meta">@Documented</span></span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@interface</span> List &#123;</span><br><span class="line">        NotBlank[] value();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HaveNoBlankValidator</span> <span class="keyword">implements</span> <span class="title">ConstraintValidator</span>&lt;<span class="title">HaveNoBlank</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String value, ConstraintValidatorContext context)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// null 不做检验</span></span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 校验失败</span></span><br><span class="line">        <span class="keyword">return</span> !value.contains(<span class="string">" "</span>);</span><br><span class="line">        <span class="comment">// 校验成功</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>四、全局异常处理</h1>
<p> 参数校验失败会自动引发异常，我们当然不可能再去手动捕捉异常进行处理。但我们又不想手动捕捉这个异常，又要对这个异常进行处理，那正好使用SpringBoot全局异常处理来达到一劳永逸的效果！</p>
<h2 id="基本使用">基本使用</h2>
<p>首先，我们需要新建一个类，在这个类上加上<code>@ControllerAdvice</code>或<code>@RestControllerAdvice</code>注解，这个类就配置成全局处理类了。（这个根据你的Controller层用的是<code>@Controller</code>还是<code>@RestController</code>来决定） 然后在类中新建方法，在方法上加上<code>@ExceptionHandler</code>注解并指定你想处理的异常类型，接着在方法内编写对该异常的操作逻辑，就完成了对该异常的全局处理！我们现在就来演示一下对参数校验失败抛出的<code>MethodArgumentNotValidException</code>全局处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.csdn.demo1.global;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.validation.ObjectError;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.MethodArgumentNotValidException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestControllerAdvice;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionControllerAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(MethodArgumentNotValidException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseStatus</span>(<span class="title">HttpStatus</span>.<span class="title">BAD_REQUEST</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">String</span> <span class="title">MethodArgumentNotValidExceptionHandler</span>(<span class="title">MethodArgumentNotValidException</span> <span class="title">e</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 从异常对象中拿到ObjectError对象</span></span><br><span class="line">        ObjectError objectError = e.getBindingResult().getAllErrors().get(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 然后提取错误提示信息进行返回</span></span><br><span class="line">        <span class="keyword">return</span> objectError.getDefaultMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 我们再次进行测试，这次返回的就是我们制定的错误提示信息！我们通过全局异常处理优雅的实现了我们想要的功能！以后我们再想写接口参数校验，就只需要在入参的成员变量上加上Validator校验规则注解，然后在参数上加上@Valid注解即可完成校验，校验失败会自动返回错误提示信息，无需任何其他代码！<br>
<img src="https://img-blog.csdnimg.cn/20200830204830239.png" alt="在这里插入图片描述"></p>
<h2 id="自定义异常">自定义异常</h2>
<p> 在很多情况下，我们需要手动抛出异常，比如在业务层当有些条件并不符合业务逻辑，而使用自定义异常有诸多优点：</p>
<ul>
<li>自定义异常可以携带更多的信息，不像这样只能携带一个字符串。</li>
<li>项目开发中经常是很多人负责不同的模块，使用自定义异常可以统一了对外异常展示的方式。</li>
<li>自定义异常语义更加清晰明了，一看就知道是项目中手动抛出的异常。<br>
 我们现在就来开始写一个自定义异常：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.csdn.demo1.global;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span> <span class="comment">//只要getter方法，无需setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">APIException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> code;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">APIException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">1001</span>, <span class="string">"接口错误"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">APIException</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">1001</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">APIException</span><span class="params">(<span class="keyword">int</span> code, String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(msg);</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 然后在刚才的全局异常类中加入如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义的全局异常</span></span><br><span class="line">   <span class="meta">@ExceptionHandler</span>(APIException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">   <span class="title">public</span> <span class="title">String</span> <span class="title">APIExceptionHandler</span>(<span class="title">APIException</span> <span class="title">e</span>) </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> e.getMsg();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p> 这样就对异常的处理就比较规范了，当然还可以添加对Exception的处理，这样无论发生什么异常我们都能屏蔽掉然后响应数据给前端，不过建议最后项目上线时这样做，能够屏蔽掉错误信息暴露给前端，在开发中为了方便调试还是不要这样做。另外，当我们抛出自定义异常的时候全局异常处理只响应了异常中的错误信息msg给前端，并没有将错误代码code返回。这还需要配合数据统一响应。</p>
<p> <strong>如果在多模块使用</strong>，全局异常等公共功能抽象成子模块，则在需要的子模块中需要将该模块包扫描加入，<code>@SpringBootApplication(scanBasePackages = {&quot;com.xxx&quot;})</code></p>
<h1>五、数据统一响应</h1>
<p> 统一数据响应是我们自己自定义一个响应体类，无论后台是运行正常还是发生异常，响应给前端的数据格式是不变的！这里我包括了响应信息代码code和响应信息说明msg，首先可以设置一个枚举规范响应体中的响应码和响应信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ResultCode &#123;</span><br><span class="line">    SUCCESS(<span class="number">1000</span>, <span class="string">"操作成功"</span>),</span><br><span class="line">    FAILED(<span class="number">1001</span>, <span class="string">"响应失败"</span>),</span><br><span class="line">    VALIDATE_FAILED(<span class="number">1002</span>, <span class="string">"参数校验失败"</span>),</span><br><span class="line">    ERROR(<span class="number">5000</span>, <span class="string">"未知错误"</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> code;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    ResultCode(<span class="keyword">int</span> code, String msg) &#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 自定义响应体</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.csdn.demo1.global;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultVO</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 状态码，比如1000代表响应成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> code;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 响应信息，用来说明响应情况</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 响应的具体数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ResultVO</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(ResultCode.SUCCESS, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ResultVO</span><span class="params">(ResultCode resultCode, T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = resultCode.getCode();</span><br><span class="line">        <span class="keyword">this</span>.msg = resultCode.getMsg();</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 最后需要修改全局异常处理类的返回类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionControllerAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(APIException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">ResultVO</span>&lt;<span class="title">String</span>&gt; <span class="title">APIExceptionHandler</span>(<span class="title">APIException</span> <span class="title">e</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 注意哦，这里传递的响应码枚举</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResultVO&lt;&gt;(ResultCode.FAILED, e.getMsg());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(MethodArgumentNotValidException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">ResultVO</span>&lt;<span class="title">String</span>&gt; <span class="title">MethodArgumentNotValidExceptionHandler</span>(<span class="title">MethodArgumentNotValidException</span> <span class="title">e</span>) </span>&#123;</span><br><span class="line">        ObjectError objectError = e.getBindingResult().getAllErrors().get(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 注意哦，这里传递的响应码枚举</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResultVO&lt;&gt;(ResultCode.VALIDATE_FAILED, objectError.getDefaultMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 最后在controller层进行接口信息数据的返回</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/getUser"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResultVO&lt;User&gt; <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setId(<span class="number">1L</span>);</span><br><span class="line">        user.setAccount(<span class="string">"12345678"</span>);</span><br><span class="line">        user.setPassword(<span class="string">"12345678"</span>);</span><br><span class="line">        user.setEmail(<span class="string">"123@qq.com"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResultVO&lt;&gt;(user);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p> 经过测试，这样响应码和响应信息只能是枚举规定的那几个，就真正做到了响应数据格式、响应码和响应信息规范化、统一化！<br>
<img src="https://img-blog.csdnimg.cn/20200830211916735.png" alt="在这里插入图片描述"></p>
<h1>六、全局处理响应数据(可选择)</h1>
<p> 接口返回统一响应体 + 异常也返回统一响应体，其实这样已经很好了，但还是有可以优化的地方。要知道一个项目下来定义的接口搞个几百个太正常不过了，要是每一个接口返回数据时都要用响应体来包装一下好像有点麻烦，有没有办法省去这个包装过程呢？当然是有的，还是要用到全局处理。但是为了扩展性，就是允许绕过数据统一响应（这样就可以提供多方使用），我们可以自定义注解，利用注解来选择是否进行全局响应包装。<br>
 首先创建自定义注解，作用相当于全局处理类开关：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD&#125;) <span class="comment">// 表明该注解只能放在方法上</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> NotResponseBody &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 其次创建一个类并加上注解使其成为全局处理类。然后继承<code>ResponseBodyAdvice</code>接口重写其中的方法，即可对我们的controller进行增强操作，具体看代码和注释：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.csdn.demo1.global;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.JsonProcessingException;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.MethodParameter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.MediaType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.converter.HttpMessageConverter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.server.ServerHttpRequest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.server.ServerHttpResponse;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestControllerAdvice;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.mvc.method.annotation.ResponseBodyAdvice;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestControllerAdvice</span>(basePackages = &#123;<span class="string">"com.scdn.demo1.controller"</span>&#125;) <span class="comment">// 注意哦，这里要加上需要扫描的包</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponseControllerAdvice</span> <span class="keyword">implements</span> <span class="title">ResponseBodyAdvice</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(MethodParameter returnType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; aClass)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 如果接口返回的类型本身就是ResultVO那就没有必要进行额外的操作，返回false</span></span><br><span class="line">        <span class="comment">// 如果方法上加了我们的自定义注解也没有必要进行额外的操作</span></span><br><span class="line">        <span class="keyword">return</span> !(returnType.getParameterType().equals(ResultVO<span class="class">.<span class="keyword">class</span>) || <span class="title">returnType</span>.<span class="title">hasMethodAnnotation</span>(<span class="title">NotResponseBody</span>.<span class="title">class</span>))</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">beforeBodyWrite</span><span class="params">(Object data, MethodParameter returnType, MediaType mediaType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; aClass, ServerHttpRequest request, ServerHttpResponse response)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// String类型不能直接包装，所以要进行些特别的处理</span></span><br><span class="line">        <span class="keyword">if</span> (returnType.getGenericParameterType().equals(String<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">            ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 将数据包装在ResultVO里后，再转换为json字符串响应给前端</span></span><br><span class="line">                <span class="keyword">return</span> objectMapper.writeValueAsString(<span class="keyword">new</span> ResultVO&lt;&gt;(data));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> APIException(<span class="string">"返回String类型错误"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将原本的数据包装在ResultVO里</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResultVO&lt;&gt;(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 重写的这两个方法是用来在<code>controller</code>将数据进行返回前进行增强操作，<code>supports</code>方法要返回为true才会执行<code>beforeBodyWrite</code>方法，所以如果有些情况不需要进行增强操作可以在<code>supports</code>方法里进行判断。对返回数据进行真正的操作还是在<code>beforeBodyWrite</code>方法中，我们可以直接在该方法里包装数据，这样就不需要每个接口都进行数据包装了，省去了很多麻烦。此时controller只需这样写就行了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/getUser"</span>)</span><br><span class="line"><span class="comment">//@NotResponseBody  //是否绕过数据统一响应开关</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setId(<span class="number">1L</span>);</span><br><span class="line">    user.setAccount(<span class="string">"12345678"</span>);</span><br><span class="line">    user.setPassword(<span class="string">"12345678"</span>);</span><br><span class="line">    user.setEmail(<span class="string">"123@qq.com"</span>);</span><br><span class="line">    <span class="comment">// 注意哦，这里是直接返回的User类型，并没有用ResultVO进行包装</span></span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>七、总结</h1>
<p>自此整个后端接口基本体系就构建完毕了</p>
<ul>
<li>通过Validator + 自动抛出异常来完成了方便的参数校验</li>
<li>通过全局异常处理 + 自定义异常完成了异常操作的规范</li>
<li>通过数据统一响应完成了响应数据的规范</li>
<li>多个方面组装非常优雅的完成了后端接口的协调，让开发人员有更多的经历注重业务逻辑代码，轻松构建后端接口</li>
</ul>
<hr>
<p><a href="https://github.com/RudeCrab/rude-java/blob/master/project-practice/validation-and-exception-handler/validation-and-exception-handler.md" target="_blank" rel="noopener">参考文章</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot整合knife4j实现Api文档</title>
    <url>/posts/db133795.html</url>
    <content><![CDATA[<h1>一、简介</h1>
<blockquote>
<p> knife4j是为Java MVC框架集成Swagger生成Api文档的增强解决方案,前身是swagger-bootstrap-ui,取名kni4j是希望她能像一把匕首一样小巧,轻量,并且功能强悍!<br>
　knife4j的前身是swagger-bootstrap-ui，为了契合微服务的架构发展,由于原来swagger-bootstrap-ui采用的是后端Java代码+前端Ui混合打包的方式,在微服务架构下显的很臃肿,因此项目正式更名为knife4j</p>
</blockquote>
<p><a href="https://doc.xiaominfo.com/knife4j/" target="_blank" rel="noopener">knife4j官方文档</a><br>
<a href="https://gitee.com/xiaoym/knife4j" target="_blank" rel="noopener">码云仓库地址</a></p>
<a id="more"></a>
<h1>二、项目搭建</h1>
<h2 id="1、maven引入">1、maven引入</h2>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.xiaoymin<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>knife4j-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--在引用时请在maven中央仓库搜索最新版本号--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><a href="https://mvnrepository.com/artifact/com.github.xiaoymin/knife4j-spring-boot-starter" target="_blank" rel="noopener">knife4j仓库地址</a></p>
<h2 id="2、创建Swagger配置文件">2、创建Swagger配置文件</h2>
<p>首先创建<code>application-dev.yml</code>和<code>application-prod.yml</code>开发和生产环境，最后在<code>application.yml</code>中配置当前环境，这样就可以在生产环境中关闭在线接口文档了。另外也可以使用注解<code>@Profile</code>设置环境</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.csdn.demo1.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.github.xiaoymin.knife4j.spring.annotations.EnableKnife4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Import;</span><br><span class="line"><span class="keyword">import</span> springfox.bean.validators.configuration.BeanValidatorPluginsConfiguration;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.ApiInfoBuilder;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.PathSelectors;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.RequestHandlerSelectors;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.ApiInfo;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spi.DocumentationType;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spring.web.plugins.Docket;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.swagger2.annotations.EnableSwagger2;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger</span>2</span><br><span class="line"><span class="meta">@EnableKnife</span>4j</span><br><span class="line"><span class="meta">@Import</span>(BeanValidatorPluginsConfiguration<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">SwaggerConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果要设置多个用户组，只需要在定义一个Docket并打上@Bean返回即可</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">docket</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置要显示的在线接口文档环境</span></span><br><span class="line">        Profiles profiles = Profiles.of(<span class="string">"dev"</span>,<span class="string">"test"</span>);</span><br><span class="line">        <span class="comment">//通过environment.acceptsProfiles判断是否处于当前自己设定的环境中</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = environment.acceptsProfiles(profiles);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">            	<span class="comment">//是否在浏览器显示,如果一直要显示开启，就选择true</span></span><br><span class="line">                .enable(flag)</span><br><span class="line">             	<span class="comment">//.enable(true)</span></span><br><span class="line">                <span class="comment">//分组名称</span></span><br><span class="line">                .groupName(<span class="string">"1.0版本"</span>)</span><br><span class="line">                .select()</span><br><span class="line">                <span class="comment">//这里指定Controller扫描包路径(项目路径也行)</span></span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="string">"com.csdn.demo1.controller"</span>))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> ApiInfo <span class="title">apiInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiInfoBuilder()</span><br><span class="line">                .title(<span class="string">"接口说明"</span>)</span><br><span class="line">                .description(<span class="string">"DEMO服务接口说明"</span>)</span><br><span class="line">                .termsOfServiceUrl(<span class="string">"http://localhost:8888/"</span>)</span><br><span class="line">                .version(<span class="string">"1.0"</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200822223403412.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbW9uX1RU,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h1>三、knife项目使用</h1>
<h2 id="1、常用注解介绍">1、常用注解介绍</h2>
<h4 id="Api">@Api()</h4>
<p>作用在类上，用来标注该类具体实现内容。<br>
<em>参数：</em><br>
<strong>tags：类标签，一般用来写类的名称或作用。（常用）<br>
description：可描述描述该类作用。</strong></p>
<hr>
<h4 id="ApiOperation">@ApiOperation()</h4>
<p>用于方法的说明<br>
<em>参数：</em><br>
<strong>value ：方法说明（常用）<br>
notes ：注释说明<br>
httpMethod ： 说明这个方法被请求的方式<br>
response ：方法的返回值的类型</strong></p>
<hr>
<h4 id="ApiOperationSupport">@ApiOperationSupport()</h4>
<p>（knife4j增加特性）用于接口方法排序，作者信息描述等。<br>
<em>参数：</em><br>
<strong>order：排序<br>
author：作者信息</strong></p>
<hr>
<h4 id="ApiImplicitParam">@ApiImplicitParam()</h4>
<p>对单个参数的说明<br>
<em>参数：</em><br>
<strong>name ：参数名。<br>
value ： 参数的具体意义，作用。（常用）<br>
required ： 参数是否必填。 （常用）<br>
dataType ：参数的数据类型。 （常用）<br>
paramType ：查询参数类型，这里有几种形式：<br>
类型　　　　　作用<br>
path 　　　以地址的形式提交数据<br>
query  　　直接跟参数完成自动映射赋值<br>
body　　　以流的形式提交 仅支持POST<br>
header　　参数在request headers 里边提交<br>
form　　　以form表单的形式提交 仅支持POST</strong></p>
<hr>
<h4 id="ApiModel">@ApiModel()</h4>
<p>用于描述一个数据模型的信息，即我们常用的实体、VO类、DTO类等描述<br>
<em>参数：</em><br>
<strong>value ： 数据模型名称。（常用）<br>
description:具体描述<br>
parent：父类</strong></p>
<hr>
<h4 id="ApiModelProperty">@ApiModelProperty()</h4>
<p>用于描述数据模型的属性信息<br>
<em>参数：</em><br>
<strong>value：字段说明 （常用）<br>
name：重写属性名字<br>
dataType：重写属性类型<br>
required：是否必填 （常用）<br>
example：举例说明 （常用）<br>
hidden：隐藏</strong></p>
<hr>
<h4 id="ApiIgnore">@ApiIgnore</h4>
<p>自动生成接口说明时忽略</p>
<h2 id="2、项目中的简单使用">2、项目中的简单使用</h2>
<p> 在项目启动中我还遇到了<code>javax/validation/constraints/Min</code>报错，原因是我使用了最新的springboot框架版本，新版本没有自动引入 validation对应的包，所以要想使用校验功能要手动引入包。在pom.xml引入依赖即可</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-validation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> 启动项目后，访问<code>http://localhost:8080/doc.html</code>即可(ip和端口根据实际需求来)。根据接口的不同需求，结合官方文档，可以写出自己需要的个性化需求。下面是我自己测试的demo<br>
<a href="https://doc.xiaominfo.com/knife4j/" target="_blank" rel="noopener">官方文档参考</a></p>
<p><img src="https://img-blog.csdnimg.cn/20200823214211723.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbW9uX1RU,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>
<img src="https://img-blog.csdnimg.cn/20200823214335383.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbW9uX1RU,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<hr>
<p><a href="https://blog.csdn.net/tuoyun6647/article/details/106021012" target="_blank" rel="noopener">参考文章</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue打包部署出现白屏</title>
    <url>/posts/1e9a5ba7.html</url>
    <content><![CDATA[<h4 id="1、问题描述">1、问题描述</h4>
<p> 我们用vue项目在本地跑的时候一切正常，当时我们用<code>npm run build</code>命令打包并部署服务器后，发现Index展示的是白屏，控制台显示资源都能正确访问到<img src="https://img-blog.csdnimg.cn/20200704175746282.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbW9uX1RU,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<a id="more"></a>
<h4 id="2、原因">2、原因</h4>
<p> 出现这个问题的原因就是Vue路由模式的设置问题，首先简单介绍一下Vue的两种路由模式：<strong>hash模式和history模式</strong><br>
 这两个模式最直观的区别就是在url中 hash 模式带了一个很丑的 # 而history是没有#的，在一般开发环境下，这两个模式都是可以正常使用的，但是打包编译的时候这两个模式有些地方需要进行修改才能防止打包后的页面变成空白。</p>
<hr>
<p>PS:页面空白另一种可能是文件引用路径不对，在vue.config.js里修改，之后重新打包</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">	...</span><br><span class="line">    publicPath: <span class="string">'./'</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="3、解决方法">3、解决方法</h4>
<ol>
<li>路由模式设置为hash<br>
 打开<code>router/index.js</code>，设置mode为hash后打包部署</li>
</ol>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    mode: <span class="string">'hash'</span>,</span><br><span class="line">    routes</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>路由模式设置为history<br>
 使用这个模式，在开发阶段一切都是正常的，但是需要打包部署时，需要在<code>router/index.js</code>中添加base属性。<a href="http://xn--nginxwww-8t1mv2in3id8aiz1avsc6xnwjy9tljymujbbygo7fg11ix8b.test.com/vue/app/%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%EF%BC%8C%E5%B0%B1%E5%BF%85%E9%A1%BB%E8%A6%81%E5%9C%A8%E6%B7%BB%E5%8A%A0" target="_blank" rel="noopener">假如打包的目录文件是放在nginx服务器www.test.com/vue/app/目录下的，就必须要在添加</a><strong>base:’/vue/app/’</strong>，两边**/**都不能缺少</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    mode: <span class="string">'history'</span>,</span><br><span class="line">    base: <span class="string">'/vue/app/'</span></span><br><span class="line">    routes</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux上使用docker运行酷Q机器人</title>
    <url>/posts/18a55fe7.html</url>
    <content><![CDATA[<p> 我们知道酷Q机器人是运行在windows上的，配合图灵机器人的API可以实现QQ或者微信的自动对话，但是如果想让机器人不间断24小时运行，那就需要使用云服务了，并且需要使用docker作为运行的容器来运行酷Q机器人。</p>
<h3 id="1、安装和运行docker">1、安装和运行docker</h3>
<p>这里我用了Centos的linux操作系统，使用其他Linux的也大同小异，不过这里的操作都需要root权限，没有的话需要<code>sudo su</code>获得root权限</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#下载docker</span></span><br><span class="line">yum install docker</span><br><span class="line"><span class="comment">#运行docker</span></span><br><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="2、下载酷Q镜像">2、下载酷Q镜像</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull coolq/wine-coolq</span><br></pre></td></tr></table></figure>
<p>这里的镜像是从docker中央仓库获取，也是别人已经打包好的镜像，我们直接拿来用就行了<br>
<img src="https://img-blog.csdnimg.cn/20200522193608772.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbW9uX1RU,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
使用<code>docker images</code>可以查看拉取的镜像<br>
<img src="https://img-blog.csdnimg.cn/20200522193655630.png" alt="在这里插入图片描述"></p>
<h3 id="3、后台运行酷Q容器">3、后台运行酷Q容器</h3>
<p>创建一个用于存放（映射）coolq数据的目录，用于持久化存放coolq（酷Q应用）的数据。这里我在根目录下创建cooqldata文件夹</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir /coolqdata</span><br></pre></td></tr></table></figure>
<p>后台运行<br>
docker run --name=coolq -d -p 8765:9000 -v /coolqdata:/home/user/coolq -e VNC_PASSWD=12345678 -e COOLQ_ACCOUNT=1000000 coolq/wine-coolq</p>
<h6 id="其中部分参数根据自己的需求替换：">其中部分参数根据自己的需求替换：</h6>
<p>远程监听端口<br>
8765(9000映射成8765，前面的端口号可以自定义)<br>
数据存放位置<br>
/coolqdata（容器内的/home/user/coolq路径 映射到本机的/coolqdata）<br>
远程访问密码<br>
12345678（只能设8位）<br>
机器人 QQ 帐号<br>
1000000</p>
<p>==最后开放设置的端口号==</p>
<h4 id="4、登录VNC进行机器人的设置">4、登录VNC进行机器人的设置</h4>
<p>打开浏览器，在浏览器输入服务器ip+端口号即可进行访问，按要求进行机器人的登录设置，可以登录http://www.tuling123.com/ 获取机器人对话的API接口并放入到酷Q中，这里如果需要复制可使用旁边的工具</p>
<p><img src="https://img-blog.csdnimg.cn/20200522195848627.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbW9uX1RU,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<hr>
<p>参考文章:<a href="https://www.cnblogs.com/tielemao/p/8462263.html" target="_blank" rel="noopener">Linux通过docker安装运行酷Q–用QQ骰子君进行跑团</a>.</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos启动Ipv4地址进行远程连接和Yum换源</title>
    <url>/posts/2a55c286.html</url>
    <content><![CDATA[<h3 id="启动Ipv4地址">启动Ipv4地址</h3>
<p> 好多时候，在虚拟机中安装完后，进去centos中，使用<code>ifconfig</code>发现没有此命令，可使用<code>ip a</code>查看IP，但是有时你会发现没有显示ipv4的地址，这样我们也无法进行远程连接，这个问题原因是安装centos的时候没有启用默认的网卡<br>
解决办法:<br>
CentOS配置网卡开机自动获取IP地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/sysconfig/network-scripts</span><br><span class="line"><span class="comment">#注意这是我的网卡配置，具体机器需要ls查看一下</span></span><br><span class="line">vim ifcfg-ens33</span><br></pre></td></tr></table></figure>
<p>进入配置后将 <code>ONBOOT=”no”</code> 改为 <code>ONBOOT=”yes”</code><br>
保存后执行<code>systemctl restart network</code></p>
<a id="more"></a>
<h3 id="Centos-Yum换源">Centos Yum换源</h3>
<h6 id="1-备份">1. 备份</h6>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</span><br></pre></td></tr></table></figure>
<h5 id="2-下载新的-CentOS-Base-repo-到-etc-yum-repos-d">2. 下载新的 CentOS-Base.repo 到 /etc/yum.repos.d/</h5>
<p><strong>CentOS 6</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-6.repo</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-6.repo</span><br></pre></td></tr></table></figure>
<p><strong>CentOS 7</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo</span><br></pre></td></tr></table></figure>
<p><strong>CentOS 8</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-8.repo</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-8.repo</span><br></pre></td></tr></table></figure>
<h5 id="3-运行-yum-makecache-生成缓存">3. 运行 <code>yum makecache</code> 生成缓存</h5>
]]></content>
      <categories>
        <category>虚拟化与云计算</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos7安装Anaconda实现远程Jupyter登陆</title>
    <url>/posts/191c082b.html</url>
    <content><![CDATA[<h3 id="1、下载Anaconda">1、下载Anaconda</h3>
<blockquote>
<p>官方下载: <a href="https://www.anaconda.com/download/" target="_blank" rel="noopener">https://www.anaconda.com/download/</a><br>
清华镜像下载: <a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/?C=N&amp;O=D" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/?C=N&amp;O=D</a></p>
</blockquote>
<p> centos在线下载最新版Anaconda</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda3-2020.02-Linux-x86_64.sh</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="2、Anaconda安装">2、Anaconda安装</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash Anaconda3-2020.02-Linux-x86_64.sh</span><br></pre></td></tr></table></figure>
<p> 在安装的过程中间可能会有些询问，比如是否指定新的安装位置等，我这里都选择了默认安装了。</p>
<h3 id="3、加载配置">3、加载配置</h3>
<p> 安装完成后，anaconda会自动初始化，初始化过程中会在 <code>~/.bashrc </code>文件中写入一些内容，因此我们需要重新加载该文件使anaconda生效</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>
<p> 成功执行后可以发现命令提示符前面加了一个(base)，这就说明成功安装了anaconda<br>
<img src="https://img-blog.csdnimg.cn/20200507203600596.png" alt="Alt"><br>
 这里要注意的是，<code>~/.bashrc</code>初始化的时候，anaconda是默认执行<br>
<code>conda  activate base</code>命令的，如果想变回原来的终端，只需要执行<code>conda deactivate</code>命令。如果想要永久消除，<code>vim  ~/.bashrc</code>进入文件在最后加上<code>conda deactivate</code>，保存退出就可<br>
<img src="https://img-blog.csdnimg.cn/2020050720562438.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbW9uX1RU,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> 另外，如果需要另外安装库，则只需要</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda install xxx</span><br></pre></td></tr></table></figure>
<h3 id="4、配置jupyter-notebook">4、配置jupyter notebook</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#进入conda base环境，后面操作都需要在base环境下</span></span><br><span class="line">conda activate base</span><br><span class="line"><span class="comment">#生成jupyter的配置文件</span></span><br><span class="line">jupyter notebook --generate-config</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200507210502610.png" alt="alt"><br>
 在设置远程登陆配置前，首先需要生成秘钥</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#进入python交互环境</span></span><br><span class="line">ipython</span><br><span class="line"><span class="comment">#导入依赖</span></span><br><span class="line"><span class="keyword">from</span> notebook.auth <span class="keyword">import</span> passwd</span><br><span class="line"><span class="comment">#生成秘钥，生成的秘钥要复制</span></span><br><span class="line">passwd()</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200507215931671.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbW9uX1RU,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
 进入配置文件并编辑<code>vim /root/.jupyter/jupyter_notebook_config.py</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在空白区域进行插入</span></span><br><span class="line">c.NotebookApp.ip = <span class="string">'*'</span> <span class="comment">#允许访问此服务器的 IP，星号表示任意 IP</span></span><br><span class="line">c.NotebookApp.password = u<span class="string">'sha1:fdd89498b287:bbb896de44a315f88c0e699db0798ebc2c098686'</span> <span class="comment"># 之前生成的密码 hash 字串</span></span><br><span class="line">c.NotebookApp.open_browser = False <span class="comment"># 运行时不打开本机浏览器</span></span><br><span class="line">c.NotebookApp.port = 9999 <span class="comment"># 端口随意设置，注意确保云服务器此端口要开放。</span></span><br><span class="line">c.NotebookApp.enable_mathjax = True <span class="comment"># 启用 MathJax</span></span><br><span class="line">c.NotebookApp.allow_root = True</span><br><span class="line">c.NotebookApp.notebook_dir = <span class="string">'/root/JupyterNotebook'</span> <span class="comment">#工作目录，保存代码项目文件。</span></span><br></pre></td></tr></table></figure>
<p> 保存后退出，并创建工作目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir /root/JupyterNotebook</span><br></pre></td></tr></table></figure>
<p> 另外要注意云服务器端口的开放。</p>
<h3 id="5、jupyter后台运行">5、jupyter后台运行</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#后台运行</span></span><br><span class="line">nohup jupyter notebook &amp;</span><br></pre></td></tr></table></figure>
<p>成功后可以打开浏览器即可远程登陆使用啦<br>
<img src="https://img-blog.csdnimg.cn/20200507220815404.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbW9uX1RU,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<hr>
<p>​	当然，如果直接安装了python和pip，那也可以单独安装jupyter，详情可以参考https://zhuanlan.zhihu.com/p/154310404</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>python实现Synology NAS的关机</title>
    <url>/posts/461ef441.html</url>
    <content><![CDATA[<h4 id="一、问题描述">一、问题描述</h4>
<p> 因为需要使用编程进行NAS的关机，而且这个程序不能在NAS内部运行，因此想到了使用远程连接来进行NAS的关机操作。因为NAS是一种定制的LINUX系统，因此可以利用Python使用SSH来远程连接，并使用命令行关机指令<code>shutdown -h now</code>实现远程关机。</p>
<a id="more"></a>
<h4 id="二、实验步骤">二、实验步骤</h4>
<h5 id="1、启用NAS的SSH功能">1、启用NAS的SSH功能</h5>
<p>1、打开控制面板选择高级模式<br>
<img src="https://img-blog.csdnimg.cn/20200429112924953.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbW9uX1RU,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
2、进入终端机和SNMP<br>
<img src="https://img-blog.csdnimg.cn/2020042911293858.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbW9uX1RU,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
3、选择启用SSH功能<br>
<img src="https://img-blog.csdnimg.cn/20200429112942903.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbW9uX1RU,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h5 id="2、Python实现远程关机">2、Python实现远程关机</h5>
<p>1、安装paramiko模块<br>
 paramiko是用python语言写的一个模块，遵循SSH2协议，支持以加密和认证的方式，进行远程服务器的连接。跟常用软件xshell 、xftp功能一样，但是可以连接多台服务器，进行复杂的操作。<br>
 在这里我使用了Jupyter，因此使用了anaconda安装方法。打开<code>Anaconda Prompt (anaconda)</code>终端，输入以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda install paramiko</span><br></pre></td></tr></table></figure>
<p>2、执行Python程序<br>
 这里使用了SSHClient基于用户名和密码的 sshclient 方式登录。其中hostname填写NAS的ip地址，password填写自己设置的密码，command是需要执行的命令。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> paramiko</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立一个sshclient对象</span></span><br><span class="line">ssh = paramiko.SSHClient()</span><br><span class="line"><span class="comment"># 允许将信任的主机自动加入到host_allow 列表，此方法必须放在connect方法的前面</span></span><br><span class="line">ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class="line"><span class="comment"># 调用connect方法连接服务器</span></span><br><span class="line"><span class="comment"># 需要管理员账号</span></span><br><span class="line">ssh.connect(hostname=<span class="string">'192.168.1.104'</span>, port=<span class="number">22</span>, username=<span class="string">'root'</span>, password=<span class="string">'123456'</span>)</span><br><span class="line"><span class="comment"># 执行命令</span></span><br><span class="line"><span class="comment"># 关机命令</span></span><br><span class="line">command=<span class="string">"shutdown -h now"</span></span><br><span class="line">stdin, stdout, stderr = ssh.exec_command(command)</span><br><span class="line"><span class="comment"># 结果放到stdout中，如果有错误将放到stderr中</span></span><br><span class="line">print(stdout.read().decode())</span><br><span class="line">print(<span class="string">'执行完毕'</span>)</span><br><span class="line"><span class="comment"># 关闭连接</span></span><br><span class="line">ssh.close()</span><br></pre></td></tr></table></figure>
<hr>
<p>其他登录方式参考<br>
<a href="https://blog.csdn.net/appke846/article/details/80514024" target="_blank" rel="noopener">参考文章</a></p>
]]></content>
      <categories>
        <category>虚拟化与云计算</category>
      </categories>
      <tags>
        <tag>虚拟化基础</tag>
      </tags>
  </entry>
  <entry>
    <title>java设计模式----代理模式</title>
    <url>/posts/31773db5.html</url>
    <content><![CDATA[<h3 id="一、代理模式介绍">一、代理模式介绍</h3>
<p> 代理模式(Proxy Pattern)，是23种设计模式之一，它关心的主要是过程，而不是结果。代理模式主要提供了对目标对象的间接访问方式，即通过代理对象来访问目标对象，这样可以在目标对象实现的基础上，==增强额外的功能操作，即扩展目标对象的功能==，<em>SpringAop</em>便是一个很好的例子。而被代理的对象可以是远程对象、创建开销大的对象或需要安全控制的对象。代理模式的简单示意图如下。<br>
<img src="https://img-blog.csdnimg.cn/2020041418500189.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbW9uX1RU,size_16,color_FFFFFF,t_70" alt="代理模式示意图"><br>
 代理模式主要有三种实现方式 <strong>静态代理</strong>、<strong>动态代理</strong>(JDK代理、接口代理)和<strong>Cglib代理</strong>(不需要实现接口)。</p>
<a id="more"></a>
<h3 id="二、三种代理模式的简单介绍">二、三种代理模式的简单介绍</h3>
<h4 id="1、静态代理">1、静态代理</h4>
<h6 id="1、介绍">1、介绍</h6>
<p> 静态代理UML类图如下图，StudentDaoProxy类是代理类，通过聚合的方式代理StudentDao类，同时StudentDao类和代理类都实现IStudentDao接口类。<br>
 静态代理的优点是能够较为简单快速的在不修改目标对象的前提下，对目标对象功能进行扩展；而缺点就是不够灵活，如果接口新增方法，那么需要维护类的成本太大。<img src="https://img-blog.csdnimg.cn/2020041419041627.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbW9uX1RU,size_16,color_FFFFFF,t_70" alt="静态代理"></p>
<h6 id="2、代码实现">2、代码实现</h6>
<p>①新建IStudentDao接口类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IStudentDao</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>②被代理的学生类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentDao</span> <span class="keyword">implements</span> <span class="title">IStudentDao</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"正在读书中。。。。。"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>③创建代理类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentDaoProxy</span> <span class="keyword">implements</span> <span class="title">IStudentDao</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 被代理类聚合到代理类</span></span><br><span class="line">	<span class="keyword">private</span> StudentDao studentDao;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">StudentDaoProxy</span><span class="params">(StudentDao studentDao)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 通过构造器传入聚合对象，也可以通过set方法传入</span></span><br><span class="line">		<span class="keyword">this</span>.studentDao=studentDao;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 增强方法，这里可以写其他复杂业务</span></span><br><span class="line">		System.out.println(<span class="string">"打开书本。。。。。"</span>);</span><br><span class="line">		<span class="comment">//被代理类原方法</span></span><br><span class="line">		studentDao.read();</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>④用户测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		StudentDao studentDao = <span class="keyword">new</span> StudentDao();</span><br><span class="line">		StudentDaoProxy studentDaoProxy = <span class="keyword">new</span> StudentDaoProxy(studentDao);</span><br><span class="line">		<span class="comment">// 使用代理方法</span></span><br><span class="line">		studentDaoProxy.read();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">打开书本。。。。。</span><br><span class="line">正在读书中。。。。。</span><br></pre></td></tr></table></figure>
<h4 id="2、动态代理">2、动态代理</h4>
<h6 id="1、介绍-v2">1、介绍</h6>
<p> 动态代理对象不需要实现接口，但是目标对象还是需要实现接口。而代理对象的生成，是利用JDK的API，动态的在内存中构建代理对象，相比于静态代理灵活的多，所以也叫JDK代理或接口代理。其UML类图如下<br>
<img src="https://img-blog.csdnimg.cn/20200414195831770.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbW9uX1RU,size_16,color_FFFFFF,t_70" alt="动态代理"></p>
<h6 id="2、代码实现-v2">2、代码实现</h6>
<p>①新建IStudentDao接口类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IStudentDao</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>②被代理的学生类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentDao</span> <span class="keyword">implements</span> <span class="title">IStudentDao</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"正在读书中。。。。。"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>③创建代理类<br>
这里相比静态代理有点小修改，JDK代理需要使用<code>newProxyInstance</code>方法，其完整写法是<code>static Object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandlerh)</code>，该方法在<code>java.lang.reflect.Proxy</code>包内，通过反射机制实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 被代理类聚合到代理类</span></span><br><span class="line">	<span class="keyword">private</span> Object target;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ProxyFactory</span><span class="params">(Object studentDao)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 通过构造器传入聚合对象，也可以通过set方法传入</span></span><br><span class="line">		<span class="keyword">this</span>.target=studentDao;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//给目标对象 生成一个代理对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getProxyInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="comment">//说明</span></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 *  public static Object newProxyInstance(ClassLoader loader,</span></span><br><span class="line"><span class="comment">	                                          Class&lt;?&gt;[] interfaces,</span></span><br><span class="line"><span class="comment">	                                          InvocationHandler h)	                                          </span></span><br><span class="line"><span class="comment">	            //1. ClassLoader loader ： 指定当前目标对象使用的类加载器, 获取加载器的方法固定</span></span><br><span class="line"><span class="comment">	            //2. Class&lt;?&gt;[] interfaces: 目标对象实现的接口类型，使用泛型方法确认类型</span></span><br><span class="line"><span class="comment">	            //3. InvocationHandler h : 事情处理，执行目标对象的方法时，会触发事情处理器方法, 会把当前执行的目标对象方法作为参数传入</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), </span><br><span class="line">					target.getClass().getInterfaces(), </span><br><span class="line">					<span class="keyword">new</span> MyInvocationHandler()); </span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		 <span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span>  <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">				<span class="comment">// 自定义业务逻辑</span></span><br><span class="line">				System.out.println(<span class="string">"JDK代理开始~~"</span>);</span><br><span class="line">				<span class="comment">//反射机制调用目标对象的方法</span></span><br><span class="line">				Object returnVal = method.invoke(target, args);</span><br><span class="line">				System.out.println(<span class="string">"JDK代理提交"</span>);</span><br><span class="line">				<span class="keyword">return</span> returnVal;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>④用户测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		StudentDao studentDao = <span class="keyword">new</span> StudentDao();</span><br><span class="line">		ProxyFactory studentDaoProxy = <span class="keyword">new</span> ProxyFactory(studentDao);</span><br><span class="line">		<span class="comment">// 使用代理方法,注意这里一定要用接口接收</span></span><br><span class="line">		IStudentDao studentDao2 = (IStudentDao) studentDaoProxy.getProxyInstance();</span><br><span class="line">		studentDao2.read();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JDK代理开始~~</span><br><span class="line">正在读书中。。。。。</span><br><span class="line">JDK代理提交</span><br></pre></td></tr></table></figure>
<h4 id="3、Cglib代理">3、Cglib代理</h4>
<h6 id="1、介绍-v3">1、介绍</h6>
<ul>
<li>动态代理或静态代理都要求实现一个接口，但是对于Cglib并不需要实现任何接口。</li>
<li>Cglib代理也叫作子类代理，它是在内存中构建一个子类对象从而实现对目标对象功能扩展，所以也可称为动态代理。</li>
<li>Cglib是一个强大的高性能的代码生成包，它可以在运行期扩展java类与实现java接口。它广泛的被许多AOP框架使用，例如SpringAOP，实现方法拦截。</li>
<li>在AOP编程中如何选择代理模式：<br>
1.目标对象需要实现接口，用JDK代理<br>
2.目标对象不需要实现接口，用Cglib代理</li>
<li>Cglib包的底层是通过使用字节码处理框架ASM来转换字节码并生成新的类<br>
<img src="https://img-blog.csdnimg.cn/20200414200122604.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbW9uX1RU,size_16,color_FFFFFF,t_70" alt="cglib代理"></li>
</ul>
<h6 id="2、代码实现-v3">2、代码实现</h6>
<p>使用Cglib时代理的类不能为final/static，否则不会被拦截，同时需要引入cglib相关jar包<br>
链接：<a href="https://pan.baidu.com/s/1ydin81D5ueuIm2cbSXSnIw" target="_blank" rel="noopener">https://pan.baidu.com/s/1ydin81D5ueuIm2cbSXSnIw</a><br>
提取码：b5au</p>
<p>①被代理的学生类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentDao</span> <span class="keyword">implements</span> <span class="title">IStudentDao</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"正在读书中。。。。。"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>②创建代理类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//维护一个目标对象</span></span><br><span class="line">		<span class="keyword">private</span> Object target;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//构造器，传入一个被代理的对象</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">ProxyFactory</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.target = target;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//返回一个代理对象:  是 target 对象的代理对象</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> Object <span class="title">getProxyInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="comment">//1. 创建一个工具类</span></span><br><span class="line">			Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">			<span class="comment">//2. 设置父类</span></span><br><span class="line">			enhancer.setSuperclass(target.getClass());</span><br><span class="line">			<span class="comment">//3. 设置回调函数</span></span><br><span class="line">			enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">			<span class="comment">//4. 创建子类对象，即代理对象</span></span><br><span class="line">			<span class="keyword">return</span> enhancer.create();</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">		<span class="comment">//重写  intercept 方法，会调用目标对象的方法</span></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object arg0, Method method, Object[] args, MethodProxy arg3)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">			System.out.println(<span class="string">"Cglib代理模式 ~~ 开始"</span>);</span><br><span class="line">			Object returnVal = method.invoke(target, args);</span><br><span class="line">			System.out.println(<span class="string">"Cglib代理模式 ~~ 提交"</span>);</span><br><span class="line">			<span class="keyword">return</span> returnVal;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>③用户测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		StudentDao studentDao = <span class="keyword">new</span> StudentDao();</span><br><span class="line">		ProxyFactory studentDaoProxy = <span class="keyword">new</span> ProxyFactory(studentDao);</span><br><span class="line">		StudentDao studentDao2 = (StudentDao)studentDaoProxy.getProxyInstance();</span><br><span class="line">		studentDao2.read();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cglib代理模式 ~~ 开始</span><br><span class="line">正在读书中。。。。。</span><br><span class="line">Cglib代理模式 ~~ 提交</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker制作自己的镜像--ubuntu16.04构建Python和Paddlepaddle</title>
    <url>/posts/e1b007ae.html</url>
    <content><![CDATA[<h3 id="1、拉取ubuntu16-04纯净镜像">1、拉取ubuntu16.04纯净镜像</h3>
<p>首先进入虚拟机管理员，将ubuntu16基础镜像从中心仓库拉下来，输入命令<code>docker pull ubuntu:16.04</code>,<br>
docker就会自动下载ubuntu16的镜像了<br>
<img src="https://img-blog.csdnimg.cn/20200410202138280.png" alt="在这里插入图片描述"><br>
用<code>docker images</code> 查看下载好的镜像<br>
<img src="https://img-blog.csdnimg.cn/20200410202204654.png" alt="在这里插入图片描述"><br>
因为需要制作自己的容器，因此先下载好python3.7的tar包，这里我们选择编译安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在线下载python3.7，如果嫌慢可以先下载好直接拖进来</span></span><br><span class="line">wget https://www.python.org/ftp/python/3.7.0/Python-3.7.0.tgz</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200410202353342.png" alt="在这里插入图片描述"></p>
<a id="more"></a>
<h3 id="2、ubuntu16-04容器内安装Python3-7和Paddlepaddle">2、ubuntu16.04容器内安装Python3.7和Paddlepaddle</h3>
<p><code>docker run -it -v $PWD:/home/root123 ubuntu:16.04 /bin/bash</code>输入命令进入并运行容器，可以看见成功进入ubuntu容器了<br>
<img src="https://img-blog.csdnimg.cn/20200410202325422.png" alt="在这里插入图片描述"><br>
在这里有可能自带的apt源还是国外的，而且没有vi/vim可编辑软件，所以这里用了echo直接更新源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mv /etc/apt/sources.list /etc/apt/sources.list.bak</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse"</span> &gt;&gt; /etc/apt/sources.list</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiverse"</span> &gt;&gt;/etc/apt/sources.list</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse"</span> &gt;&gt;/etc/apt/sources.list</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"deb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiverse"</span> &gt;&gt;/etc/apt/sources.list</span><br></pre></td></tr></table></figure>
<p>之后进行必要的组件升级安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt update</span><br><span class="line"></span><br><span class="line">apt install vim	<span class="comment">#安装vim</span></span><br><span class="line"></span><br><span class="line">apt install gcc</span><br><span class="line"></span><br><span class="line"><span class="comment">###pythin必须的基础包</span></span><br><span class="line">apt-get install zlib1g-dev libbz2-dev libssl-dev libncurses5-dev libsqlite3-dev libreadline-dev tk-dev libgdbm-dev libdb-dev libpcap-dev xz-utils libexpat1-dev</span><br><span class="line"></span><br><span class="line">apt-get install liblzma-dev libffi-dev libc6-dev</span><br></pre></td></tr></table></figure>
<p>完成后进入与主机挂载的目录下，可以看见主机目录的文件成功映射到了虚拟机内<br>
<img src="https://img-blog.csdnimg.cn/20200410202407936.png" alt="在这里插入图片描述"><br>
解压<code>tar -zxvf Python-3.7.0.tgz</code>，完成后进入Python-3.7.0目录，后面就需要依次进行编译安装了，这步可能时间会有点长</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#以下命令分开执行</span></span><br><span class="line">./configure --with-ssl --prefix=/usr/<span class="built_in">local</span>/python3 --<span class="built_in">enable</span>-optimizations</span><br><span class="line"></span><br><span class="line">make</span><br><span class="line"></span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>之后进行链接，依次输入一下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ln -s /usr/<span class="built_in">local</span>/python3/bin/python3.7 /usr/bin/python3</span><br><span class="line">ln -s /usr/<span class="built_in">local</span>/python3/bin/pip3.7 /usr/bin/pip3</span><br></pre></td></tr></table></figure>
<p>到此为止Python就安装完了，验证一下发现很成功<br>
<img src="https://img-blog.csdnimg.cn/20200410202416990.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbW9uX1RU,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
接下来就进行Paddlepaddle的安装，这里因为安装了pip，因此使用pip安装，输入以下命令</p>
<p>当然也可以用其他方式安装，<a href="https://www.paddlepaddle.org.cn/install/quick" target="_blank" rel="noopener">其他安装方式</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 -m pip install paddlepaddle -i https://mirror.baidu.com/pypi/simple</span><br></pre></td></tr></table></figure>
<p>安装完成后，验证一下是否成功安装。</p>
<p>先进入<code>python3</code>，然后输入<code>import paddle.fluid</code>，在输入<code>paddle.fluid.install_check.run_check()</code>，如果出现 <code>Your Paddle Fluid is installed successfully!</code>，说明已成功安装。<br>
<img src="https://img-blog.csdnimg.cn/20200410202427737.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbW9uX1RU,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="3、制作自己的镜像">3、制作自己的镜像</h3>
<p>退出容器后，我们需要构建自己的镜像,可以看到，我们成功的构建了属于我们自己的容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看所有容器</span></span><br><span class="line">docker ps -a</span><br><span class="line"><span class="comment">#-m后是说明文字 -a是作者 容器id 后面是镜像名字</span></span><br><span class="line">docker commit -m <span class="string">"add vim&amp;source"</span> -a <span class="string">"author"</span> 1db56d541f2c python:1.0</span><br><span class="line"><span class="comment">#完成后输入一下即可看见新的镜像</span></span><br><span class="line">docker images</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200410202434190.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbW9uX1RU,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
最后可将容器保存为文件，存放于当前目录下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker save -o python.tar python3.7:1.0</span><br></pre></td></tr></table></figure>
<p>而从外部装载时则需要输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker load -input python.tar</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Synology安装并实现在linux和win下使用ISCSI存储</title>
    <url>/posts/63c06a7a.html</url>
    <content><![CDATA[<h3 id="1、虚拟机安装Synology需要准备的工具">1、虚拟机安装Synology需要准备的工具</h3>
<ul>
<li>
<p>Synology Assistant</p>
</li>
<li>
<p>DSM_DS3615xs_5967.pat</p>
</li>
<li>
<p>XPEnoboot_DS3615xs_5.2-5967.1.iso</p>
</li>
</ul>
<blockquote>
<p>链接：<a href="https://pan.baidu.com/s/1vU0WDlJV_pxTTt0d02KLKg" target="_blank" rel="noopener">https://pan.baidu.com/s/1vU0WDlJV_pxTTt0d02KLKg</a>  提取码：0sy9<br>
或者https://download.csdn.net/download/lemon_TT/14945706</p>
</blockquote>
<p>注意DSM和XPEnoboot的版本要一致，如上都是DS3615xs_5967</p>
<p>XPEnoboot_DS3615xs_5.1-5967.1.iso用于引导镜像</p>
<p>DSM是系统文件</p>
<p>Synology Assistant是客户端管理工具</p>
<a id="more"></a>
<h3 id="2、-Synology的安装">2、 Synology的安装</h3>
<h5 id="打开虚拟机新建，选择自定义">打开虚拟机新建，选择自定义</h5>
<p><img src="https://s1.ax1x.com/2020/04/08/GW1XUe.png" alt="GW1XUe.png"></p>
<h5 id="因为考虑兼容问题，这里选择12的版本">因为考虑兼容问题，这里选择12的版本</h5>
<p><a href="https://imgchr.com/i/GW1Tjx" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/04/08/GW1Tjx.png" alt="GW1Tjx.png"></a><br>
<a href="https://imgchr.com/i/GW1og1" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/04/08/GW1og1.png" alt="GW1og1.png"></a><br>
<a href="https://imgchr.com/i/GW1I3R" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/04/08/GW1I3R.png" alt="GW1I3R.png"></a><br>
<a href="https://imgchr.com/i/GW15C9" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/04/08/GW15C9.png" alt="GW15C9.png"></a></p>
<h5 id="网络选择桥接模式，为了让局域网内其他主机能够顺利进行访问">网络选择桥接模式，为了让局域网内其他主机能够顺利进行访问</h5>
<p><a href="https://imgchr.com/i/GW1fN4" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/04/08/GW1fN4.png" alt="GW1fN4.png"></a><br>
<a href="https://imgchr.com/i/GW1Hu6" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/04/08/GW1Hu6.md.png" alt="GW1Hu6.md.png"></a><br>
<a href="https://imgchr.com/i/GW1qHO" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/04/08/GW1qHO.md.png" alt="GW1qHO.md.png"></a></p>
<h5 id="因为本次需要搭建一个raid6，因此至少需要4个硬盘。在这里我们先创建好">因为本次需要搭建一个raid6，因此至少需要4个硬盘。在这里我们先创建好</h5>
<p><img src="https://s1.ax1x.com/2020/04/08/GW1OED.png" alt="GW1OED.png"></p>
<h5 id="如何需要修改电源固件选项，需要把CD-ROM设置为优先启动，保存后选择install">如何需要修改电源固件选项，需要把CD-ROM设置为优先启动，保存后选择install</h5>
<p><img src="https://s1.ax1x.com/2020/04/08/GW8smV.png" alt="GW8smV.png"><br>
<img src="https://s1.ax1x.com/2020/04/08/GW8DO0.png" alt="GW8DO0.png"></p>
<p><img src="https://s1.ax1x.com/2020/04/08/GW86TU.png" alt="GW86TU.png"></p>
<hr>
<h4 id="到目前为止，就可以进行NAS的安装了，打开群晖助手进行扫描，如果没有报错，也可以进行安装，但是如果报错了没找到，没关系，我们还有另一种网页进行安装，下面让我来详细介绍一下。">到目前为止，就可以进行NAS的安装了，打开群晖助手进行扫描，如果没有报错，也可以进行安装，但是如果报错了没找到，没关系，我们还有另一种网页进行安装，下面让我来详细介绍一下。</h4>
<h5 id="首先打开浏览器输入以下网址http-find-synology-com-浏览器就会自动搜索了">首先打开浏览器输入以下网址<code>http://find.synology.com/</code>浏览器就会自动搜索了</h5>
<h5 id="选择联机">选择联机</h5>
<p><img src="https://s1.ax1x.com/2020/04/08/GWtl4S.png" alt="GWtl4S.png"></p>
<h5 id="在此之后选择手动安装，如何将pat文件加进来后选择立即安装">在此之后选择手动安装，如何将pat文件加进来后选择立即安装</h5>
<p><img src="https://s1.ax1x.com/2020/04/08/GWtmnI.png" alt="GWtmnI.png"></p>
<h5 id="选择确定后需要等待急几分钟">选择确定后需要等待急几分钟</h5>
<p><img src="https://s1.ax1x.com/2020/04/08/GWtE1H.png" alt="GWtE1H.png"></p>
<h5 id="完成后创建用户名和密码">完成后创建用户名和密码</h5>
<p><img src="https://s1.ax1x.com/2020/04/08/GWNpvj.png" alt="GWNpvj.png"></p>
<h5 id="中间的更新选项可以自由选择，而账户创建选择跳过，之后成功进入NAS界面了">中间的更新选项可以自由选择，而账户创建选择跳过，之后成功进入NAS界面了</h5>
<p><img src="https://s1.ax1x.com/2020/04/08/GWNE5T.png" alt="GWNE5T.png"></p>
<h3 id="3、iSCSI存储的构建">3、iSCSI存储的构建</h3>
<h5 id="打开存储空间管理员选项，可以看见有4个空硬盘">打开存储空间管理员选项，可以看见有4个空硬盘</h5>
<p><img src="https://s1.ax1x.com/2020/04/08/GWUX9S.png" alt="GWUX9S.png"></p>
<h5 id="选择iSCSI-LUN，选择新增">选择iSCSI LUN，选择新增</h5>
<p><img src="https://s1.ax1x.com/2020/04/08/GWUvcQ.png" alt="GWUvcQ.png"></p>
<h5 id="直接默认选项下一步，raid类型选择RAID6">直接默认选项下一步，raid类型选择RAID6</h5>
<p><img src="https://s1.ax1x.com/2020/04/08/GWagDs.png" alt="GWagDs.png"></p>
<h5 id="如果设计隐私，可以启用CHAP进行密码保护">如果设计隐私，可以启用CHAP进行密码保护</h5>
<p><img src="https://s1.ax1x.com/2020/04/08/GWayvQ.png" alt="GWayvQ.png"><br>
<img src="https://s1.ax1x.com/2020/04/08/GWar8S.png" alt="GWar8S.png"><br>
<img src="https://s1.ax1x.com/2020/04/08/GWaDC8.png" alt="GWaDC8.png"></p>
<p><img src="https://s1.ax1x.com/2020/04/08/GWagDs.png" alt="GWagDs.png"><br>
<img src="https://s1.ax1x.com/2020/04/08/GWayvQ.png" alt="GWayvQ.png"><br>
<img src="https://s1.ax1x.com/2020/04/08/GWar8S.png" alt="GWar8S.png"></p>
<h5 id="成功后显示如下信息就大功告辞了，这里因为有奇偶校验盘，所以会有容量损失。">成功后显示如下信息就大功告辞了，这里因为有奇偶校验盘，所以会有容量损失。</h5>
<p><img src="https://s1.ax1x.com/2020/04/08/GWaDC8.png" alt="GWaDC8.png"></p>
<h3 id="4、在windows上使用iSCSI存储">4、在windows上使用iSCSI存储</h3>
<h5 id="在windows控制面板中的管理工具，打开iSCSI发起程序">在windows控制面板中的管理工具，打开iSCSI发起程序</h5>
<p><img src="https://s1.ax1x.com/2020/04/08/GW2qqf.png" alt="GW2qqf.png"></p>
<h5 id="在发现里输入NAS的ip地址，程序就会自动搜寻">在发现里输入NAS的ip地址，程序就会自动搜寻</h5>
<p><img src="https://s1.ax1x.com/2020/04/08/GW2bsP.png" alt="GW2bsP.png"></p>
<h5 id="可以看到程序已经成功发现目标，选择连接即可连接到iSCSI-LUN">可以看到程序已经成功发现目标，选择连接即可连接到iSCSI LUN</h5>
<p><img src="https://s1.ax1x.com/2020/04/08/GW2HMt.png" alt="GW2HMt.png"></p>
<h5 id="打开磁盘管理，这里为了兼容我们选择MBR">打开磁盘管理，这里为了兼容我们选择MBR</h5>
<p><img src="https://s1.ax1x.com/2020/04/08/GWWZ0f.png" alt="GWWZ0f.png"></p>
<h5 id="然后可以发现多了一个空磁盘，选择新建卷，格式化后就形成了一个新的磁盘，打开我的电脑即可访问新的磁盘，和内置磁盘一模一样。">然后可以发现多了一个空磁盘，选择新建卷，格式化后就形成了一个新的磁盘，打开我的电脑即可访问新的磁盘，和内置磁盘一模一样。</h5>
<p><img src="https://s1.ax1x.com/2020/04/08/GWWVnP.png" alt="GWWVnP.png"><br>
<img src="https://s1.ax1x.com/2020/04/08/GWWAXt.png" alt="GWWAXt.png"></p>
<h3 id="5、在ESXi下使用iSCSI-存储">5、在ESXi下使用iSCSI 存储</h3>
<p>首先需要断开windows的连接，这里默认已经启动好了ESXi虚拟机，打开exsi浏览器控制面板。</p>
<p><img src="https://s1.ax1x.com/2020/04/08/GW5dVx.png" alt="GW5dVx.png"></p>
<h5 id="选择配置iSCSI，在动态目标里填上NAS的ip地址，保存后退出再进来可以发现静态目标已经自动生成。">选择配置iSCSI，在动态目标里填上NAS的ip地址，保存后退出再进来可以发现静态目标已经自动生成。</h5>
<p><img src="https://s1.ax1x.com/2020/04/08/GW4kc9.png" alt="GW4kc9.png"><br>
<img src="https://s1.ax1x.com/2020/04/08/GW49tU.png" alt="GW49tU.png"></p>
<h5 id="在设备里可以成功找到我们安装好的为定义的空磁盘">在设备里可以成功找到我们安装好的为定义的空磁盘</h5>
<p><img src="https://s1.ax1x.com/2020/04/08/GWIAdx.png" alt="GWIAdx.png"></p>
<h5 id="如何右键删除分区表后再重新进入选择新建数据存储">如何右键删除分区表后再重新进入选择新建数据存储</h5>
<p><img src="https://s1.ax1x.com/2020/04/08/GWo2UP.png" alt="GWo2UP.png"></p>
<h5 id="默认下一步">默认下一步</h5>
<p><img src="https://s1.ax1x.com/2020/04/08/GWo5vQ.png" alt="GWo5vQ.png"><br>
<img src="https://s1.ax1x.com/2020/04/08/GWoh8S.png" alt="GWoh8S.png"></p>
<h5 id="最终可以看见成功创建好了分区，之后就可以直接在该文件存储上存储数据了">最终可以看见成功创建好了分区，之后就可以直接在该文件存储上存储数据了</h5>
<p><img src="https://s1.ax1x.com/2020/04/08/GWT3Pf.png" alt="GWT3Pf.png"></p>
]]></content>
      <categories>
        <category>虚拟化与云计算</category>
      </categories>
      <tags>
        <tag>虚拟化基础</tag>
      </tags>
  </entry>
  <entry>
    <title>NAS、SAN、ISCSI存储简单理解</title>
    <url>/posts/2.927e+166.html</url>
    <content><![CDATA[<h3 id="NAS">NAS</h3>
<p> NAS是Network-Attached Storage的简称。中文一般称为“网络附加存储”，或者“网络连接存储”。我们可以把NAS理解为通过网络提供存储的设备（请特别注意，不需要光纤交换机，普通的局域网交换机即可）。</p>
<p>NAS是一种基于IP的高性能文件共享和存储专用设备。</p>
<ul>
<li>可使NAS客户端通过IP网络共享文件</li>
<li>采用针对文件I/O而优化的专用操作系统</li>
<li>使UNIX和Windows用户都能共享数据</li>
</ul>
<p> 通俗来讲：NAS可以是一个独立的存储系统，从与普通的应用服务器对比也可以看出，NAS是直接独立的存储，我们就称为<strong>NAS存储系统</strong>。一般来说，我们也可以用NAS搭建家庭共享存储设备，可以实现视频、照片等在多终端的同时共享。</p>
<p><img src="https://s1.ax1x.com/2020/04/08/GWAFfS.png" alt="GWAFfS.png"></p>
<a id="more"></a>
<h3 id="SAN">SAN</h3>
<p> SAN全称Storage Area Network and SAN Protocols，中文名存储区域网络，SAN是一种高速网络，提供在计算机与存储系统之间的数据传输。存储设备是指一台或多台用以存储计算机数据的磁盘设备，通常指磁盘阵列。其采用网状通道（Fibre Channel，简称FC）技术，通过FC交换机连接存储阵列和服务器主机，建立专用于数据存储的区域网络。SAN存储由于其基础是一个专用网络，因此扩展性很强，不管是在一个SAN系统中增加一定的存储空间还是增加几台使用存储空间的服务器都非常方便。</p>
<p>但注意的是，SAN和NAS并不是相互冲突的，是可以共存于一个系统网络中的，但NAS通过一个公共的接口实现空间的管理和资源共享，SAN仅仅是为服务器存储数据提供一个专门的快速后方通道</p>
<p><img src="https://s1.ax1x.com/2020/04/08/GWE1Et.png" alt="GWE1Et.png"></p>
<h3 id="iSCSI存储">iSCSI存储</h3>
<p> 使用专门的存储区域网成本很高，而利用普通的数据网来传输ISCSI数据实现和SAN相似的功能可以大大的降低成本，同时提高系统的灵活性。SCSI就是这样一种技术，它利用普通的TCP/IP网来传输本来用存储区域网来传输的SCSI数据块。</p>
<p> ISCSI网络存储的兴起原因：使用专门的光纤介质组建的SAN模式的存储区域网成本很高，而利用普通的数据网来传输ISCSI数据实现和SAN相似的功能可以大大的降低成本，同时提高系统的灵活性。</p>
<p><img src="https://s1.ax1x.com/2020/04/08/GWZtmj.png" alt="GWZtmj.png"></p>
<h3 id="DAS"><strong>DAS</strong></h3>
<p> 一种直接与主机系统相连接的存储设备，如作为服务器的计算机内部硬件驱动。</p>
<h6 id></h6>
]]></content>
      <categories>
        <category>虚拟化与云计算</category>
      </categories>
      <tags>
        <tag>虚拟化基础</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot2整合WebSocket入门实战</title>
    <url>/posts/f56bb91e.html</url>
    <content><![CDATA[<h1>一、问题描述</h1>
<p>最近刚好有一个需要，就是需要服务端推送消息到客户端，解决方案第一个想到的便是前端轮询服务器，查询服务器是否有请求。对于这种方法，优点是简单，但缺点也十分明显，那就是十分耗费服务器资源。因此在这里介绍了第二种方法，使用webSocket。</p>
<h1>二、websocket与http 区别</h1>
<p>http协议是用在应用层的协议，他是基于tcp协议的，http协议建立链接也必须要有三次握手才能发送信息。http链接分为短链接，长链接，短链接是每次请求都要三次握手才能发送自己的信息。即每一个request对应一个response。长链接是在一定的期限内保持链接。保持TCP连接不断开。客户端与服务器通信，必须要有客户端发起然后服务器返回结果。客户端是主动的，服务器是被动的。<br>
WebSocket是HTML5中的协议， 他是为了解决客户端发起多个http请求到服务器资源浏览器必须要经过长时间的轮训问题而生的，他实现了多路复用，他是全双工通信。在webSocket协议下客服端和浏览器可以同时发送信息。服务器也可以主动推送消息给客户端。</p>
<p><img src="https://img-blog.csdnimg.cn/20210127184737826.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbW9uX1RU,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<a id="more"></a>
<h1>三、springboot整合WebSocket</h1>
<h2 id="1、maven依赖">1、maven依赖</h2>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;  </span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  </span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt;  </span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h2 id="2、配置WebSocketConfig">2、配置WebSocketConfig</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketConfig</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//如果使用了springboot启动项目，则需要bean注入，而如果使用了外置tomcat容器，则并不要bean注入，否侧会报错</span></span><br><span class="line">    <span class="meta">@Bean</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServerEndpointExporter <span class="title">serverEndpointExporter</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ServerEndpointExporter();  </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3、设置WebSocketServer（重点）">3、设置WebSocketServer（重点）</h2>
<p>直接<code>@ServerEndpoint(&quot;/wsserver/{userId}&quot;)</code> 、<code>@Component</code>启用即可，然后在里面实现<code>@OnOpen</code>开启连接，<code>@onClose</code>关闭连接，<code>@onMessage</code>接收消息等方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ServerEndpoint</span>(<span class="string">"/wsserver/&#123;userId&#125;"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger logger = LogManager.getLogger(WebSocketServer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">/**静态变量，用来记录当前在线连接数。应该把它设计成线程安全的。*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger onlineCount = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="comment">/**concurrent包的线程安全Set，用来存放每个客户端对应的MyWebSocket对象。*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ConcurrentHashMap&lt;String,WebSocketServer&gt; webSocketMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">/**与某个客户端的连接会话，需要通过它来给客户端发送数据*/</span></span><br><span class="line">    <span class="keyword">private</span> Session session;</span><br><span class="line">    <span class="comment">/**接收userId*/</span></span><br><span class="line">    <span class="keyword">private</span> String userId=<span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接建立成功调用的方法*/</span></span><br><span class="line">    <span class="meta">@OnOpen</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOpen</span><span class="params">(Session session,@PathParam(<span class="string">"userId"</span>)</span> String userId) <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.session = session;</span><br><span class="line">        <span class="keyword">this</span>.userId=userId;</span><br><span class="line">        <span class="keyword">if</span>(webSocketMap.containsKey(userId))&#123;</span><br><span class="line">            <span class="comment">//必须显示关闭，否则Map里没有了但是sesseion还能连接</span></span><br><span class="line">            webSocketMap.get(userId).session.close();</span><br><span class="line">            webSocketMap.remove(userId);</span><br><span class="line">            webSocketMap.put(userId,<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//加入set中，如果配置了nginx，会存在缓存</span></span><br><span class="line">        webSocketMap.put(userId,<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//在线数加1</span></span><br><span class="line">        addOnlineCount();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">"用户连接:"</span>+userId+<span class="string">",当前在线人数为:"</span> + getOnlineCount());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sendMessage(<span class="string">"连接成功"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            logger.error(<span class="string">"用户:"</span>+userId+<span class="string">",网络异常!!!!!!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接关闭调用的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnClose</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClose</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(webSocketMap.containsKey(userId))&#123;</span><br><span class="line">            <span class="keyword">this</span>.session.close();</span><br><span class="line">            webSocketMap.remove(userId);</span><br><span class="line">            <span class="comment">//从set中删除</span></span><br><span class="line">            subOnlineCount();</span><br><span class="line">        &#125;</span><br><span class="line">        logger.info(<span class="string">"用户退出:"</span>+userId+<span class="string">",当前在线人数为:"</span> + getOnlineCount());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 收到客户端消息后调用的方法</span></span><br><span class="line"><span class="comment">     *需要有</span></span><br><span class="line"><span class="comment">     * &#123;</span></span><br><span class="line"><span class="comment">     *     xxx:xxx,</span></span><br><span class="line"><span class="comment">     *     "toUserId","xx"</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 客户端发送过来的消息*/</span></span><br><span class="line">    <span class="meta">@OnMessage</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(String message, Session session)</span> </span>&#123;</span><br><span class="line">            logger.info(<span class="string">"用户消息:"</span>+userId+<span class="string">",报文:"</span>+message);</span><br><span class="line">            <span class="comment">//可以群发消息</span></span><br><span class="line">            <span class="comment">//消息保存到数据库、redis</span></span><br><span class="line">            <span class="keyword">if</span>(StringUtils.isNotBlank(message))&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//解析发送的报文</span></span><br><span class="line">                    JSONObject jsonObject = JSON.parseObject(message);</span><br><span class="line">                    <span class="comment">//追加发送人(防止串改)</span></span><br><span class="line">                    jsonObject.put(<span class="string">"fromUserId"</span>,<span class="keyword">this</span>.userId);</span><br><span class="line">                    String toUserId=jsonObject.getString(<span class="string">"toUserId"</span>);</span><br><span class="line">                    <span class="comment">//传送给对应toUserId用户的websocket</span></span><br><span class="line">                    <span class="keyword">if</span>(StringUtils.isNotBlank(toUserId)&amp;&amp;webSocketMap.containsKey(toUserId))&#123;</span><br><span class="line">                        webSocketMap.get(toUserId).sendMessage(jsonObject.toJSONString());</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        logger.error(<span class="string">"请求的userId:"</span>+toUserId+<span class="string">"不在该服务器上"</span>);</span><br><span class="line">                        <span class="comment">//否则不在这个服务器上，发送到mysql或者redis</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> error</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnError</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Session session, Throwable error)</span> </span>&#123;</span><br><span class="line">        logger.error(<span class="string">"用户错误:"</span>+<span class="keyword">this</span>.userId+<span class="string">",原因:"</span>+error.getMessage());</span><br><span class="line">        error.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现服务器主动推送</span></span><br><span class="line"><span class="comment">     * 这里需要</span></span><br><span class="line"><span class="comment">     * &#123;xxx:xxx&#125;格式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String message)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.session);</span><br><span class="line">        <span class="keyword">this</span>.session.getBasicRemote().sendText(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送自定义消息</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendInfo</span><span class="params">(String message,@PathParam(<span class="string">"userId"</span>)</span> String userId) <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"发送消息到:"</span>+userId+<span class="string">"，报文:"</span>+message);</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isNotBlank(userId)&amp;&amp;webSocketMap.containsKey(userId))&#123;</span><br><span class="line">            webSocketMap.get(userId).sendMessage(message);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            logger.error(<span class="string">"用户"</span>+userId+<span class="string">",不在线！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">getOnlineCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> onlineCount.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addOnlineCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        WebSocketServer.onlineCount.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">subOnlineCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        WebSocketServer.onlineCount.decrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回sessionMap，用来多个websocket进行通信，可以在外面的类发送消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ConcurrentHashMap&lt;String, WebSocketServer&gt; <span class="title">getWebSocketMap</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> webSocketMap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：如果项目使用了nginx反向代理，则需要在nginx的配置文件的<code>location/</code>位置处添加</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">proxy_http_version 1.1;</span><br><span class="line">proxy_set_header Upgrade <span class="variable">$http_upgrade</span>;</span><br><span class="line">proxy_set_header Connection <span class="string">"upgrade"</span>;</span><br><span class="line"><span class="comment"># 超时时间设置为两小时</span></span><br><span class="line">proxy_read_timeout 7200s;</span><br></pre></td></tr></table></figure>
<h2 id="4、前端页面调用">4、前端页面调用</h2>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Test My WebSocket<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    Test<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"text"</span> <span class="attr">type</span>=<span class="string">"text"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"send()"</span>&gt;</span>Send<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"closeWebSocket()"</span>&gt;</span>Close<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"message"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> websocket = <span class="literal">null</span>;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">//判断当前浏览器是否支持WebSocket</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (<span class="string">'WebSocket'</span> <span class="keyword">in</span> <span class="built_in">window</span>) &#123;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">//连接WebSocket节点 </span></span></span><br><span class="line"><span class="actionscript">        <span class="comment">//这里的userid自己修改就可以模拟开多个界面</span></span></span><br><span class="line"><span class="actionscript">        <span class="comment">//这里的地址写上你websocket的服务地址</span></span></span><br><span class="line"><span class="actionscript">        websocket = <span class="keyword">new</span> WebSocket(<span class="string">"ws://localhost:8888/wsserver/1"</span>);</span></span><br><span class="line"><span class="actionscript">    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="actionscript">        alert(<span class="string">'Not support websocket'</span>)</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="actionscript">    <span class="comment">//连接发生错误的回调方法</span></span></span><br><span class="line"><span class="actionscript">    websocket.onerror = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        setMessageInnerHTML(<span class="string">"error"</span>);</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="actionscript">    <span class="comment">//连接成功建立的回调方法</span></span></span><br><span class="line"><span class="actionscript">    websocket.onopen = <span class="function"><span class="keyword">function</span><span class="params">(event)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">            setMessageInnerHTML(<span class="string">"open"</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="actionscript">        <span class="comment">//接收到消息的回调方法</span></span></span><br><span class="line"><span class="actionscript">    websocket.onmessage = <span class="function"><span class="keyword">function</span><span class="params">(event)</span> </span>&#123;</span></span><br><span class="line">        setMessageInnerHTML(event.data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">//连接关闭的回调方法</span></span></span><br><span class="line"><span class="actionscript">    websocket.onclose = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        setMessageInnerHTML(<span class="string">"close"</span>);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">//监听窗口关闭事件，当窗口关闭时，主动去关闭websocket连接，防止连接还没断开就关闭窗口，server端会抛异常。</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onbeforeunload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line">        websocket.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">//将消息显示在网页上</span></span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">setMessageInnerHTML</span><span class="params">(innerHTML)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.getElementById(<span class="string">'message'</span>).innerHTML += innerHTML + <span class="string">'&lt;br/&gt;'</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">//关闭连接</span></span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">closeWebSocket</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line">        websocket.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">//发送消息</span></span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> message = <span class="built_in">document</span>.getElementById(<span class="string">'text'</span>).value;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(message);</span></span><br><span class="line">        websocket.send(message);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="5、运行结果">5、运行结果</h2>
<p>在这里我开了两个界面，userId分别是1和2，这里我在1发送了如下json串，这会经过服务器自动转发到仍然在线的2。同时我们可以查看到服务端可以统计当前在线人数，还打印出了转发的报文</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;msg&quot;: &quot;wda&quot;,</span><br><span class="line">	&quot;toUserId&quot;: &quot;2&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210127184839487.png" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20210127184824244.png" alt="在这里插入图片描述"><br>
简单的实战到此为止，再次基础上可以修改很多功能啦~</p>
<h1>四、WebSocket注意事项</h1>
<h2 id="1、问题一">1、问题一</h2>
<h3 id="1-1-问题描述">1.1 问题描述</h3>
<p>在websocket服务中，有时候可能需要加其他类，比如我需要<code>VideoService</code>类，这时候使用<code>@Autowired</code>自动注入，但是运行的时候报错<code>java.lang.NullPointerException</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> VideoService videoService;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-原因与解决方法">1.2 原因与解决方法</h3>
<p>这个线程是tomcat启动的，在这个tomcat启动的线程中是不能使用spring容器提供的<code>@Autowired</code>的单例bean。</p>
<p>如果不是static，这个repository就是null。在这个线程中也没有办法从spring容器中取到这个bean，所以只能把这个bean设置为static，这样这个单例bean就脱离了spring容器的限制，可以在所有线程中使用了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 视频服务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> VideoService videoService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRepository</span><span class="params">(CallService callService)</span> </span>&#123;</span><br><span class="line">    StudentWebSocketServer.callService=callService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一个思路：实现BeanFactoryAware，这样可以通过注入的BeanFactory拿到这个bean，应该也是可行的</p>
<h2 id="2、问题二">2、问题二</h2>
<h3 id="2-1-问题描述">2.1 问题描述</h3>
<p>刚开始的时候用户退出只将Session从Map中取出，发现用户退出了，但是用户仍然可以发送消息，经过测试才发现单纯从Map去除并不会断开session连接，需要显示调用<code>session.close()</code>才能真正断开连接</p>
<h2 id="3、问题三">3、问题三</h2>
<h3 id="3-1-问题描述">3.1 问题描述</h3>
<p>配置了Nginx的<code>proxy_read_timeout</code>参数后，websocket会进行缓存，当websocket再次进行<code>onOpen()</code>重连时，websocket仍然会检测到原来的连接(即session)，直到<code>proxy_read_timeout</code>参数过期；同时客户端发送心跳包给websocket连接，会使得<code>proxy_read_timeout</code>参数延续</p>
<h1>五、未来与展望</h1>
<p>wensocket对于并发并不是很好，一般使用netty，下面是一些参考链接</p>
<hr>
<p><a href="https://blog.csdn.net/huiyunfei/article/details/90719351" target="_blank" rel="noopener">springboot集成websocket的两种实现方式</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/105675083" target="_blank" rel="noopener">SpringBoot(23) 集成socket.io服务端和客户端实现通信</a></p>
<p><a href="https://www.xncoding.com/2017/07/16/spring/sb-socketio.html" target="_blank" rel="noopener">SpringBoot系列 - 集成SocketIO实时通信</a></p>
<p><a href="https://socketio.bootcss.com/docs/" target="_blank" rel="noopener">Socket.io文档</a></p>
<p><a href="https://www.dlblog.club/a/IB4w9VN6" target="_blank" rel="noopener">Spring-Boot快速集成netty-socketio(socket服务实现，支持认证)</a></p>
<p><a href="https://www.cnblogs.com/kiwifly/p/11729304.html" target="_blank" rel="noopener">集成 websocket 的四种方案</a></p>
<p><a href="https://github.com/mrniko/netty-socketio" target="_blank" rel="noopener">https://github.com/mrniko/netty-socketio</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot集成RabbitMQ简单入门实践</title>
    <url>/posts/538a1b2.html</url>
    <content><![CDATA[<h3 id="一、RabbitMQ核心概念">一、RabbitMQ核心概念</h3>
<p>RabbitMQ是一个由erlang开发的AMQP(Advanved Message Queue Protocol)的开源实现。所有 MQ 产品从模型抽象上来说都是一样的过程：</p>
<blockquote>
<p>消费者（consumer）订阅某个队列。生产者（producer）创建消息，然后发布到队列（queue）中，最后将消息发送到监听的消费者。</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/img_convert/f2c700887fa3dfe1fae01a0dbe6ecf63.png" alt></p>
<h5 id="1、Message">1、Message</h5>
<p>消息，消息是不具名的，它由消息头和消息体组成。消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括routing-key(路由键)、priority(相对于其他消息的优先权)、delivery-mode(指出该消息可能需要持久性存储)等。</p>
<h5 id="2、Publisher">2、Publisher</h5>
<p>消息的生产者，也是一个向交换器发布消息的客户端应用程序。</p>
<a id="more"></a>
<h5 id="3、Exchange">3、Exchange</h5>
<p>交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列。</p>
<p>Exchange有4种类型:direct(默认)，fanout, topic, 和headers，不同类型的Exchange转发消息的策略有所区别。</p>
<h5 id="4、Queue">4、Queue</h5>
<p>消息队列，用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。</p>
<h5 id="5、Binding">5、Binding</h5>
<p>绑定，用于消息队列和交换器之间的关联。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。Exchange 和Queue的绑定可以是多对多的关系。</p>
<h5 id="6、Connection">6、Connection</h5>
<p>网络连接，比如一个TCP连接。</p>
<h5 id="7、Channel">7、Channel</h5>
<p>信道，多路复用连接中的一条独立的双向数据流通道。信道是建立在真实的TCP连接内的虚拟连接，AMQP 命令都是通过信道发出去的，不管是发布消息、订阅队列还是接收消息，这些动作都是通过信道完成。因为对于操作系统来说建立和销毁 TCP 都是非常昂贵的开销，所以引入了信道的概念，以复用一条TCP连接。</p>
<h5 id="8、Consumer">8、Consumer</h5>
<p>消息的消费者，表示一个从消息队列中取得消息的客户端应用程序。</p>
<h5 id="9、Virtual-Host">9、Virtual Host</h5>
<p>虚拟主机，表示一批交换器、消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。每个 vhost 本质上就是一个 mini 版的 RabbitMQ 服务器，拥有自己的队列、交换器、绑定和权限机制。vhost 是 AMQP 概念的基础，必须在连接时指定， RabbitMQ 默认的 vhost 是 / 。</p>
<h5 id="10、Broker">10、Broker</h5>
<p>表示消息队列服务器实体<br>
<img src="https://img-blog.csdnimg.cn/img_convert/372d6ee73ac9f85bfbea86a0421b4906.png" alt="GZ9M79.png"></p>
<h3 id="二、AMQP的消息路由">二、AMQP的消息路由</h3>
<ol>
<li>
<p>AMQP 中消息的路由过程和 Java 开发者熟悉的 JMS 存在一些差别，AMQP 中增加了 Exchange 和 Binding 的角色。生产者把消息发布到 Exchange 上，消息最终到达队列并被消费者接收，而 Binding 决定交换器的消息应该发送到那个队列。<br>
<img src="https://img-blog.csdn.net/20181022154515317?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5NDc5MDQx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p>
<h4 id="Exchange-类型"><strong>Exchange 类型</strong></h4>
<p>Exchange分发消息时根据类型的不同分发策略有区别，目前共四种类型：direct、fanout、topic、headers 。headers 匹配 AMQP 消息的 header 而不是路由键，此外 headers 交换器和 direct 交换器完全一致，但性能差很多，目前几乎用不到了，所以直接看另外三种类型：</p>
<h4 id="1、direct">1、direct</h4>
<p><img src="https://img-blog.csdn.net/20181022154545524?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5NDc5MDQx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p>
<p>direct 交换器</p>
<p>消息中的路由键（routing key）如果和 Binding 中的 binding key 一致， 交换器就将消息发到对应的队列中。路由键与队列名完全匹配，如果一个队列绑定到交换机要求路由键为“dog”，则只转发 routing key 标记为“dog”的消息，不会转发“dog.puppy”，也不会转发“dog.guard”等等。它是完全匹配、单播的模式。</p>
<h4 id="2、fanout">2、fanout</h4>
<p><img src="https://img-blog.csdn.net/20181022154613161?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5NDc5MDQx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p>
<p>fanout 交换器</p>
<p>每个发到 fanout 类型交换器的消息都会分到所有绑定的队列上去。fanout 交换器不处理路由键，只是简单的将队列绑定到交换器上，每个发送到交换器的消息都会被转发到与该交换器绑定的所有队列上。很像子网广播，每台子网内的主机都获得了一份复制的消息。fanout 类型转发消息是最快的。</p>
<h4 id="3、topic">3、topic</h4>
<p><img src="https://img-blog.csdn.net/20181022154644143?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5NDc5MDQx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p>
<p>topic 交换器</p>
<p>topic 交换器通过模式匹配分配消息的路由键属性，将路由键和某个模式进行匹配，此时队列需要绑定到一个模式上。它将路由键和绑定键的字符串切分成单词，这些单词之间用点隔开。它同样也会识别两个通配符：符号“#”和符号“</p>
<p>”。#匹配0个或多个单词，</p>
<p>匹配不多不少一个单词。</p>
</li>
</ol>
<h3 id="三、RabbitMQ的安装">三、RabbitMQ的安装</h3>
<p>Windows和Linux的普通安装我在这就不阐述了，网上一搜有很多方法，但要注意的是erl版本和RabbitMQ版本的对应关系，具体见<a href="https://www.rabbitmq.com/which-erlang.html" target="_blank" rel="noopener">官网版本对应</a></p>
<p>在这里我提供了一种简单的安装方法，这里的安装环境是centos7.6，docker安装，直接几分钟就可以安装好了。默认你已经安装好了docker</p>
<blockquote>
<p>1、打开远程服务器，记得下载这个带web管理的</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull rabbitmq:management</span><br></pre></td></tr></table></figure>
<blockquote>
<p>2.查看下载的镜像</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>
<blockquote>
<p>3.运行镜像，这里注意防火墙的开放</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --name rabbitmq -p 5671:5671 -p 5672:5672 -p 4369:4369 -p 25672:25672 -p 15671:15671 -p 15672:15672 rabbitmq:management</span><br></pre></td></tr></table></figure>
<blockquote>
<p>4.输入网址：<a href="http://IP:15672/" target="_blank" rel="noopener">http://IP:15672/</a> 账号密码：guest/guest，即可进入web管理界面</p>
</blockquote>
<h3 id="四、springboot集成简单实践-点对点">四、springboot集成简单实践(点对点)</h3>
<h5 id="1、打开管理界面，点击进入Exchanges，选择新建一个，这里我设置名字为exchange-direct，并且选择类型为direct-表示点对点。而如果要广播模式，就选择fanout模式，并且绑定的队列不需要设置路由键，这样只要有生产者生产，所有监听的消费者都能收到。">1、打开管理界面，点击进入Exchanges，选择新建一个，这里我设置名字为exchange.direct，并且选择类型为direct,表示点对点。而如果要广播模式，就选择fanout模式，并且绑定的队列不需要设置路由键，这样只要有生产者生产，所有监听的消费者都能收到。</h5>
<p><img src="https://img-blog.csdnimg.cn/img_convert/58afb5845b1749c97694b90911235eda.png" alt="GZkGLT.png"></p>
<h5 id="2、点击Queues，新建一个队列，这里我新建了login的队列">2、点击Queues，新建一个队列，这里我新建了login的队列</h5>
<p><img src="https://img-blog.csdnimg.cn/img_convert/5e3c0de2e5e49c14a7443cc9b7118db4.png" alt="GZk8yV.md.png"></p>
<h5 id="3、返回刚才的Exchange交换器，点击进入我们刚才创建的exchange-direct，来对login队列进行绑定，这里路由键也设置为login">3、返回刚才的Exchange交换器，点击进入我们刚才创建的exchange.direct，来对login队列进行绑定，这里路由键也设置为login</h5>
<p><img src="https://img-blog.csdnimg.cn/img_convert/deed23c94bbfbfe9f072d28d0cf8bbd7.png" alt="GZkYeU.png"></p>
<h5 id="4、springboot项目引入maven依赖">4、springboot项目引入maven依赖</h5>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h5 id="5、配置yml">5、配置yml</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring</span><br><span class="line">  rabbitmq:</span><br><span class="line">    host: localhost</span><br><span class="line">    port: <span class="number">5672</span></span><br><span class="line">    username: guest</span><br><span class="line">    password: guest</span><br></pre></td></tr></table></figure>
<h5 id="6、config">6、config</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义MessageConverter：将数据自动转为josn发送出去</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAMQPConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessageConverter <span class="title">messageConverter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Jackson2JsonMessageConverter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="6、利用RabbitTemplate消息发送处理组件">6、利用RabbitTemplate消息发送处理组件</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMQTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//对象被默认序列化</span></span><br><span class="line">        Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        map.put(<span class="string">"msg"</span>,<span class="string">"helloword"</span>);</span><br><span class="line">        map.put(<span class="string">"data"</span>, Arrays.asList(<span class="string">"jkdsnj"</span>,<span class="number">123</span>,<span class="keyword">true</span>));</span><br><span class="line">       rabbitTemplate.convertAndSend(<span class="string">"exchange.direct"</span>,<span class="string">"login"</span>,map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	<span class="comment">//这是监听，一有生产者生产，这里立刻能收到消息</span></span><br><span class="line">        Object o = rabbitTemplate.receiveAndConvert(<span class="string">"login"</span>);</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>另外消费者还可以通过注解实现，在方法前加入RabbitListener，并写出队列，即可自动监听，同时注意需要在启动类上加@EnableRabbit</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"login"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(Map map)</span></span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"Rabbit"</span> + map);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>好了，到现在为止，一个简单的点对点消息队列已经集成完毕，根据这个可以根据需要加入到项目中，具体也可见参考文章</p>
<br>
<hr>
<h4 id="参考文章">参考文章</h4>
<p><a href="https://blog.csdn.net/qq_29479041/article/details/83273735" target="_blank" rel="noopener">https://blog.csdn.net/qq_29479041/article/details/83273735</a></p>
<p><a href="https://www.jianshu.com/p/bd41f1a1e53d" target="_blank" rel="noopener">https://www.jianshu.com/p/bd41f1a1e53d</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos7安装zookeeper和Web UI</title>
    <url>/posts/f2395be.html</url>
    <content><![CDATA[<h2 id="一、zookeeper的安装">一、zookeeper的安装</h2>
<h4 id="1、zookeeper介绍">1、zookeeper介绍</h4>
<p>ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。</p>
<p>ZooKeeper的目标就是封装好复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户。</p>
<p>ZooKeeper包含一个简单的原语集， [1] 提供Java和C的接口。官网：<a href="https://zookeeper.apache.org/" target="_blank" rel="noopener">https://zookeeper.apache.org</a></p>
<h4 id="2、安装环境">2、安装环境</h4>
<p>Centos7.6 、JDK1.8</p>
<a id="more"></a>
<h4 id="3、安装过程">3、安装过程</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/apache/zookeeper/zookeeper-3.6.2/apache-zookeeper-3.6.2-bin.tar.gz</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -zxvf apache-zookeeper-3.6.2-bin.tar.gz</span><br></pre></td></tr></table></figure>
<p>进入conf文件夹<code>cd  apache-zookeeper-3.6.2-bin/conf</code>将配置文件复制，这一步很关键，另外整个文件名可以修改一下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp zoo_sample.cfg zoo.cfg</span><br></pre></td></tr></table></figure>
<p>然后在根目录新建/data，并且配置zoo.cfg其中两项如下(这是我自己定义的路径)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dataDir=/data/zookeeper/data</span><br><span class="line">dataLogDir=/data/zookeeper/logs</span><br></pre></td></tr></table></figure>
<p>另外zookeeper是默认占用8080端口的，如果开了tomcat就会报错，所以我在配置文件里添加了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">admin.serverPort=11223</span><br></pre></td></tr></table></figure>
<p>然后修改环境变量 <code>vim /etc/profile</code> ，完成后<code>source /etc/profile</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#这里的ZOOKEEPER_HOME指的是你刚刚解压的目录</span></span><br><span class="line"><span class="comment">#这里因为源文件名字太长，我已经更名mv apache-zookeeper-3.6.2-bin.tar.gz zookeeper</span></span><br><span class="line"><span class="built_in">export</span> ZOOKEEPER_HOME=/root/zookeeper/</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$ZOOKEEPER_HOME</span>/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure>
<p>另外这里贴出zoo.cfg的一些配置信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># The number of milliseconds of each tick</span></span><br><span class="line"><span class="comment"># tickTime：CS通信心跳数</span></span><br><span class="line"><span class="comment"># Zookeeper 服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每个 tickTime 时间就会发送一个心跳。tickTime以毫秒为单位。</span></span><br><span class="line">tickTime=2000</span><br><span class="line"></span><br><span class="line"><span class="comment"># The number of ticks that the initial </span></span><br><span class="line"><span class="comment"># synchronization phase can take</span></span><br><span class="line"><span class="comment"># initLimit：LF初始通信时限</span></span><br><span class="line"><span class="comment"># 集群中的follower服务器(F)与leader服务器(L)之间初始连接时能容忍的最多心跳数（tickTime的数量）。</span></span><br><span class="line">initLimit=5</span><br><span class="line"></span><br><span class="line"><span class="comment"># The number of ticks that can pass between </span></span><br><span class="line"><span class="comment"># sending a request and getting an acknowledgement</span></span><br><span class="line"><span class="comment"># syncLimit：LF同步通信时限</span></span><br><span class="line"><span class="comment"># 集群中的follower服务器与leader服务器之间请求和应答之间能容忍的最多心跳数（tickTime的数量）。</span></span><br><span class="line">syncLimit=2</span><br><span class="line"></span><br><span class="line"><span class="comment"># the directory where the snapshot is stored.</span></span><br><span class="line"><span class="comment"># do not use /tmp for storage, /tmp here is just </span></span><br><span class="line"><span class="comment"># example sakes.</span></span><br><span class="line"><span class="comment"># dataDir：数据文件目录</span></span><br><span class="line"><span class="comment"># Zookeeper保存数据的目录，默认情况下，Zookeeper将写数据的日志文件也保存在这个目录里。</span></span><br><span class="line">dataDir=/data/soft/zookeeper-3.4.12/data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># dataLogDir：日志文件目录</span></span><br><span class="line"><span class="comment"># Zookeeper保存日志文件的目录。</span></span><br><span class="line">dataLogDir=/data/soft/zookeeper-3.4.12/logs</span><br><span class="line"></span><br><span class="line"><span class="comment"># the port at which the clients will connect</span></span><br><span class="line"><span class="comment"># clientPort：客户端连接端口</span></span><br><span class="line"><span class="comment"># 客户端连接 Zookeeper 服务器的端口，Zookeeper 会监听这个端口，接受客户端的访问请求。</span></span><br><span class="line">clientPort=2181</span><br><span class="line"></span><br><span class="line"><span class="comment"># the maximum number of client connections.</span></span><br><span class="line"><span class="comment"># increase this if you need to handle more clients</span></span><br><span class="line"><span class="comment">#maxClientCnxns=60</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Be sure to read the maintenance section of the </span></span><br><span class="line"><span class="comment"># administrator guide before turning on autopurge.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The number of snapshots to retain in dataDir</span></span><br><span class="line"><span class="comment">#autopurge.snapRetainCount=3</span></span><br><span class="line"><span class="comment"># Purge task interval in hours</span></span><br><span class="line"><span class="comment"># Set to "0" to disable auto purge feature</span></span><br><span class="line"><span class="comment">#autopurge.purgeInterval=1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 服务器名称与地址：集群信息（服务器编号，服务器地址，LF通信端口，选举端口）</span></span><br><span class="line"><span class="comment"># 这个配置项的书写格式比较特殊，规则如下：</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># server.N=YYY:A:B  </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 其中N表示服务器编号，YYY表示服务器的IP地址，A为LF通信端口，表示该服务器与集群中的leader交换的信息的端口。B为选举端口，表示选举新leader时服务器间相互通信的端口（当leader挂掉时，其余服务器会相互通信，选择出新的leader）。一般来说，集群中每个服务器的A端口都是一样，每个服务器的B端口也是一样。但是当所采用的为伪集群时，IP地址都一样，只能时A端口和B端口不一样。</span></span><br></pre></td></tr></table></figure>
<h4 id="4、zookeeper的常用命令">4、zookeeper的常用命令</h4>
<p>进入zookeeper的bin目录下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">启动命令：./zkServer.sh start</span><br><span class="line"></span><br><span class="line">停止命令：./zkServer.sh stop　　</span><br><span class="line"></span><br><span class="line">重启命令：./zkServer.sh restart</span><br><span class="line"></span><br><span class="line">状态查看命令：./zkServer.sh status</span><br></pre></td></tr></table></figure>
<h4 id="5、开放端口号">5、开放端口号</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --permanent --zone=public --add-port=2181/tcp</span><br><span class="line"><span class="comment">#重启防火墙</span></span><br><span class="line">systemctl restart firewalld</span><br><span class="line"><span class="comment">#查看开放端口</span></span><br><span class="line">netstat -ntl</span><br></pre></td></tr></table></figure>
<h2 id="二、Web-UI可视化的安装">二、Web-UI可视化的安装</h2>
<h4 id="1、Maven的安装">1、Maven的安装</h4>
<p>这里需要git和maven，git的话服务器很多就有自带，就不多阐述了，这里来说一下maven的安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://mirrors.hust.edu.cn/apache/maven/maven-3/3.3.9/binaries/apache-maven-3.3.9-bin.tar.gz</span><br><span class="line">tar -zxvf apache-maven-3.3.9-bin.tar.gz</span><br><span class="line">mv apache-maven-3.3.9 /usr/<span class="built_in">local</span>/maven3</span><br></pre></td></tr></table></figure>
<h4 id="2、添加环境变量">2、添加环境变量</h4>
<p>和上面添加一样</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> M2_HOME=/usr/<span class="built_in">local</span>/maven3</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$M2_HOME</span>/bin</span><br></pre></td></tr></table></figure>
<p>如果输入<code>mvn -v</code>有结果的话，就说明安装成功了</p>
<h4 id="3、生成zkui的jar包">3、生成zkui的jar包</h4>
<p>首先下载源码包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://gitee.com/ilanni/zkui.git</span><br></pre></td></tr></table></figure>
<p>进入zkui目录后进行编译，构建和打包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mvn clean install</span><br></pre></td></tr></table></figure>
<p>成功后会生成target文件夹，里面的<code>zkui-2.0-SNAPSHOT-jar-with-dependencies.jar</code>就是我们需要的文件</p>
<h4 id="4、启动jar包">4、启动jar包</h4>
<p>将目录下的config.cfg文件移动到target目录下，然后启动jar包，默认用户名admin，密码manager，端口9090(注意端口的开放)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cpzk config.cfg target/config.cfg</span><br><span class="line"><span class="built_in">cd</span> target</span><br><span class="line">java -jar zkui-2.0-SNAPSHOT-jar-with-dependencies.jar</span><br></pre></td></tr></table></figure>
<h2 id="三、Dubbo-Admin可视化安装">三、Dubbo-Admin可视化安装</h2>
<h4 id="1、下载dubbo-admin">1、下载dubbo-admin</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/apache/dubbo-admin.git</span><br></pre></td></tr></table></figure>
<h4 id="2、设置端口">2、设置端口</h4>
<p>在<code>dubbo-admin\dubbo-admin-server\src\main\resources\application.properties</code>中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#### 添加一行</span></span><br><span class="line">server.port=8099</span><br></pre></td></tr></table></figure>
<h4 id="3、忽略test">3、忽略test</h4>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">#### 在root的pom.xml里面</span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.21.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">#### 改为如下</span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.21.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">skipTests</span>&gt;</span>true<span class="tag">&lt;/<span class="name">skipTests</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="4、打包">4、打包</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#### 在IDEA里面的右边点开Maven点击dubbo-admin（root）</span></span><br><span class="line"><span class="comment">#### 先后执行如下2个命令</span></span><br><span class="line">clean</span><br><span class="line">install</span><br></pre></td></tr></table></figure>
<h4 id="5、部署">5、部署</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#### 完成后dubbo-admin\dubbo-admin-distribution\target会有个dubbo-admin-0.1.jar</span></span><br><span class="line"><span class="comment">#### 可以部署到本机或者linux上</span></span><br><span class="line"> </span><br><span class="line">请确保zookeeper已经启动</span><br><span class="line">java -jar dubbo-admin-0.1.jar</span><br><span class="line">或者后台运行</span><br><span class="line">nohup java -jar dubbo-admin-0.1.jar  &gt; dubbo-admin.log  2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>
<br/>
<br/>
<p><a href="https://www.cnblogs.com/h--d/p/10269869.html" target="_blank" rel="noopener">参考文章一</a></p>
<p><a href="https://www.cnblogs.com/smail-bao/p/7794636.html" target="_blank" rel="noopener">参考文章二</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>java通过IP解析地理位置</title>
    <url>/posts/3b99ced5.html</url>
    <content><![CDATA[<h2 id="一、问题描述">一、问题描述</h2>
<p>最近在做一个外包项目，这里要求如果定位高延迟怎么办，另外为了能够加附近的人为好友方便，所以想到了利用用户的IP进行粗略的地理位置定位。因为在写的时候遇到了一些坑，所以在这里特别记录一下，方便以后翻阅。</p>
<a id="more"></a>
<h2 id="二、获取访问者ip">二、获取访问者ip</h2>
<h5 id="1、获取ip的java工具类">1、获取ip的java工具类</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IpUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LogManager.getLogger(IpUtil<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getIpAddr</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        String ipAddress = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ipAddress = request.getHeader(<span class="string">"x-forwarded-for"</span>);</span><br><span class="line">            <span class="keyword">if</span> (ipAddress == <span class="keyword">null</span> || ipAddress.length() == <span class="number">0</span> || <span class="string">"unknown"</span>.equalsIgnoreCase(ipAddress)) &#123;</span><br><span class="line">                ipAddress = request.getHeader(<span class="string">"Proxy-Client-IP"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ipAddress == <span class="keyword">null</span> || ipAddress.length() == <span class="number">0</span> || <span class="string">"unknown"</span>.equalsIgnoreCase(ipAddress)) &#123;</span><br><span class="line">                ipAddress = request.getHeader(<span class="string">"WL-Proxy-Client-IP"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ipAddress == <span class="keyword">null</span> || ipAddress.length() == <span class="number">0</span> || <span class="string">"unknown"</span>.equalsIgnoreCase(ipAddress)) &#123;</span><br><span class="line">                ipAddress = request.getRemoteAddr();</span><br><span class="line">                <span class="keyword">if</span> (ipAddress.equals(<span class="string">"127.0.0.1"</span>)) &#123;</span><br><span class="line">                    <span class="comment">// 根据网卡取本机配置的IP</span></span><br><span class="line">                    InetAddress inet = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        inet = InetAddress.getLocalHost();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">                        logger.error(<span class="string">"获取用户的主机发生异常"</span>,e);</span><br><span class="line">                    &#125;</span><br><span class="line">                    ipAddress = inet.getHostAddress();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 对于通过多个代理的情况，第一个IP为客户端真实IP,多个IP按照','分割</span></span><br><span class="line">            <span class="keyword">if</span> (ipAddress != <span class="keyword">null</span> &amp;&amp; ipAddress.length() &gt; <span class="number">15</span>) &#123; <span class="comment">// "***.***.***.***".length()</span></span><br><span class="line">                <span class="comment">// = 15</span></span><br><span class="line">                <span class="keyword">if</span> (ipAddress.indexOf(<span class="string">","</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    ipAddress = ipAddress.substring(<span class="number">0</span>, ipAddress.indexOf(<span class="string">","</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            ipAddress=<span class="string">""</span>;</span><br><span class="line">            logger.error(<span class="string">"获取用户的ip地址发生异常"</span>,e);</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">//ipAddress = this.getRequest().getRemoteAddr();</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ipAddress;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2、获取当前的用户的HttpServletRequest">2、获取当前的用户的HttpServletRequest</h5>
<p>一种方法就是利用Controller层的Api接口传进来，但是这样做并不是特别好，所以这里利用了Spring，该方法直接可以在Service获得当前的 HttpServletRequest，但是要注意的是，如果又开了一个线程的话，会报空指针异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();</span><br></pre></td></tr></table></figure>
<h5 id="3、nginx配置">3、nginx配置</h5>
<p>当项目没有额外配置nginx已经其他服务时，当前代码已经可以获得访问者的ip，但是如果配置了例如nginx，name当部署到服务器上时，总是会返回服务器的ip地址，在这里我掉坑了好久，解决方法是进行nginx的配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">       // 配置此处用于获取客户端的真实IP</span><br><span class="line">       proxy_set_header Host <span class="variable">$http_host</span>;</span><br><span class="line">   	proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">   	proxy_set_header X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">   	proxy_set_header X-Forwarded-Proto <span class="variable">$scheme</span>;</span><br><span class="line">   	proxy_pass http://localhost:8080;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="三、利用IP解析地理位置">三、利用IP解析地理位置</h2>
<p>在这里其实有很多种方法了，可以利用百度的API，但是有额度限制，在这里我用的是126的API接口</p>
<p><code>http://ip.ws.126.net/ipquery?ip=IP</code></p>
<p>因为126接口无法解析成JSON格式，所以只能自己写代码进行String的拆解。首先进行接口的访问</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RestTemplate restTemplate=<span class="keyword">new</span> RestTemplate();</span><br><span class="line">       Map&lt;String,String&gt; params=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       params.put(<span class="string">"ip"</span>,ip);  <span class="comment">//</span></span><br><span class="line">       ResponseEntity&lt;String&gt; responseEntity=restTemplate.getForEntity(<span class="string">"http://ip.ws.126.net/ipquery?ip=&#123;ip&#125;"</span>,String<span class="class">.<span class="keyword">class</span>,<span class="title">params</span>)</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 字符串解析</span></span><br><span class="line">       String resultStr = responseEntity.getBody().trim();</span><br><span class="line">       <span class="keyword">int</span> provinceNum = resultStr.indexOf(<span class="string">"lo"</span>) +<span class="number">4</span> ;</span><br><span class="line">       <span class="keyword">int</span> cityNum = resultStr.indexOf(<span class="string">"lc"</span>)  +<span class="number">4</span>;</span><br><span class="line">       String province = resultStr.trim().substring(provinceNum,provinceNum+<span class="number">3</span>);</span><br><span class="line">       String city = resultStr.trim().substring(cityNum,cityNum+<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<br>
<br>
<br>
<p><a href="https://blog.csdn.net/weixin_42686556/article/details/81948418?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">参考文章</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu16.04下docker的入门学习</title>
    <url>/posts/9188f990.html</url>
    <content><![CDATA[<h2 id="一、虚拟机">一、虚拟机</h2>
<p>这里我使用的是VMWare 15的虚拟机软件，Linux版本使用了ubuntu16.04 TLE版本，建议去阿里云下载ubuntu的镜像，启动后默认就可以了，之后所有的操作都以最高权限操作，输入<code>sudo su</code>进行切换。不过这里需要注意的是刚开始系统的apt源是国外的，所以使用<code>apt update</code>时会报错，所以需要在设置里先修改到国内源。后面也可以进入<code>/etc/apt/source.list</code>下进行国内源的添加，这些网上有很多，这里就不阐述了。</p>
<a id="more"></a>
<h2 id="二、docker-的安装">二、docker 的安装</h2>
<h5 id="1、更新apt库">1、更新apt库</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure>
<h5 id="2、以下安装使得允许apt通过HTTPS使用存储库">2、以下安装使得允许apt通过HTTPS使用存储库</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install apt-transport-https ca-certificates curl software-properties-common</span><br></pre></td></tr></table></figure>
<h5 id="3、添加阿里GPG秘钥">3、添加阿里GPG秘钥</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure>
<!-- more-->
<h5 id="4、添加阿里docker源">4、添加阿里docker源</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository <span class="string">"deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/ubuntu <span class="variable">$(lsb_release -cs)</span> stable"</span></span><br></pre></td></tr></table></figure>
<h5 id="5、更新apt源">5、更新apt源</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>
<h5 id="6、安装">6、安装</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install -y docker-ce</span><br></pre></td></tr></table></figure>
<h5 id="7、查看版本">7、查看版本</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker --version</span><br></pre></td></tr></table></figure>
<p>如果成功安装就会显示docker的版本号，另外，为了加快docker镜像的拉取，我们也需要修改docker源</p>
<h5 id="8、更换docker源">8、更换docker源</h5>
<p>以下是国内可用的镜像源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Docker 官方中国区：https://registry.docker-cn.com</span><br><span class="line">网易：http://hub-mirror.c.163.com</span><br><span class="line">中国科技大学：https://docker.mirrors.ustc.edu.cn</span><br><span class="line">阿里云：https://y0qd3iq.mirror.aliyuncs.com</span><br></pre></td></tr></table></figure>
<p>增加Docker的镜像源配置文件 /etc/docker/daemon.json，如果没有配置过镜像该文件默认是不存的，在其中增加如下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"registry-mirrors"</span>: [<span class="string">"https://y0qd3iq.mirror.aliyuncs.com"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的URL就是指定的镜像源，可以将其设置为上面说的四个镜像源中的任何一个。</p>
<p>然后重启Docker服务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service docker restart</span><br></pre></td></tr></table></figure>
<p>然后通过以下命令查看配置是否生效：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker info|grep Mirrors -A 1</span><br></pre></td></tr></table></figure>
<p>可以看到如下的输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Registry Mirrors:</span><br><span class="line"> https://y0qd3iq.mirror.aliyuncs.com/</span><br></pre></td></tr></table></figure>
<p>就表示镜像配置成功，然后再执行docker pull操作，就会很快了。可以使用 <code>docker run hello-world</code> 来验证是否成功</p>
<h2 id="三、docker常用命令">三、docker常用命令</h2>
<h5 id="1、查看docker-当前版本">1、查看docker 当前版本</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure>
<h5 id="2、启动与停止">2、启动与停止</h5>
<p>安装完成Docker后，默认已经启动了docker服务，如需手动控制docker服务的启停，可执行如下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动docker</span></span><br><span class="line">sudo service docker start</span><br><span class="line"><span class="comment"># 停止docker</span></span><br><span class="line">sudo service docker stop</span><br><span class="line"><span class="comment"># 重启docker</span></span><br><span class="line">sudo service docker restart</span><br></pre></td></tr></table></figure>
<h5 id="3、查看所有镜像">3、查看所有镜像</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker image ls</span><br><span class="line">sudo docker image ls --all</span><br></pre></td></tr></table></figure>
<ul>
<li>REPOSITORY：镜像所在的仓库名称</li>
<li>TAG：镜像标签</li>
<li>IMAGEID：镜像ID</li>
<li>CREATED：镜像的创建日期(不是获取该镜像的日期)</li>
<li>SIZE：镜像大小</li>
</ul>
<h5 id="4、拉取镜像">4、拉取镜像</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker image pull 镜像名称:版本号 <span class="comment"># 不指定版本默认为最新版</span></span><br><span class="line"><span class="comment">#举例</span></span><br><span class="line">sudo docker image pull library/hello-world</span><br></pre></td></tr></table></figure>
<h5 id="5、删除镜像">5、删除镜像</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker image rm 镜像名称/镜像ID</span><br></pre></td></tr></table></figure>
<h5 id="6、创建容器-必须现有镜像，才能创建运行容器">6、创建容器(必须现有镜像，才能创建运行容器)</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker run [option] 镜像名 [向启动容器中传入的命令] <span class="comment"># 创建容器</span></span><br></pre></td></tr></table></figure>
<p>常用可选参数说明：</p>
<ul>
<li>-i 表示以“交互模式”运行容器</li>
<li>-t 表示容器启动后会进入其命令行。加入这两个参数后，容器创建就能登录进去。即 分配一个伪终端。</li>
<li>–name 为创建的容器命名</li>
<li>-v 表示目录映射关系(前者是宿主机目录，后者是映射到宿主机上的目录，即 宿主机目录:容器中目录)，可以使 用多个-v 做多个目录或文件映射。注意:最好做目录映射，在宿主机上做修改，然后 共享到容器上。</li>
<li>-d 在run后面加上-d参数,则会创建一个守护式容器在后台运行(这样创建容器后不 会自动登录容器，如果只加-i -t 两个参数，创建后就会自动进去容器)。</li>
<li>-p 表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个-p 做多个端口映射</li>
<li>-e 为容器设置环境变量</li>
<li>–network=host 表示将主机的网络环境映射到容器中，容器的网络与主机相同</li>
<li>-it 创建一个伪终端交互界面，name指定容器名称</li>
</ul>
<h5 id="7、查看所有容器">7、查看所有容器</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker container ls <span class="comment">#查看所有正在运行的容器</span></span><br><span class="line">sodu docker ps</span><br><span class="line">sudo docker container ls --all <span class="comment"># 查看所有已创建的容器</span></span><br><span class="line">sudo docker ps -a</span><br></pre></td></tr></table></figure>
<p>查看容器</p>
<ul>
<li>container id 容器id</li>
<li>image 镜像名称</li>
<li>command 创建后运行的命令</li>
<li>created 创建时间</li>
<li>status 关闭时间</li>
<li>ports 绑定的端口</li>
<li>names 容器名称</li>
</ul>
<h5 id="8、创建一个守护式容器">8、创建一个守护式容器</h5>
<p>如果对于一个需要长期运行的容器来说，我们可以创建一个守护式容器。在容器内部exit退出时，容器也不会停止。即正常来说，进入交互伪终端后输入exit容器也会对应关闭，但是加了-d 内部使用exit也不会结束运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo docker run -dit --name&#x3D;ubuntu2 ubuntu &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>
<h5 id="9、运行已经开启的容器">9、运行已经开启的容器</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker container <span class="built_in">exec</span> -it &lt;容器名/id&gt; &lt;运行后使用的第一个命令&gt;</span><br><span class="line"><span class="comment"># 运行使用的第一个命令一般默认为 /bin/bash 否则无法进入交互界面</span></span><br></pre></td></tr></table></figure>
<h5 id="10、停止与启动容器">10、停止与启动容器</h5>
<p>Container 可以省略</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 停止一个已经在运行的容器</span></span><br><span class="line">sudo docker container stop 容器名或容器id</span><br><span class="line"><span class="comment"># 启动一个已经停止的容器</span></span><br><span class="line">sudo docker container start 容器名或容器id</span><br><span class="line"><span class="comment"># kill掉一个已经在运行的容器</span></span><br><span class="line">sudo docker container <span class="built_in">kill</span> 容器名</span><br></pre></td></tr></table></figure>
<h5 id="11、删除容器">11、删除容器</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker container rm 容器名或容器id</span><br></pre></td></tr></table></figure>
<h2 id="四、入门（创建自己的docker）">四、入门（创建自己的docker）</h2>
<h5 id="1、建立一个C文件，如下：">1、建立一个C文件，如下：</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line">void <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Hello World, this is my first docker image!\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2、编译">2、编译</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc demo.c -o demo -static</span><br></pre></td></tr></table></figure>
<p>生成可执行文件demo <strong>一定要静态编译，否则会找不到对应的库，报错</strong></p>
<h5 id="3、编辑一个Dockerfile">3、编辑一个Dockerfile</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM scratch</span><br><span class="line"></span><br><span class="line">ADD demo /</span><br><span class="line"></span><br><span class="line">CMD [<span class="string">"/demo"</span>]</span><br></pre></td></tr></table></figure>
<p>然后把demo和Dockerfile都放在一个目录下</p>
<h5 id="4、进行docker的生成">4、进行docker的生成</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker build -t hello:0.1 .</span><br></pre></td></tr></table></figure>
<p>hello:0.1是名称和Tag，后面的　.　表示当前目录</p>
<h5 id="5、运行">5、运行</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run hello:0.1</span><br></pre></td></tr></table></figure>
<h2 id="五、举例（基于ubuntu创建python3-8镜像）">五、举例（基于ubuntu创建python3.8镜像）</h2>
<h5 id="1、下载ubuntu16-04基础镜像">1、下载ubuntu16.04基础镜像</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull ubuntu:16.04</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20201114131659809.png#pic_center" alt="在这里插入图片描述"></p>
<h5 id="2、运行容器">2、运行容器</h5>
<p>这里i是指进入交互环境，t指进入终端 ， v指的是容器内路径映射到宿主机的某一路径 ，此时PWD我的当前目录已经挂载到容器的/home/root123目录下了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it -v <span class="variable">$PWD</span>:/home/root123 ubuntu:16.04 /bin/bash</span><br></pre></td></tr></table></figure>
<h5 id="3、安装基本组件">3、安装基本组件</h5>
<p>在这里有可能自带的apt源还是国外的，而且没有vi/vim可编辑软件，所以这里用了echo直接更新源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mv /etc/apt/sources.list /etc/apt/sources.list.bak</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"deb http://mirrors.163.com/debian/ jessie main non-free contrib"</span> &gt;&gt; /etc/apt/sources.list</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"deb http://mirrors.163.com/debian/ jessie-proposed-updates main non-free contrib"</span> &gt;&gt;/etc/apt/sources.list</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"deb-src http://mirrors.163.com/debian/ jessie main non-free contrib"</span> &gt;&gt;/etc/apt/sources.list</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"deb-src http://mirrors.163.com/debian/ jessie-proposed-updates main non-free contrib"</span> &gt;&gt;/etc/apt/sources.list</span><br></pre></td></tr></table></figure>
<p>在这里可能存在源的问题(我在这里卡了好久，哭)，可以进入/etc/apt/sources.list进行源的更换</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#阿里云</span></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiverse</span><br></pre></td></tr></table></figure>
<p>之后依次执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt update</span><br><span class="line"></span><br><span class="line">apt install vim	<span class="comment">#安装vim</span></span><br><span class="line"></span><br><span class="line">apt install gcc</span><br></pre></td></tr></table></figure>
<p>安装python要的基础包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install zlib1g-dev libbz2-dev libssl-dev libncurses5-dev libsqlite3-dev libreadline-dev tk-dev libgdbm-dev libdb-dev libpcap-dev xz-utils libexpat1-dev</span><br><span class="line"></span><br><span class="line">apt-get install liblzma-dev libffi-dev libc6-dev</span><br></pre></td></tr></table></figure>
<p>解压python源码包，可以去官网上下载，这里进行编译安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -zxvf Python-3.8.1.tgz</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./configure -–with-ssl --prefix=/usr/<span class="built_in">local</span>/python3 --<span class="built_in">enable</span>-optimizations</span><br><span class="line"></span><br><span class="line">make</span><br><span class="line"></span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>进行链接，相当于windows的快捷方式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ln -s /usr/<span class="built_in">local</span>/python3/bin/python3.8 /usr/bin/python3</span><br><span class="line"></span><br><span class="line">ln -s /usr/<span class="built_in">local</span>/python3/bin/pip3.8 /usr/bin/pip3</span><br></pre></td></tr></table></figure>
<h5 id="4、定制我们的容器镜像">4、定制我们的容器镜像</h5>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">docker container ls -a   <span class="comment">#查看所有容器</span></span><br></pre></td></tr></table></figure>
<p>docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</p>
<p>OPTIONS说明：</p>
<p>-a :提交的镜像作者；</p>
<p>-c :使用Dockerfile指令来创建镜像；</p>
<p>-m :提交时的说明文字；</p>
<p>-p :在commit时，将容器暂停。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">docker commit -m <span class="string">"add vim&amp;source"</span> -a <span class="string">"author"</span> <span class="number">1</span>db56d541f2c python:<span class="number">1.0</span></span><br><span class="line"><span class="comment">#完成后输入一下即可看见新的镜像</span></span><br><span class="line">docker images</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20201114131730155.png#pic_center" alt="在这里插入图片描述"></p>
<h5 id="5、保存image和container容器">5、保存image和container容器</h5>
<p>image保存为文件</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">docker save -o python.tar python:<span class="number">1.0</span></span><br></pre></td></tr></table></figure>
<p>image装载</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">docker load -input python.tar</span><br></pre></td></tr></table></figure>
<p>容器导出：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">docker export -o python-export.tar c70bf6d6ca45 <span class="comment">#这是容器的id</span></span><br></pre></td></tr></table></figure>
<p>容器导入：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">docker import python-export.tar python:v1.<span class="number">0</span></span><br></pre></td></tr></table></figure>
<h6 id="注意：save和load是一对，export和import是一对">注意：save和load是一对，export和import是一对</h6>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>使用idea搭建springboot initializer服务器</title>
    <url>/posts/55d4cd20.html</url>
    <content><![CDATA[<h3 id="问题描述">问题描述</h3>
<p>最近我在搭建springboot项目时，连接公司网线时发现idea一直新建不了项目，浏览器访问<a href="https://start.spring.io/" target="_blank" rel="noopener">https://start.spring.io</a>也访问不了，但是自己手机热点是可以正常访问的，猜想是被拦截了，所以为了方便，参考网上教程，我打算在自己的服务器上搭建服务，在这里我的服务器是Centos7.6</p>
<a id="more"></a>
<h3 id="搭建过程">搭建过程</h3>
<p>首先下载项目，终端执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;spring-io&#x2F;initializr.git</span><br></pre></td></tr></table></figure>
<p>如果没有git ，那么需要先进行安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum install git</span><br></pre></td></tr></table></figure>
<p>另外项目依赖maven，所以要首先确保计算机上安装有maven环境。如果没有maven，则执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;apache&#x2F;maven&#x2F;maven-3&#x2F;3.5.4&#x2F;binaries&#x2F;apache-maven-3.5.4-bin.tar.gz</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxvf apache-maven-3.5.4-bin.tar.gz</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo update-alternatives --install &#x2F;usr&#x2F;bin&#x2F;mvn mvn &#x2F;root&#x2F;apache-maven-3.5.4&#x2F;bin&#x2F;mvn 1000</span><br></pre></td></tr></table></figure>
<p>然后进入下载的文件夹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd initializr</span><br></pre></td></tr></table></figure>
<p>执行构建命令，这一块可能会很慢，反正我花了好久</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;mvnw clean install</span><br></pre></td></tr></table></figure>
<p>之后进入initializr-service文件夹，并执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd initializr-service</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">..&#x2F;mvnw package</span><br></pre></td></tr></table></figure>
<p>构建成功后会在initializr-service文件夹中生成一个target文件夹，进入target文件夹，在这里我指定了端口号为8082，当然自己可以根据需要修改。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd target</span><br><span class="line">nohup java -jar initializr-service.jar --server.port&#x3D;8082</span><br></pre></td></tr></table></figure>
<hr>
<p>最后在进行springboot初始化时选择custom，然后把你的<code>http://ip:port</code>输入就可。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>IDETools</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot集群体系架构入门</title>
    <url>/posts/895833a0.html</url>
    <content><![CDATA[<p><a href="https://zaomianbao.com/blog/2018/08/22/10" target="_blank" rel="noopener">springboot体系结构</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟机安装多个centos7进行集群</title>
    <url>/posts/a9664e3.html</url>
    <content><![CDATA[<h4 id="1-虚拟机镜像的选择">1 虚拟机镜像的选择</h4>
<p>做项目时需要考虑高并发场景，最先想到的就是搭建一个集群进行负载均衡，本来想直接在服务器上进行试验，后来发现要多台服务器而且集群貌似需要在内网段进行，所以选择了虚拟机进行集群。因为电脑内存有限，所以选择了centos7最小镜像进行搭建，minimal版本的ios镜像，这是我选择的镜像下载地址<a href="http://mirrors.aliyun.com/centos/7/isos/x86_64/" target="_blank" rel="noopener">Centos7下载</a></p>
<p>我这里使用了virtualBox作为我的虚拟机软件，因为它相比VM消耗的资源更少，安装过程就不详细展述了，这里要注意的是网络的选择，需要选择两个网卡：</p>
<p>NAT—用来连接外网，下载软件(该镜像是没有任何东西的)</p>
<p>Host-Only—用来和主机进行通信</p>
<a id="more"></a>
<h4 id="2-虚拟机的配置">2 虚拟机的配置</h4>
<p>centos minimal系统安装好后默认是不启动网络的，无法访问外网，并且centos7 默认不支持ipconfig命令，通过 “ip addr”进行网盘信息查询，可以看到两个网卡分别变成了enp0s3和enp0s8。</p>
<p>在这里注意一下，登录的用户名是root。</p>
<ul>
<li>
<p>开启网络访问</p>
<p>配置方式为将/etc/sysconfig/network-scripts/ifcfg-enp0s3文件以及ifcfg-enp0s8的ONBOOT=no 改为 ONBOOT=yes。</p>
<p>输入以下命令之后就可以上网了，而且可以直接用SSH连接(先查看本地地址，然后使用finalshell进行连接)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service network restart</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>安装ifconfig功能：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install net-tools</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>安装其余常用工具</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install gcc gcc-c++ vim make gdb wget</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>重命名enp0s3为eth0</p>
<p>对/etc/default/grub文件进行编辑，并在GRUB_CMDLINE_LINUX的最后，加上 net.ifnames=0 biosdevname=0 的参数,然后依次执行如下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grub2-mkconfig -o /boot/grub2/grub.cfg</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mv /etc/sysconfig/network-scripts/ifcfg-enp0s3 /etc/sysconfig/network-scripts/ifcfg-eth0</span><br></pre></td></tr></table></figure>
<p>最后reboot进行重启</p>
</li>
</ul>
<h4 id="3-设置tomcat开机自启">3 设置tomcat开机自启</h4>
<p>怎么安装tomcat以及jdk在这里就不展述了，网上有很多教程，在这里我罗列一种开机自启tomcat的方法，我的</p>
<p>tomcat目录为<code>/root/down/apache-tomcat-8.5.45</code></p>
<p>JDK目录为<code>/root/down/jdk1.8.0_221/</code></p>
<p>1、为Tomcat添加启动参数</p>
<p>catalina.sh在执行的时候会调用同级路径下的setenv.sh来设置额外的环境变量，因此在<code>/root/down/apache-tomcat-8.5.45/bin</code>路径下创建setenv.sh文件，内容如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#JAVA_HOME </span></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/root/down/jdk1.8.0_221/</span><br><span class="line"><span class="built_in">export</span> JRE_HOME=<span class="variable">$JAVA_HOME</span>/jre</span><br><span class="line"><span class="built_in">export</span> CLASSPATH=<span class="variable">$JAVA_HOME</span>/lib:<span class="variable">$JRE_HOME</span>/lib:<span class="variable">$CLASSPATH</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$JRE_HOME</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> CATALINA_HOME=/root/down/apache-tomcat-8.5.45</span><br><span class="line"><span class="built_in">export</span> CATALINA_BASE=/root/down/apache-tomcat-8.5.45</span><br><span class="line"><span class="comment"># 设置Tomcat的PID文件</span></span><br><span class="line">CATALINA_PID=<span class="string">"<span class="variable">$CATALINA_BASE</span>/tomcat.pid"</span></span><br><span class="line"><span class="comment"># 添加JVM选项</span></span><br><span class="line">JAVA_OPTS=<span class="string">"-server -XX:PermSize=256M -XX:MaxPermSize=1024m -Xms512M -Xmx1024M -XX:MaxNewSize=256m"</span></span><br></pre></td></tr></table></figure>
<p>2、在/usr/lib/systemd/system路径下添加tomcat.service文件，内容如下：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=tomcat</span><br><span class="line">After=syslog.target network.target remote-fs.target nss-lookup.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">PIDFile=<span class="regexp">/root/down</span><span class="regexp">/apache-tomcat-8.5.45/tomcat</span>.pid</span><br><span class="line">ExecStart=<span class="regexp">/root/down</span><span class="regexp">/apache-tomcat-8.5.45/bin</span><span class="regexp">/startup.sh</span></span><br><span class="line"><span class="regexp">ExecReload=/bin</span><span class="regexp">/kill -s HUP $MAINPID</span></span><br><span class="line"><span class="regexp">ExecStop=/bin</span><span class="regexp">/kill -s QUIT $MAINPID</span></span><br><span class="line"><span class="regexp">PrivateTmp=true</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">[Install]</span></span><br><span class="line"><span class="regexp">WantedBy=multi-user.target</span></span><br></pre></td></tr></table></figure>
<p>3、把tomcat加入开机自启动<br>
<code>systemctl enable tomcat.service</code></p>
<p>4、重启服务器<br>
<code>reboot</code></p>
<p>5、再次连接后，查看服务状态<br>
<code>systemctl status tomcat.service</code></p>
<p>在这里有个坑，就是浏览器访问时会一直转圈，我估计是机器性能的缘故</p>
<p>安装上文的参考文章进行多个虚拟机的搭建，然后配置好jdk和tomcat，在这里要注意的是防火墙的使用，虚拟机的话可以直接关闭防火墙</p>
<hr>
<p>1、firewalld的基本使用<br>
启动： systemctl start firewalld</p>
<p>查看状态： systemctl status firewalld / firewall-cmd --state 这个命令也可以，只是信息会简单点</p>
<p>停止： systemctl disable firewalld</p>
<p>禁用： systemctl stop firewalld</p>
<p>怎么开启一个端口</p>
<p>添加</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=8080/tcp --permanent  （--permanent永久生效，没有此参数重启后失效）</span><br></pre></td></tr></table></figure>
<p>添加端口外部访问权限（这样外部才能访问）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --add-port=8080/tcp</span><br></pre></td></tr></table></figure>
<p>重新载入，添加端口后重新载入才能起作用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>
<p>这些之后，端口是开启成功的，如果没有成功，重启系统试试。</p>
<p>查看端口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --query-port=80/tcp</span><br></pre></td></tr></table></figure>
<p>删除端口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --remove-port=80/tcp --permanent</span><br></pre></td></tr></table></figure>
<p>查看firewall是否运行,下面两个命令都可以</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl status firewalld</span><br><span class="line"></span><br><span class="line">firewall-cmd --state</span><br></pre></td></tr></table></figure>
<p>查看当前开了哪些端口</p>
<p>其实一个服务对应一个端口，每个服务对应/usr/lib/firewalld/services下面一个xml文件。</p>
<p>查看开启了哪些服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --list-services</span><br></pre></td></tr></table></figure>
<p>查看开启了哪些端口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --list-ports</span><br></pre></td></tr></table></figure>
<p>查看还有哪些服务可以打开</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --get-services</span><br></pre></td></tr></table></figure>
<p>查看所有打开的端口：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --list-ports</span><br></pre></td></tr></table></figure>
<p>更新防火墙规则：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>
<h3 id="参考文章"><a href="https://blog.csdn.net/su83362368/article/details/78502545" target="_blank" rel="noopener">参考文章</a></h3>
]]></content>
      <categories>
        <category>虚拟化与云计算</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx入门学习</title>
    <url>/posts/45652.html</url>
    <content><![CDATA[<h1>一、Nginx介绍与安装</h1>
<h2 id="1、Nginx简介">1、Nginx简介</h2>
<p><em>Nginx</em>  (engine x) 是一个高性能的<a href="https://baike.baidu.com/item/HTTP" target="_blank" rel="noopener">HTTP</a>和<a href="https://baike.baidu.com/item/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/7793488" target="_blank" rel="noopener">反向代理</a>的轻量级web服务器，同时也提供了IMAP/POP3/SMTP服务。由于它的内存占用少，启动极快，高并发能力强，在互联网项目中广泛应用。<a href="https://news.netcraft.com/archives/2021/10/15/october-2021-web-server-survey.html" target="_blank" rel="noopener">其他web服务器对比</a></p>
<p>Nginx有以下一些特点</p>
<ul>
<li>
<p>反向代理</p>
</li>
<li>
<p>集群与负载均衡</p>
</li>
<li>
<p>动静分离(静态资源虚拟化)</p>
</li>
<li>
<p>限流</p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/be71b1828c26124572f06507e06eaca3.png" alt></p>
<p>上图基本上说明了当下流行的技术架构。</p>
<a id="more"></a>
<h2 id="2、常见特点简介">2、常见特点简介</h2>
<h3 id="2-1-反向代理">2.1 反向代理</h3>
<p>再讲反向代理之前首先要知道什么叫正向代理，正向代理相当于当你要访问一个资源时，你需要一个代理服务器进行资源访问</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/705d19bf88d1140c8a2d31c0a2c8c794.png" alt></p>
<p>反向代理，客户端对代理是无感知的，因为客户端不需要任何配置就可以访问，我们只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，在返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器的地址，隐藏了真实服务器的ip</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/2878e1c5402fac597d742944e5c71158.png" alt></p>
<h3 id="2-2-负载均衡">2.2 负载均衡</h3>
<p>简单来说，我们增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，也就是我们所说的负载均衡</p>
<h3 id="2-3-动静分离">2.3 动静分离</h3>
<p>动静分离就是讲动态资源和静态资源相互分离，把动态页面和静态页面由不同的服务器来解析，加快解析速度。降低原来单个服务器的压力。</p>
<h2 id="3、Nginx的安装">3、Nginx的安装</h2>
<h3 id="3-1-软件安装">3.1 软件安装</h3>
<p>PCRE库支持正则表达式。如果我们在配置文件nginx.conf中使用了正则表达式，那么在编译Nginx时就必须把PCRE库编译进Nginx，因为Nginx的HTTP模块需要靠它来解析正则表达式。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#检测是否安装，若没有安装，则需要安装</span></span><br><span class="line"><span class="comment">#在这里有些系统会自带，所以不安装也没事</span></span><br><span class="line">rpm -qa pcre</span><br><span class="line"><span class="comment">#根据情况自行调整版本</span></span><br><span class="line">wget https://nchc.dl.sourceforge.net/project/pcre/pcre/8.45/pcre-8.45.tar.bz2</span><br><span class="line"><span class="comment">#解压</span></span><br><span class="line">tar -jxvf pcre-8.45.tar.bz2</span><br><span class="line"><span class="built_in">cd</span> pcre-8.45</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>安装nginx，首先需要安装相应的依赖，这里我用的是Centos操作做系统，从<a href="http://nginx.org/" target="_blank" rel="noopener">Nginx下载地址</a>下载最新nginx</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#首先安装前置依赖</span></span><br><span class="line">yum -y install make zlib zlib-devel gcc-c++ libtool  openssl openssl-devel</span><br><span class="line"><span class="comment">#下载最新稳定版</span></span><br><span class="line">wget http://nginx.org/download/nginx-1.20.1.tar.gz</span><br><span class="line"><span class="comment">#解压</span></span><br><span class="line">tar -zxvf nginx-1.20.1.tar.gz</span><br><span class="line">mkdir -p /var/temp/nginx</span><br><span class="line"><span class="built_in">cd</span> nginx-1.20.1</span><br><span class="line"><span class="comment">#默认配置</span></span><br><span class="line">./configure</span><br><span class="line">make </span><br><span class="line">make install</span><br><span class="line"><span class="comment">#进入sbin目录，启动</span></span><br><span class="line">./nginx</span><br><span class="line"><span class="comment">#停止：</span></span><br><span class="line">./nginx -s stop</span><br><span class="line"><span class="comment">#重新加载：</span></span><br><span class="line">./nginx -s reload </span><br><span class="line"><span class="comment">#查看配置信息</span></span><br><span class="line">nginx -V</span><br><span class="line"><span class="comment">#测试配置文件是否正确</span></span><br><span class="line">nginx -t</span><br><span class="line"><span class="comment">#帮助命令</span></span><br><span class="line">nginx -h</span><br></pre></td></tr></table></figure>
<p>nginx常见配置解释如下</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>–prefix</td>
<td>指定nginx安装目录</td>
</tr>
<tr>
<td>–pid-path</td>
<td>指向nginx的pid</td>
</tr>
<tr>
<td>–lock-path</td>
<td>锁定安装文件，防止被恶意篡改或误篡改</td>
</tr>
<tr>
<td>–error-log</td>
<td>错误日志</td>
</tr>
<tr>
<td>–http-log-path</td>
<td>http日志</td>
</tr>
<tr>
<td>–with-http_gzip_static_module</td>
<td>启用gzip模块，在线实时压缩输出数据流</td>
</tr>
<tr>
<td>–http-client-body-temp-path</td>
<td>设定客户端请求的临时目录</td>
</tr>
<tr>
<td>–http-proxy-temp-path</td>
<td>设定http代理临时目录</td>
</tr>
<tr>
<td>–http-fastcgi-temp-path</td>
<td>设定fastcgi临时目录</td>
</tr>
<tr>
<td>–http-uwsgi-temp-path</td>
<td>设定uwsgi临时目录</td>
</tr>
<tr>
<td>–http-scgi-temp-path</td>
<td>设定scgi临时目录</td>
</tr>
</tbody>
</table>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#自定义配置，可以自行修改</span></span><br><span class="line">./configure \</span><br><span class="line">--prefix=/usr/<span class="built_in">local</span>/nginx \</span><br><span class="line">--pid-path=/var/run/nginx.pid \</span><br><span class="line">--lock-path=/var/lock/nginx.lock \</span><br><span class="line">--error-log-path=/var/<span class="built_in">log</span>/nginx/error.log \</span><br><span class="line">--http-log-path=/var/<span class="built_in">log</span>/nginx/access.log \</span><br><span class="line">--with-http_gzip_static_module \</span><br><span class="line">--http-client-body-temp-path=/var/temp/nginx/client \</span><br><span class="line">--http-proxy-temp-path=/var/temp/nginx/proxy \</span><br><span class="line">--http-fastcgi-temp-path=/var/temp/nginx/fastgi \</span><br><span class="line">--http-uwsgi-temp-path=/var/temp/nginx/uwsgi \</span><br><span class="line">--http-scgi-temp-path=/var/temp/nginx/scgi \</span><br><span class="line">--with-http_stub_status_module \</span><br><span class="line">--with-http_ssl_module \</span><br><span class="line">--with-http_stub_status_module</span><br></pre></td></tr></table></figure>
<h3 id="3-2-环境与端口配置">3.2 环境与端口配置</h3>
<p>注意端口的开放，配置成功即可访问</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看开放的端口号 </span></span><br><span class="line">firewall-cmd --list-all</span><br><span class="line">lsof -i:80</span><br><span class="line"><span class="comment">#设置开放的端口号 </span></span><br><span class="line">firewall-cmd --add-service=http --permanent </span><br><span class="line">sudo firewall-cmd --add-port=80/tcp --permanent </span><br><span class="line"><span class="comment">#重启防火墙 </span></span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>
<p>为了更方便启动，需要配置环境变量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/profile</span><br><span class="line"><span class="comment">#在尾部添加</span></span><br><span class="line"><span class="built_in">export</span> NGINX_HOME=/usr/<span class="built_in">local</span>/nginx</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$NGINX_HOME</span>/sbin:<span class="variable">$PATH</span></span><br><span class="line"><span class="comment">#重启</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure>
<p><em>当然Nginx安装如果不想这么麻烦，可以直接在宝塔面板进行快速安装(傻瓜式安装，不过我装了有点问题，折腾了好久还是选择了安装包安装)</em></p>
<h1>二、Nginx原理</h1>
<h2 id="1、nginx工作原理图">1、nginx工作原理图</h2>
<p><img src="https://img-blog.csdnimg.cn/img_convert/ba2ddfdd9a0cfb3303aa0efbc7aa3845.png" alt="lfxJk6.jpg"></p>
<p>Nginx只有一个主线程，可以有多个worker线程，<code>ps -ef |grep nginx</code>可以查看活着的线程。而多个worker可以进行热部署，而且提高了服务的可靠性，另外worker数一般和cpu核心数相等，这样能最大限度发挥性能。对于连接数worker_connection，访问静态资源占用2个(请求和返回)，动态资源占用4个(另外再加上tomcat的请求)。nginx在linux默认采用epoll的io线程处理模型，采用的是==异步非阻塞==的机制来完成线程的处理，所以上面的tomcat1如果发生了阻塞，并不会影响tomcat2的执行。</p>
<ul>
<li>
<p>nginx的worker工作采用的抢占式的机制</p>
</li>
<li>
<p>nginx采用的是epoll的异步非阻塞的io模型，也就是多路复用的io线程模型。</p>
</li>
</ul>
<h2 id="2、nginx默认配置">2、nginx默认配置</h2>
<p>访问<code>http:ip</code>，Nginx–&gt;监听80端口–&gt;找到对应server----&gt;映射路由/----&gt; html中的index.html</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/7ebcb3b9371e10e9a9e12f2b22004ba8.png#pic_center" alt="5wWRnx.png"></p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置worker进程的用户，指的linux中的用户，会涉及到nginx操作目录或文件的一些权限，默认为 nobody。</span></span><br><span class="line"><span class="comment"># 默认情况是：nobody，你注释的情况下也是nobody。当然你也可以修改成 user root，修改以后记得重启翻方可生效，然后通过ps -ef | grep nginx 可以查看效果。</span></span><br><span class="line"><span class="comment">#user  nobody;</span></span><br><span class="line"><span class="comment">#worker进程工作数设置，一般来说CPU有几个，就设置几个，或者设置为N-1也行</span></span><br><span class="line"><span class="attribute">worker_processes</span>  <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#  nginx 日志级别 debug | info | notice | warn | error | crit | alert | emerg,错误级别从左到右越来越大</span></span><br><span class="line"><span class="comment"># 默认是：error级别，存储的路在 /var/log/nginx/error.log</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  notice;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  info;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置nginx进程 pid</span></span><br><span class="line"><span class="comment">#pid        logs/nginx.pid;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置系统的线程模型和工作线程的线程数量</span></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="comment"># linux系统默认使用epoll</span></span><br><span class="line">    <span class="comment"># use epoll;</span></span><br><span class="line">    <span class="comment"># 每个工作进程的最大允许连接的客户端最大连接数</span></span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># http 是指令块，针对http网络传输的一些指令配置</span></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="comment"># 包含和导入外部的文件，进行模块化的划分。#在conf目录下的文件夹，mime.types会根据不同资源告诉浏览器用相应的工具打开。也可以将server模块放到其他模块</span></span><br><span class="line">    <span class="attribute">include</span>       mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 配置日志格式</span></span><br><span class="line">    <span class="comment">#log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '</span></span><br><span class="line">    <span class="comment">#                  '$status $body_bytes_sent "$http_referer" '</span></span><br><span class="line">    <span class="comment">#                  '"$http_user_agent" "$http_x_forwarded_for"';</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 给于access_log的格式是main格式，然后把每次请求的信息写入到logs/access.log中。</span></span><br><span class="line">    <span class="comment">#access_log  logs/access.log  main;</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 启用文件的高效传输，打开有利于文件传输的性能</span></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="comment">#tcp_nopush它必须和sendfile使用，并且sendfile打开了才生效，它的含义是：当请求的数据包累积了到一定的大小的时候，在进行发送。</span></span><br><span class="line">    <span class="comment">#tcp_nopush     on;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 客户端连接服务器的超时时间，默认是65秒，0代表不保持连接。</span></span><br><span class="line">    <span class="comment">#keepalive_timeout  0;</span></span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 开启gzip,利于文件和请求数据的传输。</span></span><br><span class="line">    <span class="attribute">gzip</span>  <span class="literal">on</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 服务虚拟主机配置</span></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="comment"># 监听端口</span></span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">        <span class="comment"># 监听服务器ip，域名，或者localhost</span></span><br><span class="line">        <span class="attribute">server_name</span>  localhost;</span><br><span class="line">        <span class="comment">#access_log  logs/host.access.log  main;</span></span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">root</span>   html;</span><br><span class="line">            <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">        <span class="attribute">location</span> = /50x.html &#123;</span><br><span class="line">            <span class="attribute">root</span>   html;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 服务虚拟主机配置</span></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="comment"># 监听端口</span></span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">8087</span>;</span><br><span class="line">        <span class="comment"># 监听服务器ip，域名，或者localhost</span></span><br><span class="line">        <span class="attribute">server_name</span>  localhost;</span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">root</span>   html;</span><br><span class="line">            <span class="attribute">index</span>  newindex.html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3、常见错误与进程退出">3、常见错误与进程退出</h2>
<p><strong>问题</strong></p>
<p>在启动的过程中，如果出现了&quot;/var/run/nginx.pid failed &quot;错误信息的时候，一般是文件目录不存在，或者文件被误删</p>
<p><strong>解决方案</strong></p>
<ul>
<li>重新创建此目录即可</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p /var/run/nginx/</span><br></pre></td></tr></table></figure>
<ul>
<li>如果重启过程中报错如下异常，则指定nginx.conf文件进行启动和重启</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nginx -c /usr/<span class="built_in">local</span>/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure>
<ul>
<li>然后在重启启动nginx服务</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>
<p><strong>Nginx退出方式</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 强制关闭</span></span><br><span class="line">nginx -s stop</span><br><span class="line"><span class="comment"># 如果用户请求还正在与nginx 服务正在打交道，这个时候是不会退出nginx服务。直到用户的连接响应完毕才关闭</span></span><br><span class="line">nginx -s quit</span><br></pre></td></tr></table></figure>
<h1>三、Nginx常见功能</h1>
<h2 id="1、Location语法">1、Location语法</h2>
<p>location指令语法如下：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">location</span> [ = | <span class="regexp">~ |~*</span> |^~] uri&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><strong>=</strong>  ：用于不含正则表达式的 uri 前，要求请求字符串与 uri 严格匹配，如果匹配成功，就停止继续向下搜索并立即处理该请求。</p>
</li>
<li>
<p><strong>~</strong> ：用于表示 uri 包含正则表达式，并且区分大小写。</p>
</li>
<li>
<p><strong>~</strong> *：用于表示 uri 包含正则表达式，并且不区分大小写。</p>
</li>
<li>
<p><strong>^~</strong> ：用于不含正则表达式的 uri 前，要求 Nginx 服务器找到标识 uri 和请求字符串匹配度最高的 location 后，立即使用此 location 处理请求，而不再使用 location 块中的正则 uri 和请求字符串做匹配。</p>
</li>
</ul>
<p>注意：如果 uri 包含正则表达式，则必须要有 ~ 或者 ~* 标识。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 服务虚拟主机配置</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">   <span class="comment"># 监听端口</span></span><br><span class="line">   <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">   <span class="comment"># 监听服务器ip，域名，或者localhost</span></span><br><span class="line">   <span class="attribute">server_name</span>  localhost;</span><br><span class="line">   <span class="comment">#access_log  logs/host.access.log  main;</span></span><br><span class="line">   <span class="comment"># 精准匹配</span></span><br><span class="line">   <span class="attribute">location</span> / &#123;</span><br><span class="line">       <span class="attribute">root</span>   html;</span><br><span class="line">       <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment"># 精准匹配</span></span><br><span class="line">   <span class="attribute">location</span> = /asserts/css/login.css &#123;</span><br><span class="line">       <span class="attribute">root</span>   /resources;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment"># 正则表达式匹配 *代表的是不区分大小写</span></span><br><span class="line">   <span class="attribute">location</span> <span class="regexp">~* \.(GIF|png|bmp|jpg|jpeg)</span> &#123;</span><br><span class="line">       <span class="attribute">root</span>   /www/shawn/resources;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="comment"># ^~ 以某种字符路径开头请求</span></span><br><span class="line">   <span class="attribute">location</span><span class="regexp"> ^~</span> /asserts/img &#123;</span><br><span class="line">       <span class="attribute">root</span>   /resources;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">   <span class="attribute">location</span> = /50x.html &#123;</span><br><span class="line">       <span class="attribute">root</span>   html;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2、反向代理">2、反向代理</h2>
<p>首先准备两台tomcat服务器，修改端口号(有三处需要修改，文件位置在conf/server.xml)，一个修改成8081，另一个8082，然后分别在Webapp中创建文件夹edu和udp并在目录下创建a.html，里面随便可以写任何东西。然后修改nginx的配置文件(文件位置在/usr/local/nginx/conf/nginx.conf) server部分如下，浏览器输入</p>
<p><code>服务器ip/udp/a.html</code> 后就会自动访问，并不需要输入端口号。</p>
<p>若一个Nginx服务器需要代理多个应用，则需要创建多个server。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">location</span> <span class="regexp">~ /edu/</span> &#123;</span><br><span class="line"><span class="attribute">proxy_pass</span>   http://127.0.0.1:8081;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span> <span class="regexp">~ /udp/</span> &#123;</span><br><span class="line"><span class="attribute">proxy_pass</span>   http://127.0.0.1:8082;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3、负载均衡">3、负载均衡</h2>
<h3 id="3-1-简介">3.1 简介</h3>
<p>分配策略有以下几点</p>
<ul>
<li>
<p><strong>轮询（默认）</strong> <br>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。</p>
</li>
<li>
<p><strong>weight</strong> <br>weight代表权，默认为 1, 权重越高被分配的客户端多。weight指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。可以与least_conn和ip_hash结合使用</p>
</li>
<li>
<p><strong>ip_hash</strong> <br>每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。ip_hash不能与backup同时使用；当有服务器需要剔除，必须手动down掉。</p>
</li>
<li>
<p><strong>least_conn</strong> <br>把请求转发给连接数较少的后端服务器，适合请求处理时间长短不一造成服务器过载的情况。</p>
</li>
<li>
<p><strong>fair（第三方）</strong> <br>按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p>
</li>
<li>
<p><strong>url_hash（第三方）</strong> <br>按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，要配合缓存命中来使用。</p>
</li>
</ul>
<h3 id="3-2-upstream">3.2 upstream</h3>
<blockquote>
<p>官网参考：<a href="http://nginx.org/en/docs/stream/ngx_stream_upstream_module.html" target="_blank" rel="noopener">http://nginx.org/en/docs/stream/ngx_stream_upstream_module.html</a></p>
</blockquote>
<ul>
<li><strong>max_conns</strong> <br>可以限制一台服务器的最大访问连接数。默认值是：0，代表不限制。可以用来限流</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">upstream</span> tomcatservers &#123;</span><br><span class="line">  <span class="attribute">server</span> <span class="number">127.0.0.1:8080</span>  max_conns=<span class="number">2</span>;</span><br><span class="line">  <span class="comment">#让一个服务器慢慢的加入到集群中，hash和random以及一台server失效(商业版使用)</span></span><br><span class="line">  <span class="comment">#server 127.0.0.1:8081  weight=10 slow_start=60s;</span></span><br><span class="line">  <span class="attribute">server</span> <span class="number">127.0.0.1:8082</span>  weight=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>down</strong> <br>如果用down进行服务器标记就告诉当前服务器不可用的状态，这样就可以停用8080服务</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">upstream</span> tomcatservers &#123;</span><br><span class="line">  <span class="attribute">server</span> <span class="number">127.0.0.1:8080</span>  weight=<span class="number">10</span> down;</span><br><span class="line">  <span class="attribute">server</span> <span class="number">127.0.0.1:8081</span>  weight=<span class="number">2</span>;</span><br><span class="line">  <span class="attribute">server</span> <span class="number">127.0.0.1:8082</span>  weight=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>backup</strong> <br>backup 表示当前服务器节点是备用机，只有在其他的服务器都宕机以后，自己才会加入到集群中，被用户访问到；可以用于灰度部署时候的一种更替效果。</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">upstream</span> tomcatservers &#123;</span><br><span class="line">  <span class="attribute">server</span> <span class="number">127.0.0.1:8080</span>  weight=<span class="number">10</span> backup;</span><br><span class="line">  <span class="attribute">server</span> <span class="number">127.0.0.1:8081</span>  weight=<span class="number">2</span>;</span><br><span class="line">  <span class="attribute">server</span> <span class="number">127.0.0.1:8082</span>  weight=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>max_fails 和 fail_timeout</strong> <br>max_fails 表示失败几次，则标记server已宕机，剔出上游服务；fail_timeout 表示失败的重试时间。max_fails默认值1，fail_timeout的默认值是10</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">upstream</span> tomcatservers &#123;</span><br><span class="line">  <span class="comment">#1秒内最大错误次数到达2次时则剔除该服务，下一秒不会访问，1秒后会再有新请求尝试连接挂掉的server，如果还是失败，重复上一过程，直到恢复。</span></span><br><span class="line">  <span class="attribute">server</span> <span class="number">127.0.0.1:8080</span>  max_fails=<span class="number">2</span> fail_timeout=<span class="number">1</span>;</span><br><span class="line">  <span class="attribute">server</span> <span class="number">127.0.0.1:8081</span>  weight=<span class="number">1</span>;</span><br><span class="line">  <span class="attribute">server</span> <span class="number">127.0.0.1:8082</span>  weight=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-简单实例">3.3 简单实例</h3>
<p>负载均衡指的是当访问相同路径的资源，nginx按照设置好的分配策略，自动进行某一个tomcat的访问，比如我直接输入<code>服务器ip/edu/a.html</code>，我服务器中有两台tomcat并且同时有路径/edu/a.html，当访问时会按照固定分配策略选择一台tomcat进行服务，若其中一台挂了，另一台还可以正常工作。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line">http&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">#负载均衡</span></span><br><span class="line">   <span class="attribute">upstream</span> myserver &#123;</span><br><span class="line">   <span class="comment">#ip_hash</span></span><br><span class="line">   <span class="comment">#fair  </span></span><br><span class="line">   <span class="comment">#least_conn</span></span><br><span class="line"> <span class="attribute">server</span>  服务器ip:<span class="number">8081</span> weight=<span class="number">5</span>;</span><br><span class="line"> <span class="attribute">server</span>  服务器ip:<span class="number">8082</span> weight=<span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line">   &#125;</span><br><span class="line"> ...</span><br><span class="line">   <span class="section">server</span> &#123;</span><br><span class="line">   <span class="comment">#listen       80;        #端口</span></span><br><span class="line">       <span class="attribute">server_name</span>  _;   <span class="comment">#服务名</span></span><br><span class="line"></span><br><span class="line">       <span class="attribute">charset</span> utf-<span class="number">8</span>,gbk;</span><br><span class="line">       <span class="attribute">root</span>    /data/download;  <span class="comment">#显示的根索引目录</span></span><br><span class="line">       <span class="attribute">autoindex</span> <span class="literal">on</span>;             <span class="comment">#开启索引功能</span></span><br><span class="line">       <span class="comment">#autoindex_exact_size off; # 关闭计算文件确切大小（单位bytes），只显示大概大小（单位kb、mb、gb）</span></span><br><span class="line">       <span class="comment">#autoindex_localtime on;   # 显示本机时间而非 GMT 时间</span></span><br><span class="line">    <span class="comment">#负载均衡</span></span><br><span class="line">       <span class="attribute">location</span> / &#123;</span><br><span class="line">           <span class="attribute">proxy_pass</span>   http://myserver;</span><br><span class="line">           <span class="attribute">root</span>  html;</span><br><span class="line">           <span class="attribute">index</span>  index.html  index.html;</span><br><span class="line">       &#125;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4、动静分离">4、动静分离</h2>
<p>相当于一个静态资源服务器，通过 location 指定不同的后缀名实现不同的请求转发。通过 expires 参数设置，可以使浏览器缓存过期时间，减少与服务器之前的请求和流量。具体 Expires 定义：是给一个资源设定一个过期时间，也就是说无需去服务端验证，直接通过浏览器自身确认是否过期即可，所以不会产生额外的流量。</p>
<p>我在我的文件夹data下分别创建了www和image文件夹，里面分别存放了图片和一个html，当浏览器访问时就会自动寻找对应的静态资源（expires参数也可配置）,部分配置如下</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">  ...</span><br><span class="line">    <span class="comment">#负载均衡</span></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">proxy_pass</span>   http://myserver;</span><br><span class="line">            <span class="attribute">root</span>  html;</span><br><span class="line">            <span class="attribute">index</span>  index.html  index.html;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">#动静分离</span></span><br><span class="line">        <span class="comment">#真实地址 http:ip/contest/data/shawn1/index.html</span></span><br><span class="line">      <span class="comment">#location后路径若有/，则访问必须带/；若没有，则都可以访问</span></span><br><span class="line">    <span class="attribute">location</span> /shawn1&#123;</span><br><span class="line">            <span class="attribute">root</span>  /contest/data;</span><br><span class="line">            <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">#真实地址 http:ip/contest/data/index.html</span></span><br><span class="line">        <span class="attribute">location</span> /shawn2/&#123;</span><br><span class="line">            <span class="attribute">alias</span>   /contest/data/;</span><br><span class="line">            <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> /image/&#123;</span><br><span class="line">            <span class="attribute">root</span>  /contest/data/;</span><br><span class="line">            <span class="comment">#列出当前文件夹文件</span></span><br><span class="line">            <span class="attribute">autoindex</span> <span class="literal">on</span>;</span><br><span class="line">            <span class="attribute">expires</span> <span class="number">12h</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>alias与root的区别</strong></p>
<ul>
<li>
<p>root 实际访问文件路径会拼接URL中的路径；alias 实际访问文件路径不会拼接URL中的路径</p>
</li>
<li>
<p>在一个location中，alias可以存在多个，但是root只能有一个</p>
</li>
<li>
<p>alias只能存在与location中，但是root可以用在server、http和location中</p>
</li>
<li>
<p>alias后面必须要“/”结束，否则会找不到文件，而root的“/”可有可无</p>
</li>
</ul>
<h2 id="5、nginx其他情况">5、nginx其他情况</h2>
<p>使用Nginx做代理的时候，有时需要把请求原封不动的转发给下一个服务。比如，访<code>shawn.com/test/a/b.html</code>, 要求转发到<code>localhost:8088/test/a/b.html</code>，请求只会替换域名。</p>
<p>简单配置如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">upstream user &#123;</span><br><span class="line">  server localhost:8088 weight=5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen              80;</span><br><span class="line">    server_name         shawn.com;</span><br><span class="line">    access_log  <span class="string">"pipe:rollback /data/log/nginx/access.log interval=1d baknum=7 maxsize=1G"</span>  main;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_set_header Host <span class="variable">$host</span>;</span><br><span class="line">        proxy_set_header  X-Real-IP        <span class="variable">$remote_addr</span>;</span><br><span class="line">        proxy_set_header  X-Forwarded-For  <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        proxy_set_header X-NginX-Proxy <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        proxy_pass http://user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但很多时候，我们需要根据url的前缀转发到不同的服务。比如</p>
<p><a href="http://shawn.com/user/profile.html%E8%BD%AC%E5%8F%91%E5%88%B0" target="_blank" rel="noopener">shawn.com/user/profile.html转发到</a> <strong>用户服务</strong> localhost:8089/profile.html</p>
<p><a href="http://shawn.com/order/details.html%E8%BD%AC%E5%8F%91%E5%88%B0" target="_blank" rel="noopener">shawn.com/order/details.html转发到</a> <strong>订单服务</strong>  localhost:8090/details.html</p>
<p>即，url的前缀对下游的服务是不需要的，除非下游服务添加context-path, 但很多时候我们并不喜欢加这个。如果Nginx转发的时候，把这个前缀去掉就好了。</p>
<p><strong>一个种方案是proxy_pass后面加根路径</strong> <strong>/</strong> <strong>.</strong></p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>              <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>         shawn.com;</span><br><span class="line">    <span class="attribute">access_log</span>  <span class="string">"pipe:rollback /data/log/nginx/access.log interval=1d baknum=7 maxsize=1G"</span>  main;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span><span class="regexp"> ^~/user/</span> &#123;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span>  X-Real-IP        <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span>  X-Forwarded-For  <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-NginX-Proxy <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">proxy_pass</span> http://user/;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span><span class="regexp"> ^~/order/</span> &#123;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span>  X-Real-IP        <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span>  X-Forwarded-For  <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-NginX-Proxy <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">proxy_pass</span> http://order/;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>^~/user/</code>表示匹配前缀是<code>user</code>的请求，proxy_pass的结尾有<code>/</code>， 则会把<code>/user/*</code>后面的路径直接拼接到后面，即移除user.</p>
<p><strong>另一种方案是使用</strong> <strong>rewrite</strong></p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">upstream</span> user &#123;</span><br><span class="line">  <span class="attribute">server</span> localhost:<span class="number">8089</span> weight=<span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">upstream</span> order &#123;</span><br><span class="line">  <span class="attribute">server</span> localhost:<span class="number">8090</span> weight=<span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>              <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>         abc.com;</span><br><span class="line">    <span class="attribute">access_log</span>  <span class="string">"pipe:rollback /data/log/nginx/access.log interval=1d baknum=7 maxsize=1G"</span>  main;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span><span class="regexp"> ^~/user/</span> &#123;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span>  X-Real-IP        <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span>  X-Forwarded-For  <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-NginX-Proxy <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">rewrite</span><span class="regexp"> ^/user/(.*)$</span> /<span class="variable">$1</span> <span class="literal">break</span>;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span><span class="regexp"> ^~/order/</span> &#123;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span>  X-Real-IP        <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span>  X-Forwarded-For  <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-NginX-Proxy <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">rewrite</span><span class="regexp"> ^/order/(.*)$</span> /<span class="variable">$1</span> <span class="literal">break</span>;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://order;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到proxy_pass结尾没有<code>/</code>， <code>rewrite</code>重写了url。</p>
<p><strong>last 和 break关键字的区别</strong></p>
<blockquote>
<p>只用到了break，即匹配到此处后不会继续跳。</p>
</blockquote>
<p><strong>permanent 和 redirect关键字的区别</strong></p>
<blockquote>
<p>rewrite … permanent 永久性重定向，请求日志中的状态码为301<br>rewrite … redirect 临时重定向，请求日志中的状态码为302</p>
</blockquote>
<hr>
<p>另一种就是<strong>location</strong>和<strong>proxy_pass</strong>有无“/”的几种区别探究，具体可以参考</p>
<p><a href="https://mp.weixin.qq.com/s/im--XoNkomtdC1wJwedTlw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/im--XoNkomtdC1wJwedTlw</a></p>
<h1>四、Nginx常见配置</h1>
<blockquote>
<p>Nginx可视化配置：<a href="https://www.digitalocean.com/community/tools/nginx?global.app.lang=zhCN" target="_blank" rel="noopener">https://www.digitalocean.com/community/tools/nginx?global.app.lang=zhCN</a></p>
</blockquote>
<h2 id="1、gzip压缩配置">1、gzip压缩配置</h2>
<blockquote>
<p>gzip文档:<a href="https://www.nginx.cn/doc/standard/httpgzip.html" target="_blank" rel="noopener">https://www.nginx.cn/doc/standard/httpgzip.html</a></p>
</blockquote>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置网络传输的模块 </span></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">  ......</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 开启gzip,利于文件和请求数据的传输。</span></span><br><span class="line">    <span class="attribute">gzip</span>  <span class="literal">on</span>;</span><br><span class="line">    <span class="comment"># 启用gzip压缩的最小文件，小于设置值的文件将不会压缩</span></span><br><span class="line">    <span class="attribute">gzip_min_length</span> <span class="number">1k</span>;</span><br><span class="line">    <span class="comment">#设置压缩缓冲区大小，此处设置为4个16K内存作为压缩结果流缓存</span></span><br><span class="line">    <span class="attribute">gzip_buffers</span> <span class="number">4</span> <span class="number">16k</span>;</span><br><span class="line">    <span class="comment">#默认值是1.1，对HTTP/1.1协议的请求会进行gzip压缩。</span></span><br><span class="line">  <span class="attribute">gzip_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">    <span class="comment"># 是否在http header中添加Vary: Accept-Encoding，建议开启</span></span><br><span class="line">    <span class="attribute">gzip_vary</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="comment"># gzip 压缩级别，1-9，数字越大压缩的越好，也越占用CPU时间，后面会有详细说明</span></span><br><span class="line">    <span class="attribute">gzip_comp_level</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">#禁用IE6的gzip压缩</span></span><br><span class="line">    <span class="attribute">gzip_disable</span> <span class="string">"MSIE [1-6]\."</span>;</span><br><span class="line">    <span class="comment">#any表示全部都开启压缩</span></span><br><span class="line">  <span class="comment">#gzip_proxied expired no-cache no-store private auth;</span></span><br><span class="line">    <span class="comment"># 进行压缩的文件类型。javascript有多种形式。其中的值可以在 mime.types 文件中找到。压缩图片意义不大</span></span><br><span class="line">    <span class="attribute">gzip_types</span> text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/bmp application/x-bmp image/x-ms-bmp application/vnd.ms-fontobject font/ttf font/opentype font/x-woff application/json ;</span><br><span class="line">    </span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2、跨域配置与防盗链">2、跨域配置与防盗链</h2>
<p>跨域配置完若发现无效果，试试清除缓存；而防盗链配置后只允许当前域名可以访问，否则会报错</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 静态资源服务器</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">  ......</span><br><span class="line">  </span><br><span class="line">    <span class="comment">#允许跨域请求的域，*代表所有 </span></span><br><span class="line">    <span class="attribute">add_header</span> <span class="string">'Access-Control-Allow-Origin'</span> *; </span><br><span class="line">  <span class="comment">#允许带上cookie请求 </span></span><br><span class="line">  <span class="attribute">add_header</span> <span class="string">'Access-Control-Allow-Credentials'</span> <span class="string">'true'</span>; </span><br><span class="line">  <span class="comment">#允许请求的方法，比如 GET/POST/PUT/DELETE </span></span><br><span class="line">  <span class="attribute">add_header</span> <span class="string">'Access-Control-Allow-Methods'</span> *; </span><br><span class="line">  <span class="comment">#允许请求的header </span></span><br><span class="line">  <span class="attribute">add_header</span> <span class="string">'Access-Control-Allow-Headers'</span> *;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">#防盗链</span></span><br><span class="line">    <span class="comment">#valid_referers *.shawn22.com; </span></span><br><span class="line">    <span class="comment">#非法引入会进入下方判断 </span></span><br><span class="line">    <span class="comment">#if ($invalid_referer) &#123; </span></span><br><span class="line">  <span class="comment">#  return 402; </span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#第二种方法，在映射路径里面写特定后缀名的防盗链，none代表请求头中不存在 Referer字段('空值'，比如直接在浏览器打开一个图片URI)。blocked代表请求头中存在 Referer字段，但值不是以"http(s)://"开头的字符串(被防火墙或代理服务器修改删除)。</span></span><br><span class="line">    <span class="comment">#location ~* \.(gif|jpg|png|swf|flv)$ &#123;</span></span><br><span class="line">    <span class="comment">#    root html</span></span><br><span class="line">    <span class="comment">#    valid_referers none blocked *.nginxcn.com;</span></span><br><span class="line">    <span class="comment">#    if ($invalid_referer) &#123;</span></span><br><span class="line">    <span class="comment">#        rewrite ^/ www.nginx.cn</span></span><br><span class="line">    <span class="comment">#        #return 404;</span></span><br><span class="line">    <span class="comment">#    &#125;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3、Keepalived">3、Keepalived</h2>
<h3 id="3-1-简介-v2">3.1 简介</h3>
<blockquote>
<p>nginx底层是用tcp/ip完成的服务器的通信。Httpd守护进程，一般都提供了keep-alive timeout时间设置参数。比如nginx的keepalive_timeout，和Apache的KeepAliveTimeout。这个 keepalive_timout时间值意味着：一个http产生的tcp连接在传送完最后一个响应后，还需要hold住 keepalive_timeout秒后，才开始关闭这个连接。</p>
</blockquote>
<p>keepalived配置</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">120s</span>;</span><br><span class="line">    <span class="attribute">keepalive_requests</span> <span class="number">10000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>keepalive_timeout：设置keep-alive客户端连接在服务器端保持开启的超时值（默认65s）；值为0会禁用keep-alive客户端连接；对于一些请求比较大的内部服务器通讯的场景，适当加大为120s或者300s；</p>
</li>
<li>
<p>keepalive_requests：设置一个keep-alive连接上可以服务的请求的最大数量，当最大请求数量达到时，连接被关闭。默认是100。这个参数的真实含义，是指一个keep alive建立之后，nginx就会为这个连接设置一个计数器，记录这个keep alive的长连接上已经接收并处理的客户端请求的数量。如果达到这个参数设置的最大值时，则nginx会强行关闭这个长连接，逼迫客户端不得不重新建立新的长连接。高QPS可以提高以减少连接TIME_WAIT时间</p>
</li>
</ul>
<h3 id="3-2-保持与server的长连接">3.2 保持与server的长连接</h3>
<p>为了让nginx和后端server（nginx称为upstream）之间保持长连接，同时也可以http请求组，典型设置如下。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    upstream  BACKEND &#123;</span><br><span class="line">        server   192.168.0.1：8080  weight=1 max_fails=2 fail_timeout=30s;</span><br><span class="line">        server   192.168.0.2：8080  weight=1 max_fails=2 fail_timeout=30s;</span><br><span class="line">        keepalive 300;        <span class="comment"># 这个很重要！</span></span><br><span class="line">    &#125;</span><br><span class="line">server &#123;</span><br><span class="line">        listen 8080 default_server;</span><br><span class="line">        server_name <span class="string">""</span>;</span><br><span class="line">        location /  &#123;</span><br><span class="line">            proxy_pass http://BACKEND;</span><br><span class="line">            proxy_set_header Host  <span class="variable">$Host</span>;</span><br><span class="line">            proxy_set_header x-forwarded-for <span class="variable">$remote_addr</span>;</span><br><span class="line">            proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">            <span class="comment">#add_header Cache-Control no-store;</span></span><br><span class="line">            <span class="comment">#add_header Pragma  no-cache;</span></span><br><span class="line">            proxy_http_version 1.1;         <span class="comment"># 这两个最好也设置，http1.1</span></span><br><span class="line">            proxy_set_header Upgrade <span class="variable">$http_upgrade</span>;    </span><br><span class="line">            proxy_set_header Connection <span class="string">"Upgrade"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>header相关可以参考：<a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_set_header" target="_blank" rel="noopener">http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_set_header</a></p>
<h2 id="4、expires缓存">4、expires缓存</h2>
<p>expires指令控制HTTP应答中的“Expires”和“Cache-Control”Header头部信息，启动控制页面缓存的作用<br>time可以使用正数或负数。“Expires”头标的值将通过当前系统时间加上设定time值来设定。<br>time值还控制&quot;Cache-Control&quot;的值：</p>
<ul>
<li>
<p>负数表示no-cache</p>
</li>
<li>
<p>正数或零表示max-age=time</p>
</li>
<li>
<p>epoch：指定“Expires”的值为 1 January,1970,00:00:01 GMT</p>
</li>
<li>
<p>max:指定“Expires”的值为31 December2037 23:59:59GMT,&quot;Cache-Control&quot;的值为10年。</p>
</li>
<li>
<p>-1：指定“Expires”的值为当前服务器时间-1s，即永远过期。</p>
</li>
<li>
<p>off：不修改“Expires”和&quot;Cache-Control&quot;的值</p>
</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">location</span> /static &#123;</span><br><span class="line">  <span class="attribute">alias</span> /www/resources;</span><br><span class="line">    <span class="comment">#缓存10s</span></span><br><span class="line">  <span class="attribute">expires</span> <span class="number">10s</span>;</span><br><span class="line">    <span class="comment">#在23时30分钟之后自动清除缓存</span></span><br><span class="line">    <span class="comment">#expires @23h30m;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#代表不缓存，直接缓存过期</span></span><br><span class="line">    <span class="comment">#expires epoch;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#关闭nginx的缓存机制，直接走浏览器的缓存</span></span><br><span class="line">    <span class="comment">#expires off;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#缓存永不过期</span></span><br><span class="line">    <span class="comment">#expires max;</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="5、日志文件分割">5、日志文件分割</h2>
<p>现有的日志都会存在 access.log以及error.log 文件中，但是随着时间的推移，这个文件的内容会越来越多，体积会越来越大，不便于运维人员查看，所以我们可以通过把文件切割为多份不同的小文件作为日志，切割规则可以以 天 为单位，如果每天有几百G或者几个T的日志的话，则可以按需以 每半天 或者 每小时 对日志切割</p>
<h3 id="5-1-创建脚本">5.1 创建脚本</h3>
<p>创建一个shell可执行文件 <code>cutlogs.sh</code>。USR1亦通常被用来告知应用程序重载配置文件；例如，向Apache HTTP服务器发送一个USR1信号将导致以下步骤的发生：停止接受新的连接，等待当前连接停止，重新载入配置文件，重新打开日志文件，重启服务器，从而实现相对平滑的不关机的更改。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line">LOG_PATH=<span class="string">"/usr/local/nginx/logs"</span> </span><br><span class="line">RECORD_TIME=$(date -d <span class="string">"yesterday"</span> +<span class="string">"%Y-%m-%d %H:%M:%S"</span>) </span><br><span class="line">PID=/usr/<span class="built_in">local</span>/nginx/logs/nginx.pid </span><br><span class="line">mv <span class="variable">$&#123;LOG_PATH&#125;</span>/access.log <span class="variable">$&#123;LOG_PATH&#125;</span>/access.<span class="variable">$&#123;RECORD_TIME&#125;</span>.<span class="built_in">log</span> </span><br><span class="line">mv <span class="variable">$&#123;LOG_PATH&#125;</span>/error.log <span class="variable">$&#123;LOG_PATH&#125;</span>/error.<span class="variable">$&#123;RECORD_TIME&#125;</span>.<span class="built_in">log</span> </span><br><span class="line"><span class="built_in">kill</span> -USR1 `cat <span class="variable">$PID</span>`</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#为 cutlogs.sh 添加可执行的权限</span></span><br><span class="line">chmod +x cutlogs.sh </span><br><span class="line"><span class="comment">#运行脚本</span></span><br><span class="line">./cutlogs.sh</span><br></pre></td></tr></table></figure>
<h3 id="5-2-创建定时任务">5.2 创建定时任务</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装定时任务，安装过了就不需要了</span></span><br><span class="line">yum install crontabs </span><br><span class="line"><span class="comment">#编辑并且添加一行新的任务</span></span><br><span class="line">crontab -e</span><br><span class="line"><span class="comment">#每日执行一次</span></span><br><span class="line">* * */1 * * /usr/<span class="built_in">local</span>/nginx/sbin/cutlogs.sh</span><br><span class="line"><span class="comment">#重启定时任务</span></span><br><span class="line">service crond restart</span><br></pre></td></tr></table></figure>
<p><strong>常用定时任务命令</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service crond start <span class="comment">#启动服务 </span></span><br><span class="line">service crond stop <span class="comment">#关闭服务 </span></span><br><span class="line">service crond restart <span class="comment">#重启服务 </span></span><br><span class="line">service crond reload <span class="comment">#重新载入配置 </span></span><br><span class="line">crontab -e <span class="comment"># 编辑任务 </span></span><br><span class="line">crontab -l <span class="comment"># 查看任务列表 </span></span><br><span class="line">crontab -h <span class="comment">#帮助</span></span><br></pre></td></tr></table></figure>
<p><strong>定时任务表达式</strong></p>
<p>Cron表达式是，分为5或6个域，每个域代表一个含义，定时参考:<a href="https://crontab.guru/" target="_blank" rel="noopener">https://crontab.guru/</a></p>
<table>
<thead>
<tr>
<th></th>
<th>分</th>
<th>时</th>
<th>日</th>
<th>月</th>
<th>周几</th>
<th>年(可选)</th>
</tr>
</thead>
<tbody>
<tr>
<td>取值范围</td>
<td>0-59</td>
<td>0-23</td>
<td>1-31</td>
<td>1-12</td>
<td>1-7</td>
<td>2019/2020/…</td>
</tr>
</tbody>
</table>
<p><strong>常用表达式</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#每分钟执行</span></span><br><span class="line">*/1 * * * *</span><br><span class="line"><span class="comment">#每日凌晨（每天晚上23:59）执行</span></span><br><span class="line">59 23 * * *</span><br><span class="line"><span class="comment">#每日凌晨1点执行</span></span><br><span class="line">0 1 * * *</span><br></pre></td></tr></table></figure>
<h1>五、Nginx配置高可用集群</h1>
<p><img src="https://img-blog.csdnimg.cn/img_convert/329a6a534474ca1ca0c797ad3ddf46ff.png" alt="lfxtfO.jpg"></p>
<p>原理如上，相信大家的水平应该都能看懂，在配置时需要一些准备工作</p>
<ol>
<li>
<p>两台服务器</p>
</li>
<li>
<p>两台服务器都需要安装好Nginx</p>
</li>
<li>
<p>两台服务器需要安装keepalived</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装命令</span></span><br><span class="line">yum install keepalived -y</span><br><span class="line"><span class="comment">#检查是否安装好</span></span><br><span class="line">rpm -q -a keepalived</span><br></pre></td></tr></table></figure>
<p>安装安成后在/etc/keepalived下有配置文件，原理详看<a href="https://baike.baidu.com/item/Keepalived/10346758?fr=aladdin" target="_blank" rel="noopener">keepalived原理</a></p>
<h3 id="主从配置-还有双主模式自行学习">主从配置(还有双主模式自行学习)</h3>
<p><img src="https://img-blog.csdnimg.cn/img_convert/22ad20b01b39e7d5f926db69d263b6c9.png" alt="lfx1mR.jpg"></p>
<p>1、修改keepalived配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">global_defs &#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">#在/etc/hosts中修改</span></span><br><span class="line">   router_id LVS_DEVEL    <span class="comment">#主机名字</span></span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#检测脚本和权重参数</span></span><br><span class="line">vrrp_script chk_http_port &#123;</span><br><span class="line">  script <span class="string">"/usr/local/src/nginx_check.sh"</span></span><br><span class="line">  interval 2   <span class="comment">#检测间隔</span></span><br><span class="line">  weight -2  <span class="comment">#权重</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#虚拟IP配置</span></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state MASTER       <span class="comment">#备份改成BACKUP</span></span><br><span class="line">    interface eth0      <span class="comment">#网卡  ifconfig可以查看</span></span><br><span class="line">    virtual_router_id 51    <span class="comment">#主备机必须相同</span></span><br><span class="line">    priority 100      <span class="comment">#优先级 主机较大，备份机较小</span></span><br><span class="line">    advert_int 1    <span class="comment">#心跳包间隔</span></span><br><span class="line">    authentication &#123;     <span class="comment">#校验方式</span></span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;    <span class="comment">#可以绑定多个虚拟ip</span></span><br><span class="line">       在这里添加虚拟ip地址</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、在<code>/usr/local/src</code>添加检测脚本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">A=`ps -C nginx –no-header |wc -l` </span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$A</span> -eq 0 ];<span class="keyword">then</span></span><br><span class="line">  /usr/<span class="built_in">local</span>/nginx/sbin/nginx</span><br><span class="line">  sleep 2</span><br><span class="line">  <span class="keyword">if</span> [ `ps -C nginx --no-header |wc -l` -eq 0   ];<span class="keyword">then</span></span><br><span class="line">    killall keepalived</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>3、启动两台服务器的nginx和keepalived，其中备份机的keepalived配置需要简单修改，根据注释应该能看懂了。</p>
<p>注意：keepalived一般是在内网段进行，要公网服务器进行的话，需要至少三个公网ip（现阶段没这么多资金于是就没试验了），还有如果是虚拟机进行试验的话防火墙需要注意</p>
<h1>六、Nginx配置ssl提供https访问</h1>
<h2 id="1、介绍与环境准备">1、介绍与环境准备</h2>
<h3 id="1-1-https配置作用">1.1 https配置作用</h3>
<p><strong>HTTP</strong> （HyperText Transfer Protocol：超文本传输协议）是一种用于分布式、协作式和超媒体信息系统的应用层协议。 简单来说就是一种发布和接收 HTML 页面的方法，被用于在 Web 浏览器和网站服务器之间传递信息。</p>
<p>HTTP 默认工作在 TCP 协议 80 端口，用户访问网站 <strong>http://</strong>  打头的都是标准 HTTP 服务。</p>
<p>HTTP 协议以明文方式发送内容，==不提供任何方式的数据加密，==如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。</p>
<p><strong>HTTPS</strong> （Hypertext Transfer Protocol Secure：超文本传输安全协议）是一种透过计算机网络进行安全通信的传输协议。HTTPS 经由 HTTP 进行通信，但利用 SSL/TLS 来加密数据包。HTTPS 开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。</p>
<h3 id="1-2-配置步骤">1.2 配置步骤</h3>
<ul>
<li>
<p>要有个域名，并且要有服务器(提供ip)并且服务器ip和域名要进行解析。</p>
</li>
<li>
<p>购买ssl安全证书或者免费领取一个ssl安全证书。</p>
</li>
<li>
<p>把域名和ssl安全证书进行绑定授权</p>
</li>
<li>
<p>授权成功以后，然后把证书安装到nginx中。</p>
</li>
</ul>
<h2 id="2、阿里云下载SSL">2、阿里云下载SSL</h2>
<h3 id="2-1-前提准备">2.1 前提准备</h3>
<ul>
<li>
<p>一台服务器（ECS和轻量云服务器都可以）</p>
</li>
<li>
<p>一个域名</p>
</li>
<li>
<p>域名已经实名认证以及解析完毕</p>
</li>
<li>
<p>服务器已备案</p>
</li>
</ul>
<h3 id="2-2-SSL证书申请">2.2 SSL证书申请</h3>
<p>进入阿里云平台，认领免费证书，之后进行申请签发，很快就能审核通过，下载nginx证书到本地。这里注意一个证书只能对应一个具体的域名。<br>
<img src="https://img-blog.csdnimg.cn/df0ce72c1a3a424f8f75269e75c65338.png" alt="请添加图片描述"><br>
<img src="https://img-blog.csdnimg.cn/304b3dda44dc45079d5fd6e4d20f07a1.png" alt="请添加图片描述"></p>
<h2 id="3、Nginx配置https">3、Nginx配置https</h2>
<p>这里只需要<code>ssl_certificate、ssl_certificate_key</code>，另外配置server为443，并且将http重定向到443端口。配置完成后重启即可。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这个服务器是http://www.itbooking.net的服务</span></span><br><span class="line"><span class="string">server</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="string">listen</span> <span class="number">80</span><span class="string">;</span></span><br><span class="line">    <span class="comment">#需要将yourdomain.com替换成证书绑定的域名。</span></span><br><span class="line">    <span class="string">server_name</span> <span class="string">www.shawn22.xyz;</span> </span><br><span class="line">    <span class="comment">#将所有HTTP请求通过rewrite指令重定向到HTTPS。</span></span><br><span class="line">    <span class="string">rewrite</span> <span class="string">^(.*)$</span> <span class="string">https://$host$1;</span> </span><br><span class="line">    <span class="string">location</span> <span class="string">/</span> <span class="string">&#123;</span></span><br><span class="line">        <span class="string">index</span> <span class="string">index.html</span> <span class="string">index.htm;</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个服务器是https://www.itbooking.net的服务</span></span><br><span class="line"><span class="string">server</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="string">listen</span> <span class="number">443</span> <span class="string">ssl;</span></span><br><span class="line">    <span class="comment">#配置HTTPS的默认访问端口为443。</span></span><br><span class="line">    <span class="comment">#如果未在此处配置HTTPS的默认访问端口，可能会造成Nginx无法启动。</span></span><br><span class="line">    <span class="comment">#如果您使用Nginx 1.15.0及以上版本，请使用listen 443 ssl代替listen 443和ssl on。</span></span><br><span class="line">    <span class="comment">#需要将yourdomain.com替换成证书绑定的域名。</span></span><br><span class="line">    <span class="string">server_name</span> <span class="string">www.shawn22.xyz;</span> </span><br><span class="line">    <span class="string">root</span> <span class="string">html;</span></span><br><span class="line">    <span class="string">index</span> <span class="string">index.html</span> <span class="string">index.htm;</span></span><br><span class="line">    <span class="comment">#需要将cert-file-name.pem替换成已上传的证书文件的名称</span></span><br><span class="line">    <span class="string">ssl_certificate</span> <span class="string">cert/6695459_www.shawn22.xyz.pem;</span> </span><br><span class="line">    <span class="comment">#需要将cert-file-name.key替换成已上传的证书密钥文件的名称。</span></span><br><span class="line">    <span class="string">ssl_certificate_key</span> <span class="string">cert/6695459_www.shawn22.xyz.key;</span> </span><br><span class="line">    <span class="string">ssl_session_timeout</span> <span class="string">5m;</span></span><br><span class="line">    <span class="string">ssl_ciphers</span> <span class="string">ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span></span><br><span class="line">    <span class="comment">#表示使用的加密套件的类型。</span></span><br><span class="line">    <span class="comment">#表示使用的TLS协议的类型。</span></span><br><span class="line">    <span class="string">ssl_protocols</span> <span class="string">TLSv1</span> <span class="string">TLSv1.1</span> <span class="string">TLSv1.2;</span> </span><br><span class="line">    <span class="string">ssl_prefer_server_ciphers</span> <span class="string">on;</span></span><br><span class="line">    <span class="string">location</span> <span class="string">/</span> <span class="string">&#123;</span></span><br><span class="line">        <span class="comment">#站点目录。</span></span><br><span class="line">        <span class="string">root</span> <span class="string">html;</span>  </span><br><span class="line">        <span class="string">index</span> <span class="string">index.html</span> <span class="string">index.htm;</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>注：宝塔面板可能会有问题，可能需要重装</p>
<p><br>参考：</p>
<p><a href="https://www.cnblogs.com/woshimrf/p/nginx-config-location.html" target="_blank" rel="noopener">https://www.cnblogs.com/woshimrf/p/nginx-config-location.html</a></p>
<p><a href="http://www.gulixueyuan.com/my/course/332" target="_blank" rel="noopener">尚硅谷nginx学习视频</a></p>
<br>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>githubPage和hexo进行个人博客搭建</title>
    <url>/posts/1f66eb4d.html</url>
    <content><![CDATA[<p>参考如下</p>
<h4 id="博客搭建"><a href="https://blog.csdn.net/sinat_37781304/article/details/82729029" target="_blank" rel="noopener">博客搭建</a></h4>
<h4 id="博客搭建-v2"><a href="https://blog.csdn.net/qq_37513473/article/details/88617281" target="_blank" rel="noopener">博客搭建</a></h4>
<h4 id="博客美化"><a href="http://xxty.fun/2019/08/14/hexo%E5%8D%9A%E5%AE%A2%EF%BC%9Ayilia%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96/" target="_blank" rel="noopener">博客美化</a></h4>
<hr>
<p>另外因为yilia默认的文章搜索是按照/年/月/日/文章 来进行搜索的，这种搜索方式不利于被检索到，而且当题目是中文的时候，中文会变成很长的编码，看起来也很不爽，在网上找了很久，最终采用<code>hexo-abbrlink</code>这个插件，下面简单说一下安装步骤，因为网上说的还是有些坑</p>
<br/>
<a id="more"></a>
<p>首先安装插件，在根目录下安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure>
<p>然后配置根目录的_config.yml，找到以下文件并修改</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">permalink: post/:abbrlink.html     <span class="comment"># 此处可以自己设置，也可以直接使用 :/abbrlink</span></span><br><span class="line">abbrlink:  </span><br><span class="line">	alg: crc32  <span class="comment"># 算法：crc16(default) and crc32  </span></span><br><span class="line">	rep: hex    <span class="comment"># 进制：dec(default) and hex</span></span><br></pre></td></tr></table></figure>
<p>在这里我要说一说注意冒号，不写的话就不会进行匹配了，还有如果不想把文章都发到根目录下，也就是像我一样有个posts文件夹的话，首先要进行文件目录的创建，即</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page posts</span><br></pre></td></tr></table></figure>
<p>然后删除index.md文件，最后进行清除和构建，每篇文章就会自动构建一个abbrlink，这样就可以按照                <code>你的域名/posts/xxx.html</code>进行访问了</p>
<p>另外这篇美化hexo的很不错</p>
<p><a href="http://yansheng836.coding.me/article/e9d1b881.html" target="_blank" rel="noopener">高级yilia美化</a></p>
]]></content>
      <categories>
        <category>Github</category>
      </categories>
      <tags>
        <tag>hexo的搭建和美化</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/posts/4a17b156.html</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start">Quick Start</h2>
<h3 id="Create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>分类</title>
    <url>/categories/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/photos/data.json</url>
    <content><![CDATA[{"list":[{"date":"2021-08","arr":{"year":2021,"month":8,"link":["2021-08-12_神里绫华1.png","2021-08-12_神里绫华2.jpg","2021-08-12_神里绫华3.jpg","2021-08-12_神里绫华4.jpg","2021-08-12_神里绫华5.jpg","2021-08-12_神里绫华7.jpg"],"text":["神里绫华1","神里绫华2","神里绫华3","神里绫华4","神里绫华5","神里绫华7"],"type":["image","image","image","image","image","image"]}},{"date":"2020-06","arr":{"year":2020,"month":6,"link":["2020-06-16_可莉1.jpg","2020-06-16_可莉10.jpg","2020-06-16_可莉2.jpg","2020-06-16_可莉3.jpg","2020-06-16_可莉4.jpg","2020-06-16_可莉5.jpg","2020-06-16_可莉6.jpg","2020-06-16_可莉7.jpg","2020-06-16_可莉8.jpg","2020-06-16_可莉9.jpg"],"text":["可莉1","可莉10","可莉2","可莉3","可莉4","可莉5","可莉6","可莉7","可莉8","可莉9"],"type":["image","image","image","image","image","image","image","image","image","image"]}},{"date":"2020-05","arr":{"year":2020,"month":5,"link":["2020-05-01_动漫1.jpg","2020-05-01_动漫2.png","2020-05-01_动漫3.jpg","2020-05-01_动漫4.jpg","2020-05-01_动漫5.jpg","2020-05-17_动漫1.jpg"],"text":["动漫1","动漫2","动漫3","动漫4","动漫5","动漫1"],"type":["image","image","image","image","image","image"]}},{"date":"2020-01","arr":{"year":2020,"month":1,"link":["2020-01-01_风景1.png","2020-01-01_风景2.jpg"],"text":["风景1","风景2"],"type":["image","image"]}}]}]]></content>
  </entry>
  <entry>
    <title>相册</title>
    <url>/photos/index.html</url>
    <content><![CDATA[<link rel="stylesheet" href="./ins.css">
<div class="photos-btn-wrap">
	<a class="photos-btn active" href="javascript:void(0)">Photos</a>
	<a class="photos-btn" href="/photos/videos.html">Vedio</a>
</div>
<div class="instagram itemscope">
	<a href="https://www.instagram.com/lawlitewang20/" target="_blank" class="open-ins">图片正在加载中…</a>
</div>
<script>
  (function() {
    var loadScript = function(path) {
      var $script = document.createElement('script')
      document.getElementsByTagName('body')[0].appendChild($script)
      $script.setAttribute('src', path)
    }
    setTimeout(function() {
      loadScript('./ins.js')
    }, 0)
  })()
</script>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/photos/lazyload.min.js</url>
    <content><![CDATA[/*!
 * An jQuery | zepto plugin for lazy loading images.
 * author -> jieyou
 * see https://github.com/jieyou/lazyload
 * use some tuupola's code https://github.com/tuupola/jquery_lazyload (BSD)
 * use component's throttle https://github.com/component/throttle (MIT)
 */
!function(a){"function"==typeof define&&define.amd?define(["jquery"],a):a(window.jQuery||window.Zepto)}(function(a){function g(){}function h(a,b){var e;return e=b._$container==d?("innerHeight"in c?c.innerHeight:d.height())+d.scrollTop():b._$container.offset().top+b._$container.height(),e<=a.offset().top-b.threshold}function i(b,e){var f;return f=e._$container==d?d.width()+(a.fn.scrollLeft?d.scrollLeft():c.pageXOffset):e._$container.offset().left+e._$container.width(),f<=b.offset().left-e.threshold}function j(a,b){var c;return c=b._$container==d?d.scrollTop():b._$container.offset().top,c>=a.offset().top+b.threshold+a.height()}function k(b,e){var f;return f=e._$container==d?a.fn.scrollLeft?d.scrollLeft():c.pageXOffset:e._$container.offset().left,f>=b.offset().left+e.threshold+b.width()}function l(a,b){var c=0;a.each(function(d){function g(){f.trigger("_lazyload_appear"),c=0}var f=a.eq(d);if(!(f.width()<=0&&f.height()<=0||"none"===f.css("display")))if(b.vertical_only)if(j(f,b));else if(h(f,b)){if(++c>b.failure_limit)return!1}else g();else if(j(f,b)||k(f,b));else if(h(f,b)||i(f,b)){if(++c>b.failure_limit)return!1}else g()})}function m(a){return a.filter(function(b){return!a.eq(b)._lazyload_loadStarted})}function n(a,b){function h(){f=0,g=+new Date,e=a.apply(c,d),c=null,d=null}var c,d,e,f,g=0;return function(){c=this,d=arguments;var a=new Date-g;return f||(a>=b?h():f=setTimeout(h,b-a)),e}}var f,c=window,d=a(c),e={threshold:0,failure_limit:0,event:"scroll",effect:"show",effect_params:null,container:c,data_attribute:"original",data_srcset_attribute:"original-srcset",skip_invisible:!0,appear:g,load:g,vertical_only:!1,check_appear_throttle_time:300,url_rewriter_fn:g,no_fake_img_loader:!1,placeholder_data_img:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC",placeholder_real_img:"http://ditu.baidu.cn/yyfm/lazyload/0.0.1/img/placeholder.png"};f=function(){var a=Object.prototype.toString;return function(b){return a.call(b).replace("[object ","").replace("]","")}}(),a.fn.hasOwnProperty("lazyload")||(a.fn.lazyload=function(b){var i,j,k,h=this;return a.isPlainObject(b)||(b={}),a.each(e,function(g,h){var i=f(b[g]);-1!=a.inArray(g,["threshold","failure_limit","check_appear_throttle_time"])?"String"==i?b[g]=parseInt(b[g],10):"Number"!=i&&(b[g]=h):"container"==g?(b._$container=b.hasOwnProperty(g)?b[g]==c||b[g]==document?d:a(b[g]):d,delete b.container):!e.hasOwnProperty(g)||b.hasOwnProperty(g)&&i==f(e[g])||(b[g]=h)}),i="scroll"==b.event,k=0==b.check_appear_throttle_time?l:n(l,b.check_appear_throttle_time),j=i||"scrollstart"==b.event||"scrollstop"==b.event,h.each(function(c){var e=this,f=h.eq(c),i=f.attr("src"),k=f.attr("data-"+b.data_attribute),l=b.url_rewriter_fn==g?k:b.url_rewriter_fn.call(e,f,k),n=f.attr("data-"+b.data_srcset_attribute),o=f.is("img");return 1==f._lazyload_loadStarted||i==l?(f._lazyload_loadStarted=!0,h=m(h),void 0):(f._lazyload_loadStarted=!1,o&&!i&&f.one("error",function(){f.attr("src",b.placeholder_real_img)}).attr("src",b.placeholder_data_img),f.one("_lazyload_appear",function(){function i(){d&&f.hide(),o?(n&&f.attr("srcset",n),l&&f.attr("src",l)):f.css("background-image",'url("'+l+'")'),d&&f[b.effect].apply(f,c?b.effect_params:[]),h=m(h)}var d,c=a.isArray(b.effect_params);f._lazyload_loadStarted||(d="show"!=b.effect&&a.fn[b.effect]&&(!b.effect_params||c&&0==b.effect_params.length),b.appear!=g&&b.appear.call(e,f,h.length,b),f._lazyload_loadStarted=!0,b.no_fake_img_loader||n?(b.load!=g&&f.one("load",function(){b.load.call(e,f,h.length,b)}),i()):a("<img />").one("load",function(){i(),b.load!=g&&b.load.call(e,f,h.length,b)}).attr("src",l))}),j||f.on(b.event,function(){f._lazyload_loadStarted||f.trigger("_lazyload_appear")}),void 0)}),j&&b._$container.on(b.event,function(){k(h,b)}),d.on("resize load",function(){k(h,b)}),a(function(){k(h,b)}),this})});]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/photos/ins.css</url>
    <content><![CDATA[#post-instagram{
	padding: 30px;
}
#post-instagram .article-entry{
	padding-right: 0;
}
.instagram{
	position: relative;
	min-height: 500px;
}
.instagram img {
	width: 100%;
}
.instagram .year {
	font-size: 16px;
}
.instagram .open-ins{
	padding: 10px 0;
	color: #cdcdcd;
}
.instagram .open-ins:hover{
	color: #657b83;
}
.instagram .year{
	display: inline;
}
.instagram .thumb {
	width: 25%;
	height: 0; 
	padding-bottom: 25%;
	position: relative;
	display: inline-block;
	text-align: center;
	background: #ededed;
	outline: 1px solid #ddd;
}
.instagram .thumb a {
	position: relative;
}
.instagram .album h1 em{
	font-style: normal;
	font-size: 14px;
	margin-left: 10px;
}
.instagram .album ul{
	display: flex;
	flex-wrap: wrap;
	clear: both;
	width: 100%;
	text-align: left;
}
.instagram .album li{
	list-style: none;
	display: inline-block;
	box-sizing: border-box;
	padding: 0 5px;
	margin-bottom: -10px;
	height: 0;
	width: 25%;
	position: relative;
	padding-bottom: 25%;
}
.instagram .album li:before{
	display: none;
}
.instagram .album div.img-box{
	position: absolute;
	width: 90%;
	height: 90%;
	-webkit-box-shadow: 0 1px 0 rgba(255,255,255,0.4), 0 1px 0 1px rgba(255,255,255,0.1);
	-moz-box-shadow: 0 1px 0 rgba(255,255,255,0.4), 0 1px 0 1px rgba(255,255,255,0.1);
	box-shadow: 0 1px 0 rgba(255,255,255,0.4), 0 1px 0 1px rgba(255,255,255,0.1);
}
.instagram .album div.img-box img{
	width: 100%;
	height: 100%;
    position: absolute;
    z-index: 2;
}
.instagram .album div.img-box .img-bg{
	position: absolute;
	top: 0;
	left: 0;
	bottom: 0px;
	width: 100%;
	margin: -5px;
	padding: 5px;
	-webkit-box-shadow: 0 0 0 1px rgba(0,0,0,.04), 0 1px 5px rgba(0,0,0,0.1);
	-moz-box-shadow: 0 0 0 1px rgba(0,0,0,.04), 0 1px 5px rgba(0,0,0,0.1);
	box-shadow: 0 0 0 1px rgba(0,0,0,.04), 0 1px 5px rgba(0,0,0,0.1);
	-webkit-transition: all 0.15s ease-out 0.1s;
	-moz-transition: all 0.15s ease-out 0.1s;
	-o-transition: all 0.15s ease-out 0.1s;
	transition: all 0.15s ease-out 0.1s;
	opacity: 0.2;
	cursor: pointer;
	display: block;
	z-index: 3;
}
.instagram .album div.img-box .icon {
    font-size: 14px;
    position: absolute;
    left: 50%;
    top: 50%;
    margin-left: -7px;
    margin-top: -7px;
    color: #999;
    z-index: 1;
}
.instagram .album div.img-box .img-bg:hover{
	opacity: 0;
}
.photos-btn-wrap {
	border-bottom: 1px solid #e5e5e5;
	margin-bottom: 20px;
}
.photos-btn {
	font-size: 16px;
	color: #333;
	margin-bottom: -4px;
	padding: 5px 8px 3px;
}
.photos-btn.active {
	color: #08c;
	border: 1px solid #e5e5e5;
	border-bottom: 5px solid #fff;
}

@media screen and (max-width:600px) {
	.instagram .thumb {
		width: 50%;
		padding-bottom: 50%;
	}
	.instagram .album li {
		width: 100%;
		position: relative;
		padding-bottom: 100%;
		text-align: center;
	}
	.instagram .album div.img-box{
		margin: 0;
		width: 90%;
		height: 90%;
	}
}

/* ====== video ===== */
 .video-container {
    z-index: 1;
    position: relative;
    padding-bottom: 56.25%;
    margin: 0 auto;
}
.video-container iframe, .video-container object, .video-container embed {
    z-index: 1;
    position: absolute;
    top: 0;
    left: 7%;
    width: 85%;
    height: 85%;
    box-shadow: 0px 0px 20px 2px #888888;
}]]></content>
  </entry>
  <entry>
    <title>相册</title>
    <url>/photos/videos.html</url>
    <content><![CDATA[<link rel="stylesheet" href="./ins.css">
<div class="photos-btn-wrap">	<a class="photos-btn" href="/photos">Photos</a>
	<a class="photos-btn active" href="/photos/videos.html">Videos</a>
</div>
<center>
    <h1>星轨</h1>
</center>
<hr/>
<center>
    <div class="video-container">
        <iframe height="80%" width="80%" src="http://121.199.167.227/video/hutao.mp4" frameborder=0 allowfullscreen></iframe>
    </div>
</center>
<hr/>



]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/photos/ins.js</url>
    <content><![CDATA[/******/
(function(modules) { // webpackBootstrap
  /******/ // The module cache
  /******/
  var installedModules = {};
  /******/
  /******/ // The require function
  /******/
  function __webpack_require__(moduleId) {
    /******/
    /******/ // Check if module is in cache
    /******/
    if (installedModules[moduleId])
    /******/
      return installedModules[moduleId].exports;
    /******/
    /******/ // Create a new module (and put it into the cache)
    /******/
    var module = installedModules[moduleId] = {
      /******/
      exports: {},
      /******/
      id: moduleId,
      /******/
      loaded: false
        /******/
    };
    /******/
    /******/ // Execute the module function
    /******/
    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
    /******/
    /******/ // Flag the module as loaded
    /******/
    module.loaded = true;
    /******/
    /******/ // Return the exports of the module
    /******/
    return module.exports;
    /******/
  }
  /******/
  /******/
  /******/ // expose the modules object (__webpack_modules__)
  /******/
  __webpack_require__.m = modules;
  /******/
  /******/ // expose the module cache
  /******/
  __webpack_require__.c = installedModules;
  /******/
  /******/ // __webpack_public_path__
  /******/
  __webpack_require__.p = "/dist/";
  /******/
  /******/ // Load entry module and return exports
  /******/
  return __webpack_require__(0);
  /******/
})
/************************************************************************/
/******/
([
  /* 0 */
  /***/
  function(module, exports, __webpack_require__) {

    'use strict';

    __webpack_require__(1);

    var _view = __webpack_require__(2);

    var _view2 = _interopRequireDefault(_view);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }

    /**
     * @name impush-client 
     * @description 这个项目让我发家致富…
     * @date 2016-12-1
     */

    var _collection = [];
    var _count = 0;
    var searchData;

    function addMask(elem) {
      var rect = elem.getBoundingClientRect();
      var style = getComputedStyle(elem, null);

      var mask = document.createElement('i');
      mask.className = 'icon-film';
      mask.style.color = '#fff';
      mask.style.fontSize = '26px';
      mask.style.position = 'absolute';
      mask.style.right = '10px';
      mask.style.bottom = '10px';
      mask.style.zIndex = 1;
      elem.parentNode.appendChild(mask);
    }

    var createVideoIncon = function createVideoIncon() {
      var $videoImg = document.querySelectorAll('.thumb a[data-type="video"]');
      for (var i = 0, len = $videoImg.length; i < len; i++) {
        addMask($videoImg[i]);
      }
    };
    var render = function render(res) {
      var ulTmpl = "";
      for (var j = 0, len2 = res.list.length; j < len2; j++) {
        var data = res.list[j].arr;
        var liTmpl = "";
        for (var i = 0, len = data.link.length; i < len; i++) {
          // var minSrc = 'https://raw.githubusercontent.com/lawlite19/blog-back-up/master/min_photos/' + data.link[i];
          // var src = 'https://raw.githubusercontent.com/lawlite19/blog-back-up/master/photos/' + data.link[i];
          var minSrc = 'https://gitee.com/LXT2017/Picbed/raw/master/min_photos/' + data.link[i];
          var src = 'https://gitee.com/LXT2017/Picbed/raw/master/photos/' + data.link[i];
          var type = data.type[i];
          var target = src + (type === 'video' ? '.mp4' : '.jpg');
          src += '';

          liTmpl += '<figure class="thumb" itemprop="associatedMedia" itemscope="" itemtype="http://schema.org/ImageObject">\
                <a href="' + src + '" itemprop="contentUrl" data-size="1080x1080" data-type="' + type + '" data-target="' + src + '">\
                  <img class="reward-img" data-type="' + type + '" data-src="' + minSrc + '" src="/assets/img/empty.png" itemprop="thumbnail" onload="lzld(this)">\
                </a>\
                <figcaption style="display:none" itemprop="caption description">' + data.text[i] + '</figcaption>\
            </figure>';
        }
        ulTmpl = ulTmpl + '<section class="archives album"><h1 class="year">' + data.year + '年<em>' + data.month + '月</em></h1>\
        <ul class="img-box-ul">' + liTmpl + '</ul>\
        </section>';
      }
      document.querySelector('.instagram').innerHTML = '<div class="photos" itemscope="" itemtype="http://schema.org/ImageGallery">' + ulTmpl + '</div>';
      createVideoIncon();
      _view2.default.init();
    };

    var replacer = function replacer(str) {
      var arr = str.split("/");
      return "/assets/ins/" + arr[arr.length - 1];
    };

    var ctrler = function ctrler(data) {
      var imgObj = {};
      for (var i = 0, len = data.length; i < len; i++) {
        var y = data[i].y;
        var m = data[i].m;
        var src = replacer(data[i].src);
        var text = data[i].text;
        var key = y + "" + ((m + "").length == 1 ? "0" + m : m);
        if (imgObj[key]) {
          imgObj[key].srclist.push(src);
          imgObj[key].text.push(text);
        } else {
          imgObj[key] = {
            year: y,
            month: m,
            srclist: [src],
            text: [text]
          };
        }
      }
      render(imgObj);
    };

    function loadData(success) {
      if (!searchData) {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', './data.json?t=' + +new Date(), true);

        xhr.onload = function() {
          if (this.status >= 200 && this.status < 300) {
            var res = JSON.parse(this.response);
            searchData = res;
            success(searchData);
          } else {
            console.error(this.statusText);
          }
        };

        xhr.onerror = function() {
          console.error(this.statusText);
        };

        xhr.send();
      } else {
        success(searchData);
      }
    }

    var Ins = {
      init: function init() {
        loadData(function(data) {
          render(data);
        });
      }
    };

    Ins.init();

    // export default impush;

    /***/
  },
  /* 1 */
  /***/
  function(module, exports, __webpack_require__) {

    /* WEBPACK VAR INJECTION */
    (function(global) {
      'use strict';

      var inViewport = __webpack_require__(3);
      var lazyAttrs = ['data-src'];

      global.lzld = lazyload();

      // Provide libs using getAttribute early to get the good src
      // and not the fake data-src
      replaceGetAttribute('Image');
      replaceGetAttribute('IFrame');

      function registerLazyAttr(attr) {
        if (indexOf.call(lazyAttrs, attr) === -1) {
          lazyAttrs.push(attr);
        }
      }

      function lazyload(opts) {
        opts = merge({
          'offset': 333,
          'src': 'data-src',
          'container': false
        }, opts || {});

        if (typeof opts.src === 'string') {
          registerLazyAttr(opts.src);
        }

        var elts = [];

        function show(elt) {
          var src = findRealSrc(elt);

          if (src) {
            elt.src = src;
          }

          elt.setAttribute('data-lzled', true);
          elts[indexOf.call(elts, elt)] = null;
        }

        function findRealSrc(elt) {
          if (typeof opts.src === 'function') {
            return opts.src(elt);
          }

          return elt.getAttribute(opts.src);
        }

        function register(elt) {
          elt.onload = null;
          elt.removeAttribute('onload');
          elt.onerror = null;
          elt.removeAttribute('onerror');

          if (indexOf.call(elts, elt) === -1) {
            inViewport(elt, opts, show);
          }
        }

        return register;
      }

      function replaceGetAttribute(elementName) {
        var fullname = 'HTML' + elementName + 'Element';
        if (fullname in global === false) {
          return;
        }

        var original = global[fullname].prototype.getAttribute;
        global[fullname].prototype.getAttribute = function(name) {
          if (name === 'src') {
            var realSrc;
            for (var i = 0, max = lazyAttrs.length; i < max; i++) {
              realSrc = original.call(this, lazyAttrs[i]);
              if (realSrc) {
                break;
              }
            }

            return realSrc || original.call(this, name);
          }

          // our own lazyloader will go through theses lines
          // because we use getAttribute(opts.src)
          return original.call(this, name);
        };
      }

      function merge(defaults, opts) {
        for (var name in defaults) {
          if (opts[name] === undefined) {
            opts[name] = defaults[name];
          }
        }

        return opts;
      }

      // http://webreflection.blogspot.fr/2011/06/partial-polyfills.html
      function indexOf(value) {
        for (var i = this.length; i-- && this[i] !== value;) {}
        return i;
      }

      module.exports = lazyload;

      // export default impush;
      /* WEBPACK VAR INJECTION */
    }.call(exports, (function() {
      return this;
    }())))

    /***/
  },
  /* 2 */
  /***/
  function(module, exports) {

    'use strict';

    var initPhotoSwipeFromDOM = function initPhotoSwipeFromDOM(gallerySelector) {

      // parse slide data (url, title, size ...) from DOM elements 
      // (children of gallerySelector)
      var parseThumbnailElements = function parseThumbnailElements(el) {
        el = el.parentNode.parentNode;
        var thumbElements = el.getElementsByClassName('thumb'),
          numNodes = thumbElements.length,
          items = [],
          figureEl,
          linkEl,
          size,
          type,
          // video or not
          target,
          item;

        for (var i = 0; i < numNodes; i++) {

          figureEl = thumbElements[i]; // 

          // include only element nodes 
          if (figureEl.nodeType !== 1) {
            continue;
          }

          linkEl = figureEl.children[0]; // 

          size = linkEl.getAttribute('data-size').split('x');
          type = linkEl.getAttribute('data-type');
          target = linkEl.getAttribute('data-target');
          // create slide object
          item = {
            src: linkEl.getAttribute('href'),
            w: parseInt(size[0], 10),
            h: parseInt(size[1], 10)
          };

          if (figureEl.children.length > 1) {
            item.title = figureEl.children[1].innerHTML;
          }

          if (linkEl.children.length > 0) {
            item.msrc = linkEl.children[0].getAttribute('src');
            item.type = type;
            item.target = target;
            item.html = '<video src="' + target + '" controls="controls" autoplay="autoplay"></video>';
            if (type === 'video') {
              //item.src = null;
            }
          }

          item.el = figureEl; // save link to element for getThumbBoundsFn
          items.push(item);
        }

        return items;
      };

      // find nearest parent element
      var closest = function closest(el, fn) {
        return el && (fn(el) ? el : closest(el.parentNode, fn));
      };

      // triggers when user clicks on thumbnail
      var onThumbnailsClick = function onThumbnailsClick(e) {
        e = e || window.event;
        e.preventDefault ? e.preventDefault() : e.returnValue = false;

        var eTarget = e.target || e.srcElement;

        // find root element of slide
        var clickedListItem = closest(eTarget, function(el) {
          return el.tagName && el.tagName.toUpperCase() === 'FIGURE';
        });

        if (!clickedListItem) {
          return;
        }

        // find index of clicked item by looping through all child nodes
        // alternatively, you may define index via data- attribute
        var clickedGallery = clickedListItem.parentNode,

          // childNodes = clickedListItem.parentNode.childNodes,
          // numChildNodes = childNodes.length,
          childNodes = document.getElementsByClassName('thumb'),
          numChildNodes = childNodes.length,
          nodeIndex = 0,
          index;

        for (var i = 0; i < numChildNodes; i++) {
          if (childNodes[i].nodeType !== 1) {
            continue;
          }

          if (childNodes[i] === clickedListItem) {
            index = nodeIndex;
            break;
          }
          nodeIndex++;
        }

        if (index >= 0) {
          // open PhotoSwipe if valid index found
          openPhotoSwipe(index, clickedGallery);
        }
        return false;
      };

      // parse picture index and gallery index from URL (#&pid=1&gid=2)
      var photoswipeParseHash = function photoswipeParseHash() {
        var hash = window.location.hash.substring(1),
          params = {};

        if (hash.length < 5) {
          return params;
        }

        var vars = hash.split('&');
        for (var i = 0; i < vars.length; i++) {
          if (!vars[i]) {
            continue;
          }
          var pair = vars[i].split('=');
          if (pair.length < 2) {
            continue;
          }
          params[pair[0]] = pair[1];
        }

        if (params.gid) {
          params.gid = parseInt(params.gid, 10);
        }

        return params;
      };

      var openPhotoSwipe = function openPhotoSwipe(index, galleryElement, disableAnimation, fromURL) {
        var pswpElement = document.querySelectorAll('.pswp')[0],
          gallery,
          options,
          items;

        items = parseThumbnailElements(galleryElement);
        // define options (if needed)
        options = {

          // define gallery index (for URL)
          galleryUID: galleryElement.getAttribute('data-pswp-uid'),

          getThumbBoundsFn: function getThumbBoundsFn(index) {
            // See Options -> getThumbBoundsFn section of documentation for more info
            var thumbnail = items[index].el.getElementsByTagName('img')[0],
              // find thumbnail
              pageYScroll = window.pageYOffset || document.documentElement.scrollTop,
              rect = thumbnail.getBoundingClientRect();

            return {
              x: rect.left,
              y: rect.top + pageYScroll,
              w: rect.width
            };
          }

        };

        // PhotoSwipe opened from URL
        if (fromURL) {
          if (options.galleryPIDs) {
            // parse real index when custom PIDs are used 
            // http://photoswipe.com/documentation/faq.html#custom-pid-in-url
            for (var j = 0; j < items.length; j++) {
              if (items[j].pid == index) {
                options.index = j;
                break;
              }
            }
          } else {
            // in URL indexes start from 1
            options.index = parseInt(index, 10) - 1;
          }
        } else {
          options.index = parseInt(index, 10);
        }

        // exit if index not found
        if (isNaN(options.index)) {
          return;
        }

        if (disableAnimation) {
          options.showAnimationDuration = 0;
        }

        // Pass data to PhotoSwipe and initialize it
        gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, options);
        gallery.init();

        var $tempVideo;
        var stopVideoHandle = function stopVideoHandle() {
          if ($tempVideo) {
            $tempVideo.remove();
            $tempVideo = null;
          }
        };
        var changeHandle = function changeHandle() {
          var item = gallery.currItem;
          stopVideoHandle();
          if (item.type === 'video') {
            var $ctn = item.container;
            var style = $ctn.getElementsByClassName('pswp__img')[0].style;
            var $video = document.createElement('video');
            $video.setAttribute('autoplay', 'autoplay');
            $video.setAttribute('controls', 'controls');
            $video.setAttribute('src', item.target);
            $video.style.width = style.width;
            $video.style.height = style.height;
            $video.style.position = 'absolute';
            $video.style.zIndex = 2;
            $tempVideo = $video;
            $ctn.appendChild($video);
          }
        };
        gallery.listen('initialZoomIn', changeHandle);
        gallery.listen('afterChange', changeHandle);
        gallery.listen('initialZoomOut', stopVideoHandle);
      };

      // loop through all gallery elements and bind events
      var galleryElements = document.querySelectorAll(gallerySelector);
      for (var i = 0, l = galleryElements.length; i < l; i++) {
        galleryElements[i].setAttribute('data-pswp-uid', i + 1);
        galleryElements[i].onclick = onThumbnailsClick;
      }

      // Parse URL and open gallery if it contains #&pid=3&gid=1
      var hashData = photoswipeParseHash();
      if (hashData.pid && hashData.gid) {
        openPhotoSwipe(hashData.pid, galleryElements[hashData.gid - 1], true, true);
      }
    };

    var Viewer = function() {
      function init() {
        initPhotoSwipeFromDOM('.photos');
      }
      return {
        init: init
      };
    }();

    module.exports = Viewer;

    /***/
  },
  /* 3 */
  /***/
  function(module, exports) {

    /* WEBPACK VAR INJECTION */
    (function(global) {
      module.exports = inViewport;

      var instances = [];
      var supportsMutationObserver = typeof global.MutationObserver === 'function';

      function inViewport(elt, params, cb) {
        var opts = {
          container: global.document.body,
          offset: 0
        };

        if (params === undefined || typeof params === 'function') {
          cb = params;
          params = {};
        }

        var container = opts.container = params.container || opts.container;
        var offset = opts.offset = params.offset || opts.offset;

        for (var i = 0; i < instances.length; i++) {
          if (instances[i].container === container) {
            return instances[i].isInViewport(elt, offset, cb);
          }
        }

        return instances[
          instances.push(createInViewport(container)) - 1
        ].isInViewport(elt, offset, cb);
      }

      function addEvent(el, type, fn) {
        if (el.attachEvent) {
          el.attachEvent('on' + type, fn);
        } else {
          el.addEventListener(type, fn, false);
        }
      }

      function debounce(func, wait, immediate) {
        var timeout;
        return function() {
          var context = this,
            args = arguments;
          var callNow = immediate && !timeout;
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
          if (callNow) func.apply(context, args);

          function later() {
            timeout = null;
            if (!immediate) func.apply(context, args);
          }
        };
      }

      // https://github.com/jquery/sizzle/blob/3136f48b90e3edc84cbaaa6f6f7734ef03775a07/sizzle.js#L708
      var contains = function() {
        if (!global.document) {
          return true;
        }
        return global.document.documentElement.compareDocumentPosition ?
          function(a, b) {
            return !!(a.compareDocumentPosition(b) & 16);
          } :
          global.document.documentElement.contains ?
          function(a, b) {
            return a !== b && (a.contains ? a.contains(b) : false);
          } :
          function(a, b) {
            while (b = b.parentNode) {
              if (b === a) {
                return true;
              }
            }
            return false;
          };
      }

      function createInViewport(container) {
        var watches = createWatches();

        var scrollContainer = container === global.document.body ? global : container;
        var debouncedCheck = debounce(watches.checkAll(watchInViewport), 15);

        addEvent(scrollContainer, 'scroll', debouncedCheck);

        if (scrollContainer === global) {
          addEvent(global, 'resize', debouncedCheck);
        }

        if (supportsMutationObserver) {
          observeDOM(watches, container, debouncedCheck);
        }

        // failsafe check, every 200ms we check for visible images
        // usecase: a hidden parent containing eleements
        // when the parent becomes visible, we have no event that the children
        // became visible
        setInterval(debouncedCheck, 150);

        function isInViewport(elt, offset, cb) {
          if (!cb) {
            return isVisible(elt, offset);
          }

          var remote = createRemote(elt, offset, cb);
          remote.watch();
          return remote;
        }

        function createRemote(elt, offset, cb) {
          function watch() {
            watches.add(elt, offset, cb);
          }

          function dispose() {
            watches.remove(elt);
          }

          return {
            watch: watch,
            dispose: dispose
          };
        }

        function watchInViewport(elt, offset, cb) {
          if (isVisible(elt, offset)) {
            watches.remove(elt);
            cb(elt);
          }
        }

        function isVisible(elt, offset) {
          if (!contains(global.document.documentElement, elt) || !contains(global.document.documentElement, container)) {
            return false;
          }

          // Check if the element is visible
          // https://github.com/jquery/jquery/blob/740e190223d19a114d5373758127285d14d6b71e/src/css/hiddenVisibleSelectors.js
          if (!elt.offsetWidth || !elt.offsetHeight) {
            return false;
          }

          var eltRect = elt.getBoundingClientRect();
          var viewport = {};

          if (container === global.document.body) {
            viewport = {
              top: -offset,
              left: -offset,
              right: global.document.documentElement.clientWidth + offset,
              bottom: global.document.documentElement.clientHeight + offset
            };
          } else {
            var containerRect = container.getBoundingClientRect();
            viewport = {
              top: containerRect.top - offset,
              left: containerRect.left - offset,
              right: containerRect.right + offset,
              bottom: containerRect.bottom + offset
            };
          }

          // The element must overlap with the visible part of the viewport
          var visible =
            (
              (eltRect.right > viewport.left) &&
              (eltRect.left < viewport.right) &&
              (eltRect.bottom > viewport.top) &&
              (eltRect.top < viewport.bottom)
            );

          return visible;
        }

        return {
          container: container,
          isInViewport: isInViewport
        };
      }

      function createWatches() {
        var watches = [];

        function add(elt, offset, cb) {
          if (!isWatched(elt)) {
            watches.push([elt, offset, cb]);
          }
        }

        function remove(elt) {
          var pos = indexOf(elt);
          if (pos !== -1) {
            watches.splice(pos, 1);
          }
        }

        function indexOf(elt) {
          for (var i = watches.length - 1; i >= 0; i--) {
            if (watches[i][0] === elt) {
              return i;
            }
          }
          return -1;
        }

        function isWatched(elt) {
          return indexOf(elt) !== -1;
        }

        function checkAll(cb) {
          return function() {
            for (var i = watches.length - 1; i >= 0; i--) {
              cb.apply(this, watches[i]);
            }
          };
        }

        return {
          add: add,
          remove: remove,
          isWatched: isWatched,
          checkAll: checkAll
        };
      }

      function observeDOM(watches, container, cb) {
        var observer = new MutationObserver(watch);
        var filter = Array.prototype.filter;
        var concat = Array.prototype.concat;

        observer.observe(container, {
          childList: true,
          subtree: true,
          // changes like style/width/height/display will be catched
          attributes: true
        });

        function watch(mutations) {
          // some new DOM nodes where previously watched
          // we should check their positions
          if (mutations.some(knownNodes) === true) {
            setTimeout(cb, 0);
          }
        }

        function knownNodes(mutation) {
          var nodes = concat.call([],
            Array.prototype.slice.call(mutation.addedNodes),
            mutation.target
          );
          return filter.call(nodes, watches.isWatched).length > 0;
        }
      }

      /* WEBPACK VAR INJECTION */
    }.call(exports, (function() {
      return this;
    }())))

    /***/
  }
  /******/
]);]]></content>
  </entry>
</search>
